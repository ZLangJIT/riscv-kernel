patch file
diff --git a/CMakeLists.txt b/CMakeLists.txt
index db82e07..1e24bb5 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,13 +1,25 @@
 # CMake configuration file for those who don't like Make (like I do)
 # Prev-maintainer: cerg2010cerg2010
 
-cmake_minimum_required(VERSION 3.9)
+cmake_minimum_required(VERSION 3.12)
 
 set(RVVM_VERSION 0.7)
-project(RVVM VERSION ${RVVM_VERSION}
+
+project(
+	RVVM VERSION ${RVVM_VERSION}
 	DESCRIPTION "RISC-V Virtual Machine"
 	HOMEPAGE_URL "https://github.com/LekKit/RVVM"
-	LANGUAGES C CXX)
+	LANGUAGES C CXX
+)
+
+if (NOT RVVM__ROOTFS)
+	message(STATUS "STATUS: RVVM__ROOTFS must be set")
+	message(FATAL_ERROR "FATAL: RVVM__ROOTFS must be set")
+	# the default root path ('/') for finding virtio dependencies
+	set(RVVM__ROOTFS "/")
+else()
+	message(STATUS "STATUS: RVVM__ROOTFS was set")
+endif()
 
 option(RVVM_USE_RV64 "Use RV64 CPU" ON)
 option(RVVM_USE_FPU "Use floating-point instructions" ON)
@@ -18,6 +30,7 @@ option(RVVM_USE_NET "Use networking" ON)
 option(RVVM_USE_TAP_LINUX "Use Linux TAP (deprecated)" OFF)
 option(RVVM_USE_FDT "Use Flattened Device Tree generation" ON)
 option(RVVM_USE_PCI "Use ATA over PCI, PIO mode is used otherwise" ON)
+option(RVVM_USE_VIRTIO "Use Virtio" ON)
 option(RVVM_USE_SPINLOCK_DEBUG "Use spinlock debugging" ON)
 option(RVVM_USE_PRECISE_FS "Use precise FPU status tracking" OFF)
 option(RVVM_USE_LIB "Build shared librvvm library" ON)
@@ -52,11 +65,12 @@ set(RVVM_SRC_DIR "${RVVM_SOURCE_DIR}/src")
 # Get commit id
 find_package(Git)
 execute_process(COMMAND
-  "${GIT_EXECUTABLE}" describe --match=NeVeRmAtCh_TaG --always --dirty
-  WORKING_DIRECTORY "${CMAKE_SOURCE_DIR}"
-  RESULT_VARIABLE RESULT
-  OUTPUT_VARIABLE RVVM_COMMIT
-  ERROR_QUIET OUTPUT_STRIP_TRAILING_WHITESPACE)
+	 "${GIT_EXECUTABLE}" describe --match=NeVeRmAtCh_TaG --always --dirty
+	WORKING_DIRECTORY "${CMAKE_SOURCE_DIR}"
+	RESULT_VARIABLE RESULT
+	OUTPUT_VARIABLE RVVM_COMMIT
+	ERROR_QUIET OUTPUT_STRIP_TRAILING_WHITESPACE
+)
 if (RESULT)
 	message(WARNING "Couldn't determine upstream git commit!")
 	set(RVVM_COMMIT "unknown")
@@ -114,28 +128,48 @@ if (CMAKE_C_COMPILER_ID MATCHES "GNU|Clang")
 endif()
 
 if (UNIX)
-	find_package(Threads REQUIRED)
-	target_link_libraries(rvvm_common INTERFACE Threads::Threads)
-	# Link librt, libatomic if we have them
-	find_library(RVVM_RT_LIB rt)
-	if (RVVM_RT_LIB)
-		target_link_libraries(rvvm_common INTERFACE rt)
-	endif()
-	find_library(RVVM_ATOMIC_LIB atomic)
-	if (RVVM_ATOMIC_LIB)
-		target_link_libraries(rvvm_common INTERFACE ${RVVM_ATOMIC_LIB})
+	if (ANDROID)
+		#
+		# android bionic c has built-in support for pthread HOWEVER it is not full posix
+		#
+		# - android pthread is a more limited version of posix pthread
+		# - see https://stackoverflow.com/a/64432754
+		#
+		#
+		# android ndk does not contain librt
+		#
+		# android ndk has libatomic
+		#
+		target_link_libraries(rvvm_common INTERFACE atomic)
+	else()
+		find_package(Threads REQUIRED)
+		target_link_libraries(rvvm_common INTERFACE Threads::Threads)
+		# Link librt, libatomic if we have them
+		find_library(RVVM_RT_LIB rt)
+		if (RVVM_RT_LIB)
+			target_link_libraries(rvvm_common INTERFACE rt)
+		endif()
+		find_library(RVVM_ATOMIC_LIB atomic)
+		if (RVVM_ATOMIC_LIB)
+			target_link_libraries(rvvm_common INTERFACE ${RVVM_ATOMIC_LIB})
+		endif()
 	endif()
 endif()
 
 # General sources
 file(GLOB RVVM_SRC LIST_DIRECTORIES FALSE CONFIGURE_DEPENDS
-	"${RVVM_SRC_DIR}/*.h"
 	"${RVVM_SRC_DIR}/*.c"
 	"${RVVM_SRC_DIR}/cpu/riscv_*.c"
 )
+file(GLOB RVVM_SRC_H LIST_DIRECTORIES FALSE CONFIGURE_DEPENDS
+	"${RVVM_SRC_DIR}/*.h"
+	"${RVVM_SRC_DIR}/cpu/*.h"
+)
 set(RVVM_MAIN_SRC "${RVVM_SRC_DIR}/main.c")
 set(RVVM_NETWORKING_SRC "${RVVM_SRC_DIR}/networking.c")
+set(RVVM_NETWORKING_SRC_H "${RVVM_SRC_DIR}/networking.h")
 list(REMOVE_ITEM RVVM_SRC ${RVVM_MAIN_SRC} ${RVVM_NETWORKING_SRC})
+list(REMOVE_ITEM RVVM_SRC_H ${RVVM_NETWORKING_SRC_H})
 
 if (RVVM_USE_RV64)
 	file(GLOB RVVM_RV64_SRC LIST_DIRECTORIES FALSE CONFIGURE_DEPENDS
@@ -171,18 +205,29 @@ endif()
 # RVJIT sources
 if (RVVM_USE_JIT)
 	file(GLOB RVVM_RVJIT_SRC LIST_DIRECTORIES FALSE CONFIGURE_DEPENDS
-		"${RVVM_SRC_DIR}/rvjit/*.h"
 		"${RVVM_SRC_DIR}/rvjit/*.c"
 	)
+	file(GLOB RVVM_RVJIT_SRC_H LIST_DIRECTORIES FALSE CONFIGURE_DEPENDS
+		"${RVVM_SRC_DIR}/rvjit/*.h"
+	)
 	list(APPEND RVVM_SRC ${RVVM_RVJIT_SRC})
+	list(APPEND RVVM_SRC_H ${RVVM_RVJIT_SRC_H})
 	target_compile_definitions(rvvm_common INTERFACE USE_JIT)
 endif()
 
 # Device sources
 file(GLOB RVVM_DEVICES_SRC LIST_DIRECTORIES FALSE CONFIGURE_DEPENDS
-	"${RVVM_SRC_DIR}/devices/*.h"
 	"${RVVM_SRC_DIR}/devices/*.c"
 )
+file(GLOB RVVM_DEVICES_SRC_H LIST_DIRECTORIES FALSE CONFIGURE_DEPENDS
+	"${RVVM_SRC_DIR}/devices/*.h"
+)
+file(GLOB RVVM_DEVICES_VIRTIO_SRC LIST_DIRECTORIES FALSE CONFIGURE_DEPENDS
+	"${RVVM_SRC_DIR}/devices/virtio*.c"
+)
+file(GLOB RVVM_DEVICES_VIRTIO_SRC_H LIST_DIRECTORIES FALSE CONFIGURE_DEPENDS
+	"${RVVM_SRC_DIR}/devices/virtio*.h"
+)
 set(RVVM_XCB_SRC "${RVVM_SRC_DIR}/devices/x11window_xcb.c")
 set(RVVM_XLIB_SRC "${RVVM_SRC_DIR}/devices/x11window_xlib.c")
 set(RVVM_WIN32_SRC "${RVVM_SRC_DIR}/devices/win32window.c")
@@ -190,13 +235,26 @@ set(RVVM_HAIKU_SRC "${RVVM_SRC_DIR}/devices/haiku_window.cpp")
 set(RVVM_SDL_SRC "${RVVM_SRC_DIR}/devices/sdl_window.c")
 set(RVVM_TAP_LINUX_SRC "${RVVM_SRC_DIR}/devices/tap_linux.c")
 set(RVVM_TAP_USER_SRC "${RVVM_SRC_DIR}/devices/tap_user.c")
+set(RVVM_VIRTIO_WINDOW_SRC "${RVVM_SRC_DIR}/devices/virtio_window.c")
 list(REMOVE_ITEM RVVM_DEVICES_SRC
 	${RVVM_XLIB_SRC}
 	${RVVM_WIN32_SRC}
 	${RVVM_HAIKU_SRC}
 	${RVVM_SDL_SRC}
 	${RVVM_TAP_LINUX_SRC}
-	${RVVM_TAP_USER_SRC})
+	${RVVM_TAP_USER_SRC}
+	${RVVM_VIRTIO_WINDOW_SRC}
+)
+
+if (NOT RVVM_USE_VIRTIO)
+	list(REMOVE_ITEM RVVM_DEVICES_SRC ${RVVM_DEVICES_VIRTIO_SRC})
+	list(REMOVE_ITEM RVVM_DEVICES_SRC_H ${RVVM_DEVICES_VIRTIO_SRC_H})
+else()
+	target_compile_definitions(rvvm_common INTERFACE USE_VIRTIO=1)
+	set( CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} "${CMAKE_CURRENT_SOURCE_DIR}/cmake/packages" )
+	find_package(VIRGLRENDERER REQUIRED)
+	target_link_libraries(rvvm_common INTERFACE virglrenderer)
+endif()
 
 if (RVVM_USE_GUI AND (NOT BUILD_LIBRETRO))
 	target_compile_definitions(rvvm_common INTERFACE USE_GUI)
@@ -313,10 +371,45 @@ else()
 		set_target_properties(rvvm_libretro PROPERTIES SUFFIX "${LIBRETRO_SUFFIX}.bc")
 	elseif (LIBRETRO_STATIC)
 		set_target_properties(rvvm_libretro PROPERTIES SUFFIX "${LIBRETRO_SUFFIX}.a")
-	endif ()
+	endif()
 endif()
 
 # Restore IPO setting
 if (RVVM_LTO)
 	set(CMAKE_INTERPROCEDURAL_OPTIMIZATION ${RVVM_OLD_IPO})
 endif()
+
+set(INSTALL_BIN_DIR "${CMAKE_INSTALL_PREFIX}/bin" CACHE PATH "Installation directory for executables")
+set(INSTALL_LIB_DIR "${CMAKE_INSTALL_PREFIX}/lib" CACHE PATH "Installation directory for libraries")
+set(INSTALL_INC_DIR "${CMAKE_INSTALL_PREFIX}/include" CACHE PATH "Installation directory for headers")
+
+if (BUILD_LIBRETRO)
+	install(
+		TARGETS rvvm_static rvvm_libretro
+		RUNTIME DESTINATION "${INSTALL_BIN_DIR}"
+		ARCHIVE DESTINATION "${INSTALL_LIB_DIR}"
+		LIBRARY DESTINATION "${INSTALL_LIB_DIR}"
+	)
+elseif (RVVM_USE_LIB)
+	install(
+		TARGETS rvvm_static rvvm rvvm_cli
+		RUNTIME DESTINATION "${INSTALL_BIN_DIR}"
+		ARCHIVE DESTINATION "${INSTALL_LIB_DIR}"
+		LIBRARY DESTINATION "${INSTALL_LIB_DIR}"
+	)
+else()
+	install(
+		TARGETS rvvm_static rvvm_cli
+		RUNTIME DESTINATION "${INSTALL_BIN_DIR}"
+		ARCHIVE DESTINATION "${INSTALL_LIB_DIR}"
+		LIBRARY DESTINATION "${INSTALL_LIB_DIR}"
+	)
+endif()
+
+install(
+	FILES
+		${CMAKE_CURRENT_SOURCE_DIR}/src/rvvmlib.h
+		${CMAKE_CURRENT_SOURCE_DIR}/src/fdtlib.h
+		${RVVM_DEVICES_SRC_H}
+	DESTINATION "${INSTALL_INC_DIR}"
+)
diff --git a/Makefile b/Makefile
index 2366413..e514d84 100644
--- a/Makefile
+++ b/Makefile
@@ -289,7 +289,9 @@ override CFLAGS := -I$(SRCDIR) -DRVVM_VERSION=\"$(VERSION)\" $(CFLAGS)
 # Conditionally compiled sources, do not build by default
 SRC_cond := $(SRCDIR)/devices/x11window_xlib.c $(SRCDIR)/devices/win32window.c \
 		$(SRCDIR)/devices/sdl_window.c $(SRCDIR)/devices/haiku_window.cpp \
-		$(SRCDIR)/devices/tap_linux.c $(SRCDIR)/devices/tap_user.c $(SRCDIR)/networking.c
+		$(SRCDIR)/devices/tap_linux.c $(SRCDIR)/devices/tap_user.c $(SRCDIR)/networking.c $(SRCDIR)/devices/virtio-blk.c $(SRCDIR)/devices/virtio-gpu.c $(SRCDIR)/devices/virtio-input.c $(SRCDIR)/devices/virtio-net.c $(SRCDIR)/devices/virtio_window.c
+		
+# $(SRCDIR)/devices/virtio_window.c reference only
 
 # Output directories / files
 BUILDDIR ?= $(BUILD_TYPE).$(OS).$(ARCH)
@@ -318,6 +320,7 @@ USE_TAP_LINUX ?= 0
 USE_FDT ?= 1
 USE_PCI ?= 1
 USE_VFIO ?= 1
+USE_VIRTIO ?= 1
 USE_SPINLOCK_DEBUG ?= 1
 USE_JNI ?= 1
 USE_ISOLATION ?= 1
@@ -449,6 +452,16 @@ ifeq ($(USE_VFIO),1)
 override CFLAGS += -DUSE_VFIO
 endif
 
+ifeq ($(USE_VIRTIO),1)
+SRC += $(SRCDIR)/devices/virtio-blk.c
+SRC += $(SRCDIR)/devices/virtio-gpu.c
+SRC += $(SRCDIR)/devices/virtio-input.c
+ifeq ($(USE_NET),1)
+SRC += $(SRCDIR)/devices/virtio-net.c
+endif
+override CFLAGS += -DUSE_VIRTIO
+endif
+
 ifeq ($(USE_SPINLOCK_DEBUG),1)
 override CFLAGS += -DUSE_SPINLOCK_DEBUG
 endif
diff --git a/cmake/packages/FindEPOXY.cmake b/cmake/packages/FindEPOXY.cmake
new file mode 100644
index 0000000..bd1be91
--- /dev/null
+++ b/cmake/packages/FindEPOXY.cmake
@@ -0,0 +1,73 @@
+# Try to find the EPOXY library
+#
+# If successful, the following variables will be defined:
+# EPOXY_INCLUDE_DIR
+# EPOXY_LIBRARIES
+# EPOXY_FOUND
+#
+# additionally exposes the following target:
+# epoxy
+
+find_package(PkgConfig QUIET)
+pkg_check_modules(PC_GLOB QUIET epoxy)
+
+set(CMAKE_FIND_DEBUG_MODE FALSE)
+
+find_path(EPOXY_INCLUDE_DIRS NAMES epoxy/gl.h epoxy/egl.h
+  PATHS ${RVVM__ROOTFS}include ${RVVM__ROOTFS}usr/include
+  NO_DEFAULT_PATH
+  NO_PACKAGE_ROOT_PATH
+  NO_CMAKE_PATH
+  NO_CMAKE_ENVIRONMENT_PATH
+  NO_SYSTEM_ENVIRONMENT_PATH
+  NO_CMAKE_SYSTEM_PATH
+  NO_CMAKE_FIND_ROOT_PATH
+)
+find_library(EPOXY_LIBRARIES NAMES libepoxy.so
+  PATHS ${RVVM__ROOTFS}lib ${RVVM__ROOTFS}usr/lib
+  NO_DEFAULT_PATH
+  NO_PACKAGE_ROOT_PATH
+  NO_CMAKE_PATH
+  NO_CMAKE_ENVIRONMENT_PATH
+  NO_SYSTEM_ENVIRONMENT_PATH
+  NO_CMAKE_SYSTEM_PATH
+  NO_CMAKE_FIND_ROOT_PATH
+)
+
+set(CMAKE_FIND_DEBUG_MODE FALSE)
+
+if(EPOXY_INCLUDE_DIRS AND (EXISTS "${EPOXY_INCLUDE_DIRS}/epoxy/gl.h" OR EXISTS "${EPOXY_INCLUDE_DIRS}/epoxy/egl.h"))
+  set(EPOXY_VERSION_STRING "1.0")
+else()
+  set(EPOXY_INCLUDE_DIRS "")
+  set(EPOXY_LIBRARIES "")
+endif()
+
+include(FindPackageHandleStandardArgs)
+find_package_handle_standard_args(EPOXY
+                                  FOUND_VAR
+                                    EPOXY_FOUND
+                                  REQUIRED_VARS
+                                    EPOXY_INCLUDE_DIRS
+                                    EPOXY_LIBRARIES
+                                  VERSION_VAR
+                                    EPOXY_VERSION_STRING)
+mark_as_advanced(EPOXY_INCLUDE_DIRS EPOXY_LIBRARIES)
+
+message(STATUS "EPOXY: found :        ${EPOXY_FOUND}")
+message(STATUS "EPOXY: include_dirs : ${EPOXY_INCLUDE_DIRS}")
+message(STATUS "EPOXY: lib :          ${EPOXY_LIBRARIES}")
+message(STATUS "EPOXY: version :      ${EPOXY_VERSION_STRING}")
+
+if (EPOXY_FOUND AND NOT TARGET epoxy)
+  add_library(epoxy UNKNOWN IMPORTED)
+  set_target_properties(epoxy PROPERTIES IMPORTED_LOCATION ${EPOXY_LIBRARIES})
+  target_include_directories(epoxy INTERFACE ${EPOXY_INCLUDE_DIRS})
+  if (EXISTS "${EPOXY_INCLUDE_DIRS}/epoxy/gl.h")
+    target_compile_definitions(epoxy INTERFACE HAVE_EPOXY_GL_H)
+  endif()
+  if (EXISTS "${EPOXY_INCLUDE_DIRS}/epoxy/egl.h")
+    target_compile_definitions(epoxy INTERFACE HAVE_EPOXY_EGL_H)
+  endif()
+  set(EPOXY_TARGET epoxy)
+endif()
diff --git a/cmake/packages/FindVIRGLRENDERER.cmake b/cmake/packages/FindVIRGLRENDERER.cmake
new file mode 100644
index 0000000..9ced2aa
--- /dev/null
+++ b/cmake/packages/FindVIRGLRENDERER.cmake
@@ -0,0 +1,80 @@
+# Try to find the VIRGLRENDERER library
+#
+# If successful, the following variables will be defined:
+# VIRGLRENDERER_INCLUDE_DIR
+# VIRGLRENDERER_LIBRARIES
+# VIRGLRENDERER_FOUND
+#
+# additionally exposes the following target:
+# virglrenderer
+
+find_package(EPOXY REQUIRED)
+
+find_package(PkgConfig QUIET)
+pkg_check_modules(PC_GLOB QUIET VIRGLRENDERER)
+
+set(CMAKE_FIND_DEBUG_MODE FALSE)
+
+find_path(VIRGLRENDERER_INCLUDE_DIRS NAMES virgl/virgl-version.h
+  PATHS ${RVVM__ROOTFS}include ${RVVM__ROOTFS}usr/include
+  NO_DEFAULT_PATH
+  NO_PACKAGE_ROOT_PATH
+  NO_CMAKE_PATH
+  NO_CMAKE_ENVIRONMENT_PATH
+  NO_SYSTEM_ENVIRONMENT_PATH
+  NO_CMAKE_SYSTEM_PATH
+  NO_CMAKE_FIND_ROOT_PATH
+)
+find_library(VIRGLRENDERER_LIBRARIES NAMES libvirglrenderer.so
+  PATHS ${RVVM__ROOTFS}lib ${RVVM__ROOTFS}usr/lib
+  NO_DEFAULT_PATH
+  NO_PACKAGE_ROOT_PATH
+  NO_CMAKE_PATH
+  NO_CMAKE_ENVIRONMENT_PATH
+  NO_SYSTEM_ENVIRONMENT_PATH
+  NO_CMAKE_SYSTEM_PATH
+  NO_CMAKE_FIND_ROOT_PATH
+)
+
+set(CMAKE_FIND_DEBUG_MODE FALSE)
+
+if(VIRGLRENDERER_INCLUDE_DIRS AND EXISTS "${VIRGLRENDERER_INCLUDE_DIRS}/virgl/virgl-version.h" AND EXISTS "${VIRGLRENDERER_INCLUDE_DIRS}/virgl/virglrenderer.h")
+  FILE(STRINGS "${VIRGLRENDERER_INCLUDE_DIRS}/virgl/virgl-version.h" VIRGLRENDERER_version_major_str REGEX "^#define[ \t]+VIRGL_MAJOR_VERSION[ \t]+\(.+\)")
+  FILE(STRINGS "${VIRGLRENDERER_INCLUDE_DIRS}/virgl/virgl-version.h" VIRGLRENDERER_version_minor_str REGEX "^#define[ \t]+VIRGL_MINOR_VERSION[ \t]+\(.+\)")
+  FILE(STRINGS "${VIRGLRENDERER_INCLUDE_DIRS}/virgl/virgl-version.h" VIRGLRENDERER_version_micro_str REGEX "^#define[ \t]+VIRGL_MICRO_VERSION[ \t]+\(.+\)")
+
+  STRING(REGEX REPLACE "^#define[ \t]+VIRGL_MAJOR_VERSION[ \t]+\\\(([^\)]+)\\\).*" "\\1" VIRGL_MAJOR_VERSION "${VIRGLRENDERER_version_major_str}")
+  STRING(REGEX REPLACE "^#define[ \t]+VIRGL_MINOR_VERSION[ \t]+\\\(([^\)]+)\\\).*" "\\1" VIRGL_MINOR_VERSION "${VIRGLRENDERER_version_minor_str}")
+  STRING(REGEX REPLACE "^#define[ \t]+VIRGL_MICRO_VERSION[ \t]+\\\(([^\)]+)\\\).*" "\\1" VIRGL_MICRO_VERSION "${VIRGLRENDERER_version_micro_str}")
+  
+  STRING(CONCAT VIRGLRENDERER_VERSION_STRING ${VIRGL_MAJOR_VERSION} "." ${VIRGL_MINOR_VERSION} "." ${VIRGL_MICRO_VERSION})
+else()
+  set(VIRGLRENDERER_INCLUDE_DIRS "")
+  set(VIRGLRENDERER_LIBRARIES "")
+endif()
+
+include(FindPackageHandleStandardArgs)
+find_package_handle_standard_args(VIRGLRENDERER
+                                  FOUND_VAR
+                                    VIRGLRENDERER_FOUND
+                                  REQUIRED_VARS
+                                    VIRGLRENDERER_INCLUDE_DIRS
+                                    VIRGLRENDERER_LIBRARIES
+                                  VERSION_VAR
+                                    VIRGLRENDERER_VERSION_STRING)
+mark_as_advanced(VIRGLRENDERER_INCLUDE_DIRS VIRGLRENDERER_LIBRARIES)
+
+message(STATUS "VIRGLRENDERER: found :        ${VIRGLRENDERER_FOUND}")
+message(STATUS "VIRGLRENDERER: include_dirs : ${VIRGLRENDERER_INCLUDE_DIRS}")
+message(STATUS "VIRGLRENDERER: lib :          ${VIRGLRENDERER_LIBRARIES}")
+message(STATUS "VIRGLRENDERER: version :      ${VIRGLRENDERER_VERSION_STRING}")
+
+if (VIRGLRENDERER_FOUND AND NOT TARGET virglrenderer)
+  add_library(virglrenderer UNKNOWN IMPORTED)
+  set_target_properties(virglrenderer PROPERTIES IMPORTED_LOCATION ${VIRGLRENDERER_LIBRARIES})
+  target_include_directories(virglrenderer INTERFACE ${VIRGLRENDERER_INCLUDE_DIRS})
+  target_compile_definitions(virglrenderer INTERFACE HAVE_VIRGL_VERSION_H)
+  target_compile_definitions(virglrenderer INTERFACE HAVE_VIRGLRENDERER_H)
+  target_link_libraries(virglrenderer INTERFACE epoxy)
+  set(VIRGLRENDERER_TARGET virglrenderer)
+endif()
diff --git a/src/devices/shm.c b/src/devices/shm.c
new file mode 100644
index 0000000..fddf9c3
--- /dev/null
+++ b/src/devices/shm.c
@@ -0,0 +1,199 @@
+/*
+shm.c - Memory-Mapped Shared Memory
+Copyright (C) 2024  ZLangJIT <github.com/ZLangJIT>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "shm.h"
+
+#include "utils.h"
+
+#ifdef USE_FDT
+#include "fdtlib.h"
+#endif
+
+#if _WIN32
+
+#include <fileapi.h> // CreateFile
+#include <memoryapi.h> // MapViewOfFile, UnmapViewOfFile
+
+#else
+
+#include <fcntl.h> // open
+#include <unistd.h> // close
+#include <sys/stat.h> // stat
+#include <sys/mman.h> // mmap
+
+#endif
+
+PUBLIC rvvm_mmio_dev_t* shm_init_(rvvm_machine_t* machine, rvvm_mmio_dev_t* shm_region, const char * dev_name);
+
+static void shm_remove_file(rvvm_mmio_dev_t* device)
+{
+    shm_ctx_t* shm_ctx = (shm_ctx_t*)device->data;
+#if _WIN32
+    rvvm_info("unmapping path '%s' via UnmapViewOfFile", shm_ctx->source);
+    UnmapViewOfFile(shm_ctx->buffer);
+#else
+    rvvm_info("unmapping path '%s' via munmmap", shm_ctx->source);
+	munmap(shm_ctx->buffer, shm_ctx->size);
+#endif
+    free(shm_ctx);
+}
+
+static rvvm_mmio_type_t shm_data_dev_type = {
+    .name = "rvvm_shm_data_file",
+    .remove = shm_remove_file,
+};
+
+static rvvm_mmio_type_t shm_exe_dev_type = {
+    .name = "rvvm_shm_exe_file",
+    .remove = shm_remove_file,
+};
+
+PUBLIC rvvm_mmio_dev_t* shm_init_named(rvvm_machine_t* machine, const char * global_name, const char * dev_name)
+{
+	UNUSED(machine);
+	UNUSED(global_name);
+	UNUSED(dev_name);
+	return NULL;
+}
+
+PUBLIC rvvm_mmio_dev_t* shm_init_data(rvvm_machine_t* machine, const char * path, const char * dev_name)
+{
+	shm_ctx_t* shm_ctx = safe_new_obj(shm_ctx_t);
+	shm_ctx->source = path;
+#if _WIN32
+    rvvm_info("mapping path '%s' via MapViewOfFile", path);
+	HANDLE file_handle = CreateFileA(path,
+		GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL
+	);
+	if (GetLastError() == ERROR_FILE_NOT_FOUND || file_handle == INVALID_HANDLE_VALUE) {
+		free(shm_file);
+		free(shm_ctx);
+		return NULL;
+	}
+	shm_ctx->size = GetFileSize(file_handle, NULL);
+	HANDLE file_mapping = CreateFileMapping(file_handle, NULL, PAGE_READ, 0, shm_ctx->size, NULL);
+	CloseHandle(file_handle);
+	shm_ctx->buffer = MapViewOfFile(file_mapping, FILE_MAP_READ, 0, 0, shm_ctx->size);
+	CloseHandle(file_mapping);
+#else
+    rvvm_info("mapping path '%s' via mmap", path);
+	int file_handle = open(path, O_RDONLY);
+	if (file_handle == -1) {
+		free(shm_ctx);
+		rvvm_error("Failed to map file %s (open() failed)", path);
+		return NULL;
+	}
+	struct stat file_info;
+	if (fstat(file_handle, &file_info) == -1) {
+		close(file_handle);
+		free(shm_ctx);
+		rvvm_error("Failed to map file %s (fstat() failed)", path);
+		return NULL;
+	}
+	shm_ctx->size = file_info.st_size;
+	shm_ctx->buffer = mmap(NULL, shm_ctx->size, PROT_READ, MAP_PRIVATE, file_handle, 0);
+	close(file_handle);
+	if (shm_ctx->buffer == MAP_FAILED) {
+		free(shm_ctx);
+		rvvm_error("Failed to map file %s (MAP_FAILED)", path);
+		return NULL;
+	}
+#endif
+	// Map the buffer into physical memory
+	rvvm_info("mapped path '%s' at address %p with size %zu", path, shm_ctx->buffer, shm_ctx->size);
+	rvvm_mmio_dev_t shm_region = {
+		.mapping = shm_ctx->buffer,
+		.size = shm_ctx->size,
+		.data = shm_ctx,
+		.type = &shm_data_dev_type,
+	};
+	UNUSED(dev_name);
+	rvvm_mmio_dev_t* mmio = rvvm_attach_mmio(machine, &shm_region);
+	if (mmio == NULL) return mmio;
+	#ifdef USE_FDT
+	struct fdt_node* fb_fdt = fdt_node_create("rvvm_shm_data_file");
+	fdt_node_add_prop_str(fb_fdt, "source", shm_ctx->source);
+	fdt_node_add_prop(fb_fdt, "buffer", shm_region.mapping, shm_region.size);
+	fdt_node_add_prop_u64(fb_fdt, "size", shm_region.size);
+	#endif
+	return mmio;
+}
+
+PUBLIC rvvm_mmio_dev_t* shm_init_exe(rvvm_machine_t* machine, const char * path, const char * dev_name)
+{
+	shm_ctx_t* shm_ctx = safe_new_obj(shm_ctx_t);
+    shm_ctx->source = path;
+#if _WIN32
+    rvvm_info("mapping path '%s' via MapViewOfFile", path);
+	HANDLE file_handle = CreateFileA(path,
+		GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL
+	);
+	if (GetLastError() == ERROR_FILE_NOT_FOUND || file_handle == INVALID_HANDLE_VALUE) {
+		free(shm_ctx);
+		return NULL;
+	}
+	shm_ctx->size = GetFileSize(file_handle, NULL);
+	HANDLE file_mapping = CreateFileMapping(file_handle, NULL, PAGE_EXECUTE_READ, 0, shm_ctx->size, NULL);
+	CloseHandle(file_handle);
+	shm_ctx->buffer = MapViewOfFile(file_mapping, FILE_MAP_READ | FILE_MAP_EXECUTE, 0, 0, shm_ctx->size);
+	CloseHandle(file_mapping);
+#else
+    rvvm_info("mapping path '%s' via mmap", path);
+	int file_handle = open(path, O_RDONLY);
+	if (file_handle == -1) {
+		free(shm_ctx);
+		rvvm_error("Failed to map file %s (open() failed)", path);
+		return NULL;
+	}
+	struct stat file_info;
+	if (fstat(file_handle, &file_info) == -1) {
+		close(file_handle);
+		free(shm_ctx);
+		rvvm_error("Failed to map file %s (fstat() failed)", path);
+		return NULL;
+	}
+	shm_ctx->size = file_info.st_size;
+	shm_ctx->buffer = mmap(NULL, shm_ctx->size, PROT_READ | PROT_EXEC, MAP_PRIVATE, file_handle, 0);
+	close(file_handle);
+	if (shm_ctx->buffer == MAP_FAILED) {
+		free(shm_ctx);
+		rvvm_error("Failed to map file %s (MAP_FAILED)", path);
+		return NULL;
+	}
+#endif
+	// Map the buffer into physical memory
+	rvvm_info("mapped path '%s' at address %p with size %zu", path, shm_ctx->buffer, shm_ctx->size);
+	rvvm_mmio_dev_t shm_region = {
+		.mapping = shm_ctx->buffer,
+		.size = shm_ctx->size,
+		.data = shm_ctx,
+		.type = &shm_exe_dev_type,
+	};
+
+	UNUSED(dev_name);
+	rvvm_mmio_dev_t* mmio = rvvm_attach_mmio(machine, &shm_region);
+	if (mmio == NULL) return mmio;
+	#ifdef USE_FDT
+	struct fdt_node* fb_fdt = fdt_node_create("rvvm_shm_exe_file");
+	fdt_node_add_prop_str(fb_fdt, "source", shm_ctx->source);
+	fdt_node_add_prop(fb_fdt, "buffer", shm_region.mapping, shm_region.size);
+	fdt_node_add_prop_u64(fb_fdt, "size", shm_region.size);
+	fdt_node_add_child(rvvm_get_fdt_soc(machine), fb_fdt);
+	#endif
+	return mmio;
+}
diff --git a/src/devices/shm.h b/src/devices/shm.h
new file mode 100644
index 0000000..dad2653
--- /dev/null
+++ b/src/devices/shm.h
@@ -0,0 +1,40 @@
+/*
+shm.h - Memory-Mapped Shared Memory
+Copyright (C) 2024  ZLangJIT <github.com/ZLangJIT>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef RVVM_SHM_H
+#define RVVM_SHM_H
+
+#include "rvvmlib.h"
+
+//! SHM context description
+typedef struct {
+	const char * source;
+    void*     buffer; //!< Buffer in host memory
+    uint64_t  size;  //!< Buffer size in host memory
+} shm_ctx_t;
+
+/*
+ * SHM API
+ */
+
+//! \brief   Attach shared memory context to the machine.
+PUBLIC rvvm_mmio_dev_t* shm_init_named(rvvm_machine_t* machine, const char * global_name, const char * dev_name);
+PUBLIC rvvm_mmio_dev_t* shm_init_data(rvvm_machine_t* machine, const char * path, const char * dev_name);
+PUBLIC rvvm_mmio_dev_t* shm_init_exe(rvvm_machine_t* machine, const char * path, const char * dev_name);
+
+#endif
diff --git a/src/devices/virtio-blk.c b/src/devices/virtio-blk.c
new file mode 100644
index 0000000..783f220
--- /dev/null
+++ b/src/devices/virtio-blk.c
@@ -0,0 +1,490 @@
+#include <assert.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+#include "virtio_common.h"
+#include "virtio_device.h"
+#include "riscv_hart.h"
+#include "riscv_priv.h"
+#include "virtio.h"
+
+enum {
+    RV_MEM_LB = 0b000,
+    RV_MEM_LH = 0b001,
+    RV_MEM_LW = 0b010,
+    RV_MEM_LBU = 0b100,
+    RV_MEM_LHU = 0b101,
+    RV_MEM_SB = 0b000,
+    RV_MEM_SH = 0b001,
+    RV_MEM_SW = 0b010,
+};
+
+#define DISK_BLK_SIZE 512
+
+#define VBLK_DEV_CNT_MAX 1
+
+#define VBLK_FEATURES_0 0
+#define VBLK_FEATURES_1 1 /* VIRTIO_F_VERSION_1 */
+#define VBLK_QUEUE_NUM_MAX 1024
+#define VBLK_QUEUE (vblk->queues[vblk->QueueSel])
+
+#define PRIV(x) ((struct virtio_blk_config *) x->priv)
+
+PACKED(struct virtio_blk_config {
+    uint64_t capacity;
+    uint32_t size_max;
+    uint32_t seg_max;
+
+    struct virtio_blk_geometry {
+        uint16_t cylinders;
+        uint8_t heads;
+        uint8_t sectors;
+    } geometry;
+
+    uint32_t blk_size;
+
+    struct virtio_blk_topology {
+        uint8_t physical_block_exp;
+        uint8_t alignment_offset;
+        uint16_t min_io_size;
+        uint32_t opt_io_size;
+    } topology;
+
+    uint8_t writeback;
+    uint8_t unused0[3];
+    uint32_t max_discard_sectors;
+    uint32_t max_discard_seg;
+    uint32_t discard_sector_alignment;
+    uint32_t max_write_zeroes_sectors;
+    uint32_t max_write_zeroes_seg;
+    uint8_t write_zeroes_may_unmap;
+    uint8_t unused1[3];
+});
+
+PACKED(struct vblk_req_header {
+    uint32_t type;
+    uint32_t reserved;
+    uint64_t sector;
+    uint8_t status;
+});
+
+static struct virtio_blk_config vblk_configs[VBLK_DEV_CNT_MAX];
+static int vblk_dev_cnt = 0;
+
+static void virtio_blk_set_fail(virtio_blk_state_t *vblk)
+{
+    vblk->Status |= VIRTIO_STATUS__DEVICE_NEEDS_RESET;
+    if (vblk->Status & VIRTIO_STATUS__DRIVER_OK)
+        vblk->InterruptStatus |= VIRTIO_INT__CONF_CHANGE;
+}
+
+static inline uint32_t vblk_preprocess(virtio_blk_state_t *vblk, uint32_t addr)
+{
+    if ((addr >= RAM_SIZE) || (addr & 0b11))
+        return virtio_blk_set_fail(vblk), 0;
+
+    return addr >> 2;
+}
+
+static void virtio_blk_update_status(virtio_blk_state_t *vblk, uint32_t status)
+{
+    vblk->Status |= status;
+    if (status)
+        return;
+
+    /* Reset */
+    uint32_t *ram = vblk->ram;
+    uint32_t *disk = vblk->disk;
+    void *priv = vblk->priv;
+    uint32_t capacity = PRIV(vblk)->capacity;
+    memset(vblk, 0, sizeof(*vblk));
+    vblk->ram = ram;
+    vblk->disk = disk;
+    vblk->priv = priv;
+    PRIV(vblk)->capacity = capacity;
+}
+
+static void virtio_blk_write_handler(virtio_blk_state_t *vblk,
+                                     uint64_t sector,
+                                     uint32_t desc_addr,
+                                     uint32_t len)
+{
+    void *dest = (void *) ((uintptr_t) vblk->disk + sector * DISK_BLK_SIZE);
+    const void *src = (void *) ((uintptr_t) vblk->ram + desc_addr);
+    memcpy(dest, src, len);
+}
+
+static void virtio_blk_read_handler(virtio_blk_state_t *vblk,
+                                    uint64_t sector,
+                                    uint32_t desc_addr,
+                                    uint32_t len)
+{
+    void *dest = (void *) ((uintptr_t) vblk->ram + desc_addr);
+    const void *src =
+        (void *) ((uintptr_t) vblk->disk + sector * DISK_BLK_SIZE);
+    memcpy(dest, src, len);
+}
+
+static int virtio_blk_desc_handler(virtio_blk_state_t *vblk,
+                                   const virtio_blk_queue_t *queue,
+                                   uint32_t desc_idx,
+                                   uint32_t *plen)
+{
+    /* A full virtio_blk_req is represented by 3 descriptors, where
+     * the first descriptor contains:
+     *   le32 type
+     *   le32 reserved
+     *   le64 sector
+     * the second descriptor contains:
+     *   u8 data[][512]
+     * the third descriptor contains:
+     *   u8 status
+     */
+    struct virtq_desc vq_desc[3];
+
+    /* Collect the descriptors */
+    for (int i = 0; i < 3; i++) {
+        /* The size of the `struct virtq_desc` is 4 words */
+        const uint32_t *desc = &vblk->ram[queue->QueueDesc + desc_idx * 4];
+
+        /* Retrieve the fields of current descriptor */
+        vq_desc[i].addr = desc[0];
+        vq_desc[i].len = desc[2];
+        vq_desc[i].flags = desc[3];
+        desc_idx = desc[3] >> 16; /* vq_desc[desc_cnt].next */
+    }
+
+    /* The next flag for the first and second descriptors should be set,
+     * whereas for the third descriptor is should not be set
+     */
+    if (!(vq_desc[0].flags & VIRTIO_DESC_F_NEXT) ||
+        !(vq_desc[1].flags & VIRTIO_DESC_F_NEXT) ||
+        (vq_desc[2].flags & VIRTIO_DESC_F_NEXT)) {
+        /* since the descriptor list is abnormal, we don't write the status
+         * back here */
+        virtio_blk_set_fail(vblk);
+        return -1;
+    }
+
+    /* Process the header */
+    const struct vblk_req_header *header =
+        (struct vblk_req_header *) ((uintptr_t) vblk->ram + vq_desc[0].addr);
+    uint32_t type = header->type;
+    uint64_t sector = header->sector;
+    uint8_t *status = (uint8_t *) ((uintptr_t) vblk->ram + vq_desc[2].addr);
+
+    /* Check sector index is valid */
+    if (sector > (PRIV(vblk)->capacity - 1)) {
+        *status = VIRTIO_BLK_S_IOERR;
+        return -1;
+    }
+
+    /* Process the data */
+    switch (type) {
+    case VIRTIO_BLK_T_IN:
+        virtio_blk_read_handler(vblk, sector, vq_desc[1].addr, vq_desc[1].len);
+        break;
+    case VIRTIO_BLK_T_OUT:
+        virtio_blk_write_handler(vblk, sector, vq_desc[1].addr, vq_desc[1].len);
+        break;
+    default:
+        fprintf(stderr, "unsupported virtio-blk operation!\n");
+        *status = VIRTIO_BLK_S_UNSUPP;
+        return -1;
+    }
+
+    /* Return the device status */
+    *status = VIRTIO_BLK_S_OK;
+    *plen = vq_desc[1].len;
+
+    return 0;
+}
+
+static void virtio_queue_notify_handler(virtio_blk_state_t *vblk, int index)
+{
+    uint32_t *ram = vblk->ram;
+    virtio_blk_queue_t *queue = &vblk->queues[index];
+    if (vblk->Status & VIRTIO_STATUS__DEVICE_NEEDS_RESET)
+        return;
+
+    if (!((vblk->Status & VIRTIO_STATUS__DRIVER_OK) && queue->ready))
+        return virtio_blk_set_fail(vblk);
+
+    /* Check for new buffers */
+    uint16_t new_avail = ram[queue->QueueAvail] >> 16;
+    if (new_avail - queue->last_avail > (uint16_t) queue->QueueNum)
+        return (fprintf(stderr, "size check fail\n"),
+                virtio_blk_set_fail(vblk));
+
+    if (queue->last_avail == new_avail)
+        return;
+
+    /* Process them */
+    uint16_t new_used = ram[queue->QueueUsed] >> 16; /* virtq_used.idx (le16) */
+    while (queue->last_avail != new_avail) {
+        /* Obtain the index in the ring buffer */
+        uint16_t queue_idx = queue->last_avail % queue->QueueNum;
+
+        /* Since each buffer index occupies 2 bytes but the memory is aligned
+         * with 4 bytes, and the first element of the available queue is stored
+         * at ram[queue->QueueAvail + 1], to acquire the buffer index, it
+         * requires the following array index calculation and bit shifting.
+         * Check also the `struct virtq_avail` on the spec.
+         */
+        uint16_t buffer_idx = ram[queue->QueueAvail + 1 + queue_idx / 2] >>
+                              (16 * (queue_idx % 2));
+
+        /* Consume request from the available queue and process the data in the
+         * descriptor list.
+         */
+        uint32_t len = 0;
+        int result = virtio_blk_desc_handler(vblk, queue, buffer_idx, &len);
+        if (result != 0)
+            return virtio_blk_set_fail(vblk);
+
+        /* Write used element information (`struct virtq_used_elem`) to the used
+         * queue */
+        uint32_t vq_used_addr =
+            queue->QueueUsed + 1 + (new_used % queue->QueueNum) * 2;
+        ram[vq_used_addr] = buffer_idx; /* virtq_used_elem.id  (le32) */
+        ram[vq_used_addr + 1] = len;    /* virtq_used_elem.len (le32) */
+        queue->last_avail++;
+        new_used++;
+    }
+
+    /* Check le32 len field of `struct virtq_used_elem` on the spec  */
+    vblk->ram[queue->QueueUsed] &= MASK(16); /* Reset low 16 bits to zero */
+    vblk->ram[queue->QueueUsed] |= ((uint32_t) new_used) << 16; /* len */
+
+    /* Send interrupt, unless VIRTQ_AVAIL_F_NO_INTERRUPT is set */
+    if (!(ram[queue->QueueAvail] & 1))
+        vblk->InterruptStatus |= VIRTIO_INT__USED_RING;
+}
+
+static bool virtio_blk_reg_read(virtio_blk_state_t *vblk,
+                                uint32_t addr,
+                                uint32_t *value)
+{
+#define _(reg) VIRTIO_##reg
+    switch (addr) {
+    case _(MagicValue):
+        *value = 0x74726976;
+        return true;
+    case _(Version):
+        *value = 2;
+        return true;
+    case _(DeviceID):
+        *value = 2;
+        return true;
+    case _(VendorID):
+        *value = VIRTIO_VENDOR_ID;
+        return true;
+    case _(DeviceFeatures):
+        *value = vblk->DeviceFeaturesSel == 0
+                     ? VBLK_FEATURES_0
+                     : (vblk->DeviceFeaturesSel == 1 ? VBLK_FEATURES_1 : 0);
+        return true;
+    case _(QueueNumMax):
+        *value = VBLK_QUEUE_NUM_MAX;
+        return true;
+    case _(QueueReady):
+        *value = VBLK_QUEUE.ready ? 1 : 0;
+        return true;
+    case _(InterruptStatus):
+        *value = vblk->InterruptStatus;
+        return true;
+    case _(Status):
+        *value = vblk->Status;
+        return true;
+    case _(ConfigGeneration):
+        *value = 0;
+        return true;
+    default:
+        /* Invalid address which exceeded the range */
+        if (!RANGE_CHECK(addr, _(Config), sizeof(struct virtio_blk_config)))
+            return false;
+
+        /* Read configuration from the corresponding register */
+        *value = ((uint32_t *) PRIV(vblk))[addr - _(Config)];
+
+        return true;
+    }
+#undef _
+}
+
+static bool virtio_blk_reg_write(virtio_blk_state_t *vblk,
+                                 uint32_t addr,
+                                 uint32_t value)
+{
+#define _(reg) VIRTIO_##reg
+    switch (addr) {
+    case _(DeviceFeaturesSel):
+        vblk->DeviceFeaturesSel = value;
+        return true;
+    case _(DriverFeatures):
+        vblk->DriverFeaturesSel == 0 ? (vblk->DriverFeatures = value) : 0;
+        return true;
+    case _(DriverFeaturesSel):
+        vblk->DriverFeaturesSel = value;
+        return true;
+    case _(QueueSel):
+        if (value < ARRAY_SIZE(vblk->queues))
+            vblk->QueueSel = value;
+        else
+            virtio_blk_set_fail(vblk);
+        return true;
+    case _(QueueNum):
+        if (value > 0 && value <= VBLK_QUEUE_NUM_MAX)
+            VBLK_QUEUE.QueueNum = value;
+        else
+            virtio_blk_set_fail(vblk);
+        return true;
+    case _(QueueReady):
+        VBLK_QUEUE.ready = value & 1;
+        if (value & 1)
+            VBLK_QUEUE.last_avail = vblk->ram[VBLK_QUEUE.QueueAvail] >> 16;
+        return true;
+    case _(QueueDescLow):
+        VBLK_QUEUE.QueueDesc = vblk_preprocess(vblk, value);
+        return true;
+    case _(QueueDescHigh):
+        if (value)
+            virtio_blk_set_fail(vblk);
+        return true;
+    case _(QueueDriverLow):
+        VBLK_QUEUE.QueueAvail = vblk_preprocess(vblk, value);
+        return true;
+    case _(QueueDriverHigh):
+        if (value)
+            virtio_blk_set_fail(vblk);
+        return true;
+    case _(QueueDeviceLow):
+        VBLK_QUEUE.QueueUsed = vblk_preprocess(vblk, value);
+        return true;
+    case _(QueueDeviceHigh):
+        if (value)
+            virtio_blk_set_fail(vblk);
+        return true;
+    case _(QueueNotify):
+        if (value < ARRAY_SIZE(vblk->queues))
+            virtio_queue_notify_handler(vblk, value);
+        else
+            virtio_blk_set_fail(vblk);
+        return true;
+    case _(InterruptACK):
+        vblk->InterruptStatus &= ~value;
+        return true;
+    case _(Status):
+        virtio_blk_update_status(vblk, value);
+        return true;
+    default:
+        /* Invalid address which exceeded the range */
+        if (!RANGE_CHECK(addr, _(Config), sizeof(struct virtio_blk_config)))
+            return false;
+
+        /* Write configuration to the corresponding register */
+        ((uint32_t *) PRIV(vblk))[addr - _(Config)] = value;
+
+        return true;
+    }
+#undef _
+}
+
+void virtio_blk_read(rvvm_hart_t *vm,
+                     virtio_blk_state_t *vblk,
+                     uint32_t addr,
+                     uint8_t width,
+                     uint32_t *value)
+{
+    switch (width) {
+    case RV_MEM_LW:
+        if (!virtio_blk_reg_read(vblk, addr >> 2, value))
+            riscv_trap(vm, TRAP_LOAD_FAULT, vm->registers[REGISTER_PC]);
+        break;
+    case RV_MEM_LBU:
+    case RV_MEM_LB:
+    case RV_MEM_LHU:
+    case RV_MEM_LH:
+        riscv_trap(vm, TRAP_LOAD_MISALIGN, vm->registers[REGISTER_PC]);
+        return;
+    default:
+        riscv_trap(vm, TRAP_ILL_INSTR, 0);
+        return;
+    }
+}
+
+void virtio_blk_write(rvvm_hart_t *vm,
+                      virtio_blk_state_t *vblk,
+                      uint32_t addr,
+                      uint8_t width,
+                      uint32_t value)
+{
+    switch (width) {
+    case RV_MEM_SW:
+        if (!virtio_blk_reg_write(vblk, addr >> 2, value))
+            riscv_trap(vm, TRAP_STORE_FAULT, vm->registers[REGISTER_PC]);
+        break;
+    case RV_MEM_SB:
+    case RV_MEM_SH:
+        riscv_trap(vm, TRAP_STORE_MISALIGN, vm->registers[REGISTER_PC]);
+        return;
+    default:
+        riscv_trap(vm, TRAP_ILL_INSTR, 0);
+        return;
+    }
+}
+
+uint32_t *virtio_blk_init(virtio_blk_state_t *vblk, char *disk_file)
+{
+    if (vblk_dev_cnt >= VBLK_DEV_CNT_MAX) {
+        fprintf(stderr,
+                "Exceeded the number of virtio-blk devices that can be "
+                "allocated.\n");
+        exit(2);
+    }
+
+    /* Allocate memory for the private member */
+    vblk->priv = &vblk_configs[vblk_dev_cnt++];
+
+    /* No disk image is provided */
+    if (!disk_file) {
+        /* By setting the block capacity to zero, the kernel will
+         * then not to touch the device after booting */
+        PRIV(vblk)->capacity = 0;
+        return NULL;
+    }
+
+    /* Open disk file */
+    int disk_fd = open(disk_file, O_RDWR);
+    if (disk_fd < 0) {
+        fprintf(stderr, "could not open %s\n", disk_file);
+        exit(2);
+    }
+
+    /* Get the disk image size */
+    struct stat st;
+    fstat(disk_fd, &st);
+    size_t disk_size = st.st_size;
+
+    /* Set up the disk memory */
+    uint32_t *disk_mem =
+        mmap(NULL, disk_size, PROT_READ | PROT_WRITE, MAP_SHARED, disk_fd, 0);
+    if (disk_mem == MAP_FAILED) {
+        fprintf(stderr, "Could not map disk\n");
+        return NULL;
+    }
+    assert(!(((uintptr_t) disk_mem) & 0b11));
+    close(disk_fd);
+
+    vblk->disk = disk_mem;
+    PRIV(vblk)->capacity = (disk_size - 1) / DISK_BLK_SIZE + 1;
+
+    return disk_mem;
+}
diff --git a/src/devices/virtio-gpu.c b/src/devices/virtio-gpu.c
new file mode 100644
index 0000000..7c3d992
--- /dev/null
+++ b/src/devices/virtio-gpu.c
@@ -0,0 +1,1441 @@
+#include <assert.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <sys/uio.h>
+#include <unistd.h>
+#include <virgl/virglrenderer.h>
+
+#include "virtio_common.h"
+#include "virtio_device.h"
+#include "virtio_list.h"
+#include "riscv_hart.h"
+#include "riscv_priv.h"
+#include "virtio.h"
+#include "virtio_window.h"
+
+#define VIRTIO_F_VERSION_1 1
+
+#define VIRTIO_GPU_EVENT_DISPLAY (1 << 0)
+#define VIRTIO_GPU_F_VIRGL (1 << 0)
+#define VIRTIO_GPU_F_EDID (1 << 1)
+#define VIRTIO_GPU_FLAG_FENCE (1 << 0)
+
+#define VGPU_QUEUE_NUM_MAX 1024
+#define VGPU_QUEUE (vgpu->queues[vgpu->QueueSel])
+
+#define PRIV(x) ((struct vgpu_scanout_info *) x->priv)
+
+#define STRIDE_SIZE 4096
+
+enum {
+    RV_MEM_LB = 0b000,
+    RV_MEM_LH = 0b001,
+    RV_MEM_LW = 0b010,
+    RV_MEM_LBU = 0b100,
+    RV_MEM_LHU = 0b101,
+    RV_MEM_SB = 0b000,
+    RV_MEM_SH = 0b001,
+    RV_MEM_SW = 0b010,
+};
+
+struct vgpu_scanout_info {
+    uint32_t width;
+    uint32_t height;
+    uint32_t enabled;
+};
+
+struct vgpu_resource_2d {
+    /* Public: */
+    uint32_t scanout_id;
+    uint32_t format;
+    uint32_t width;
+    uint32_t height;
+    uint32_t stride;
+    uint32_t bits_per_pixel;
+    uint32_t *image;
+    /* Private: */
+    uint32_t resource_id;
+    size_t page_cnt;
+    struct iovec *iovec;
+    struct list_head list;
+};
+
+PACKED(struct vgpu_config {
+    uint32_t events_read;
+    uint32_t events_clear;
+    uint32_t num_scanouts;
+    uint32_t num_capsets;
+});
+
+PACKED(struct vgpu_ctrl_hdr {
+    uint32_t type;
+    uint32_t flags;
+    uint64_t fence_id;
+    uint32_t ctx_id;
+    uint8_t ring_idx;
+    uint8_t padding[3];
+});
+
+PACKED(struct vgpu_rect {
+    uint32_t x;
+    uint32_t y;
+    uint32_t width;
+    uint32_t height;
+});
+
+PACKED(struct vgpu_resp_disp_info {
+    struct vgpu_ctrl_hdr hdr;
+    struct virtio_gpu_display_one {
+        struct vgpu_rect r;
+        uint32_t enabled;
+        uint32_t flags;
+    } pmodes[VIRTIO_GPU_MAX_SCANOUTS];
+});
+
+PACKED(struct vgpu_res_create_2d {
+    struct vgpu_ctrl_hdr hdr;
+    uint32_t resource_id;
+    uint32_t format;
+    uint32_t width;
+    uint32_t height;
+});
+
+PACKED(struct vgpu_res_unref {
+    struct vgpu_ctrl_hdr hdr;
+    uint32_t resource_id;
+    uint32_t padding;
+});
+
+PACKED(struct vgpu_set_scanout {
+    struct vgpu_ctrl_hdr hdr;
+    struct vgpu_rect r;
+    uint32_t scanout_id;
+    uint32_t resource_id;
+});
+
+PACKED(struct vgpu_res_flush {
+    struct vgpu_ctrl_hdr hdr;
+    struct vgpu_rect r;
+    uint32_t resource_id;
+    uint32_t padding;
+});
+
+PACKED(struct vgpu_trans_to_host_2d {
+    struct vgpu_ctrl_hdr hdr;
+    struct vgpu_rect r;
+    uint64_t offset;
+    uint32_t resource_id;
+    uint32_t padding;
+});
+
+PACKED(struct vgpu_res_attach_backing {
+    struct vgpu_ctrl_hdr hdr;
+    uint32_t resource_id;
+    uint32_t nr_entries;
+});
+
+PACKED(struct vgpu_mem_entry {
+    uint64_t addr;
+    uint32_t length;
+    uint32_t padding;
+});
+
+PACKED(struct vgpu_resp_edid {
+    struct vgpu_ctrl_hdr hdr;
+    uint32_t size;
+    uint32_t padding;
+    char edid[1024];
+});
+
+PACKED(struct vgpu_get_capset_info {
+    struct vgpu_ctrl_hdr hdr;
+    uint32_t capset_index;
+    uint32_t padding;
+});
+
+PACKED(struct vgpu_resp_capset_info {
+    struct vgpu_ctrl_hdr hdr;
+    uint32_t capset_id;
+    uint32_t capset_max_version;
+    uint32_t capset_max_size;
+    uint32_t padding;
+});
+
+PACKED(struct virtio_gpu_ctx_create {
+    struct vgpu_ctrl_hdr hdr;
+    uint32_t nlen;
+    uint32_t context_init;
+    char debug_name[64];
+});
+
+/* clang-format off */
+PACKED(struct virtio_gpu_ctx_destroy {
+    struct vgpu_ctrl_hdr hdr;
+});
+/* clang-format on */
+
+PACKED(struct virtio_gpu_resource_create_3d {
+    struct vgpu_ctrl_hdr hdr;
+    uint32_t resource_id;
+    uint32_t target;
+    uint32_t format;
+    uint32_t bind;
+    uint32_t width;
+    uint32_t height;
+    uint32_t depth;
+    uint32_t array_size;
+    uint32_t last_level;
+    uint32_t nr_samples;
+    uint32_t flags;
+    uint32_t padding;
+});
+
+PACKED(struct virtio_gpu_ctx_resource {
+    struct vgpu_ctrl_hdr hdr;
+    uint32_t resource_id;
+    uint32_t padding;
+});
+
+PACKED(struct virtio_gpu_box {
+    uint32_t x;
+    uint32_t y;
+    uint32_t z;
+    uint32_t w;
+    uint32_t h;
+    uint32_t d;
+});
+
+PACKED(struct virtio_gpu_transfer_host_3d {
+    struct vgpu_ctrl_hdr hdr;
+    struct virtio_gpu_box box;
+    uint64_t offset;
+    uint32_t resource_id;
+    uint32_t level;
+    uint32_t stride;
+    uint32_t layer_stride;
+});
+
+PACKED(struct virtio_gpu_cmd_submit {
+    struct vgpu_ctrl_hdr hdr;
+    uint32_t size;
+    uint32_t num_in_fences;
+});
+
+PACKED(struct virtio_gpu_resp_map_info {
+    struct vgpu_ctrl_hdr hdr;
+    uint32_t map_info;
+    uint32_t padding;
+});
+
+static struct vgpu_config vgpu_configs;
+static LIST_HEAD(vgpu_res_2d_list);
+
+static inline void *vgpu_mem_host_to_guest(virtio_gpu_state_t *vgpu,
+                                           uint32_t addr)
+{
+    return (void *) ((uintptr_t) vgpu->ram + addr);
+}
+
+static struct vgpu_resource_2d *create_vgpu_resource_2d(int resource_id)
+{
+    struct vgpu_resource_2d *res = malloc(sizeof(struct vgpu_resource_2d));
+    if (!res)
+        return NULL;
+
+    res->resource_id = resource_id;
+    list_add(&res->list, &vgpu_res_2d_list);
+    return res;
+}
+
+static struct vgpu_resource_2d *acquire_vgpu_resource_2d(uint32_t resource_id)
+{
+    struct vgpu_resource_2d *res_2d;
+    list_for_each_entry (res_2d, &vgpu_res_2d_list, list) {
+        if (res_2d->resource_id == resource_id)
+            return res_2d;
+    }
+
+    return NULL;
+}
+
+static int destroy_vgpu_resource_2d(uint32_t resource_id)
+{
+    struct vgpu_resource_2d *res_2d = acquire_vgpu_resource_2d(resource_id);
+
+    /* Failed to find the resource */
+    if (!res_2d)
+        return -1;
+
+    window_lock(resource_id);
+
+    /* Release the resource */
+    free(res_2d->image);
+    list_del(&res_2d->list);
+    free(res_2d->iovec);
+    free(res_2d);
+
+    window_unlock(resource_id);
+
+    return 0;
+}
+
+static void virtio_gpu_set_fail(virtio_gpu_state_t *vgpu)
+{
+    vgpu->Status |= VIRTIO_STATUS__DEVICE_NEEDS_RESET;
+    if (vgpu->Status & VIRTIO_STATUS__DRIVER_OK)
+        vgpu->InterruptStatus |= VIRTIO_INT__CONF_CHANGE;
+}
+
+static inline uint32_t vgpu_preprocess(virtio_gpu_state_t *vgpu, uint32_t addr)
+{
+    if ((addr >= RAM_SIZE) || (addr & 0b11))
+        return virtio_gpu_set_fail(vgpu), 0;
+
+    return addr >> 2;
+}
+
+static void virtio_gpu_update_status(virtio_gpu_state_t *vgpu, uint32_t status)
+{
+    vgpu->Status |= status;
+    if (status)
+        return;
+
+    /* Reset */
+    uint32_t *ram = vgpu->ram;
+    void *priv = vgpu->priv;
+    uint32_t scanout_num = vgpu_configs.num_scanouts;
+    memset(vgpu->priv, 0, sizeof(*vgpu->priv));
+    memset(vgpu, 0, sizeof(*vgpu));
+    vgpu->ram = ram;
+    vgpu->priv = priv;
+    vgpu_configs.num_scanouts = scanout_num;
+
+    /* Release all 2D resources */
+    struct list_head *curr, *next;
+    list_for_each_safe (curr, next, &vgpu_res_2d_list) {
+        struct vgpu_resource_2d *res_2d =
+            list_entry(curr, struct vgpu_resource_2d, list);
+
+        list_del(&res_2d->list);
+        free(res_2d->image);
+        free(res_2d->iovec);
+        free(res_2d);
+    }
+}
+
+static void virtio_gpu_get_display_info_handler(virtio_gpu_state_t *vgpu,
+                                                struct virtq_desc *vq_desc,
+                                                uint32_t *plen)
+{
+    /* Write display infomation */
+    struct vgpu_resp_disp_info *response =
+        vgpu_mem_host_to_guest(vgpu, vq_desc[1].addr);
+
+    memset(response, 0, sizeof(*response));
+    response->hdr.type = VIRTIO_GPU_RESP_OK_DISPLAY_INFO;
+
+    int scanout_num = vgpu_configs.num_scanouts;
+    for (int i = 0; i < scanout_num; i++) {
+        response->pmodes[i].r.width = PRIV(vgpu)[i].width;
+        response->pmodes[i].r.height = PRIV(vgpu)[i].height;
+        response->pmodes[i].enabled = PRIV(vgpu)[i].enabled;
+    }
+
+    /* Update write length */
+    *plen = sizeof(*response);
+}
+
+static void virtio_gpu_resource_create_2d_handler(virtio_gpu_state_t *vgpu,
+                                                  struct virtq_desc *vq_desc,
+                                                  uint32_t *plen)
+{
+    /* Read request */
+    struct vgpu_res_create_2d *request =
+        vgpu_mem_host_to_guest(vgpu, vq_desc[0].addr);
+
+    /* Create 2D resource */
+    struct vgpu_resource_2d *res_2d =
+        create_vgpu_resource_2d(request->resource_id);
+
+    if (!res_2d) {
+        fprintf(stderr, "%s(): Failed to allocate 2D resource\n", __func__);
+        virtio_gpu_set_fail(vgpu);
+        return;
+    }
+
+    /* Select image formats */
+    uint32_t bits_per_pixel;
+
+    switch (request->format) {
+    case VIRTIO_GPU_FORMAT_B8G8R8A8_UNORM:
+        bits_per_pixel = 32;
+        break;
+    case VIRTIO_GPU_FORMAT_B8G8R8X8_UNORM:
+        bits_per_pixel = 32;
+        break;
+    case VIRTIO_GPU_FORMAT_A8R8G8B8_UNORM:
+        bits_per_pixel = 32;
+        break;
+    case VIRTIO_GPU_FORMAT_X8R8G8B8_UNORM:
+        bits_per_pixel = 32;
+        break;
+    case VIRTIO_GPU_FORMAT_R8G8B8A8_UNORM:
+        bits_per_pixel = 32;
+        break;
+    case VIRTIO_GPU_FORMAT_X8B8G8R8_UNORM:
+        bits_per_pixel = 32;
+        break;
+    case VIRTIO_GPU_FORMAT_A8B8G8R8_UNORM:
+        bits_per_pixel = 32;
+        break;
+    case VIRTIO_GPU_FORMAT_R8G8B8X8_UNORM:
+        bits_per_pixel = 32;
+        break;
+    default:
+        fprintf(stderr, "%s(): Unsupported format %d\n", __func__,
+                request->format);
+        virtio_gpu_set_fail(vgpu);
+        return;
+    }
+
+    uint32_t bytes_per_pixel = bits_per_pixel / 8;
+
+    /* Set 2D resource */
+    res_2d->width = request->width;
+    res_2d->height = request->height;
+    res_2d->format = request->format;
+    res_2d->bits_per_pixel = bits_per_pixel;
+    res_2d->stride = STRIDE_SIZE;
+    res_2d->image = malloc(bytes_per_pixel * (request->width + res_2d->stride) *
+                           request->height);
+
+    /* Failed to create image buffer */
+    if (!res_2d->image) {
+        fprintf(stderr, "%s(): Failed to allocate image buffer\n", __func__);
+        virtio_gpu_set_fail(vgpu);
+        return;
+    }
+
+    /* Write response */
+    struct vgpu_ctrl_hdr *response =
+        vgpu_mem_host_to_guest(vgpu, vq_desc[1].addr);
+
+    memset(response, 0, sizeof(*response));
+    response->type = VIRTIO_GPU_RESP_OK_NODATA;
+
+    /* Return write length */
+    *plen = sizeof(*response);
+}
+
+static void virtio_gpu_cmd_resource_unref_handler(virtio_gpu_state_t *vgpu,
+                                                  struct virtq_desc *vq_desc,
+                                                  uint32_t *plen)
+{
+    /* Read request */
+    struct vgpu_res_unref *request =
+        vgpu_mem_host_to_guest(vgpu, vq_desc[0].addr);
+
+    /* Destroy 2D resource */
+    int result = destroy_vgpu_resource_2d(request->resource_id);
+
+    if (result != 0) {
+        fprintf(stderr, "%s(): Failed to destroy 2D resource\n", __func__);
+        virtio_gpu_set_fail(vgpu);
+        return;
+    }
+
+    /* Write response */
+    struct vgpu_ctrl_hdr *response =
+        vgpu_mem_host_to_guest(vgpu, vq_desc[1].addr);
+
+    memset(response, 0, sizeof(struct vgpu_ctrl_hdr));
+    response->type = VIRTIO_GPU_RESP_OK_NODATA;
+
+    /* Return write length */
+    *plen = sizeof(*response);
+}
+
+static uint8_t virtio_gpu_generate_edid_checksum(uint8_t *edid, size_t size)
+{
+    uint8_t sum = 0;
+
+    for (size_t i = 0; i < size; i++)
+        sum += edid[i];
+
+    return 0x100 - sum;
+}
+
+static void virtio_gpu_generate_edid(uint8_t *edid, int width_cm, int height_cm)
+{
+    /* Check:
+     * "VESA ENHANCED EXTENDED DISPLAY IDENTIFICATION DATA STANDARD"
+     * (Defines EDID Structure Version 1, Revision 4)
+     */
+
+    memset(edid, 0, 128);
+
+    /* EDID header */
+    edid[0] = 0x00;
+    edid[1] = 0xff;
+    edid[2] = 0xff;
+    edid[3] = 0xff;
+    edid[4] = 0xff;
+    edid[5] = 0xff;
+    edid[6] = 0xff;
+    edid[7] = 0x00;
+
+    /* ISA (Industry Standard Architecture)
+     * Plug and Play Device Identifier (PNPID) */
+    char manufacture[3] = {'T', 'W', 'N'};
+
+    /* Vendor ID uses 2 bytes to store 3 characters, where 'A' starts as 1 */
+    uint16_t vendor_id = ((((manufacture[0] - '@') & 0b11111) << 10) |
+                          (((manufacture[1] - '@') & 0b11111) << 5) |
+                          (((manufacture[2] - '@') & 0b11111) << 0));
+    /* Convert vendor ID to big-endian order */
+    edid[8] = vendor_id >> 8;
+    edid[9] = vendor_id && 0xff;
+
+    /* Product code (all zeros if unused) */
+    memset(&edid[10], 0, 6);
+
+    /* Week of manufacture (1-54) */
+    edid[16] = 0;
+    /* Year of manufacture (starts from 1990) */
+    edid[17] = 2023 - 1990;
+
+    /* EDID 1.4 (Version 1, Revision 4) */
+    edid[18] = 1; /* Version number */
+    edid[19] = 4; /* Revision number */
+
+    /* Video input definition */
+    uint8_t signal_interface = 0b1 << 7;  /* digital */
+    uint8_t color_bit_depth = 0b010 << 4; /* 8 bits per primary color */
+    uint8_t interface_type = 0b101;       /* DisplayPort is supported */
+    edid[20] = signal_interface | color_bit_depth | interface_type;
+
+    /* Screen size or aspect ratio */
+    edid[21] = width_cm;  /* Horizontal screen size (1cm - 255cm) */
+    edid[22] = height_cm; /* Vertical screen size (1cm - 255cm) */
+
+    /* Gamma value */
+    edid[23] = 1; /* Assigned with the minimum value */
+
+    /* Feature support */
+    uint8_t power_management = 0 << 4; /* standby, suspend and active-off
+                                        * modes are not supported */
+    uint8_t color_type = 0 << 2; /* ignored as it is for the analog display */
+    uint8_t other_flags = 0b110; /* [2]: sRGB as default color space
+                                  * [1]: Prefered timing mode with native format
+                                  * [0]: Non-continuys frequency */
+    edid[24] = power_management | color_type | other_flags;
+
+    /* Established timmings: These are the default timmings defined by the
+     * VESA. Each bit represents 1 configuration. For now, we enable the
+     * timming configurations of 1024x768@60Hz only */
+    edid[35] = 0b00000000;
+    edid[36] = 0b00001000;
+    edid[37] = 0b00000000;
+
+    /* Standard timmings: 16 bytes data start from edid[38] to edid[54] as
+     * additional timming configurations with 2 bytes for each to define
+     * the horizontal pixel number, aspect ratio, and refresh rate. */
+
+    /* Extension block count number */
+    edid[126] = 0; /* No other extension blocks are defined */
+
+    /* Checksum of the first (and the only) extension block */
+    edid[127] = virtio_gpu_generate_edid_checksum(edid, 127);
+}
+
+static void virtio_gpu_get_edid_handler(virtio_gpu_state_t *vgpu,
+                                        struct virtq_desc *vq_desc,
+                                        uint32_t *plen)
+{
+    /* Generate the display EDID */
+    struct vgpu_resp_edid edid = {
+        .hdr = {.type = VIRTIO_GPU_RESP_OK_EDID},
+        .size = 128 /* One EDID extension block only */
+    };
+    virtio_gpu_generate_edid((uint8_t *) edid.edid, 0, 0);
+
+    /* Write EDID response */
+    struct vgpu_resp_edid *response =
+        vgpu_mem_host_to_guest(vgpu, vq_desc[1].addr);
+    memcpy(response, &edid, sizeof(*response));
+
+    /* return write length */
+    *plen = sizeof(*response);
+}
+
+static void virtio_gpu_get_capset_handler(virtio_gpu_state_t *vgpu,
+                                          struct virtq_desc *vq_desc,
+                                          uint32_t *plen)
+{
+    /* Write capability set */
+    struct vgpu_resp_capset_info *response =
+        vgpu_mem_host_to_guest(vgpu, vq_desc[1].addr);
+
+    memset(response, 0, sizeof(*response));
+    response->hdr.type = VIRTIO_GPU_RESP_OK_CAPSET_INFO;
+    response->capset_id = VIRTIO_GPU_CAPSET_VIRGL2;
+    response->capset_max_version = 1;
+    response->capset_max_size = 0;
+
+    /* Update write length */
+    *plen = sizeof(*response);
+}
+
+static void virtio_gpu_cmd_set_scanout_handler(virtio_gpu_state_t *vgpu,
+                                               struct virtq_desc *vq_desc,
+                                               uint32_t *plen)
+{
+    /* Read request */
+    struct vgpu_set_scanout *request =
+        vgpu_mem_host_to_guest(vgpu, vq_desc[0].addr);
+
+    /* Acquire 2D resource */
+    struct vgpu_resource_2d *res_2d =
+        acquire_vgpu_resource_2d(request->resource_id);
+
+    /* Linux's virtio-gpu driver may send scanout command
+     * even if the resource does not exist */
+    if (res_2d)
+        /* Set scanout ID to proper 2D resource */
+        res_2d->scanout_id = request->scanout_id;
+
+    /* Write response */
+    struct vgpu_ctrl_hdr *response =
+        vgpu_mem_host_to_guest(vgpu, vq_desc[1].addr);
+
+    memset(response, 0, sizeof(*response));
+    response->type = VIRTIO_GPU_RESP_OK_NODATA;
+
+    /* Return write length */
+    *plen = sizeof(*response);
+}
+
+static void virtio_gpu_cmd_resource_flush_handler(virtio_gpu_state_t *vgpu,
+                                                  struct virtq_desc *vq_desc,
+                                                  uint32_t *plen)
+{
+    /* Read request */
+    struct vgpu_res_flush *request =
+        vgpu_mem_host_to_guest(vgpu, vq_desc[0].addr);
+
+    /* Acquire 2D resource */
+    struct vgpu_resource_2d *res_2d =
+        acquire_vgpu_resource_2d(request->resource_id);
+
+    /* Trigger display window rendering */
+    window_render((struct gpu_resource *) res_2d);
+
+    /* Write response */
+    struct vgpu_ctrl_hdr *response =
+        vgpu_mem_host_to_guest(vgpu, vq_desc[1].addr);
+
+    memset(response, 0, sizeof(*response));
+    response->type = VIRTIO_GPU_RESP_OK_NODATA;
+
+    /* Return write length */
+    *plen = sizeof(*response);
+}
+
+static void virtio_gpu_cmd_transfer_to_host_2d_handler(
+    virtio_gpu_state_t *vgpu,
+    struct virtq_desc *vq_desc,
+    uint32_t *plen)
+{
+    /* Read request */
+    struct vgpu_trans_to_host_2d *req =
+        vgpu_mem_host_to_guest(vgpu, vq_desc[0].addr);
+
+    /* Acquire 2D resource */
+    struct vgpu_resource_2d *res_2d =
+        acquire_vgpu_resource_2d(req->resource_id);
+
+    if (!res_2d) {
+        fprintf(stderr, "%s(): Failed to find 2D resource\n", __func__);
+        virtio_gpu_set_fail(vgpu);
+        return;
+    }
+
+    /* Check image boundary */
+    if (req->r.x > res_2d->width || req->r.y > res_2d->height ||
+        req->r.width > res_2d->width || req->r.height > res_2d->height ||
+        req->r.x + req->r.width > res_2d->width ||
+        req->r.y + req->r.height > res_2d->height) {
+        fprintf(stderr, "%s(): Invalid image size\n", __func__);
+        virtio_gpu_set_fail(vgpu);
+        return;
+    }
+
+    /* Transfer frame data from guest to host */
+    uint32_t stride = res_2d->stride;
+    uint32_t bpp = res_2d->bits_per_pixel / 8; /* Bytes per pixel */
+    uint32_t width =
+        (req->r.width < res_2d->width) ? req->r.width : res_2d->width;
+    uint32_t height =
+        (req->r.height < res_2d->height) ? req->r.height : res_2d->height;
+    void *img_data = (void *) res_2d->image;
+
+    for (uint32_t h = 0; h < height; h++) {
+        size_t src_offset = req->offset + stride * h;
+        size_t dest_offset = (req->r.y + h) * stride + (req->r.x * bpp);
+        void *dest = (void *) ((uintptr_t) img_data + dest_offset);
+        size_t done = 0;
+        size_t total = width * bpp;
+
+        for (uint32_t i = 0; i < res_2d->page_cnt; i++) {
+            /* Skip empty pages */
+            if (res_2d->iovec[i].iov_base == 0 || res_2d->iovec[i].iov_len == 0)
+                continue;
+
+            if (src_offset < res_2d->iovec[i].iov_len) {
+                /* Source offset is in the image coordinate. The address to
+                 * copy from is the page base address plus with the offset
+                 */
+                void *src = (void *) ((uintptr_t) res_2d->iovec[i].iov_base +
+                                      src_offset);
+
+                /* Take as much as data of current page can provide */
+                size_t remained = total - done;
+                size_t page_avail = res_2d->iovec[i].iov_len - src_offset;
+                size_t nbytes = (remained < page_avail) ? remained : page_avail;
+
+                /* Copy to 2D resource buffer */
+                memcpy((void *) ((uintptr_t) dest + done), src, nbytes);
+
+                /* If there is still data left to read, but current page is
+                 * exhausted, we need to read from the beginning of the next
+                 * page, where its offset should be 0 */
+                src_offset = 0;
+
+                /* Count the total received bytes so far */
+                done += nbytes;
+
+                /* Data transfering of current scanline is complete */
+                if (done >= total)
+                    break;
+            } else {
+                /* Keep substracting until reaching the page */
+                src_offset -= res_2d->iovec[i].iov_len;
+            }
+        }
+    }
+
+    /* Write response */
+    struct vgpu_ctrl_hdr *response =
+        vgpu_mem_host_to_guest(vgpu, vq_desc[1].addr);
+
+    struct vgpu_ctrl_hdr res_no_data = {.type = VIRTIO_GPU_RESP_OK_NODATA};
+    memcpy(response, &res_no_data, sizeof(struct vgpu_ctrl_hdr));
+
+    /* Update write length */
+    *plen = sizeof(*response);
+}
+
+static void virtio_gpu_cmd_resource_attach_backing_handler(
+    virtio_gpu_state_t *vgpu,
+    struct virtq_desc *vq_desc,
+    uint32_t *plen)
+{
+    /* Read request */
+    struct vgpu_res_attach_backing *backing_info =
+        vgpu_mem_host_to_guest(vgpu, vq_desc[0].addr);
+    struct vgpu_mem_entry *pages =
+        vgpu_mem_host_to_guest(vgpu, vq_desc[1].addr);
+
+    /* Acquire 2D resource */
+    struct vgpu_resource_2d *res_2d =
+        acquire_vgpu_resource_2d(backing_info->resource_id);
+
+    /* Dispatch page memories to the 2D resource */
+    res_2d->page_cnt = backing_info->nr_entries;
+    res_2d->iovec = malloc(sizeof(struct iovec) * backing_info->nr_entries);
+    struct vgpu_mem_entry *mem_entries = (struct vgpu_mem_entry *) pages;
+
+    for (size_t i = 0; i < backing_info->nr_entries; i++) {
+        /* Attach address and length of i-th page to the 2D resource */
+        res_2d->iovec[i].iov_base =
+            vgpu_mem_host_to_guest(vgpu, mem_entries[i].addr);
+        res_2d->iovec[i].iov_len = mem_entries[i].length;
+
+        /* Corrupted page address */
+        if (!res_2d->iovec[i].iov_base) {
+            fprintf(stderr, "%s(): Invalid page address\n", __func__);
+            virtio_gpu_set_fail(vgpu);
+            return;
+        }
+    }
+
+    /* Write response */
+    struct vgpu_ctrl_hdr *response =
+        vgpu_mem_host_to_guest(vgpu, vq_desc[2].addr);
+
+    memset(response, 0, sizeof(*response));
+    response->type = VIRTIO_GPU_RESP_OK_NODATA;
+
+    /* Return write length */
+    *plen = sizeof(*response);
+}
+
+static void virtio_gpu_cmd_update_cursor_handler(virtio_gpu_state_t *vgpu,
+                                                 struct virtq_desc *vq_desc,
+                                                 uint32_t *plen)
+{
+    /* Write response */
+    struct vgpu_ctrl_hdr *response =
+        vgpu_mem_host_to_guest(vgpu, vq_desc[1].addr);
+
+    memset(response, 0, sizeof(*response));
+    response->type = VIRTIO_GPU_RESP_OK_NODATA;
+
+    /* Return write length */
+    *plen = sizeof(*response);
+}
+
+static void virtio_gpu_cmd_move_cursor_handler(virtio_gpu_state_t *vgpu,
+                                               struct virtq_desc *vq_desc,
+                                               uint32_t *plen)
+{
+    /* Write response */
+    struct vgpu_ctrl_hdr *response =
+        vgpu_mem_host_to_guest(vgpu, vq_desc[1].addr);
+
+    memset(response, 0, sizeof(*response));
+    response->type = VIRTIO_GPU_RESP_OK_NODATA;
+
+    /* Return write length */
+    *plen = sizeof(*response);
+}
+
+static void virtio_gpu_cmd_ctx_create_handler(virtio_gpu_state_t *vgpu,
+                                              struct virtq_desc *vq_desc,
+                                              uint32_t *plen)
+{
+    /* Read request */
+    struct virtio_gpu_ctx_create *request =
+        vgpu_mem_host_to_guest(vgpu, vq_desc[0].addr);
+
+    /* Create 3D context with VirGL */
+    virgl_renderer_context_create(request->hdr.ctx_id, request->nlen,
+                                  request->debug_name);
+
+    /* Write response */
+    struct vgpu_ctrl_hdr *response =
+        vgpu_mem_host_to_guest(vgpu, vq_desc[1].addr);
+
+    memset(response, 0, sizeof(*response));
+    response->type = VIRTIO_GPU_RESP_OK_NODATA;
+
+    /* Return write length */
+    *plen = sizeof(*response);
+}
+
+static void virtio_gpu_cmd_ctx_destroy_handler(virtio_gpu_state_t *vgpu,
+                                               struct virtq_desc *vq_desc,
+                                               uint32_t *plen)
+{
+    /* Read request */
+    struct virtio_gpu_ctx_destroy *request =
+        vgpu_mem_host_to_guest(vgpu, vq_desc[0].addr);
+
+    /* Destroy 3D context with VirGL */
+    virgl_renderer_context_destroy(request->hdr.ctx_id);
+
+    /* Write response */
+    struct vgpu_ctrl_hdr *response =
+        vgpu_mem_host_to_guest(vgpu, vq_desc[1].addr);
+
+    memset(response, 0, sizeof(*response));
+    response->type = VIRTIO_GPU_RESP_OK_NODATA;
+
+    /* Return write length */
+    *plen = sizeof(*response);
+}
+
+static void virtio_gpu_cmd_attach_resource_handler(virtio_gpu_state_t *vgpu,
+                                                   struct virtq_desc *vq_desc,
+                                                   uint32_t *plen)
+{
+    /* Read request */
+    struct virtio_gpu_ctx_resource *request =
+        vgpu_mem_host_to_guest(vgpu, vq_desc[0].addr);
+
+    /* Attach 3D context to resource with VirGL */
+    virgl_renderer_ctx_attach_resource(request->hdr.ctx_id,
+                                       request->resource_id);
+
+    /* Write response */
+    struct vgpu_ctrl_hdr *response =
+        vgpu_mem_host_to_guest(vgpu, vq_desc[1].addr);
+
+    memset(response, 0, sizeof(*response));
+    response->type = VIRTIO_GPU_RESP_OK_NODATA;
+
+    /* Return write length */
+    *plen = sizeof(*response);
+}
+
+static void virtio_gpu_cmd_detach_resource_handler(virtio_gpu_state_t *vgpu,
+                                                   struct virtq_desc *vq_desc,
+                                                   uint32_t *plen)
+{
+    /* Read request */
+    struct virtio_gpu_ctx_resource *request =
+        vgpu_mem_host_to_guest(vgpu, vq_desc[0].addr);
+
+    /* Detach 3D context and resource with VirGL */
+    virgl_renderer_ctx_detach_resource(request->hdr.ctx_id,
+                                       request->resource_id);
+
+    /* Write response */
+    struct vgpu_ctrl_hdr *response =
+        vgpu_mem_host_to_guest(vgpu, vq_desc[1].addr);
+
+    memset(response, 0, sizeof(*response));
+    response->type = VIRTIO_GPU_RESP_OK_NODATA;
+
+    /* Return write length */
+    *plen = sizeof(*response);
+}
+
+static void virtio_gpu_cmd_resource_create_3d_handler(
+    virtio_gpu_state_t *vgpu,
+    struct virtq_desc *vq_desc,
+    uint32_t *plen)
+{
+    /* Read request */
+    struct virtio_gpu_resource_create_3d *request =
+        vgpu_mem_host_to_guest(vgpu, vq_desc[0].addr);
+
+    /* Create 3D resource with VirGL */
+    struct virgl_renderer_resource_create_args args = {
+        .handle = request->resource_id,
+        .target = request->target,
+        .format = request->format,
+        .bind = request->bind,
+        .width = request->width,
+        .height = request->height,
+        .depth = request->depth,
+        .array_size = request->array_size,
+        .last_level = request->last_level,
+        .nr_samples = request->nr_samples,
+        .flags = request->flags,
+    };
+    virgl_renderer_resource_create(&args, NULL, 0);
+
+    /* Write response */
+    struct vgpu_ctrl_hdr *response =
+        vgpu_mem_host_to_guest(vgpu, vq_desc[1].addr);
+
+    memset(response, 0, sizeof(*response));
+    response->type = VIRTIO_GPU_RESP_OK_NODATA;
+
+    /* Return write length */
+    *plen = sizeof(*response);
+}
+
+static void virtio_gpu_cmd_transfer_to_host_3d_handler(
+    virtio_gpu_state_t *vgpu,
+    struct virtq_desc *vq_desc,
+    uint32_t *plen)
+{
+    /* Read request */
+    struct virtio_gpu_transfer_host_3d *req =
+        vgpu_mem_host_to_guest(vgpu, vq_desc[0].addr);
+
+    /* Transfer data from target to host with VirGL */
+    virgl_renderer_transfer_read_iov(req->resource_id, req->hdr.ctx_id,
+                                     req->level, req->stride, req->layer_stride,
+                                     (struct virgl_box *) &req->box,
+                                     req->offset, NULL, 0);
+
+    /* Write response */
+    struct vgpu_ctrl_hdr *response =
+        vgpu_mem_host_to_guest(vgpu, vq_desc[1].addr);
+
+    struct vgpu_ctrl_hdr res_no_data = {.type = VIRTIO_GPU_RESP_OK_NODATA};
+    memcpy(response, &res_no_data, sizeof(struct vgpu_ctrl_hdr));
+
+    /* Update write length */
+    *plen = sizeof(*response);
+}
+
+static void virtio_gpu_cmd_transfer_from_host_3d_handler(
+    virtio_gpu_state_t *vgpu,
+    struct virtq_desc *vq_desc,
+    uint32_t *plen)
+{
+    /* Read request */
+    struct virtio_gpu_transfer_host_3d *req =
+        vgpu_mem_host_to_guest(vgpu, vq_desc[0].addr);
+
+    /* Transfer data from host to target with VirGL */
+    virgl_renderer_transfer_write_iov(
+        req->resource_id, req->hdr.ctx_id, req->level, req->stride,
+        req->layer_stride, (struct virgl_box *) &req->box, req->offset, NULL,
+        0);
+
+    /* Write response */
+    struct vgpu_ctrl_hdr *response =
+        vgpu_mem_host_to_guest(vgpu, vq_desc[1].addr);
+
+    struct vgpu_ctrl_hdr res_no_data = {.type = VIRTIO_GPU_RESP_OK_NODATA};
+    memcpy(response, &res_no_data, sizeof(struct vgpu_ctrl_hdr));
+
+    /* Update write length */
+    *plen = sizeof(*response);
+}
+
+static void virtio_gpu_cmd_submit_3d_handler(virtio_gpu_state_t *vgpu,
+                                             struct virtq_desc *vq_desc,
+                                             uint32_t *plen)
+{
+    /* Read request */
+    struct virtio_gpu_cmd_submit *req =
+        vgpu_mem_host_to_guest(vgpu, vq_desc[0].addr);
+
+    /* Submit 3D command with VirGL */
+    // TODO
+    void *buffer = NULL;
+    int ndw = 0;
+    virgl_renderer_submit_cmd(buffer, req->hdr.ctx_id, ndw);
+
+    /* Write response */
+    struct vgpu_ctrl_hdr *response =
+        vgpu_mem_host_to_guest(vgpu, vq_desc[1].addr);
+
+    struct vgpu_ctrl_hdr res_no_data = {.type = VIRTIO_GPU_RESP_OK_NODATA};
+    memcpy(response, &res_no_data, sizeof(struct vgpu_ctrl_hdr));
+
+    /* Update write length */
+    *plen = sizeof(*response);
+}
+
+static int virtio_gpu_desc_handler(virtio_gpu_state_t *vgpu,
+                                   const virtio_gpu_queue_t *queue,
+                                   uint32_t desc_idx,
+                                   uint32_t *plen)
+{
+    /* virtio-gpu uses 3 virtqueue descriptors at most */
+    struct virtq_desc vq_desc[3];
+
+    /* Collect descriptors */
+    for (int i = 0; i < 3; i++) {
+        /* The size of the `struct virtq_desc` is 4 words */
+        uint32_t *desc = &vgpu->ram[queue->QueueDesc + desc_idx * 4];
+
+        /* Retrieve the fields of current descriptor */
+        vq_desc[i].addr = desc[0];
+        vq_desc[i].len = desc[2];
+        vq_desc[i].flags = desc[3];
+        desc_idx = desc[3] >> 16; /* vq_desc[desc_cnt].next */
+
+        /* Leave the loop if next-flag is not set */
+        if (!(vq_desc[i].flags & VIRTIO_DESC_F_NEXT))
+            break;
+    }
+
+    /* Process the header */
+    struct vgpu_ctrl_hdr *header =
+        vgpu_mem_host_to_guest(vgpu, vq_desc[0].addr);
+
+    /* Process the command */
+    switch (header->type) {
+    case VIRTIO_GPU_CMD_GET_DISPLAY_INFO:
+        virtio_gpu_get_display_info_handler(vgpu, vq_desc, plen);
+        break;
+    case VIRTIO_GPU_CMD_RESOURCE_CREATE_2D:
+        virtio_gpu_resource_create_2d_handler(vgpu, vq_desc, plen);
+        break;
+    case VIRTIO_GPU_CMD_RESOURCE_UNREF:
+        virtio_gpu_cmd_resource_unref_handler(vgpu, vq_desc, plen);
+        break;
+    case VIRTIO_GPU_CMD_GET_EDID:
+        virtio_gpu_get_edid_handler(vgpu, vq_desc, plen);
+        break;
+    case VIRTIO_GPU_CMD_GET_CAPSET_INFO:
+        virtio_gpu_get_capset_handler(vgpu, vq_desc, plen);
+        break;
+    case VIRTIO_GPU_CMD_SET_SCANOUT:
+        virtio_gpu_cmd_set_scanout_handler(vgpu, vq_desc, plen);
+        break;
+    case VIRTIO_GPU_CMD_RESOURCE_FLUSH:
+        virtio_gpu_cmd_resource_flush_handler(vgpu, vq_desc, plen);
+        break;
+    case VIRTIO_GPU_CMD_TRANSFER_TO_HOST_2D:
+        virtio_gpu_cmd_transfer_to_host_2d_handler(vgpu, vq_desc, plen);
+        break;
+    case VIRTIO_GPU_CMD_RESOURCE_ATTACH_BACKING:
+        virtio_gpu_cmd_resource_attach_backing_handler(vgpu, vq_desc, plen);
+        break;
+    case VIRTIO_GPU_CMD_UPDATE_CURSOR:
+        virtio_gpu_cmd_update_cursor_handler(vgpu, vq_desc, plen);
+        break;
+    case VIRTIO_GPU_CMD_MOVE_CURSOR:
+        virtio_gpu_cmd_move_cursor_handler(vgpu, vq_desc, plen);
+        break;
+    case VIRTIO_GPU_CMD_CTX_CREATE:
+        printf("@@@VIRTIO_GPU_CMD_CTX_CREATE\n");
+        virtio_gpu_cmd_ctx_create_handler(vgpu, vq_desc, plen);
+        break;
+    case VIRTIO_GPU_CMD_CTX_DESTROY:
+        printf("@@@VIRTIO_GPU_CMD_CTX_DESTROY\n");
+        virtio_gpu_cmd_ctx_destroy_handler(vgpu, vq_desc, plen);
+        break;
+    case VIRTIO_GPU_CMD_CTX_ATTACH_RESOURCE:
+        printf("@@@VIRTIO_GPU_CMD_CTX_ATTACH_RESOURCE\n");
+        virtio_gpu_cmd_attach_resource_handler(vgpu, vq_desc, plen);
+        break;
+    case VIRTIO_GPU_CMD_CTX_DETACH_RESOURCE:
+        printf("@@@VIRTIO_GPU_CMD_CTX_DETACH_RESOURCE\n");
+        virtio_gpu_cmd_detach_resource_handler(vgpu, vq_desc, plen);
+        break;
+    case VIRTIO_GPU_CMD_RESOURCE_CREATE_3D:
+        printf("@@@VIRTIO_GPU_CMD_RESOURCE_CREATE_3D\n");
+        virtio_gpu_cmd_resource_create_3d_handler(vgpu, vq_desc, plen);
+        break;
+    case VIRTIO_GPU_CMD_TRANSFER_TO_HOST_3D:
+        printf("@@@VIRTIO_GPU_CMD_TRANSFER_TO_HOST_3D\n");
+        virtio_gpu_cmd_transfer_to_host_3d_handler(vgpu, vq_desc, plen);
+        break;
+    case VIRTIO_GPU_CMD_TRANSFER_FROM_HOST_3D:
+        printf("@@@VIRTIO_GPU_CMD_TRANSFER_FROM_HOST_3D\n");
+        virtio_gpu_cmd_transfer_from_host_3d_handler(vgpu, vq_desc, plen);
+        break;
+    case VIRTIO_GPU_CMD_SUBMIT_3D:
+        printf("@@@VIRTIO_GPU_CMD_SUBMIT_3D\n");
+        virtio_gpu_cmd_submit_3d_handler(vgpu, vq_desc, plen);
+        break;
+    default:
+        fprintf(stderr, "%s(): unknown command %d\n", __func__, header->type);
+        virtio_gpu_set_fail(vgpu);
+        *plen = 0;
+        return -1;
+    }
+
+    return 0;
+}
+
+static void virtio_queue_notify_handler(virtio_gpu_state_t *vgpu, int index)
+{
+    uint32_t *ram = vgpu->ram;
+    virtio_gpu_queue_t *queue = &vgpu->queues[index];
+    if (vgpu->Status & VIRTIO_STATUS__DEVICE_NEEDS_RESET)
+        return;
+
+    if (!((vgpu->Status & VIRTIO_STATUS__DRIVER_OK) && queue->ready))
+        return virtio_gpu_set_fail(vgpu);
+
+    /* Check for new buffers */
+    uint16_t new_avail = ram[queue->QueueAvail] >> 16;
+    if (new_avail - queue->last_avail > (uint16_t) queue->QueueNum)
+        return (fprintf(stderr, "%s(): size check failed\n", __func__),
+                virtio_gpu_set_fail(vgpu));
+
+    if (queue->last_avail == new_avail)
+        return;
+
+    /* Process them */
+    uint16_t new_used = ram[queue->QueueUsed] >> 16; /* virtq_used.idx (le16) */
+    while (queue->last_avail != new_avail) {
+        /* Obtain the index in the ring buffer */
+        uint16_t queue_idx = queue->last_avail % queue->QueueNum;
+
+        /* Since each buffer index occupies 2 bytes but the memory is aligned
+         * with 4 bytes, and the first element of the available queue is stored
+         * at ram[queue->QueueAvail + 1], to acquire the buffer index, it
+         * requires the following array index calculation and bit shifting.
+         * Check also the `struct virtq_avail` on the spec.
+         */
+        uint16_t buffer_idx = ram[queue->QueueAvail + 1 + queue_idx / 2] >>
+                              (16 * (queue_idx % 2));
+
+        /* Consume request from the available queue and process the data in the
+         * descriptor list.
+         */
+        uint32_t len = 0;
+        int result = virtio_gpu_desc_handler(vgpu, queue, buffer_idx, &len);
+        if (result != 0)
+            return virtio_gpu_set_fail(vgpu);
+
+        /* Write used element information (`struct virtq_used_elem`) to the used
+         * queue */
+        uint32_t vq_used_addr =
+            queue->QueueUsed + 1 + (new_used % queue->QueueNum) * 2;
+        ram[vq_used_addr] = buffer_idx; /* virtq_used_elem.id  (le32) */
+        ram[vq_used_addr + 1] = len;    /* virtq_used_elem.len (le32) */
+        queue->last_avail++;
+        new_used++;
+    }
+
+    /* Check le32 len field of `struct virtq_used_elem` on the spec  */
+    vgpu->ram[queue->QueueUsed] &= MASK(16); /* Reset low 16 bits to zero */
+    vgpu->ram[queue->QueueUsed] |= ((uint32_t) new_used) << 16; /* len */
+
+    /* Send interrupt, unless VIRTQ_AVAIL_F_NO_INTERRUPT is set */
+    if (!(ram[queue->QueueAvail] & 1))
+        vgpu->InterruptStatus |= VIRTIO_INT__USED_RING;
+}
+
+static bool virtio_gpu_reg_read(virtio_gpu_state_t *vgpu,
+                                uint32_t addr,
+                                uint32_t *value)
+{
+#define _(reg) VIRTIO_##reg
+    switch (addr) {
+    case _(MagicValue):
+        *value = 0x74726976;
+        return true;
+    case _(Version):
+        *value = 2;
+        return true;
+    case _(DeviceID):
+        *value = 16;
+        return true;
+    case _(VendorID):
+        *value = VIRTIO_VENDOR_ID;
+        return true;
+    case _(DeviceFeatures):
+        if (vgpu->DeviceFeaturesSel) { /* [63:32] */
+            *value = VIRTIO_F_VERSION_1;
+        } else { /* [31:0] */
+            *value = VIRTIO_GPU_F_EDID;
+#if SEMU_HAS(VIRGL)
+            *value |= VIRTIO_GPU_F_VIRGL;
+#endif
+        }
+        return true;
+    case _(QueueNumMax):
+        *value = VGPU_QUEUE_NUM_MAX;
+        return true;
+    case _(QueueReady):
+        *value = VGPU_QUEUE.ready ? 1 : 0;
+        return true;
+    case _(InterruptStatus):
+        *value = vgpu->InterruptStatus;
+        return true;
+    case _(Status):
+        *value = vgpu->Status;
+        return true;
+    case _(SHMLenLow):
+    case _(SHMLenHigh):
+        /* shared memory is unimplemented */
+        *value = -1;
+        return true;
+    case _(SHMBaseLow):
+        *value = 0;
+        return true;
+    case _(SHMBaseHigh):
+        *value = 0;
+        return true;
+    case _(ConfigGeneration):
+        *value = 0;
+        return true;
+    default:
+        /* Invalid address which exceeded the range */
+        if (!RANGE_CHECK(addr, _(Config), sizeof(struct vgpu_config)))
+            return false;
+
+        /* Read configuration from the corresponding register */
+        uint32_t offset = (addr - _(Config)) << 2;
+        switch (offset) {
+        case offsetof(struct vgpu_config, events_read): {
+            *value = 0; /* No event is implemented currently */
+            return true;
+        }
+        case offsetof(struct vgpu_config, num_scanouts): {
+            *value = vgpu_configs.num_scanouts;
+            return true;
+        }
+        case offsetof(struct vgpu_config, num_capsets): {
+            *value = 1; /* TODO: Add at least one capset to support VirGl */
+            return true;
+        }
+        default:
+            return false;
+        }
+    }
+#undef _
+}
+
+static bool virtio_gpu_reg_write(virtio_gpu_state_t *vgpu,
+                                 uint32_t addr,
+                                 uint32_t value)
+{
+#define _(reg) VIRTIO_##reg
+    switch (addr) {
+    case _(DeviceFeaturesSel):
+        vgpu->DeviceFeaturesSel = value;
+        return true;
+    case _(DriverFeatures):
+        vgpu->DriverFeaturesSel == 0 ? (vgpu->DriverFeatures = value) : 0;
+        return true;
+    case _(DriverFeaturesSel):
+        vgpu->DriverFeaturesSel = value;
+        return true;
+    case _(QueueSel):
+        if (value < ARRAY_SIZE(vgpu->queues))
+            vgpu->QueueSel = value;
+        else
+            virtio_gpu_set_fail(vgpu);
+        return true;
+    case _(QueueNum):
+        if (value > 0 && value <= VGPU_QUEUE_NUM_MAX)
+            VGPU_QUEUE.QueueNum = value;
+        else
+            virtio_gpu_set_fail(vgpu);
+        return true;
+    case _(QueueReady):
+        VGPU_QUEUE.ready = value & 1;
+        if (value & 1)
+            VGPU_QUEUE.last_avail = vgpu->ram[VGPU_QUEUE.QueueAvail] >> 16;
+        return true;
+    case _(QueueDescLow):
+        VGPU_QUEUE.QueueDesc = vgpu_preprocess(vgpu, value);
+        return true;
+    case _(QueueDescHigh):
+        if (value)
+            virtio_gpu_set_fail(vgpu);
+        return true;
+    case _(QueueDriverLow):
+        VGPU_QUEUE.QueueAvail = vgpu_preprocess(vgpu, value);
+        return true;
+    case _(QueueDriverHigh):
+        if (value)
+            virtio_gpu_set_fail(vgpu);
+        return true;
+    case _(QueueDeviceLow):
+        VGPU_QUEUE.QueueUsed = vgpu_preprocess(vgpu, value);
+        return true;
+    case _(QueueDeviceHigh):
+        if (value)
+            virtio_gpu_set_fail(vgpu);
+        return true;
+    case _(QueueNotify):
+        if (value < ARRAY_SIZE(vgpu->queues))
+            virtio_queue_notify_handler(vgpu, value);
+        else
+            virtio_gpu_set_fail(vgpu);
+        return true;
+    case _(InterruptACK):
+        vgpu->InterruptStatus &= ~value;
+        return true;
+    case _(Status):
+        virtio_gpu_update_status(vgpu, value);
+        return true;
+    case _(SHMSel):
+        return true;
+    default:
+        /* Invalid address which exceeded the range */
+        if (!RANGE_CHECK(addr, _(Config), sizeof(struct vgpu_config)))
+            return false;
+
+        /* Write configuration to the corresponding register */
+        uint32_t offset = (addr - _(Config)) << 2;
+        switch (offset) {
+        case offsetof(struct vgpu_config, events_clear): {
+            /* Ignored, no event is implemented currently */
+            return true;
+        }
+        default:
+            return false;
+        }
+    }
+#undef _
+}
+
+void virtio_gpu_read(rvvm_hart_t *vm,
+                     virtio_gpu_state_t *vgpu,
+                     uint32_t addr,
+                     uint8_t width,
+                     uint32_t *value)
+{
+    switch (width) {
+    case RV_MEM_LW:
+        if (!virtio_gpu_reg_read(vgpu, addr >> 2, value))
+            riscv_trap(vm, TRAP_LOAD_FAULT, vm->registers[REGISTER_PC]);
+        break;
+    case RV_MEM_LBU:
+    case RV_MEM_LB:
+    case RV_MEM_LHU:
+    case RV_MEM_LH:
+        riscv_trap(vm, TRAP_LOAD_MISALIGN, vm->registers[REGISTER_PC]);
+        return;
+    default:
+        riscv_trap(vm, TRAP_ILL_INSTR, 0);
+        return;
+    }
+}
+
+void virtio_gpu_write(rvvm_hart_t *vm,
+                      virtio_gpu_state_t *vgpu,
+                      uint32_t addr,
+                      uint8_t width,
+                      uint32_t value)
+{
+    switch (width) {
+    case RV_MEM_SW:
+        if (!virtio_gpu_reg_write(vgpu, addr >> 2, value))
+            riscv_trap(vm, TRAP_STORE_FAULT, vm->registers[REGISTER_PC]);
+        break;
+    case RV_MEM_SB:
+    case RV_MEM_SH:
+        riscv_trap(vm, TRAP_STORE_MISALIGN, vm->registers[REGISTER_PC]);
+        return;
+    default:
+        riscv_trap(vm, TRAP_ILL_INSTR, 0);
+        return;
+    }
+}
+
+void virtio_gpu_init(virtio_gpu_state_t *vgpu)
+{
+    vgpu->priv =
+        calloc(sizeof(struct vgpu_scanout_info), VIRTIO_GPU_MAX_SCANOUTS);
+}
+
+void semu_virgl_init(void)
+{
+    struct virgl_renderer_callbacks cb;
+    memset(&cb, 0, sizeof(cb));
+    cb.version = VIRGL_RENDERER_CALLBACKS_VERSION;
+
+    int flags = VIRGL_RENDERER_USE_EGL | VIRGL_RENDERER_THREAD_SYNC;
+    static int cookie;  // FIXME: This is for passing user-defined data
+
+    int ret = virgl_renderer_init(&cookie, flags, &cb);
+    if (ret) {
+        fprintf(stderr, "failed to initialize virgl renderer: %s\n",
+                strerror(ret));
+        exit(2);
+    }
+}
+
+void virtio_gpu_add_scanout(virtio_gpu_state_t *vgpu,
+                            uint32_t width,
+                            uint32_t height)
+{
+    int scanout_num = vgpu_configs.num_scanouts;
+
+    if (scanout_num >= VIRTIO_GPU_MAX_SCANOUTS) {
+        fprintf(stderr, "%s(): exceeded scanout maximum number\n", __func__);
+        exit(2);
+    }
+
+    PRIV(vgpu)[scanout_num].width = width;
+    PRIV(vgpu)[scanout_num].height = height;
+    PRIV(vgpu)[scanout_num].enabled = 1;
+
+    window_add(width, height);
+
+    vgpu_configs.num_scanouts++;
+}
diff --git a/src/devices/virtio-input.c b/src/devices/virtio-input.c
new file mode 100644
index 0000000..b37bcec
--- /dev/null
+++ b/src/devices/virtio-input.c
@@ -0,0 +1,663 @@
+#include <assert.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <pthread.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <sys/uio.h>
+#include <unistd.h>
+
+#include "virtio_common.h"
+#include "virtio_device.h"
+#include "virtio_input-event-codes.h"
+#include "virtio_list.h"
+#include "riscv_hart.h"
+#include "riscv_priv.h"
+#include "virtio.h"
+
+#define BUS_VIRTUAL 0x06 /* Definition from the Linux kernel */
+
+#define VINPUT_KEYBOARD_NAME "VirtIO Keyboard"
+#define VINPUT_MOUSE_NAME "VirtIO Mouse"
+
+#define VIRTIO_INPUT_SERIAL "None"
+
+#define VIRTIO_F_VERSION_1 1
+
+#define VINPUT_FEATURES_0 0
+#define VINPUT_FEATURES_1 1 /* VIRTIO_F_VERSION_1 */
+
+#define VINPUT_QUEUE_NUM_MAX 1024
+#define VINPUT_QUEUE (vinput->queues[vinput->QueueSel])
+
+enum {
+    RV_MEM_LB = 0b000,
+    RV_MEM_LH = 0b001,
+    RV_MEM_LW = 0b010,
+    RV_MEM_LBU = 0b100,
+    RV_MEM_LHU = 0b101,
+    RV_MEM_SB = 0b000,
+    RV_MEM_SH = 0b001,
+    RV_MEM_SW = 0b010,
+};
+
+enum {
+    VINPUT_KEYBOARD_ID = 0,
+    VINPUT_MOUSE_ID = 1,
+    VINPUT_DEV_CNT,
+};
+
+enum {
+    EVENTQ = 0,
+    STATUSQ = 1,
+};
+
+enum {
+    VIRTIO_INPUT_REG_SELECT = 0x100,
+    VIRTIO_INPUT_REG_SUBSEL = 0x101,
+    VIRTIO_INPUT_REG_SIZE = 0x102,
+};
+
+enum virtio_input_config_select {
+    VIRTIO_INPUT_CFG_UNSET = 0x00,
+    VIRTIO_INPUT_CFG_ID_NAME = 0x01,
+    VIRTIO_INPUT_CFG_ID_SERIAL = 0x02,
+    VIRTIO_INPUT_CFG_ID_DEVIDS = 0x03,
+    VIRTIO_INPUT_CFG_PROP_BITS = 0x10,
+    VIRTIO_INPUT_CFG_EV_BITS = 0x11,
+    VIRTIO_INPUT_CFG_ABS_INFO = 0x12,
+};
+
+PACKED(struct virtio_input_absinfo {
+    uint32_t min;
+    uint32_t max;
+    uint32_t fuzz;
+    uint32_t flat;
+    uint32_t res;
+});
+
+PACKED(struct virtio_input_devids {
+    uint16_t bustype;
+    uint16_t vendor;
+    uint16_t product;
+    uint16_t version;
+});
+
+PACKED(struct virtio_input_config {
+    uint8_t select;
+    uint8_t subsel;
+    uint8_t size;
+    uint8_t reserved[5];
+    union {
+        char string[128];
+        uint8_t bitmap[128];
+        struct virtio_input_absinfo abs;
+        struct virtio_input_devids ids;
+    } u;
+});
+
+PACKED(struct virtio_input_event {
+    uint16_t type;
+    uint16_t code;
+    uint32_t value;
+});
+
+struct virio_input_data {
+    uint32_t ev_notify;
+    virtio_input_state_t *vinput;
+    struct virtio_input_config cfg;
+};
+
+static pthread_mutex_t virtio_input_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pthread_cond_t virtio_input_cond = PTHREAD_COND_INITIALIZER;
+
+static struct virio_input_data vinput_dev[VINPUT_DEV_CNT];
+static int vinput_dev_cnt;
+
+static char *vinput_dev_name[VINPUT_DEV_CNT] = {
+    VINPUT_KEYBOARD_NAME,
+    VINPUT_MOUSE_NAME,
+};
+
+static void virtio_input_set_fail(virtio_input_state_t *vinput)
+{
+    vinput->Status |= VIRTIO_STATUS__DEVICE_NEEDS_RESET;
+    if (vinput->Status & VIRTIO_STATUS__DRIVER_OK)
+        vinput->InterruptStatus |= VIRTIO_INT__CONF_CHANGE;
+}
+
+static inline uint32_t vinput_preprocess(virtio_input_state_t *vinput,
+                                         uint32_t addr)
+{
+    if ((addr >= RAM_SIZE) || (addr & 0b11))
+        return virtio_input_set_fail(vinput), 0;
+
+    return addr >> 2;
+}
+
+static void virtio_input_update_status(virtio_input_state_t *vinput,
+                                       uint32_t status)
+{
+    vinput->Status |= status;
+    if (status)
+        return;
+
+    /* Reset */
+    uint32_t *ram = vinput->ram;
+    // void *priv = vinput->priv; /* TODO */
+    int id = vinput->id; /* TODO: Store in vinput->priv */
+    memset(vinput, 0, sizeof(*vinput));
+    vinput->ram = ram;
+    vinput->id = id;
+    // vinput->priv = priv;
+}
+
+static void virtio_input_desc_handler(virtio_input_state_t *vinput,
+                                      struct virtio_input_event *input_ev,
+                                      uint32_t ev_cnt,
+                                      virtio_input_queue_t *queue)
+{
+    uint32_t *desc;
+    struct virtq_desc vq_desc;
+    struct virtio_input_event *ev;
+
+    uint32_t *ram = vinput->ram;
+    uint16_t new_avail =
+        ram[queue->QueueAvail] >> 16; /* virtq_avail.idx (le16) */
+    uint16_t new_used = ram[queue->QueueUsed] >> 16; /* virtq_used.idx (le16) */
+
+    /* For checking if the event buffer has enough space to write */
+    uint32_t end = queue->last_avail + ev_cnt;
+    uint32_t flattened_avail_idx = new_avail;
+
+    /* Handle if the available index has overflowed and returned to the
+     * beginning */
+    if (new_avail < queue->last_avail)
+        flattened_avail_idx += UINT16_MAX;
+
+    /* Check if need to wait until the driver supplies new buffers */
+    if (flattened_avail_idx < end)
+        return;
+
+    for (uint32_t i = 0; i < ev_cnt; i++) {
+        /* Obtain the available ring index */
+        uint16_t queue_idx = queue->last_avail % queue->QueueNum;
+        uint16_t buffer_idx = ram[queue->QueueAvail + 1 + queue_idx / 2] >>
+                              (16 * (queue_idx % 2));
+
+        desc = &vinput->ram[queue->QueueDesc + buffer_idx * 4];
+        vq_desc.addr = desc[0];
+        vq_desc.len = desc[2];
+        vq_desc.flags = desc[3];
+        ev = (struct virtio_input_event *) ((uintptr_t) vinput->ram +
+                                            vq_desc.addr);
+
+        desc[3] = 0;
+
+        /* Write event */
+        ev->type = input_ev[i].type;
+        ev->code = input_ev[i].code;
+        ev->value = input_ev[i].value;
+
+        /* Used ring */
+        uint32_t vq_used_addr =
+            queue->QueueUsed + 1 + (new_used % queue->QueueNum) * 2;
+        ram[vq_used_addr] = buffer_idx;
+        ram[vq_used_addr + 1] = sizeof(struct virtio_input_event);
+
+        new_used++;
+        queue->last_avail++;
+    }
+
+    /* Reset used ring flag to zero (virtq_used.flags) */
+    vinput->ram[queue->QueueUsed] &= MASK(16);
+    /* Update the used ring pointer (virtq_used.idx) */
+    /* TODO: Check if the or-ing is valid or not */
+    // vinput->ram[queue->QueueUsed] |= ((uint32_t) new_used) << 16;
+    uint16_t *used = (uint16_t *) &vinput->ram[queue->QueueUsed];
+    used[1] = new_used;
+
+    return;
+}
+
+static void virtio_queue_event_update(int dev_id,
+                                      struct virtio_input_event *input_ev,
+                                      uint32_t ev_cnt)
+{
+    virtio_input_state_t *vinput = vinput_dev[dev_id].vinput;
+    int index = EVENTQ;
+
+    /* Start of the critical section */
+    pthread_mutex_lock(&virtio_input_mutex);
+
+    /* Wait until event buffer to be ready */
+    while (vinput_dev[vinput->id].ev_notify <= 0)
+        pthread_cond_wait(&virtio_input_cond, &virtio_input_mutex);
+
+    /* Consume notification count */
+    vinput_dev[dev_id].ev_notify--;
+
+    uint32_t *ram = vinput->ram;
+    virtio_input_queue_t *queue = &vinput->queues[index];
+    if (vinput->Status & VIRTIO_STATUS__DEVICE_NEEDS_RESET)
+        goto success;
+
+    if (!((vinput->Status & VIRTIO_STATUS__DRIVER_OK) && queue->ready))
+        goto fail;
+
+    /* Check for new buffers */
+    uint16_t new_avail = ram[queue->QueueAvail] >> 16;
+    if (new_avail - queue->last_avail > (uint16_t) queue->QueueNum) {
+        fprintf(stderr, "%s(): size check failed\n", __func__);
+        goto fail;
+    }
+
+    if (queue->last_avail == new_avail)
+        goto success;
+
+    virtio_input_desc_handler(vinput, input_ev, ev_cnt, queue);
+
+    /* Send interrupt, unless VIRTQ_AVAIL_F_NO_INTERRUPT is set */
+    if (!(ram[queue->QueueAvail] & 1))
+        vinput->InterruptStatus |= VIRTIO_INT__USED_RING;
+
+    goto success;
+
+fail:
+    virtio_input_set_fail(vinput);
+
+success:
+    /* End of the critical section */
+    pthread_mutex_unlock(&virtio_input_mutex);
+}
+
+void virtio_input_update_key(uint32_t key, uint32_t state)
+{
+    struct virtio_input_event input_ev[] = {
+        {.type = EV_KEY, .code = key, .value = state},
+        {.type = EV_SYN, .code = SYN_REPORT, .value = 0},
+    };
+
+    size_t ev_cnt = ARRAY_SIZE(input_ev);
+    virtio_queue_event_update(VINPUT_KEYBOARD_ID, input_ev, ev_cnt);
+}
+
+void virtio_input_update_mouse_button_state(uint32_t button, bool pressed)
+{
+    struct virtio_input_event input_ev[] = {
+        {.type = EV_KEY, .code = button, .value = pressed},
+        {.type = EV_SYN, .code = SYN_REPORT, .value = 0},
+    };
+
+    size_t ev_cnt = ARRAY_SIZE(input_ev);
+    virtio_queue_event_update(VINPUT_MOUSE_ID, input_ev, ev_cnt);
+}
+
+void virtio_input_update_cursor(uint32_t x, uint32_t y)
+{
+    struct virtio_input_event input_ev[] = {
+        {.type = EV_ABS, .code = ABS_X, .value = x},
+        {.type = EV_ABS, .code = ABS_Y, .value = y},
+        {.type = EV_SYN, .code = SYN_REPORT, .value = 0},
+    };
+
+    size_t ev_cnt = ARRAY_SIZE(input_ev);
+    virtio_queue_event_update(VINPUT_MOUSE_ID, input_ev, ev_cnt);
+}
+
+static void virtio_input_properties(int dev_id)
+{
+    struct virtio_input_config *cfg = &vinput_dev[dev_id].cfg;
+
+    memset(cfg->u.bitmap, 0, 128);
+    set_bit(INPUT_PROP_POINTER, (unsigned long *) cfg->u.bitmap);
+    set_bit(INPUT_PROP_DIRECT, (unsigned long *) cfg->u.bitmap);
+    cfg->size = 128;
+}
+
+static void virtio_keyboard_support_events(int dev_id, uint8_t event)
+{
+    struct virtio_input_config *cfg = &vinput_dev[dev_id].cfg;
+
+    memset(cfg->u.bitmap, 0, 128);
+
+    switch (event) {
+    case EV_KEY:
+        memset(cfg->u.bitmap, 0xff, 128);
+        cfg->size = 128;
+        break;
+    case EV_MSC:
+        bitmap_set_bit((unsigned long *) cfg->u.bitmap, REP_DELAY);
+        bitmap_set_bit((unsigned long *) cfg->u.bitmap, REP_PERIOD);
+        cfg->size = 128;
+        break;
+    default:
+        cfg->size = 0;
+    }
+}
+
+static void virtio_mouse_support_events(int dev_id, uint8_t event)
+{
+    struct virtio_input_config *cfg = &vinput_dev[dev_id].cfg;
+
+    memset(cfg->u.bitmap, 0, 128);
+
+    switch (event) {
+    case EV_KEY:
+        bitmap_set_bit((unsigned long *) cfg->u.bitmap, BTN_LEFT);
+        bitmap_set_bit((unsigned long *) cfg->u.bitmap, BTN_RIGHT);
+        bitmap_set_bit((unsigned long *) cfg->u.bitmap, BTN_MIDDLE);
+        cfg->size = 128;
+        break;
+    case EV_ABS:
+        bitmap_set_bit((unsigned long *) cfg->u.bitmap, ABS_X);
+        bitmap_set_bit((unsigned long *) cfg->u.bitmap, ABS_Y);
+        cfg->size = 128;
+        break;
+    default:
+        cfg->size = 0;
+    }
+}
+
+static void virtio_input_support_events(int dev_id, uint8_t event)
+{
+    switch (dev_id) {
+    case VINPUT_KEYBOARD_ID:
+        virtio_keyboard_support_events(dev_id, event);
+        break;
+    case VINPUT_MOUSE_ID:
+        virtio_mouse_support_events(dev_id, event);
+        break;
+    }
+}
+
+static void virtio_input_abs_range(int dev_id, uint8_t code)
+{
+    struct virtio_input_config *cfg = &vinput_dev[dev_id].cfg;
+
+    switch (code) {
+    case ABS_X:
+        cfg->u.abs.min = 0;
+        cfg->u.abs.max = SCREEN_WIDTH;
+        cfg->u.abs.res = 1;
+        cfg->size = sizeof(struct virtio_input_absinfo);
+        break;
+    case ABS_Y:
+        cfg->u.abs.min = 0;
+        cfg->u.abs.max = SCREEN_HEIGHT;
+        cfg->u.abs.res = 1;
+        cfg->size = sizeof(struct virtio_input_absinfo);
+        break;
+    default:
+        cfg->size = 0;
+    }
+}
+
+static bool virtio_input_cfg_read(int dev_id)
+{
+    uint8_t select = vinput_dev[dev_id].cfg.select;
+    uint8_t subsel = vinput_dev[dev_id].cfg.subsel;
+    struct virtio_input_config *cfg = &vinput_dev[dev_id].cfg;
+
+    switch (select) {
+    case VIRTIO_INPUT_CFG_ID_NAME:
+        strcpy(cfg->u.string, vinput_dev_name[dev_id]);
+        cfg->size = strlen(vinput_dev_name[dev_id]);
+        return true;
+    case VIRTIO_INPUT_CFG_ID_SERIAL:
+        strcpy(cfg->u.string, VIRTIO_INPUT_SERIAL);
+        cfg->size = strlen(VIRTIO_INPUT_SERIAL);
+        return true;
+    case VIRTIO_INPUT_CFG_ID_DEVIDS:
+        cfg->u.ids.bustype = BUS_VIRTUAL;
+        cfg->u.ids.vendor = 0;
+        cfg->u.ids.product = 0;
+        cfg->u.ids.version = 1;
+        cfg->size = sizeof(struct virtio_input_devids);
+        return true;
+    case VIRTIO_INPUT_CFG_PROP_BITS:
+        virtio_input_properties(dev_id);
+        return true;
+    case VIRTIO_INPUT_CFG_EV_BITS:
+        virtio_input_support_events(dev_id, subsel);
+        return true;
+    case VIRTIO_INPUT_CFG_ABS_INFO:
+        virtio_input_abs_range(dev_id, subsel);
+        return true;
+    default:
+        fprintf(stderr,
+                "virtio-input: Unknown value written to select register.\n");
+        return false;
+    }
+}
+
+static bool virtio_input_reg_read(virtio_input_state_t *vinput,
+                                  uint32_t addr,
+                                  uint32_t *value,
+                                  size_t size)
+{
+#define _(reg) (VIRTIO_##reg << 2)
+    switch (addr) {
+    case _(MagicValue):
+        *value = 0x74726976;
+        return true;
+    case _(Version):
+        *value = 2;
+        return true;
+    case _(DeviceID):
+        *value = 18;
+        return true;
+    case _(VendorID):
+        *value = VIRTIO_VENDOR_ID;
+        return true;
+    case _(DeviceFeatures):
+        *value = vinput->DeviceFeaturesSel == 0
+                     ? VINPUT_FEATURES_0
+                     : (vinput->DeviceFeaturesSel == 1 ? VINPUT_FEATURES_1 : 0);
+        return true;
+    case _(QueueNumMax):
+        *value = VINPUT_QUEUE_NUM_MAX;
+        return true;
+    case _(QueueReady):
+        *value = VINPUT_QUEUE.ready ? 1 : 0;
+        return true;
+    case _(InterruptStatus):
+        *value = vinput->InterruptStatus;
+        return true;
+    case _(Status):
+        *value = vinput->Status;
+        return true;
+    case _(ConfigGeneration):
+        *value = 0;
+        return true;
+    case VIRTIO_INPUT_REG_SIZE:
+        if (!virtio_input_cfg_read(vinput->id))
+            return false;
+        *value = vinput_dev[vinput->id].cfg.size;
+        return true;
+    default:
+        /* Invalid address which exceeded the range */
+        if (!RANGE_CHECK(addr, _(Config), sizeof(struct virtio_input_config)))
+            return false;
+
+        /* Read virtio-input specific registers */
+        off_t offset = addr - VIRTIO_INPUT_REG_SELECT;
+        uint8_t *reg =
+            (uint8_t *) ((uintptr_t) &vinput_dev[vinput->id].cfg + offset);
+        memcpy(value, reg, size);
+
+        return true;
+    }
+#undef _
+}
+
+static bool virtio_input_reg_write(virtio_input_state_t *vinput,
+                                   uint32_t addr,
+                                   uint32_t value)
+{
+#define _(reg) (VIRTIO_##reg << 2)
+    switch (addr) {
+    case _(DeviceFeaturesSel):
+        vinput->DeviceFeaturesSel = value;
+        return true;
+    case _(DriverFeatures):
+        vinput->DriverFeaturesSel == 0 ? (vinput->DriverFeatures = value) : 0;
+        return true;
+    case _(DriverFeaturesSel):
+        vinput->DriverFeaturesSel = value;
+        return true;
+    case _(QueueSel):
+        if (value < ARRAY_SIZE(vinput->queues))
+            vinput->QueueSel = value;
+        else
+            virtio_input_set_fail(vinput);
+        return true;
+    case _(QueueNum):
+        if (value > 0 && value <= VINPUT_QUEUE_NUM_MAX)
+            VINPUT_QUEUE.QueueNum = value;
+        else
+            virtio_input_set_fail(vinput);
+        return true;
+    case _(QueueReady):
+        VINPUT_QUEUE.ready = value & 1;
+        if (value & 1)
+            VINPUT_QUEUE.last_avail =
+                vinput->ram[VINPUT_QUEUE.QueueAvail] >> 16;
+        return true;
+    case _(QueueDescLow):
+        VINPUT_QUEUE.QueueDesc = vinput_preprocess(vinput, value);
+        return true;
+    case _(QueueDescHigh):
+        if (value)
+            virtio_input_set_fail(vinput);
+        return true;
+    case _(QueueDriverLow):
+        VINPUT_QUEUE.QueueAvail = vinput_preprocess(vinput, value);
+        return true;
+    case _(QueueDriverHigh):
+        if (value)
+            virtio_input_set_fail(vinput);
+        return true;
+    case _(QueueDeviceLow):
+        VINPUT_QUEUE.QueueUsed = vinput_preprocess(vinput, value);
+        return true;
+    case _(QueueDeviceHigh):
+        if (value)
+            virtio_input_set_fail(vinput);
+        return true;
+    case _(QueueNotify):
+        if (value < ARRAY_SIZE(vinput->queues)) {
+            /* Handle event queue only for minimal implementation */
+            if (value == EVENTQ) {
+                vinput_dev[vinput->id].ev_notify++;
+                pthread_cond_signal(&virtio_input_cond);
+            }
+        } else {
+            virtio_input_set_fail(vinput);
+        }
+        return true;
+    case _(InterruptACK):
+        vinput->InterruptStatus &= ~value;
+        return true;
+    case _(Status):
+        virtio_input_update_status(vinput, value);
+        return true;
+    case _(SHMSel):
+        return true;
+    case VIRTIO_INPUT_REG_SELECT:
+        vinput_dev[vinput->id].cfg.select = value;
+        return true;
+    case VIRTIO_INPUT_REG_SUBSEL:
+        vinput_dev[vinput->id].cfg.subsel = value;
+        return true;
+    default:
+        /* No other writable registers */
+        return false;
+    }
+#undef _
+}
+
+void virtio_input_read(rvvm_hart_t *vm,
+                       virtio_input_state_t *vinput,
+                       uint32_t addr,
+                       uint8_t width,
+                       uint32_t *value)
+{
+    pthread_mutex_lock(&virtio_input_mutex);
+
+    /* XXX: 4-byte alignment (i.e., addr >> 2) is removed due to the per
+    byte accessing */
+    switch (width) {
+    case RV_MEM_LW:
+        if (!virtio_input_reg_read(vinput, addr, value, 4))
+            riscv_trap(vm, TRAP_LOAD_FAULT, vm->registers[REGISTER_PC]);
+        break;
+    case RV_MEM_LBU:
+    case RV_MEM_LB:
+    case RV_MEM_LHU:
+    case RV_MEM_LH:
+        /*FIXME: virtio-input driver need to access device config register per
+         * byte. the following code that derived from other virtio devices'
+         * implementation will cause kernel panic */
+        // riscv_trap(vm, TRAP_LOAD_MISALIGN, vm->registers[REGISTER_PC]);
+#if 1
+        // printf("read addr: 0x%x, width: %d\n", addr, width);
+        if (!virtio_input_reg_read(vinput, addr, value, 1))
+            riscv_trap(vm, TRAP_LOAD_FAULT, vm->registers[REGISTER_PC]);
+#endif
+        break;
+    default:
+        riscv_trap(vm, TRAP_ILL_INSTR, 0);
+        break;
+    }
+
+    pthread_mutex_unlock(&virtio_input_mutex);
+}
+
+void virtio_input_write(rvvm_hart_t *vm,
+                        virtio_input_state_t *vinput,
+                        uint32_t addr,
+                        uint8_t width,
+                        uint32_t value)
+{
+    pthread_mutex_lock(&virtio_input_mutex);
+
+    /* XXX: 4-byte alignment (i.e., addr >> 2) is removed due to the per
+    byte accessing */
+    switch (width) {
+    case RV_MEM_SW:
+        if (!virtio_input_reg_write(vinput, addr, value))
+            riscv_trap(vm, TRAP_STORE_FAULT, vm->registers[REGISTER_PC]);
+        break;
+    case RV_MEM_SB:
+    case RV_MEM_SH:
+        /* FIXME: virtio-input driver need to access device config register per
+         * byte. the following code that derived from other virtio devices'
+         * implementation will cause kernel panic */
+        // riscv_trap(vm, TRAP_STORE_MISALIGN, vm->registers[REGISTER_PC]);
+#if 1
+        // printf("read addr: 0x%x, width: %d\n", addr, width);
+        if (!virtio_input_reg_write(vinput, addr, value))
+            riscv_trap(vm, TRAP_STORE_FAULT, vm->registers[REGISTER_PC]);
+#endif
+        break;
+    default:
+        riscv_trap(vm, TRAP_ILL_INSTR, 0);
+        break;
+    }
+
+    pthread_mutex_unlock(&virtio_input_mutex);
+}
+
+void virtio_input_init(virtio_input_state_t *vinput)
+{
+    vinput->id = vinput_dev_cnt;
+    vinput_dev_cnt++;
+
+    vinput_dev[vinput->id].ev_notify = 0;
+    vinput_dev[vinput->id].vinput = vinput;
+}
diff --git a/src/devices/virtio-net.c b/src/devices/virtio-net.c
new file mode 100644
index 0000000..161333c
--- /dev/null
+++ b/src/devices/virtio-net.c
@@ -0,0 +1,477 @@
+#include <assert.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <linux/if.h>
+#include <linux/if_tun.h>
+#include <poll.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/uio.h>
+
+#include "virtio_common.h"
+#include "virtio_device.h"
+#include "riscv_hart.h"
+#include "riscv_priv.h"
+#include "virtio.h"
+
+#define TAP_INTERFACE "tap%d"
+
+#define VNET_DEV_CNT_MAX 1
+
+#define VNET_FEATURES_0 0
+#define VNET_FEATURES_1 1 /* VIRTIO_F_VERSION_1 */
+#define VNET_QUEUE_NUM_MAX 1024
+#define VNET_QUEUE (vnet->queues[vnet->QueueSel])
+
+#define PRIV(x) ((struct virtio_net_config *) x->priv)
+
+enum {
+    RV_MEM_LB = 0b000,
+    RV_MEM_LH = 0b001,
+    RV_MEM_LW = 0b010,
+    RV_MEM_LBU = 0b100,
+    RV_MEM_LHU = 0b101,
+    RV_MEM_SB = 0b000,
+    RV_MEM_SH = 0b001,
+    RV_MEM_SW = 0b010,
+};
+
+enum { VNET_QUEUE_RX = 0, VNET_QUEUE_TX = 1 };
+
+PACKED(struct virtio_net_config {
+    uint8_t mac[6];
+    uint16_t status;
+    uint16_t max_virtqueue_pairs;
+    uint16_t mtu;
+});
+
+static struct virtio_net_config vnet_configs[VNET_DEV_CNT_MAX];
+static int vnet_dev_cnt = 0;
+
+static void virtio_net_set_fail(virtio_net_state_t *vnet)
+{
+    vnet->Status |= VIRTIO_STATUS__DEVICE_NEEDS_RESET;
+    if (vnet->Status & VIRTIO_STATUS__DRIVER_OK)
+        vnet->InterruptStatus |= VIRTIO_INT__CONF_CHANGE;
+}
+
+static inline uint32_t vnet_preprocess(virtio_net_state_t *vnet, uint32_t addr)
+{
+    if ((addr >= RAM_SIZE) || (addr & 0b11))
+        return virtio_net_set_fail(vnet), 0;
+
+    return addr >> 2;
+}
+
+static void virtio_net_update_status(virtio_net_state_t *vnet, uint32_t status)
+{
+    vnet->Status |= status;
+    if (status)
+        return;
+
+    /* Reset */
+    int tap_fd = vnet->tap_fd;
+    uint32_t *ram = vnet->ram;
+    void *priv = vnet->priv;
+    memset(vnet, 0, sizeof(*vnet));
+    vnet->tap_fd = tap_fd, vnet->ram = ram;
+    vnet->priv = priv;
+}
+
+static bool vnet_iovec_write(struct iovec **vecs,
+                             size_t *nvecs,
+                             const uint8_t *src,
+                             size_t n)
+{
+    while (n && *nvecs) {
+        if (n < (*vecs)->iov_len) {
+            memcpy((*vecs)->iov_base, src, n);
+            (*vecs)->iov_base = (void *) ((uintptr_t) (*vecs)->iov_base + n);
+            (*vecs)->iov_len -= n;
+            return true;
+        }
+
+        memcpy((*vecs)->iov_base, src, (*vecs)->iov_len);
+        src += (*vecs)->iov_len;
+        n -= (*vecs)->iov_len;
+        (*vecs)++;
+        (*nvecs)--;
+    }
+    return n && !*nvecs;
+}
+
+static bool vnet_iovec_read(struct iovec **vecs,
+                            size_t *nvecs,
+                            uint8_t *dst,
+                            size_t n)
+{
+    while (n && *nvecs) {
+        if (n < (*vecs)->iov_len) {
+            memcpy(dst, (*vecs)->iov_base, n);
+            (*vecs)->iov_base = (void *) ((uintptr_t) (*vecs)->iov_base + n);
+            (*vecs)->iov_len -= n;
+            return true;
+        }
+        memcpy(dst, (*vecs)->iov_base, (*vecs)->iov_len);
+        dst += (*vecs)->iov_len;
+        n -= (*vecs)->iov_len;
+        (*vecs)++;
+        (*nvecs)--;
+    }
+    return n && !*nvecs;
+}
+
+/* Require existing 'desc_idx' to use as iteration variable, and input
+ * 'buffer_idx'.
+ */
+#define VNET_ITERATE_BUFFER(checked, body)                            \
+    desc_idx = buffer_idx;                                            \
+    while (1) {                                                       \
+        if (checked && desc_idx >= queue->QueueNum)                   \
+            return virtio_net_set_fail(vnet);                         \
+        const uint32_t *desc = &ram[queue->QueueDesc + desc_idx * 4]; \
+        uint16_t desc_flags = desc[3];                                \
+        body if (!(desc_flags & VIRTIO_DESC_F_NEXT)) break;           \
+        desc_idx = desc[3] >> 16;                                     \
+    }
+
+/* Input: 'buffer_idx'.
+ * Output: 'buffer_niovs' and 'buffer_iovs'
+ */
+#define VNET_BUFFER_TO_IOV(expect_readable)                               \
+    uint16_t desc_idx;                                                    \
+    /* do a first pass to validate flags and count buffers */             \
+    size_t buffer_niovs = 0;                                              \
+    VNET_ITERATE_BUFFER(                                                  \
+        true, if ((!!(desc_flags & VIRTIO_DESC_F_WRITE)) !=               \
+                  (expect_readable)) return virtio_net_set_fail(vnet);    \
+        buffer_niovs++;)                                                  \
+    /* convert to iov */                                                  \
+    struct iovec buffer_iovs[buffer_niovs];                               \
+    buffer_niovs = 0;                                                     \
+    VNET_ITERATE_BUFFER(                                                  \
+        false, uint32_t desc_addr = desc[0]; uint32_t desc_len = desc[2]; \
+        buffer_iovs[buffer_niovs].iov_base =                              \
+            (void *) ((uintptr_t) ram + desc_addr);                       \
+        buffer_iovs[buffer_niovs].iov_len = desc_len; buffer_niovs++;)
+
+#define VNET_GENERATE_QUEUE_HANDLER(NAME_SUFFIX, VERB, QUEUE_IDX, READ)        \
+    static void virtio_net_try_##NAME_SUFFIX(virtio_net_state_t *vnet)         \
+    {                                                                          \
+        uint32_t *ram = vnet->ram;                                             \
+        virtio_net_queue_t *queue = &vnet->queues[QUEUE_IDX];                  \
+        if ((vnet->Status & VIRTIO_STATUS__DEVICE_NEEDS_RESET) ||              \
+            !queue->fd_ready)                                                  \
+            return;                                                            \
+        if (!((vnet->Status & VIRTIO_STATUS__DRIVER_OK) && queue->ready))      \
+            return virtio_net_set_fail(vnet);                                  \
+                                                                               \
+        /* check for new buffers */                                            \
+        uint16_t new_avail = ram[queue->QueueAvail] >> 16;                     \
+        if (new_avail - queue->last_avail > (uint16_t) queue->QueueNum)        \
+            return (fprintf(stderr, "size check fail\n"),                      \
+                    virtio_net_set_fail(vnet));                                \
+        if (queue->last_avail == new_avail)                                    \
+            return;                                                            \
+                                                                               \
+        /* process them */                                                     \
+        uint16_t new_used = ram[queue->QueueUsed] >> 16;                       \
+        while (queue->last_avail != new_avail) {                               \
+            uint16_t queue_idx = queue->last_avail % queue->QueueNum;          \
+            uint16_t buffer_idx =                                              \
+                ram[queue->QueueAvail + 1 + queue_idx / 2] >>                  \
+                (16 * (queue_idx % 2));                                        \
+            VNET_BUFFER_TO_IOV(READ)                                           \
+            struct iovec *buffer_iovs_cursor = buffer_iovs;                    \
+            uint8_t virtio_header[12];                                         \
+            if (READ) {                                                        \
+                memset(virtio_header, 0, sizeof(virtio_header));               \
+                virtio_header[10] = 1;                                         \
+                vnet_iovec_write(&buffer_iovs_cursor, &buffer_niovs,           \
+                                 virtio_header, sizeof(virtio_header));        \
+            } else {                                                           \
+                vnet_iovec_read(&buffer_iovs_cursor, &buffer_niovs,            \
+                                virtio_header, sizeof(virtio_header));         \
+            }                                                                  \
+                                                                               \
+            ssize_t plen =                                                     \
+                VERB##v(vnet->tap_fd, buffer_iovs_cursor, buffer_niovs);       \
+            if (plen < 0 && (errno == EWOULDBLOCK || errno == EAGAIN)) {       \
+                queue->fd_ready = false;                                       \
+                break;                                                         \
+            }                                                                  \
+            if (plen < 0) {                                                    \
+                plen = 0;                                                      \
+                fprintf(stderr, "[VNET] could not " #VERB " packet: %s\n",     \
+                        strerror(errno));                                      \
+            }                                                                  \
+                                                                               \
+            /* consume from available queue, write to used queue */            \
+            queue->last_avail++;                                               \
+            ram[queue->QueueUsed + 1 + (new_used % queue->QueueNum) * 2] =     \
+                buffer_idx;                                                    \
+            ram[queue->QueueUsed + 1 + (new_used % queue->QueueNum) * 2 + 1] = \
+                READ ? (plen + sizeof(virtio_header)) : 0;                     \
+            new_used++;                                                        \
+        }                                                                      \
+        vnet->ram[queue->QueueUsed] &= MASK(16);                               \
+        vnet->ram[queue->QueueUsed] |= ((uint32_t) new_used) << 16;            \
+                                                                               \
+        /* send interrupt, unless VIRTQ_AVAIL_F_NO_INTERRUPT is set */         \
+        if (!(ram[queue->QueueAvail] & 1))                                     \
+            vnet->InterruptStatus |= VIRTIO_INT__USED_RING;                    \
+    }
+
+VNET_GENERATE_QUEUE_HANDLER(rx, read, VNET_QUEUE_RX, true)
+VNET_GENERATE_QUEUE_HANDLER(tx, write, VNET_QUEUE_TX, false)
+
+void virtio_net_refresh_queue(virtio_net_state_t *vnet)
+{
+    if (!(vnet->Status & VIRTIO_STATUS__DRIVER_OK) ||
+        (vnet->Status & VIRTIO_STATUS__DEVICE_NEEDS_RESET))
+        return;
+
+    struct pollfd pfd = {vnet->tap_fd, POLLIN | POLLOUT, 0};
+    poll(&pfd, 1, 0);
+    if (pfd.revents & POLLIN) {
+        vnet->queues[VNET_QUEUE_RX].fd_ready = true;
+        virtio_net_try_rx(vnet);
+    }
+    if (pfd.revents & POLLOUT) {
+        vnet->queues[VNET_QUEUE_TX].fd_ready = true;
+        virtio_net_try_tx(vnet);
+    }
+}
+
+static bool virtio_net_reg_read(virtio_net_state_t *vnet,
+                                uint32_t addr,
+                                uint32_t *value)
+{
+#define _(reg) VIRTIO_##reg
+    switch (addr) {
+    case _(MagicValue):
+        *value = 0x74726976;
+        return true;
+    case _(Version):
+        *value = 2;
+        return true;
+    case _(DeviceID):
+        *value = 1;
+        return true;
+    case _(VendorID):
+        *value = VIRTIO_VENDOR_ID;
+        return true;
+
+    case _(DeviceFeatures):
+        *value = vnet->DeviceFeaturesSel == 0
+                     ? VNET_FEATURES_0
+                     : (vnet->DeviceFeaturesSel == 1 ? VNET_FEATURES_1 : 0);
+        return true;
+
+    case _(QueueNumMax):
+        *value = VNET_QUEUE_NUM_MAX;
+        return true;
+    case _(QueueReady):
+        *value = VNET_QUEUE.ready ? 1 : 0;
+        return true;
+
+    case _(InterruptStatus):
+        *value = vnet->InterruptStatus;
+        return true;
+    case _(Status):
+        *value = vnet->Status;
+        return true;
+
+    case _(ConfigGeneration):
+        *value = 0;
+        return true;
+
+    /* TODO: May want to check the occasion that the Linux kernel
+     * touches the MAC address of the virtio-net under 8-bit accesses
+     */
+    default:
+        /* Invalid address which exceeded the range */
+        if (!RANGE_CHECK(addr, _(Config), sizeof(struct virtio_net_config)))
+            return false;
+
+        /* Read configuration from the corresponding register */
+        *value = ((uint32_t *) PRIV(vnet))[addr - _(Config)];
+
+        return true;
+    }
+#undef _
+}
+
+static bool virtio_net_reg_write(virtio_net_state_t *vnet,
+                                 uint32_t addr,
+                                 uint32_t value)
+{
+#define _(reg) VIRTIO_##reg
+    switch (addr) {
+    case _(DeviceFeaturesSel):
+        vnet->DeviceFeaturesSel = value;
+        return true;
+    case _(DriverFeatures):
+        vnet->DriverFeaturesSel == 0 ? (vnet->DriverFeatures = value) : 0;
+        return true;
+    case _(DriverFeaturesSel):
+        vnet->DriverFeaturesSel = value;
+        return true;
+
+    case _(QueueSel):
+        if (value < ARRAY_SIZE(vnet->queues))
+            vnet->QueueSel = value;
+        else
+            virtio_net_set_fail(vnet);
+        return true;
+    case _(QueueNum):
+        if (value > 0 && value <= VNET_QUEUE_NUM_MAX)
+            VNET_QUEUE.QueueNum = value;
+        else
+            virtio_net_set_fail(vnet);
+        return true;
+    case _(QueueReady):
+        VNET_QUEUE.ready = value & 1;
+        if (value & 1)
+            VNET_QUEUE.last_avail = vnet->ram[VNET_QUEUE.QueueAvail] >> 16;
+        if (vnet->QueueSel == VNET_QUEUE_RX)
+            vnet->ram[VNET_QUEUE.QueueAvail] |=
+                1; /* set VIRTQ_AVAIL_F_NO_INTERRUPT */
+        return true;
+    case _(QueueDescLow):
+        VNET_QUEUE.QueueDesc = vnet_preprocess(vnet, value);
+        return true;
+    case _(QueueDescHigh):
+        if (value)
+            virtio_net_set_fail(vnet);
+        return true;
+    case _(QueueDriverLow):
+        VNET_QUEUE.QueueAvail = vnet_preprocess(vnet, value);
+        return true;
+    case _(QueueDriverHigh):
+        if (value)
+            virtio_net_set_fail(vnet);
+        return true;
+    case _(QueueDeviceLow):
+        VNET_QUEUE.QueueUsed = vnet_preprocess(vnet, value);
+        return true;
+    case _(QueueDeviceHigh):
+        if (value)
+            virtio_net_set_fail(vnet);
+        return true;
+
+    case _(QueueNotify):
+        if (value < ARRAY_SIZE(vnet->queues)) {
+            switch (value) {
+            case VNET_QUEUE_RX:
+                virtio_net_try_rx(vnet);
+                break;
+            case VNET_QUEUE_TX:
+                virtio_net_try_tx(vnet);
+                break;
+            }
+        } else {
+            virtio_net_set_fail(vnet);
+        }
+        return true;
+    case _(InterruptACK):
+        vnet->InterruptStatus &= ~value;
+        return true;
+    case _(Status):
+        virtio_net_update_status(vnet, value);
+        return true;
+
+    /* TODO: May want to check the occasion that the Linux kernel
+     * touches the MAC address of the virtio-net under 8-bit accesses
+     */
+    default:
+        /* Invalid address which exceeded the range */
+        if (!RANGE_CHECK(addr, _(Config), sizeof(struct virtio_net_config)))
+            return false;
+
+        /* Write configuration to the corresponding register */
+        ((uint32_t *) PRIV(vnet))[addr - _(Config)] = value;
+
+        return true;
+    }
+#undef _
+}
+
+void virtio_net_read(rvvm_hart_t *vm,
+                     virtio_net_state_t *vnet,
+                     uint32_t addr,
+                     uint8_t width,
+                     uint32_t *value)
+{
+    switch (width) {
+    case RV_MEM_LW:
+        if (!virtio_net_reg_read(vnet, addr >> 2, value))
+            riscv_trap(vm, TRAP_LOAD_FAULT, vm->registers[REGISTER_PC]);
+        break;
+    case RV_MEM_LBU:
+    case RV_MEM_LB:
+    case RV_MEM_LHU:
+    case RV_MEM_LH:
+        riscv_trap(vm, TRAP_LOAD_MISALIGN, vm->registers[REGISTER_PC]);
+        return;
+    default:
+        riscv_trap(vm, TRAP_ILL_INSTR, 0);
+        return;
+    }
+}
+
+void virtio_net_write(rvvm_hart_t *vm,
+                      virtio_net_state_t *vnet,
+                      uint32_t addr,
+                      uint8_t width,
+                      uint32_t value)
+{
+    switch (width) {
+    case RV_MEM_SW:
+        if (!virtio_net_reg_write(vnet, addr >> 2, value))
+            riscv_trap(vm, TRAP_STORE_FAULT, vm->registers[REGISTER_PC]);
+        break;
+    case RV_MEM_SB:
+    case RV_MEM_SH:
+        riscv_trap(vm, TRAP_STORE_MISALIGN, vm->registers[REGISTER_PC]);
+        return;
+    default:
+        riscv_trap(vm, TRAP_ILL_INSTR, 0);
+        return;
+    }
+}
+
+bool virtio_net_init(virtio_net_state_t *vnet)
+{
+    if (vnet_dev_cnt >= VNET_DEV_CNT_MAX) {
+        fprintf(stderr,
+                "Excedded the number of virtio-net device can be allocated.\n");
+        exit(2);
+    }
+
+    /* Allocate memory for the private member */
+    vnet->priv = &vnet_configs[vnet_dev_cnt++];
+
+    vnet->tap_fd = open("/dev/net/tun", O_RDWR);
+    if (vnet->tap_fd < 0) {
+        fprintf(stderr, "failed to open TAP device: %s\n", strerror(errno));
+        return false;
+    }
+
+    /* Specify persistent tap device */
+    struct ifreq ifreq = {.ifr_flags = IFF_TAP | IFF_NO_PI};
+    strncpy(ifreq.ifr_name, TAP_INTERFACE, sizeof(ifreq.ifr_name));
+    if (ioctl(vnet->tap_fd, TUNSETIFF, &ifreq) < 0) {
+        fprintf(stderr, "failed to allocate TAP device: %s\n", strerror(errno));
+        return false;
+    }
+
+    fprintf(stderr, "allocated TAP interface: %s\n", ifreq.ifr_name);
+    assert(fcntl(vnet->tap_fd, F_SETFL,
+                 fcntl(vnet->tap_fd, F_GETFL, 0) | O_NONBLOCK) >= 0);
+
+    return true;
+}
diff --git a/src/devices/virtio.h b/src/devices/virtio.h
new file mode 100644
index 0000000..b23b414
--- /dev/null
+++ b/src/devices/virtio.h
@@ -0,0 +1,138 @@
+#pragma once
+
+#define VIRTIO_VENDOR_ID 0x12345678
+
+#define VIRTIO_STATUS__DRIVER_OK 4
+#define VIRTIO_STATUS__DEVICE_NEEDS_RESET 64
+
+#define VIRTIO_INT__USED_RING 1
+#define VIRTIO_INT__CONF_CHANGE 2
+
+#define VIRTIO_DESC_F_NEXT 1
+#define VIRTIO_DESC_F_WRITE 2
+
+#define VIRTIO_BLK_T_IN 0
+#define VIRTIO_BLK_T_OUT 1
+#define VIRTIO_BLK_T_FLUSH 4
+#define VIRTIO_BLK_T_GET_ID 8
+#define VIRTIO_BLK_T_GET_LIFETIME 10
+#define VIRTIO_BLK_T_DISCARD 11
+#define VIRTIO_BLK_T_WRITE_ZEROES 13
+#define VIRTIO_BLK_T_SECURE_ERASE 14
+
+#define VIRTIO_BLK_S_OK 0
+#define VIRTIO_BLK_S_IOERR 1
+#define VIRTIO_BLK_S_UNSUPP 2
+
+#define VIRTIO_GPU_FLAG_FENCE (1 << 0)
+
+#define VIRTIO_GPU_MAX_SCANOUTS 16
+
+#define VIRTIO_GPU_CAPSET_VIRGL 1
+#define VIRTIO_GPU_CAPSET_VIRGL2 2
+#define VIRTIO_GPU_CAPSET_GFXSTREAM 3
+#define VIRTIO_GPU_CAPSET_VENUS 4
+#define VIRTIO_GPU_CAPSET_CROSS_DOMAIN 5
+
+/* VirtIO MMIO registers */
+#define VIRTIO_REG_LIST                  \
+    _(MagicValue, 0x000)        /* R */  \
+    _(Version, 0x004)           /* R */  \
+    _(DeviceID, 0x008)          /* R */  \
+    _(VendorID, 0x00c)          /* R */  \
+    _(DeviceFeatures, 0x010)    /* R */  \
+    _(DeviceFeaturesSel, 0x014) /* W */  \
+    _(DriverFeatures, 0x020)    /* W */  \
+    _(DriverFeaturesSel, 0x024) /* W */  \
+    _(QueueSel, 0x030)          /* W */  \
+    _(QueueNumMax, 0x034)       /* R */  \
+    _(QueueNum, 0x038)          /* W */  \
+    _(QueueReady, 0x044)        /* RW */ \
+    _(QueueNotify, 0x050)       /* W */  \
+    _(InterruptStatus, 0x60)    /* R */  \
+    _(InterruptACK, 0x064)      /* W */  \
+    _(Status, 0x070)            /* RW */ \
+    _(QueueDescLow, 0x080)      /* W */  \
+    _(QueueDescHigh, 0x084)     /* W */  \
+    _(QueueDriverLow, 0x090)    /* W */  \
+    _(QueueDriverHigh, 0x094)   /* W */  \
+    _(QueueDeviceLow, 0x0a0)    /* W */  \
+    _(QueueDeviceHigh, 0x0a4)   /* W */  \
+    _(ConfigGeneration, 0x0fc)  /* R */  \
+    _(SHMSel, 0x0ac)            /* W */  \
+    _(SHMLenLow, 0x0b0)         /* R */  \
+    _(SHMLenHigh, 0x0b4)        /* R */  \
+    _(SHMBaseLow, 0x0b8)        /* R */  \
+    _(SHMBaseHigh, 0x0bc)       /* R */  \
+    _(QueueReset, 0x0c0)        /* RW */ \
+    _(Config, 0x100)            /* RW */
+
+enum {
+#define _(reg, addr) VIRTIO_##reg = addr >> 2,
+    VIRTIO_REG_LIST
+#undef _
+};
+
+enum virtio_gpu_ctrl_type {
+    /* 2d commands */
+    VIRTIO_GPU_CMD_GET_DISPLAY_INFO = 0x0100,
+    VIRTIO_GPU_CMD_RESOURCE_CREATE_2D,
+    VIRTIO_GPU_CMD_RESOURCE_UNREF,
+    VIRTIO_GPU_CMD_SET_SCANOUT,
+    VIRTIO_GPU_CMD_RESOURCE_FLUSH,
+    VIRTIO_GPU_CMD_TRANSFER_TO_HOST_2D,
+    VIRTIO_GPU_CMD_RESOURCE_ATTACH_BACKING,
+    VIRTIO_GPU_CMD_RESOURCE_DETACH_BACKING,
+    VIRTIO_GPU_CMD_GET_CAPSET_INFO,
+    VIRTIO_GPU_CMD_GET_CAPSET,
+    VIRTIO_GPU_CMD_GET_EDID,
+
+    /* 3d commands */
+    VIRTIO_GPU_CMD_CTX_CREATE = 0x0200,
+    VIRTIO_GPU_CMD_CTX_DESTROY,
+    VIRTIO_GPU_CMD_CTX_ATTACH_RESOURCE,
+    VIRTIO_GPU_CMD_CTX_DETACH_RESOURCE,
+    VIRTIO_GPU_CMD_RESOURCE_CREATE_3D,
+    VIRTIO_GPU_CMD_TRANSFER_TO_HOST_3D,
+    VIRTIO_GPU_CMD_TRANSFER_FROM_HOST_3D,
+    VIRTIO_GPU_CMD_SUBMIT_3D,
+    VIRTIO_GPU_CMD_RESOURCE_MAP_BLOB,
+    VIRTIO_GPU_CMD_RESOURCE_UNMAP_BLOB,
+
+    /* cursor commands */
+    VIRTIO_GPU_CMD_UPDATE_CURSOR = 0x0300,
+    VIRTIO_GPU_CMD_MOVE_CURSOR,
+
+    /* success responses */
+    VIRTIO_GPU_RESP_OK_NODATA = 0x1100,
+    VIRTIO_GPU_RESP_OK_DISPLAY_INFO,
+    VIRTIO_GPU_RESP_OK_CAPSET_INFO,
+    VIRTIO_GPU_RESP_OK_CAPSET,
+    VIRTIO_GPU_RESP_OK_EDID,
+
+    /* error responses */
+    VIRTIO_GPU_RESP_ERR_UNSPEC = 0x1200,
+    VIRTIO_GPU_RESP_ERR_OUT_OF_MEMORY,
+    VIRTIO_GPU_RESP_ERR_INVALID_SCANOUT_ID,
+    VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID,
+    VIRTIO_GPU_RESP_ERR_INVALID_CONTEXT_ID,
+    VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER,
+};
+
+enum virtio_gpu_formats {
+    VIRTIO_GPU_FORMAT_B8G8R8A8_UNORM = 1,
+    VIRTIO_GPU_FORMAT_B8G8R8X8_UNORM = 2,
+    VIRTIO_GPU_FORMAT_A8R8G8B8_UNORM = 3,
+    VIRTIO_GPU_FORMAT_X8R8G8B8_UNORM = 4,
+    VIRTIO_GPU_FORMAT_R8G8B8A8_UNORM = 67,
+    VIRTIO_GPU_FORMAT_X8B8G8R8_UNORM = 68,
+    VIRTIO_GPU_FORMAT_A8B8G8R8_UNORM = 121,
+    VIRTIO_GPU_FORMAT_R8G8B8X8_UNORM = 134
+};
+
+struct virtq_desc {
+    uint32_t addr;
+    uint32_t len;
+    uint16_t flags;
+    uint16_t next;
+};
diff --git a/src/devices/virtio_common.h b/src/devices/virtio_common.h
new file mode 100644
index 0000000..a38900b
--- /dev/null
+++ b/src/devices/virtio_common.h
@@ -0,0 +1,44 @@
+#pragma once
+
+#include "virtio_feature.h"
+
+#define BITS_PER_CHAR 8
+#define BITS_PER_LONG (BITS_PER_CHAR * sizeof(long))
+
+#define MASK(n) (~((~0U << (n))))
+
+#define ARRAY_SIZE(a) (sizeof(a) / sizeof(*(a)))
+
+/* Ensure that __builtin_clz is never called with 0 argument */
+static inline int ilog2(int x)
+{
+    return 31 - __builtin_clz(x | 1);
+}
+
+static inline void set_bit(unsigned long bit, unsigned long *word)
+{
+    *word |= (1 << bit);
+}
+
+static inline void bitmap_set_bit(unsigned long *map, unsigned long bit)
+{
+    set_bit(bit % BITS_PER_LONG, &map[bit / BITS_PER_LONG]);
+}
+
+/* Range check
+ * For any variable range checking:
+ *     if (x >= minx && x <= maxx) ...
+ * it is faster to use bit operation:
+ *     if ((signed)((x - minx) | (maxx - x)) >= 0) ...
+ */
+#define RANGE_CHECK(x, minx, size) \
+    ((int32_t) ((x - minx) | (minx + size - 1 - x)) >= 0)
+
+/* Packed macro */
+#if defined(__GNUC__) || defined(__clang__)
+#define PACKED(name) name __attribute__((packed))
+#elif defined(_MSC_VER)
+#define PACKED(name) __pragma(pack(push, 1)) name __pragma(pack(pop))
+#else /* unsupported compilers */
+#define PACKED(name)
+#endif
diff --git a/src/devices/virtio_device.h b/src/devices/virtio_device.h
new file mode 100644
index 0000000..61d38d8
--- /dev/null
+++ b/src/devices/virtio_device.h
@@ -0,0 +1,330 @@
+#pragma once
+
+#include "riscv_hart.h"
+#include "riscv_priv.h"
+#include "virtio.h"
+
+/* RAM */
+
+#define RAM_SIZE (512 * 1024 * 1024)
+#define DTB_SIZE (1 * 1024 * 1024)
+#define INITRD_SIZE (65 * 1024 * 1024)
+
+#define SCREEN_WIDTH 1024
+#define SCREEN_HEIGHT 768
+
+void ram_read(rvvm_hart_t *core,
+              uint32_t *mem,
+              const uint32_t addr,
+              const uint8_t width,
+              uint32_t *value);
+
+void ram_write(rvvm_hart_t *core,
+               uint32_t *mem,
+               const uint32_t addr,
+               const uint8_t width,
+               const uint32_t value);
+
+/* PLIC */
+
+typedef struct {
+    uint32_t masked;
+    uint32_t ip;     /* support 32 interrupt sources only */
+    uint32_t ie[32]; /* support 32 sources to 32 contexts only */
+    /* state of input interrupt lines (level-triggered), set by environment */
+    uint32_t active;
+} plic_state_t;
+
+void plic_update_interrupts(rvvm_hart_t *vm, plic_state_t *plic);
+void plic_read(rvvm_hart_t *core,
+               plic_state_t *plic,
+               uint32_t addr,
+               uint8_t width,
+               uint32_t *value);
+void plic_write(rvvm_hart_t *core,
+                plic_state_t *plic,
+                uint32_t addr,
+                uint8_t width,
+                uint32_t value);
+/* UART */
+
+#define IRQ_UART 1
+#define IRQ_UART_BIT (1 << IRQ_UART)
+
+typedef struct {
+    uint8_t dll, dlh;                  /**< divisor (ignored) */
+    uint8_t lcr;                       /**< UART config */
+    uint8_t ier;                       /**< interrupt config */
+    uint8_t current_int, pending_ints; /**< interrupt status */
+    /* other output signals, loopback mode (ignored) */
+    uint8_t mcr;
+    /* I/O handling */
+    int in_fd, out_fd;
+    bool in_ready;
+} u8250_state_t;
+
+void u8250_update_interrupts(u8250_state_t *uart);
+void u8250_read(rvvm_hart_t *core,
+                u8250_state_t *uart,
+                uint32_t addr,
+                uint8_t width,
+                uint32_t *value);
+void u8250_write(rvvm_hart_t *core,
+                 u8250_state_t *uart,
+                 uint32_t addr,
+                 uint8_t width,
+                 uint32_t value);
+void u8250_check_ready(u8250_state_t *uart);
+void capture_keyboard_input(void);
+
+/* virtio-net */
+
+#if SEMU_HAS(VIRTIONET)
+#define IRQ_VNET 2
+#define IRQ_VNET_BIT (1 << IRQ_VNET)
+
+typedef struct {
+    uint32_t QueueNum;
+    uint32_t QueueDesc;
+    uint32_t QueueAvail;
+    uint32_t QueueUsed;
+    uint16_t last_avail;
+    bool ready;
+    bool fd_ready;
+} virtio_net_queue_t;
+
+typedef struct {
+    /* feature negotiation */
+    uint32_t DeviceFeaturesSel;
+    uint32_t DriverFeatures;
+    uint32_t DriverFeaturesSel;
+    /* queue config */
+    uint32_t QueueSel;
+    virtio_net_queue_t queues[2];
+    /* status */
+    uint32_t Status;
+    uint32_t InterruptStatus;
+    /* supplied by environment */
+    int tap_fd;
+    uint32_t *ram;
+    /* implementation-specific */
+    void *priv;
+} virtio_net_state_t;
+
+void virtio_net_read(rvvm_hart_t *core,
+                     virtio_net_state_t *vnet,
+                     uint32_t addr,
+                     uint8_t width,
+                     uint32_t *value);
+void virtio_net_write(rvvm_hart_t *core,
+                      virtio_net_state_t *vnet,
+                      uint32_t addr,
+                      uint8_t width,
+                      uint32_t value);
+void virtio_net_refresh_queue(virtio_net_state_t *vnet);
+
+bool virtio_net_init(virtio_net_state_t *vnet);
+#endif /* SEMU_HAS(VIRTIONET) */
+
+/* VirtIO-Block */
+
+#if SEMU_HAS(VIRTIOBLK)
+
+#define IRQ_VBLK 3
+#define IRQ_VBLK_BIT (1 << IRQ_VBLK)
+
+typedef struct {
+    uint32_t QueueNum;
+    uint32_t QueueDesc;
+    uint32_t QueueAvail;
+    uint32_t QueueUsed;
+    uint16_t last_avail;
+    bool ready;
+} virtio_blk_queue_t;
+
+typedef struct {
+    /* feature negotiation */
+    uint32_t DeviceFeaturesSel;
+    uint32_t DriverFeatures;
+    uint32_t DriverFeaturesSel;
+    /* queue config */
+    uint32_t QueueSel;
+    virtio_blk_queue_t queues[2];
+    /* status */
+    uint32_t Status;
+    uint32_t InterruptStatus;
+    /* supplied by environment */
+    uint32_t *ram;
+    uint32_t *disk;
+    /* implementation-specific */
+    void *priv;
+} virtio_blk_state_t;
+
+void virtio_blk_read(rvvm_hart_t *vm,
+                     virtio_blk_state_t *vblk,
+                     uint32_t addr,
+                     uint8_t width,
+                     uint32_t *value);
+
+void virtio_blk_write(rvvm_hart_t *vm,
+                      virtio_blk_state_t *vblk,
+                      uint32_t addr,
+                      uint8_t width,
+                      uint32_t value);
+
+uint32_t *virtio_blk_init(virtio_blk_state_t *vblk, char *disk_file);
+#endif /* SEMU_HAS(VIRTIOBLK) */
+
+/* VirtIO-GPU */
+
+#if SEMU_HAS(VIRTIOGPU)
+
+#define IRQ_VGPU 4
+#define IRQ_VGPU_BIT (1 << IRQ_VGPU)
+
+typedef struct {
+    uint32_t QueueNum;
+    uint32_t QueueDesc;
+    uint32_t QueueAvail;
+    uint32_t QueueUsed;
+    uint16_t last_avail;
+    bool ready;
+} virtio_gpu_queue_t;
+
+typedef struct {
+    /* feature negotiation */
+    uint32_t DeviceFeaturesSel;
+    uint32_t DriverFeatures;
+    uint32_t DriverFeaturesSel;
+    /* queue config */
+    uint32_t QueueSel;
+    virtio_gpu_queue_t queues[2];
+    /* status */
+    uint32_t Status;
+    uint32_t InterruptStatus;
+    /* supplied by environment */
+    uint32_t *ram;
+    /* implementation-specific */
+    void *priv;
+} virtio_gpu_state_t;
+
+void virtio_gpu_read(rvvm_hart_t *vm,
+                     virtio_gpu_state_t *vgpu,
+                     uint32_t addr,
+                     uint8_t width,
+                     uint32_t *value);
+
+void virtio_gpu_write(rvvm_hart_t *vm,
+                      virtio_gpu_state_t *vgpu,
+                      uint32_t addr,
+                      uint8_t width,
+                      uint32_t value);
+
+void semu_virgl_init(void);
+
+void virtio_gpu_init(virtio_gpu_state_t *vgpu);
+void virtio_gpu_add_scanout(virtio_gpu_state_t *vgpu,
+                            uint32_t width,
+                            uint32_t height);
+#endif /* SEMU_HAS(VIRTIOGPU) */
+
+/* VirtIO Input */
+
+#if SEMU_HAS(VIRTIOINPUT)
+
+#define IRQ_VINPUT_KEYBOARD 5
+#define IRQ_VINPUT_KEYBOARD_BIT (1 << IRQ_VINPUT_KEYBOARD)
+
+#define IRQ_VINPUT_MOUSE 6
+#define IRQ_VINPUT_MOUSE_BIT (1 << IRQ_VINPUT_MOUSE)
+
+typedef struct {
+    uint32_t QueueNum;
+    uint32_t QueueDesc;
+    uint32_t QueueAvail;
+    uint32_t QueueUsed;
+    uint16_t last_avail;
+    bool ready;
+} virtio_input_queue_t;
+
+typedef struct {
+    /* feature negotiation */
+    uint32_t DeviceFeaturesSel;
+    uint32_t DriverFeatures;
+    uint32_t DriverFeaturesSel;
+    /* queue config */
+    uint32_t QueueSel;
+    virtio_input_queue_t queues[2];
+    /* status */
+    uint32_t Status;
+    uint32_t InterruptStatus;
+    /* supplied by environment */
+    uint32_t *ram;
+    /* implementation-specific */
+    int id;  // FIXME
+    void *priv;
+} virtio_input_state_t;
+
+void virtio_input_read(rvvm_hart_t *vm,
+                       virtio_input_state_t *vinput,
+                       uint32_t addr,
+                       uint8_t width,
+                       uint32_t *value);
+
+void virtio_input_write(rvvm_hart_t *vm,
+                        virtio_input_state_t *vinput,
+                        uint32_t addr,
+                        uint8_t width,
+                        uint32_t value);
+
+void virtio_input_init(virtio_input_state_t *vinput);
+
+void virtio_input_update_key(uint32_t key, uint32_t state);
+
+void virtio_input_update_mouse_button_state(uint32_t button, bool pressed);
+
+void virtio_input_update_cursor(uint32_t x, uint32_t y);
+#endif /* SEMU_HAS(VIRTIOINPUT) */
+
+/* clint */
+typedef struct {
+    uint32_t msip[4096];
+    uint64_t mtimecmp[4095];
+    rvtimer_t mtime;
+} clint_state_t;
+
+void clint_update_interrupts(rvvm_hart_t *vm, clint_state_t *clint);
+void clint_read(rvvm_hart_t *vm,
+                clint_state_t *clint,
+                uint32_t addr,
+                uint8_t width,
+                uint32_t *value);
+void clint_write(rvvm_hart_t *vm,
+                 clint_state_t *clint,
+                 uint32_t addr,
+                 uint8_t width,
+                 uint32_t value);
+
+/* memory mapping */
+
+typedef struct {
+    bool stopped;
+    uint32_t *ram;
+    uint32_t *disk;
+    plic_state_t plic;
+    u8250_state_t uart;
+#if SEMU_HAS(VIRTIONET)
+    virtio_net_state_t vnet;
+#endif
+#if SEMU_HAS(VIRTIOBLK)
+    virtio_blk_state_t vblk;
+#endif
+#if SEMU_HAS(VIRTIOGPU)
+    virtio_gpu_state_t vgpu;
+#endif
+#if SEMU_HAS(VIRTIOINPUT)
+    virtio_input_state_t vkeyboard;
+    virtio_input_state_t vmouse;
+#endif
+    clint_state_t clint;
+} emu_state_t;
diff --git a/src/devices/virtio_feature.h b/src/devices/virtio_feature.h
new file mode 100644
index 0000000..64e3457
--- /dev/null
+++ b/src/devices/virtio_feature.h
@@ -0,0 +1,31 @@
+#pragma once
+
+/* enable/disable (compile time) features in this header */
+
+/* virtio-blk */
+#ifndef SEMU_FEATURE_VIRTIOBLK
+#define SEMU_FEATURE_VIRTIOBLK 1
+#endif
+
+/* virtio-net */
+#ifndef SEMU_FEATURE_VIRTIONET
+#define SEMU_FEATURE_VIRTIONET 1
+#endif
+
+/* virtio-gpu */
+#ifndef SEMU_FEATURE_VIRTIOGPU
+#define SEMU_FEATURE_VIRTIOGPU 1
+#endif
+
+/* VirGL */
+#ifndef SEMU_FEATURE_VIRGL
+#define SEMU_FEATURE_VIRGL 1
+#endif
+
+/* virtio-input */
+#ifndef SEMU_FEATURE_VIRTIOINPUT
+#define SEMU_FEATURE_VIRTIOINPUT 1
+#endif
+
+/* Feature test macro */
+#define SEMU_HAS(x) SEMU_FEATURE_##x
diff --git a/src/devices/virtio_input-event-codes.h b/src/devices/virtio_input-event-codes.h
new file mode 100644
index 0000000..50ad928
--- /dev/null
+++ b/src/devices/virtio_input-event-codes.h
@@ -0,0 +1,992 @@
+/* SPDX-License-Identifier: GPL-2.0-only WITH Linux-syscall-note */
+/*
+ * Input event codes
+ *
+ *    *** IMPORTANT ***
+ * This file is not only included from C-code but also from devicetree source
+ * files. As such this file MUST only contain comments and defines.
+ *
+ * Copyright (c) 1999-2002 Vojtech Pavlik
+ * Copyright (c) 2015 Hans de Goede <hdegoede@redhat.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+#ifndef _UAPI_INPUT_EVENT_CODES_H
+#define _UAPI_INPUT_EVENT_CODES_H
+
+/*
+ * Device properties and quirks
+ */
+
+#define INPUT_PROP_POINTER 0x00        /* needs a pointer */
+#define INPUT_PROP_DIRECT 0x01         /* direct input devices */
+#define INPUT_PROP_BUTTONPAD 0x02      /* has button(s) under pad */
+#define INPUT_PROP_SEMI_MT 0x03        /* touch rectangle only */
+#define INPUT_PROP_TOPBUTTONPAD 0x04   /* softbuttons at top of pad */
+#define INPUT_PROP_POINTING_STICK 0x05 /* is a pointing stick */
+#define INPUT_PROP_ACCELEROMETER 0x06  /* has accelerometer */
+
+#define INPUT_PROP_MAX 0x1f
+#define INPUT_PROP_CNT (INPUT_PROP_MAX + 1)
+
+/*
+ * Event types
+ */
+
+#define EV_SYN 0x00
+#define EV_KEY 0x01
+#define EV_REL 0x02
+#define EV_ABS 0x03
+#define EV_MSC 0x04
+#define EV_SW 0x05
+#define EV_LED 0x11
+#define EV_SND 0x12
+#define EV_REP 0x14
+#define EV_FF 0x15
+#define EV_PWR 0x16
+#define EV_FF_STATUS 0x17
+#define EV_MAX 0x1f
+#define EV_CNT (EV_MAX + 1)
+
+/*
+ * Synchronization events.
+ */
+
+#define SYN_REPORT 0
+#define SYN_CONFIG 1
+#define SYN_MT_REPORT 2
+#define SYN_DROPPED 3
+#define SYN_MAX 0xf
+#define SYN_CNT (SYN_MAX + 1)
+
+/*
+ * Keys and buttons
+ *
+ * Most of the keys/buttons are modeled after USB HUT 1.12
+ * (see http://www.usb.org/developers/hidpage).
+ * Abbreviations in the comments:
+ * AC - Application Control
+ * AL - Application Launch Button
+ * SC - System Control
+ */
+
+#define KEY_RESERVED 0
+#define KEY_ESC 1
+#define KEY_1 2
+#define KEY_2 3
+#define KEY_3 4
+#define KEY_4 5
+#define KEY_5 6
+#define KEY_6 7
+#define KEY_7 8
+#define KEY_8 9
+#define KEY_9 10
+#define KEY_0 11
+#define KEY_MINUS 12
+#define KEY_EQUAL 13
+#define KEY_BACKSPACE 14
+#define KEY_TAB 15
+#define KEY_Q 16
+#define KEY_W 17
+#define KEY_E 18
+#define KEY_R 19
+#define KEY_T 20
+#define KEY_Y 21
+#define KEY_U 22
+#define KEY_I 23
+#define KEY_O 24
+#define KEY_P 25
+#define KEY_LEFTBRACE 26
+#define KEY_RIGHTBRACE 27
+#define KEY_ENTER 28
+#define KEY_LEFTCTRL 29
+#define KEY_A 30
+#define KEY_S 31
+#define KEY_D 32
+#define KEY_F 33
+#define KEY_G 34
+#define KEY_H 35
+#define KEY_J 36
+#define KEY_K 37
+#define KEY_L 38
+#define KEY_SEMICOLON 39
+#define KEY_APOSTROPHE 40
+#define KEY_GRAVE 41
+#define KEY_LEFTSHIFT 42
+#define KEY_BACKSLASH 43
+#define KEY_Z 44
+#define KEY_X 45
+#define KEY_C 46
+#define KEY_V 47
+#define KEY_B 48
+#define KEY_N 49
+#define KEY_M 50
+#define KEY_COMMA 51
+#define KEY_DOT 52
+#define KEY_SLASH 53
+#define KEY_RIGHTSHIFT 54
+#define KEY_KPASTERISK 55
+#define KEY_LEFTALT 56
+#define KEY_SPACE 57
+#define KEY_CAPSLOCK 58
+#define KEY_F1 59
+#define KEY_F2 60
+#define KEY_F3 61
+#define KEY_F4 62
+#define KEY_F5 63
+#define KEY_F6 64
+#define KEY_F7 65
+#define KEY_F8 66
+#define KEY_F9 67
+#define KEY_F10 68
+#define KEY_NUMLOCK 69
+#define KEY_SCROLLLOCK 70
+#define KEY_KP7 71
+#define KEY_KP8 72
+#define KEY_KP9 73
+#define KEY_KPMINUS 74
+#define KEY_KP4 75
+#define KEY_KP5 76
+#define KEY_KP6 77
+#define KEY_KPPLUS 78
+#define KEY_KP1 79
+#define KEY_KP2 80
+#define KEY_KP3 81
+#define KEY_KP0 82
+#define KEY_KPDOT 83
+
+#define KEY_ZENKAKUHANKAKU 85
+#define KEY_102ND 86
+#define KEY_F11 87
+#define KEY_F12 88
+#define KEY_RO 89
+#define KEY_KATAKANA 90
+#define KEY_HIRAGANA 91
+#define KEY_HENKAN 92
+#define KEY_KATAKANAHIRAGANA 93
+#define KEY_MUHENKAN 94
+#define KEY_KPJPCOMMA 95
+#define KEY_KPENTER 96
+#define KEY_RIGHTCTRL 97
+#define KEY_KPSLASH 98
+#define KEY_SYSRQ 99
+#define KEY_RIGHTALT 100
+#define KEY_LINEFEED 101
+#define KEY_HOME 102
+#define KEY_UP 103
+#define KEY_PAGEUP 104
+#define KEY_LEFT 105
+#define KEY_RIGHT 106
+#define KEY_END 107
+#define KEY_DOWN 108
+#define KEY_PAGEDOWN 109
+#define KEY_INSERT 110
+#define KEY_DELETE 111
+#define KEY_MACRO 112
+#define KEY_MUTE 113
+#define KEY_VOLUMEDOWN 114
+#define KEY_VOLUMEUP 115
+#define KEY_POWER 116 /* SC System Power Down */
+#define KEY_KPEQUAL 117
+#define KEY_KPPLUSMINUS 118
+#define KEY_PAUSE 119
+#define KEY_SCALE 120 /* AL Compiz Scale (Expose) */
+
+#define KEY_KPCOMMA 121
+#define KEY_HANGEUL 122
+#define KEY_HANGUEL KEY_HANGEUL
+#define KEY_HANJA 123
+#define KEY_YEN 124
+#define KEY_LEFTMETA 125
+#define KEY_RIGHTMETA 126
+#define KEY_COMPOSE 127
+
+#define KEY_STOP 128 /* AC Stop */
+#define KEY_AGAIN 129
+#define KEY_PROPS 130 /* AC Properties */
+#define KEY_UNDO 131  /* AC Undo */
+#define KEY_FRONT 132
+#define KEY_COPY 133  /* AC Copy */
+#define KEY_OPEN 134  /* AC Open */
+#define KEY_PASTE 135 /* AC Paste */
+#define KEY_FIND 136  /* AC Search */
+#define KEY_CUT 137   /* AC Cut */
+#define KEY_HELP 138  /* AL Integrated Help Center */
+#define KEY_MENU 139  /* Menu (show menu) */
+#define KEY_CALC 140  /* AL Calculator */
+#define KEY_SETUP 141
+#define KEY_SLEEP 142  /* SC System Sleep */
+#define KEY_WAKEUP 143 /* System Wake Up */
+#define KEY_FILE 144   /* AL Local Machine Browser */
+#define KEY_SENDFILE 145
+#define KEY_DELETEFILE 146
+#define KEY_XFER 147
+#define KEY_PROG1 148
+#define KEY_PROG2 149
+#define KEY_WWW 150 /* AL Internet Browser */
+#define KEY_MSDOS 151
+#define KEY_COFFEE 152 /* AL Terminal Lock/Screensaver */
+#define KEY_SCREENLOCK KEY_COFFEE
+#define KEY_ROTATE_DISPLAY 153 /* Display orientation for e.g. tablets */
+#define KEY_DIRECTION KEY_ROTATE_DISPLAY
+#define KEY_CYCLEWINDOWS 154
+#define KEY_MAIL 155
+#define KEY_BOOKMARKS 156 /* AC Bookmarks */
+#define KEY_COMPUTER 157
+#define KEY_BACK 158    /* AC Back */
+#define KEY_FORWARD 159 /* AC Forward */
+#define KEY_CLOSECD 160
+#define KEY_EJECTCD 161
+#define KEY_EJECTCLOSECD 162
+#define KEY_NEXTSONG 163
+#define KEY_PLAYPAUSE 164
+#define KEY_PREVIOUSSONG 165
+#define KEY_STOPCD 166
+#define KEY_RECORD 167
+#define KEY_REWIND 168
+#define KEY_PHONE 169 /* Media Select Telephone */
+#define KEY_ISO 170
+#define KEY_CONFIG 171   /* AL Consumer Control Configuration */
+#define KEY_HOMEPAGE 172 /* AC Home */
+#define KEY_REFRESH 173  /* AC Refresh */
+#define KEY_EXIT 174     /* AC Exit */
+#define KEY_MOVE 175
+#define KEY_EDIT 176
+#define KEY_SCROLLUP 177
+#define KEY_SCROLLDOWN 178
+#define KEY_KPLEFTPAREN 179
+#define KEY_KPRIGHTPAREN 180
+#define KEY_NEW 181  /* AC New */
+#define KEY_REDO 182 /* AC Redo/Repeat */
+
+#define KEY_F13 183
+#define KEY_F14 184
+#define KEY_F15 185
+#define KEY_F16 186
+#define KEY_F17 187
+#define KEY_F18 188
+#define KEY_F19 189
+#define KEY_F20 190
+#define KEY_F21 191
+#define KEY_F22 192
+#define KEY_F23 193
+#define KEY_F24 194
+
+#define KEY_PLAYCD 200
+#define KEY_PAUSECD 201
+#define KEY_PROG3 202
+#define KEY_PROG4 203
+#define KEY_ALL_APPLICATIONS 204 /* AC Desktop Show All Applications */
+#define KEY_DASHBOARD KEY_ALL_APPLICATIONS
+#define KEY_SUSPEND 205
+#define KEY_CLOSE 206 /* AC Close */
+#define KEY_PLAY 207
+#define KEY_FASTFORWARD 208
+#define KEY_BASSBOOST 209
+#define KEY_PRINT 210 /* AC Print */
+#define KEY_HP 211
+#define KEY_CAMERA 212
+#define KEY_SOUND 213
+#define KEY_QUESTION 214
+#define KEY_EMAIL 215
+#define KEY_CHAT 216
+#define KEY_SEARCH 217
+#define KEY_CONNECT 218
+#define KEY_FINANCE 219 /* AL Checkbook/Finance */
+#define KEY_SPORT 220
+#define KEY_SHOP 221
+#define KEY_ALTERASE 222
+#define KEY_CANCEL 223 /* AC Cancel */
+#define KEY_BRIGHTNESSDOWN 224
+#define KEY_BRIGHTNESSUP 225
+#define KEY_MEDIA 226
+
+#define KEY_SWITCHVIDEOMODE              \
+    227 /* Cycle between available video \
+outputs (Monitor/LCD/TV-out/etc) */
+#define KEY_KBDILLUMTOGGLE 228
+#define KEY_KBDILLUMDOWN 229
+#define KEY_KBDILLUMUP 230
+
+#define KEY_SEND 231        /* AC Send */
+#define KEY_REPLY 232       /* AC Reply */
+#define KEY_FORWARDMAIL 233 /* AC Forward Msg */
+#define KEY_SAVE 234        /* AC Save */
+#define KEY_DOCUMENTS 235
+
+#define KEY_BATTERY 236
+
+#define KEY_BLUETOOTH 237
+#define KEY_WLAN 238
+#define KEY_UWB 239
+
+#define KEY_UNKNOWN 240
+
+#define KEY_VIDEO_NEXT 241       /* drive next video source */
+#define KEY_VIDEO_PREV 242       /* drive previous video source */
+#define KEY_BRIGHTNESS_CYCLE 243 /* brightness up, after max is min */
+#define KEY_BRIGHTNESS_AUTO            \
+    244 /* Set Auto Brightness: manual \
+brightness control is off,             \
+rely on ambient */
+#define KEY_BRIGHTNESS_ZERO KEY_BRIGHTNESS_AUTO
+#define KEY_DISPLAY_OFF 245 /* display device to off state */
+
+#define KEY_WWAN 246 /* Wireless WAN (LTE, UMTS, GSM, etc.) */
+#define KEY_WIMAX KEY_WWAN
+#define KEY_RFKILL 247 /* Key that controls all radios */
+
+#define KEY_MICMUTE 248 /* Mute / unmute the microphone */
+
+/* Code 255 is reserved for special needs of AT keyboard driver */
+
+#define BTN_MISC 0x100
+#define BTN_0 0x100
+#define BTN_1 0x101
+#define BTN_2 0x102
+#define BTN_3 0x103
+#define BTN_4 0x104
+#define BTN_5 0x105
+#define BTN_6 0x106
+#define BTN_7 0x107
+#define BTN_8 0x108
+#define BTN_9 0x109
+
+#define BTN_MOUSE 0x110
+#define BTN_LEFT 0x110
+#define BTN_RIGHT 0x111
+#define BTN_MIDDLE 0x112
+#define BTN_SIDE 0x113
+#define BTN_EXTRA 0x114
+#define BTN_FORWARD 0x115
+#define BTN_BACK 0x116
+#define BTN_TASK 0x117
+
+#define BTN_JOYSTICK 0x120
+#define BTN_TRIGGER 0x120
+#define BTN_THUMB 0x121
+#define BTN_THUMB2 0x122
+#define BTN_TOP 0x123
+#define BTN_TOP2 0x124
+#define BTN_PINKIE 0x125
+#define BTN_BASE 0x126
+#define BTN_BASE2 0x127
+#define BTN_BASE3 0x128
+#define BTN_BASE4 0x129
+#define BTN_BASE5 0x12a
+#define BTN_BASE6 0x12b
+#define BTN_DEAD 0x12f
+
+#define BTN_GAMEPAD 0x130
+#define BTN_SOUTH 0x130
+#define BTN_A BTN_SOUTH
+#define BTN_EAST 0x131
+#define BTN_B BTN_EAST
+#define BTN_C 0x132
+#define BTN_NORTH 0x133
+#define BTN_X BTN_NORTH
+#define BTN_WEST 0x134
+#define BTN_Y BTN_WEST
+#define BTN_Z 0x135
+#define BTN_TL 0x136
+#define BTN_TR 0x137
+#define BTN_TL2 0x138
+#define BTN_TR2 0x139
+#define BTN_SELECT 0x13a
+#define BTN_START 0x13b
+#define BTN_MODE 0x13c
+#define BTN_THUMBL 0x13d
+#define BTN_THUMBR 0x13e
+
+#define BTN_DIGI 0x140
+#define BTN_TOOL_PEN 0x140
+#define BTN_TOOL_RUBBER 0x141
+#define BTN_TOOL_BRUSH 0x142
+#define BTN_TOOL_PENCIL 0x143
+#define BTN_TOOL_AIRBRUSH 0x144
+#define BTN_TOOL_FINGER 0x145
+#define BTN_TOOL_MOUSE 0x146
+#define BTN_TOOL_LENS 0x147
+#define BTN_TOOL_QUINTTAP 0x148 /* Five fingers on trackpad */
+#define BTN_STYLUS3 0x149
+#define BTN_TOUCH 0x14a
+#define BTN_STYLUS 0x14b
+#define BTN_STYLUS2 0x14c
+#define BTN_TOOL_DOUBLETAP 0x14d
+#define BTN_TOOL_TRIPLETAP 0x14e
+#define BTN_TOOL_QUADTAP 0x14f /* Four fingers on trackpad */
+
+#define BTN_WHEEL 0x150
+#define BTN_GEAR_DOWN 0x150
+#define BTN_GEAR_UP 0x151
+
+#define KEY_OK 0x160
+#define KEY_SELECT 0x161
+#define KEY_GOTO 0x162
+#define KEY_CLEAR 0x163
+#define KEY_POWER2 0x164
+#define KEY_OPTION 0x165
+#define KEY_INFO 0x166 /* AL OEM Features/Tips/Tutorial */
+#define KEY_TIME 0x167
+#define KEY_VENDOR 0x168
+#define KEY_ARCHIVE 0x169
+#define KEY_PROGRAM 0x16a /* Media Select Program Guide */
+#define KEY_CHANNEL 0x16b
+#define KEY_FAVORITES 0x16c
+#define KEY_EPG 0x16d
+#define KEY_PVR 0x16e /* Media Select Home */
+#define KEY_MHP 0x16f
+#define KEY_LANGUAGE 0x170
+#define KEY_TITLE 0x171
+#define KEY_SUBTITLE 0x172
+#define KEY_ANGLE 0x173
+#define KEY_FULL_SCREEN 0x174 /* AC View Toggle */
+#define KEY_ZOOM KEY_FULL_SCREEN
+#define KEY_MODE 0x175
+#define KEY_KEYBOARD 0x176
+#define KEY_ASPECT_RATIO 0x177 /* HUTRR37: Aspect */
+#define KEY_SCREEN KEY_ASPECT_RATIO
+#define KEY_PC 0x178   /* Media Select Computer */
+#define KEY_TV 0x179   /* Media Select TV */
+#define KEY_TV2 0x17a  /* Media Select Cable */
+#define KEY_VCR 0x17b  /* Media Select VCR */
+#define KEY_VCR2 0x17c /* VCR Plus */
+#define KEY_SAT 0x17d  /* Media Select Satellite */
+#define KEY_SAT2 0x17e
+#define KEY_CD 0x17f   /* Media Select CD */
+#define KEY_TAPE 0x180 /* Media Select Tape */
+#define KEY_RADIO 0x181
+#define KEY_TUNER 0x182 /* Media Select Tuner */
+#define KEY_PLAYER 0x183
+#define KEY_TEXT 0x184
+#define KEY_DVD 0x185 /* Media Select DVD */
+#define KEY_AUX 0x186
+#define KEY_MP3 0x187
+#define KEY_AUDIO 0x188 /* AL Audio Browser */
+#define KEY_VIDEO 0x189 /* AL Movie Browser */
+#define KEY_DIRECTORY 0x18a
+#define KEY_LIST 0x18b
+#define KEY_MEMO 0x18c /* Media Select Messages */
+#define KEY_CALENDAR 0x18d
+#define KEY_RED 0x18e
+#define KEY_GREEN 0x18f
+#define KEY_YELLOW 0x190
+#define KEY_BLUE 0x191
+#define KEY_CHANNELUP 0x192   /* Channel Increment */
+#define KEY_CHANNELDOWN 0x193 /* Channel Decrement */
+#define KEY_FIRST 0x194
+#define KEY_LAST 0x195 /* Recall Last */
+#define KEY_AB 0x196
+#define KEY_NEXT 0x197
+#define KEY_RESTART 0x198
+#define KEY_SLOW 0x199
+#define KEY_SHUFFLE 0x19a
+#define KEY_BREAK 0x19b
+#define KEY_PREVIOUS 0x19c
+#define KEY_DIGITS 0x19d
+#define KEY_TEEN 0x19e
+#define KEY_TWEN 0x19f
+#define KEY_VIDEOPHONE 0x1a0     /* Media Select Video Phone */
+#define KEY_GAMES 0x1a1          /* Media Select Games */
+#define KEY_ZOOMIN 0x1a2         /* AC Zoom In */
+#define KEY_ZOOMOUT 0x1a3        /* AC Zoom Out */
+#define KEY_ZOOMRESET 0x1a4      /* AC Zoom */
+#define KEY_WORDPROCESSOR 0x1a5  /* AL Word Processor */
+#define KEY_EDITOR 0x1a6         /* AL Text Editor */
+#define KEY_SPREADSHEET 0x1a7    /* AL Spreadsheet */
+#define KEY_GRAPHICSEDITOR 0x1a8 /* AL Graphics Editor */
+#define KEY_PRESENTATION 0x1a9   /* AL Presentation App */
+#define KEY_DATABASE 0x1aa       /* AL Database App */
+#define KEY_NEWS 0x1ab           /* AL Newsreader */
+#define KEY_VOICEMAIL 0x1ac      /* AL Voicemail */
+#define KEY_ADDRESSBOOK 0x1ad    /* AL Contacts/Address Book */
+#define KEY_MESSENGER 0x1ae      /* AL Instant Messaging */
+#define KEY_DISPLAYTOGGLE 0x1af  /* Turn display (LCD) on and off */
+#define KEY_BRIGHTNESS_TOGGLE KEY_DISPLAYTOGGLE
+#define KEY_SPELLCHECK 0x1b0 /* AL Spell Check */
+#define KEY_LOGOFF 0x1b1     /* AL Logoff */
+
+#define KEY_DOLLAR 0x1b2
+#define KEY_EURO 0x1b3
+
+#define KEY_FRAMEBACK 0x1b4 /* Consumer - transport controls */
+#define KEY_FRAMEFORWARD 0x1b5
+#define KEY_CONTEXT_MENU 0x1b6        /* GenDesc - system context menu */
+#define KEY_MEDIA_REPEAT 0x1b7        /* Consumer - transport control */
+#define KEY_10CHANNELSUP 0x1b8        /* 10 channels up (10+) */
+#define KEY_10CHANNELSDOWN 0x1b9      /* 10 channels down (10-) */
+#define KEY_IMAGES 0x1ba              /* AL Image Browser */
+#define KEY_NOTIFICATION_CENTER 0x1bc /* Show/hide the notification center */
+#define KEY_PICKUP_PHONE 0x1bd        /* Answer incoming call */
+#define KEY_HANGUP_PHONE 0x1be        /* Decline incoming call */
+
+#define KEY_DEL_EOL 0x1c0
+#define KEY_DEL_EOS 0x1c1
+#define KEY_INS_LINE 0x1c2
+#define KEY_DEL_LINE 0x1c3
+
+#define KEY_FN 0x1d0
+#define KEY_FN_ESC 0x1d1
+#define KEY_FN_F1 0x1d2
+#define KEY_FN_F2 0x1d3
+#define KEY_FN_F3 0x1d4
+#define KEY_FN_F4 0x1d5
+#define KEY_FN_F5 0x1d6
+#define KEY_FN_F6 0x1d7
+#define KEY_FN_F7 0x1d8
+#define KEY_FN_F8 0x1d9
+#define KEY_FN_F9 0x1da
+#define KEY_FN_F10 0x1db
+#define KEY_FN_F11 0x1dc
+#define KEY_FN_F12 0x1dd
+#define KEY_FN_1 0x1de
+#define KEY_FN_2 0x1df
+#define KEY_FN_D 0x1e0
+#define KEY_FN_E 0x1e1
+#define KEY_FN_F 0x1e2
+#define KEY_FN_S 0x1e3
+#define KEY_FN_B 0x1e4
+#define KEY_FN_RIGHT_SHIFT 0x1e5
+
+#define KEY_BRL_DOT1 0x1f1
+#define KEY_BRL_DOT2 0x1f2
+#define KEY_BRL_DOT3 0x1f3
+#define KEY_BRL_DOT4 0x1f4
+#define KEY_BRL_DOT5 0x1f5
+#define KEY_BRL_DOT6 0x1f6
+#define KEY_BRL_DOT7 0x1f7
+#define KEY_BRL_DOT8 0x1f8
+#define KEY_BRL_DOT9 0x1f9
+#define KEY_BRL_DOT10 0x1fa
+
+#define KEY_NUMERIC_0 0x200 /* used by phones, remote controls, */
+#define KEY_NUMERIC_1 0x201 /* and other keypads */
+#define KEY_NUMERIC_2 0x202
+#define KEY_NUMERIC_3 0x203
+#define KEY_NUMERIC_4 0x204
+#define KEY_NUMERIC_5 0x205
+#define KEY_NUMERIC_6 0x206
+#define KEY_NUMERIC_7 0x207
+#define KEY_NUMERIC_8 0x208
+#define KEY_NUMERIC_9 0x209
+#define KEY_NUMERIC_STAR 0x20a
+#define KEY_NUMERIC_POUND 0x20b
+#define KEY_NUMERIC_A 0x20c /* Phone key A - HUT Telephony 0xb9 */
+#define KEY_NUMERIC_B 0x20d
+#define KEY_NUMERIC_C 0x20e
+#define KEY_NUMERIC_D 0x20f
+
+#define KEY_CAMERA_FOCUS 0x210
+#define KEY_WPS_BUTTON 0x211 /* WiFi Protected Setup key */
+
+#define KEY_TOUCHPAD_TOGGLE 0x212 /* Request switch touchpad on or off */
+#define KEY_TOUCHPAD_ON 0x213
+#define KEY_TOUCHPAD_OFF 0x214
+
+#define KEY_CAMERA_ZOOMIN 0x215
+#define KEY_CAMERA_ZOOMOUT 0x216
+#define KEY_CAMERA_UP 0x217
+#define KEY_CAMERA_DOWN 0x218
+#define KEY_CAMERA_LEFT 0x219
+#define KEY_CAMERA_RIGHT 0x21a
+
+#define KEY_ATTENDANT_ON 0x21b
+#define KEY_ATTENDANT_OFF 0x21c
+#define KEY_ATTENDANT_TOGGLE 0x21d /* Attendant call on or off */
+#define KEY_LIGHTS_TOGGLE 0x21e    /* Reading light on or off */
+
+#define BTN_DPAD_UP 0x220
+#define BTN_DPAD_DOWN 0x221
+#define BTN_DPAD_LEFT 0x222
+#define BTN_DPAD_RIGHT 0x223
+
+#define KEY_ALS_TOGGLE 0x230          /* Ambient light sensor */
+#define KEY_ROTATE_LOCK_TOGGLE 0x231  /* Display rotation lock */
+#define KEY_REFRESH_RATE_TOGGLE 0x232 /* Display refresh rate toggle */
+
+#define KEY_BUTTONCONFIG 0x240    /* AL Button Configuration */
+#define KEY_TASKMANAGER 0x241     /* AL Task/Project Manager */
+#define KEY_JOURNAL 0x242         /* AL Log/Journal/Timecard */
+#define KEY_CONTROLPANEL 0x243    /* AL Control Panel */
+#define KEY_APPSELECT 0x244       /* AL Select Task/Application */
+#define KEY_SCREENSAVER 0x245     /* AL Screen Saver */
+#define KEY_VOICECOMMAND 0x246    /* Listening Voice Command */
+#define KEY_ASSISTANT 0x247       /* AL Context-aware desktop assistant */
+#define KEY_KBD_LAYOUT_NEXT 0x248 /* AC Next Keyboard Layout Select */
+#define KEY_EMOJI_PICKER 0x249    /* Show/hide emoji picker (HUTRR101) */
+#define KEY_DICTATE                                          \
+    0x24a /* Start or Stop Voice Dictation Session (HUTRR99) \
+           */
+#define KEY_CAMERA_ACCESS_ENABLE \
+    0x24b /* Enables programmatic access to camera devices. (HUTRR72) */
+#define KEY_CAMERA_ACCESS_DISABLE \
+    0x24c /* Disables programmatic access to camera devices. (HUTRR72) */
+#define KEY_CAMERA_ACCESS_TOGGLE                                               \
+    0x24d /* Toggles the current state of the camera access control. (HUTRR72) \
+           */
+#define KEY_ACCESSIBILITY \
+    0x24e /* Toggles the system bound accessibility UI/command (HUTRR116) */
+#define KEY_DO_NOT_DISTURB \
+    0x24f /* Toggles the system-wide "Do Not Disturb" control (HUTRR94)*/
+
+#define KEY_BRIGHTNESS_MIN 0x250 /* Set Brightness to Minimum */
+#define KEY_BRIGHTNESS_MAX 0x251 /* Set Brightness to Maximum */
+
+#define KEY_KBDINPUTASSIST_PREV 0x260
+#define KEY_KBDINPUTASSIST_NEXT 0x261
+#define KEY_KBDINPUTASSIST_PREVGROUP 0x262
+#define KEY_KBDINPUTASSIST_NEXTGROUP 0x263
+#define KEY_KBDINPUTASSIST_ACCEPT 0x264
+#define KEY_KBDINPUTASSIST_CANCEL 0x265
+
+/* Diagonal movement keys */
+#define KEY_RIGHT_UP 0x266
+#define KEY_RIGHT_DOWN 0x267
+#define KEY_LEFT_UP 0x268
+#define KEY_LEFT_DOWN 0x269
+
+#define KEY_ROOT_MENU 0x26a /* Show Device's Root Menu */
+/* Show Top Menu of the Media (e.g. DVD) */
+#define KEY_MEDIA_TOP_MENU 0x26b
+#define KEY_NUMERIC_11 0x26c
+#define KEY_NUMERIC_12 0x26d
+/*
+ * Toggle Audio Description: refers to an audio service that helps blind and
+ * visually impaired consumers understand the action in a program. Note: in
+ * some countries this is referred to as "Video Description".
+ */
+#define KEY_AUDIO_DESC 0x26e
+#define KEY_3D_MODE 0x26f
+#define KEY_NEXT_FAVORITE 0x270
+#define KEY_STOP_RECORD 0x271
+#define KEY_PAUSE_RECORD 0x272
+#define KEY_VOD 0x273 /* Video on Demand */
+#define KEY_UNMUTE 0x274
+#define KEY_FASTREVERSE 0x275
+#define KEY_SLOWREVERSE 0x276
+/*
+ * Control a data application associated with the currently viewed channel,
+ * e.g. teletext or data broadcast application (MHEG, MHP, HbbTV, etc.)
+ */
+#define KEY_DATA 0x277
+#define KEY_ONSCREEN_KEYBOARD 0x278
+/* Electronic privacy screen control */
+#define KEY_PRIVACY_SCREEN_TOGGLE 0x279
+
+/* Select an area of screen to be copied */
+#define KEY_SELECTIVE_SCREENSHOT 0x27a
+
+/* Move the focus to the next or previous user controllable element within a UI
+ * container */
+#define KEY_NEXT_ELEMENT 0x27b
+#define KEY_PREVIOUS_ELEMENT 0x27c
+
+/* Toggle Autopilot engagement */
+#define KEY_AUTOPILOT_ENGAGE_TOGGLE 0x27d
+
+/* Shortcut Keys */
+#define KEY_MARK_WAYPOINT 0x27e
+#define KEY_SOS 0x27f
+#define KEY_NAV_CHART 0x280
+#define KEY_FISHING_CHART 0x281
+#define KEY_SINGLE_RANGE_RADAR 0x282
+#define KEY_DUAL_RANGE_RADAR 0x283
+#define KEY_RADAR_OVERLAY 0x284
+#define KEY_TRADITIONAL_SONAR 0x285
+#define KEY_CLEARVU_SONAR 0x286
+#define KEY_SIDEVU_SONAR 0x287
+#define KEY_NAV_INFO 0x288
+#define KEY_BRIGHTNESS_MENU 0x289
+
+/*
+ * Some keyboards have keys which do not have a defined meaning, these keys
+ * are intended to be programmed / bound to macros by the user. For most
+ * keyboards with these macro-keys the key-sequence to inject, or action to
+ * take, is all handled by software on the host side. So from the kernel's
+ * point of view these are just normal keys.
+ *
+ * The KEY_MACRO# codes below are intended for such keys, which may be labeled
+ * e.g. G1-G18, or S1 - S30. The KEY_MACRO# codes MUST NOT be used for keys
+ * where the marking on the key does indicate a defined meaning / purpose.
+ *
+ * The KEY_MACRO# codes MUST also NOT be used as fallback for when no existing
+ * KEY_FOO define matches the marking / purpose. In this case a new KEY_FOO
+ * define MUST be added.
+ */
+#define KEY_MACRO1 0x290
+#define KEY_MACRO2 0x291
+#define KEY_MACRO3 0x292
+#define KEY_MACRO4 0x293
+#define KEY_MACRO5 0x294
+#define KEY_MACRO6 0x295
+#define KEY_MACRO7 0x296
+#define KEY_MACRO8 0x297
+#define KEY_MACRO9 0x298
+#define KEY_MACRO10 0x299
+#define KEY_MACRO11 0x29a
+#define KEY_MACRO12 0x29b
+#define KEY_MACRO13 0x29c
+#define KEY_MACRO14 0x29d
+#define KEY_MACRO15 0x29e
+#define KEY_MACRO16 0x29f
+#define KEY_MACRO17 0x2a0
+#define KEY_MACRO18 0x2a1
+#define KEY_MACRO19 0x2a2
+#define KEY_MACRO20 0x2a3
+#define KEY_MACRO21 0x2a4
+#define KEY_MACRO22 0x2a5
+#define KEY_MACRO23 0x2a6
+#define KEY_MACRO24 0x2a7
+#define KEY_MACRO25 0x2a8
+#define KEY_MACRO26 0x2a9
+#define KEY_MACRO27 0x2aa
+#define KEY_MACRO28 0x2ab
+#define KEY_MACRO29 0x2ac
+#define KEY_MACRO30 0x2ad
+
+/*
+ * Some keyboards with the macro-keys described above have some extra keys
+ * for controlling the host-side software responsible for the macro handling:
+ * -A macro recording start/stop key. Note that not all keyboards which emit
+ *  KEY_MACRO_RECORD_START will also emit KEY_MACRO_RECORD_STOP if
+ *  KEY_MACRO_RECORD_STOP is not advertised, then KEY_MACRO_RECORD_START
+ *  should be interpreted as a recording start/stop toggle;
+ * -Keys for switching between different macro (pre)sets, either a key for
+ *  cycling through the configured presets or keys to directly select a preset.
+ */
+#define KEY_MACRO_RECORD_START 0x2b0
+#define KEY_MACRO_RECORD_STOP 0x2b1
+#define KEY_MACRO_PRESET_CYCLE 0x2b2
+#define KEY_MACRO_PRESET1 0x2b3
+#define KEY_MACRO_PRESET2 0x2b4
+#define KEY_MACRO_PRESET3 0x2b5
+
+/*
+ * Some keyboards have a buildin LCD panel where the contents are controlled
+ * by the host. Often these have a number of keys directly below the LCD
+ * intended for controlling a menu shown on the LCD. These keys often don't
+ * have any labeling so we just name them KEY_KBD_LCD_MENU#
+ */
+#define KEY_KBD_LCD_MENU1 0x2b8
+#define KEY_KBD_LCD_MENU2 0x2b9
+#define KEY_KBD_LCD_MENU3 0x2ba
+#define KEY_KBD_LCD_MENU4 0x2bb
+#define KEY_KBD_LCD_MENU5 0x2bc
+
+#define BTN_TRIGGER_HAPPY 0x2c0
+#define BTN_TRIGGER_HAPPY1 0x2c0
+#define BTN_TRIGGER_HAPPY2 0x2c1
+#define BTN_TRIGGER_HAPPY3 0x2c2
+#define BTN_TRIGGER_HAPPY4 0x2c3
+#define BTN_TRIGGER_HAPPY5 0x2c4
+#define BTN_TRIGGER_HAPPY6 0x2c5
+#define BTN_TRIGGER_HAPPY7 0x2c6
+#define BTN_TRIGGER_HAPPY8 0x2c7
+#define BTN_TRIGGER_HAPPY9 0x2c8
+#define BTN_TRIGGER_HAPPY10 0x2c9
+#define BTN_TRIGGER_HAPPY11 0x2ca
+#define BTN_TRIGGER_HAPPY12 0x2cb
+#define BTN_TRIGGER_HAPPY13 0x2cc
+#define BTN_TRIGGER_HAPPY14 0x2cd
+#define BTN_TRIGGER_HAPPY15 0x2ce
+#define BTN_TRIGGER_HAPPY16 0x2cf
+#define BTN_TRIGGER_HAPPY17 0x2d0
+#define BTN_TRIGGER_HAPPY18 0x2d1
+#define BTN_TRIGGER_HAPPY19 0x2d2
+#define BTN_TRIGGER_HAPPY20 0x2d3
+#define BTN_TRIGGER_HAPPY21 0x2d4
+#define BTN_TRIGGER_HAPPY22 0x2d5
+#define BTN_TRIGGER_HAPPY23 0x2d6
+#define BTN_TRIGGER_HAPPY24 0x2d7
+#define BTN_TRIGGER_HAPPY25 0x2d8
+#define BTN_TRIGGER_HAPPY26 0x2d9
+#define BTN_TRIGGER_HAPPY27 0x2da
+#define BTN_TRIGGER_HAPPY28 0x2db
+#define BTN_TRIGGER_HAPPY29 0x2dc
+#define BTN_TRIGGER_HAPPY30 0x2dd
+#define BTN_TRIGGER_HAPPY31 0x2de
+#define BTN_TRIGGER_HAPPY32 0x2df
+#define BTN_TRIGGER_HAPPY33 0x2e0
+#define BTN_TRIGGER_HAPPY34 0x2e1
+#define BTN_TRIGGER_HAPPY35 0x2e2
+#define BTN_TRIGGER_HAPPY36 0x2e3
+#define BTN_TRIGGER_HAPPY37 0x2e4
+#define BTN_TRIGGER_HAPPY38 0x2e5
+#define BTN_TRIGGER_HAPPY39 0x2e6
+#define BTN_TRIGGER_HAPPY40 0x2e7
+
+/* We avoid low common keys in module aliases so they don't get huge. */
+#define KEY_MIN_INTERESTING KEY_MUTE
+#define KEY_MAX 0x2ff
+#define KEY_CNT (KEY_MAX + 1)
+
+/*
+ * Relative axes
+ */
+
+#define REL_X 0x00
+#define REL_Y 0x01
+#define REL_Z 0x02
+#define REL_RX 0x03
+#define REL_RY 0x04
+#define REL_RZ 0x05
+#define REL_HWHEEL 0x06
+#define REL_DIAL 0x07
+#define REL_WHEEL 0x08
+#define REL_MISC 0x09
+/*
+ * 0x0a is reserved and should not be used in input drivers.
+ * It was used by HID as REL_MISC+1 and userspace needs to detect if
+ * the next REL_* event is correct or is just REL_MISC + n.
+ * We define here REL_RESERVED so userspace can rely on it and detect
+ * the situation described above.
+ */
+#define REL_RESERVED 0x0a
+#define REL_WHEEL_HI_RES 0x0b
+#define REL_HWHEEL_HI_RES 0x0c
+#define REL_MAX 0x0f
+#define REL_CNT (REL_MAX + 1)
+
+/*
+ * Absolute axes
+ */
+
+#define ABS_X 0x00
+#define ABS_Y 0x01
+#define ABS_Z 0x02
+#define ABS_RX 0x03
+#define ABS_RY 0x04
+#define ABS_RZ 0x05
+#define ABS_THROTTLE 0x06
+#define ABS_RUDDER 0x07
+#define ABS_WHEEL 0x08
+#define ABS_GAS 0x09
+#define ABS_BRAKE 0x0a
+#define ABS_HAT0X 0x10
+#define ABS_HAT0Y 0x11
+#define ABS_HAT1X 0x12
+#define ABS_HAT1Y 0x13
+#define ABS_HAT2X 0x14
+#define ABS_HAT2Y 0x15
+#define ABS_HAT3X 0x16
+#define ABS_HAT3Y 0x17
+#define ABS_PRESSURE 0x18
+#define ABS_DISTANCE 0x19
+#define ABS_TILT_X 0x1a
+#define ABS_TILT_Y 0x1b
+#define ABS_TOOL_WIDTH 0x1c
+
+#define ABS_VOLUME 0x20
+#define ABS_PROFILE 0x21
+
+#define ABS_MISC 0x28
+
+/*
+ * 0x2e is reserved and should not be used in input drivers.
+ * It was used by HID as ABS_MISC+6 and userspace needs to detect if
+ * the next ABS_* event is correct or is just ABS_MISC + n.
+ * We define here ABS_RESERVED so userspace can rely on it and detect
+ * the situation described above.
+ */
+#define ABS_RESERVED 0x2e
+
+#define ABS_MT_SLOT 0x2f        /* MT slot being modified */
+#define ABS_MT_TOUCH_MAJOR 0x30 /* Major axis of touching ellipse */
+#define ABS_MT_TOUCH_MINOR 0x31 /* Minor axis (omit if circular) */
+#define ABS_MT_WIDTH_MAJOR 0x32 /* Major axis of approaching ellipse */
+#define ABS_MT_WIDTH_MINOR 0x33 /* Minor axis (omit if circular) */
+#define ABS_MT_ORIENTATION 0x34 /* Ellipse orientation */
+#define ABS_MT_POSITION_X 0x35  /* Center X touch position */
+#define ABS_MT_POSITION_Y 0x36  /* Center Y touch position */
+#define ABS_MT_TOOL_TYPE 0x37   /* Type of touching device */
+#define ABS_MT_BLOB_ID 0x38     /* Group a set of packets as a blob */
+#define ABS_MT_TRACKING_ID 0x39 /* Unique ID of initiated contact */
+#define ABS_MT_PRESSURE 0x3a    /* Pressure on contact area */
+#define ABS_MT_DISTANCE 0x3b    /* Contact hover distance */
+#define ABS_MT_TOOL_X 0x3c      /* Center X tool position */
+#define ABS_MT_TOOL_Y 0x3d      /* Center Y tool position */
+
+
+#define ABS_MAX 0x3f
+#define ABS_CNT (ABS_MAX + 1)
+
+/*
+ * Switch events
+ */
+
+#define SW_LID 0x00              /* set = lid shut */
+#define SW_TABLET_MODE 0x01      /* set = tablet mode */
+#define SW_HEADPHONE_INSERT 0x02 /* set = inserted */
+#define SW_RFKILL_ALL                                                    \
+    0x03                             /* rfkill master switch, type "any" \
+                        set = radio enabled */
+#define SW_RADIO SW_RFKILL_ALL       /* deprecated */
+#define SW_MICROPHONE_INSERT 0x04    /* set = inserted */
+#define SW_DOCK 0x05                 /* set = plugged into dock */
+#define SW_LINEOUT_INSERT 0x06       /* set = inserted */
+#define SW_JACK_PHYSICAL_INSERT 0x07 /* set = mechanical switch set */
+#define SW_VIDEOOUT_INSERT 0x08      /* set = inserted */
+#define SW_CAMERA_LENS_COVER 0x09    /* set = lens covered */
+#define SW_KEYPAD_SLIDE 0x0a         /* set = keypad slide out */
+#define SW_FRONT_PROXIMITY 0x0b      /* set = front proximity sensor active */
+#define SW_ROTATE_LOCK 0x0c          /* set = rotate locked/disabled */
+#define SW_LINEIN_INSERT 0x0d        /* set = inserted */
+#define SW_MUTE_DEVICE 0x0e          /* set = device disabled */
+#define SW_PEN_INSERTED 0x0f         /* set = pen inserted */
+#define SW_MACHINE_COVER 0x10        /* set = cover closed */
+#define SW_MAX 0x10
+#define SW_CNT (SW_MAX + 1)
+
+/*
+ * Misc events
+ */
+
+#define MSC_SERIAL 0x00
+#define MSC_PULSELED 0x01
+#define MSC_GESTURE 0x02
+#define MSC_RAW 0x03
+#define MSC_SCAN 0x04
+#define MSC_TIMESTAMP 0x05
+#define MSC_MAX 0x07
+#define MSC_CNT (MSC_MAX + 1)
+
+/*
+ * LEDs
+ */
+
+#define LED_NUML 0x00
+#define LED_CAPSL 0x01
+#define LED_SCROLLL 0x02
+#define LED_COMPOSE 0x03
+#define LED_KANA 0x04
+#define LED_SLEEP 0x05
+#define LED_SUSPEND 0x06
+#define LED_MUTE 0x07
+#define LED_MISC 0x08
+#define LED_MAIL 0x09
+#define LED_CHARGING 0x0a
+#define LED_MAX 0x0f
+#define LED_CNT (LED_MAX + 1)
+
+/*
+ * Autorepeat values
+ */
+
+#define REP_DELAY 0x00
+#define REP_PERIOD 0x01
+#define REP_MAX 0x01
+#define REP_CNT (REP_MAX + 1)
+
+/*
+ * Sounds
+ */
+
+#define SND_CLICK 0x00
+#define SND_BELL 0x01
+#define SND_TONE 0x02
+#define SND_MAX 0x07
+#define SND_CNT (SND_MAX + 1)
+
+#endif
diff --git a/src/devices/virtio_list.h b/src/devices/virtio_list.h
new file mode 100644
index 0000000..ed7663c
--- /dev/null
+++ b/src/devices/virtio_list.h
@@ -0,0 +1,84 @@
+#pragma once
+
+#include <stddef.h>
+
+#define container_of(ptr, type, member) \
+    ((type *) ((void *) ptr - offsetof(type, member)))
+
+#define list_entry(ptr, type, member) container_of(ptr, type, member)
+
+#define list_first_entry(ptr, type, member) \
+    list_entry((ptr)->next, type, member)
+
+#define list_prev_entry(pos, member) \
+    list_entry((pos)->member.prev, typeof(*(pos)), member)
+
+#define list_next_entry(pos, member) \
+    list_entry((pos)->member.next, typeof(*(pos)), member)
+
+#define list_entry_is_head(pos, head, member) (&pos->member == (head))
+
+#define list_for_each(pos, head) \
+    for ((pos) = (head)->next; (pos) != (head); (pos) = (pos)->next)
+
+#define list_for_each_safe(pos, _next, head)                       \
+    for (pos = (head)->next, _next = (pos)->next; (pos) != (head); \
+         (pos) = _next, _next = (pos)->next)
+
+#define list_for_each_entry(pos, head, member)                   \
+    for (pos = list_first_entry(head, __typeof__(*pos), member); \
+         &pos->member != (head); pos = list_next_entry(pos, member))
+
+#define LIST_HEAD_INIT(name)             \
+    {                                    \
+        .prev = (&name), .next = (&name) \
+    }
+
+#define LIST_HEAD(name) struct list_head name = LIST_HEAD_INIT(name)
+
+struct list_head {
+    struct list_head *next, *prev;
+};
+
+static inline void INIT_LIST_HEAD(struct list_head *list)
+{
+    list->prev = list;
+    list->next = list;
+}
+
+static inline int list_empty(const struct list_head *head)
+{
+    return head->next == head;
+}
+
+static int list_is_last(const struct list_head *list,
+                        const struct list_head *head)
+{
+    return list->next == head;
+}
+
+static inline void list_add(struct list_head *new, struct list_head *list)
+{
+    new->prev = list->prev;
+    new->next = list;
+    list->prev->next = new;
+    list->prev = new;
+}
+
+static inline void list_del(struct list_head *list)
+{
+    list->next->prev = list->prev;
+    list->prev->next = list->next;
+}
+
+static void list_del_init(struct list_head *entry)
+{
+    list_del(entry);
+    INIT_LIST_HEAD(entry);
+}
+
+static inline void list_move(struct list_head *list, struct list_head *new_head)
+{
+    list_del(list);
+    list_add(new_head, list);
+}
diff --git a/src/devices/virtio_window.c b/src/devices/virtio_window.c
new file mode 100644
index 0000000..33a93eb
--- /dev/null
+++ b/src/devices/virtio_window.c
@@ -0,0 +1,328 @@
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#include <SDL.h>
+#include <SDL_thread.h>
+
+#include "device.h"
+#include "input-event-codes.h"
+#include "virtio.h"
+#include "window.h"
+
+#define SDL_COND_TIMEOUT 1 /* ms */
+
+#define DEF_KEY_MAP(_sdl_key, _linux_key)            \
+    {                                                \
+        .sdl_key = _sdl_key, .linux_key = _linux_key \
+    }
+
+struct key_map_entry {
+    int sdl_key;
+    int linux_key;
+};
+
+struct key_map_entry key_map[] = {
+    /* Mouse */
+    DEF_KEY_MAP(SDL_BUTTON_LEFT, BTN_LEFT),
+    DEF_KEY_MAP(SDL_BUTTON_RIGHT, BTN_RIGHT),
+    DEF_KEY_MAP(SDL_BUTTON_MIDDLE, BTN_MIDDLE),
+    /* Keyboard */
+    DEF_KEY_MAP(SDLK_ESCAPE, KEY_ESC),
+    DEF_KEY_MAP(SDLK_1, KEY_1),
+    DEF_KEY_MAP(SDLK_2, KEY_2),
+    DEF_KEY_MAP(SDLK_3, KEY_3),
+    DEF_KEY_MAP(SDLK_4, KEY_4),
+    DEF_KEY_MAP(SDLK_5, KEY_5),
+    DEF_KEY_MAP(SDLK_6, KEY_6),
+    DEF_KEY_MAP(SDLK_7, KEY_7),
+    DEF_KEY_MAP(SDLK_8, KEY_8),
+    DEF_KEY_MAP(SDLK_9, KEY_9),
+    DEF_KEY_MAP(SDLK_0, KEY_0),
+    DEF_KEY_MAP(SDLK_MINUS, KEY_MINUS),
+    DEF_KEY_MAP(SDLK_EQUALS, KEY_EQUAL),
+    DEF_KEY_MAP(SDLK_BACKSPACE, KEY_BACKSPACE),
+    DEF_KEY_MAP(SDLK_TAB, KEY_TAB),
+    DEF_KEY_MAP(SDLK_q, KEY_Q),
+    DEF_KEY_MAP(SDLK_w, KEY_W),
+    DEF_KEY_MAP(SDLK_e, KEY_E),
+    DEF_KEY_MAP(SDLK_r, KEY_R),
+    DEF_KEY_MAP(SDLK_t, KEY_T),
+    DEF_KEY_MAP(SDLK_y, KEY_Y),
+    DEF_KEY_MAP(SDLK_u, KEY_U),
+    DEF_KEY_MAP(SDLK_i, KEY_I),
+    DEF_KEY_MAP(SDLK_o, KEY_O),
+    DEF_KEY_MAP(SDLK_p, KEY_P),
+    DEF_KEY_MAP(SDLK_LEFTBRACKET, KEY_LEFTBRACE),
+    DEF_KEY_MAP(SDLK_RIGHTBRACKET, KEY_RIGHTBRACE),
+    DEF_KEY_MAP(SDLK_RETURN, KEY_ENTER),
+    DEF_KEY_MAP(SDLK_LCTRL, KEY_LEFTCTRL),
+    DEF_KEY_MAP(SDLK_a, KEY_A),
+    DEF_KEY_MAP(SDLK_s, KEY_S),
+    DEF_KEY_MAP(SDLK_d, KEY_D),
+    DEF_KEY_MAP(SDLK_f, KEY_F),
+    DEF_KEY_MAP(SDLK_g, KEY_G),
+    DEF_KEY_MAP(SDLK_h, KEY_H),
+    DEF_KEY_MAP(SDLK_j, KEY_J),
+    DEF_KEY_MAP(SDLK_k, KEY_K),
+    DEF_KEY_MAP(SDLK_l, KEY_L),
+    DEF_KEY_MAP(SDLK_SEMICOLON, KEY_SEMICOLON),
+    DEF_KEY_MAP(SDLK_BACKQUOTE, KEY_GRAVE),
+    DEF_KEY_MAP(SDLK_LSHIFT, KEY_LEFTSHIFT),
+    DEF_KEY_MAP(SDLK_BACKSLASH, KEY_BACKSLASH),
+    DEF_KEY_MAP(SDLK_z, KEY_Z),
+    DEF_KEY_MAP(SDLK_x, KEY_X),
+    DEF_KEY_MAP(SDLK_c, KEY_C),
+    DEF_KEY_MAP(SDLK_v, KEY_V),
+    DEF_KEY_MAP(SDLK_b, KEY_B),
+    DEF_KEY_MAP(SDLK_n, KEY_N),
+    DEF_KEY_MAP(SDLK_m, KEY_M),
+    DEF_KEY_MAP(SDLK_COMMA, KEY_COMMA),
+    DEF_KEY_MAP(SDLK_PERIOD, KEY_DOT),
+    DEF_KEY_MAP(SDLK_SLASH, KEY_SLASH),
+    DEF_KEY_MAP(SDLK_RSHIFT, KEY_RIGHTSHIFT),
+    DEF_KEY_MAP(SDLK_LALT, KEY_LEFTALT),
+    DEF_KEY_MAP(SDLK_SPACE, KEY_SPACE),
+    DEF_KEY_MAP(SDLK_CAPSLOCK, KEY_CAPSLOCK),
+    DEF_KEY_MAP(SDLK_F1, KEY_F1),
+    DEF_KEY_MAP(SDLK_F2, KEY_F2),
+    DEF_KEY_MAP(SDLK_F3, KEY_F3),
+    DEF_KEY_MAP(SDLK_F4, KEY_F4),
+    DEF_KEY_MAP(SDLK_F5, KEY_F5),
+    DEF_KEY_MAP(SDLK_F6, KEY_F6),
+    DEF_KEY_MAP(SDLK_F7, KEY_F7),
+    DEF_KEY_MAP(SDLK_F7, KEY_F8),
+    DEF_KEY_MAP(SDLK_F9, KEY_F9),
+    DEF_KEY_MAP(SDLK_F10, KEY_F10),
+    DEF_KEY_MAP(SDLK_SCROLLLOCK, KEY_SCROLLLOCK),
+    DEF_KEY_MAP(SDLK_KP_7, KEY_KP7),
+    DEF_KEY_MAP(SDLK_KP_8, KEY_KP8),
+    DEF_KEY_MAP(SDLK_KP_9, KEY_KP9),
+    DEF_KEY_MAP(SDLK_KP_MINUS, KEY_KPMINUS),
+    DEF_KEY_MAP(SDLK_KP_4, KEY_KP4),
+    DEF_KEY_MAP(SDLK_KP_5, KEY_KP5),
+    DEF_KEY_MAP(SDLK_KP_6, KEY_KP6),
+    DEF_KEY_MAP(SDLK_KP_PLUS, KEY_KPPLUS),
+    DEF_KEY_MAP(SDLK_KP_1, KEY_KP1),
+    DEF_KEY_MAP(SDLK_KP_2, KEY_KP2),
+    DEF_KEY_MAP(SDLK_KP_3, KEY_KP3),
+    DEF_KEY_MAP(SDLK_KP_0, KEY_KP0),
+    DEF_KEY_MAP(SDLK_KP_PERIOD, KEY_KPDOT),
+    DEF_KEY_MAP(SDLK_F11, KEY_F11),
+    DEF_KEY_MAP(SDLK_F12, KEY_F12),
+    DEF_KEY_MAP(SDLK_KP_ENTER, KEY_KPENTER),
+    DEF_KEY_MAP(SDLK_RCTRL, KEY_RIGHTCTRL),
+    DEF_KEY_MAP(SDLK_RALT, KEY_RIGHTALT),
+    DEF_KEY_MAP(SDLK_HOME, KEY_HOME),
+    DEF_KEY_MAP(SDLK_UP, KEY_UP),
+    DEF_KEY_MAP(SDLK_PAGEUP, KEY_PAGEUP),
+    DEF_KEY_MAP(SDLK_LEFT, KEY_LEFT),
+    DEF_KEY_MAP(SDLK_RIGHT, KEY_RIGHT),
+    DEF_KEY_MAP(SDLK_END, KEY_END),
+    DEF_KEY_MAP(SDLK_DOWN, KEY_DOWN),
+    DEF_KEY_MAP(SDLK_PAGEDOWN, KEY_PAGEDOWN),
+    DEF_KEY_MAP(SDLK_INSERT, KEY_INSERT),
+    DEF_KEY_MAP(SDLK_DELETE, KEY_DELETE),
+};
+
+struct display_info {
+    struct gpu_resource resource;
+    uint32_t sdl_format;
+    SDL_mutex *img_mtx;
+    SDL_cond *img_cond;
+    SDL_Thread *win_thread;
+    SDL_Thread *ev_thread;
+    SDL_Window *window;
+    SDL_Renderer *renderer;
+    SDL_Surface *surface;
+    SDL_Texture *texture;
+};
+
+static struct display_info displays[VIRTIO_GPU_MAX_SCANOUTS];
+static int display_cnt;
+
+void window_add(uint32_t width, uint32_t height)
+{
+    displays[display_cnt].resource.width = width;
+    displays[display_cnt].resource.height = height;
+    display_cnt++;
+}
+
+static int sdl_key_to_linux_key(int sdl_key)
+{
+    unsigned long key_cnt = sizeof(key_map) / sizeof(struct key_map_entry);
+    for (unsigned long i = 0; i < key_cnt; i++)
+        if (sdl_key == key_map[i].sdl_key)
+            return key_map[i].linux_key;
+
+    return -1;
+}
+
+static int event_thread(void *data)
+{
+    int linux_key;
+
+    while (1) {
+        SDL_Event e;
+        if (SDL_PollEvent(&e)) {
+            switch (e.type) {
+            case SDL_QUIT: {
+                exit(0);
+            }
+            case SDL_KEYDOWN: {
+                linux_key = sdl_key_to_linux_key(e.key.keysym.sym);
+                virtio_input_update_key(linux_key, 1);
+                break;
+            }
+            case SDL_KEYUP: {
+                linux_key = sdl_key_to_linux_key(e.key.keysym.sym);
+                virtio_input_update_key(linux_key, 0);
+                break;
+            }
+            case SDL_MOUSEBUTTONDOWN: {
+                linux_key = sdl_key_to_linux_key(e.button.button);
+                virtio_input_update_mouse_button_state(linux_key, true);
+                break;
+            }
+            case SDL_MOUSEBUTTONUP: {
+                linux_key = sdl_key_to_linux_key(e.button.button);
+                virtio_input_update_mouse_button_state(linux_key, false);
+                break;
+            }
+            case SDL_MOUSEMOTION: {
+                virtio_input_update_cursor(e.motion.x, e.motion.y);
+                break;
+            }
+            }
+        }
+    }
+}
+
+static int window_thread(void *data)
+{
+    struct display_info *display = (struct display_info *) data;
+    struct gpu_resource *resource = &display->resource;
+
+    /* Create SDL window */
+    display->window = SDL_CreateWindow("semu", SDL_WINDOWPOS_UNDEFINED,
+                                       SDL_WINDOWPOS_UNDEFINED, resource->width,
+                                       resource->height, SDL_WINDOW_SHOWN);
+
+    if (!display->window) {
+        fprintf(stderr, "%s(): failed to create window\n", __func__);
+        exit(2);
+    }
+
+    /* Create SDL render */
+    display->renderer =
+        SDL_CreateRenderer(display->window, -1, SDL_RENDERER_ACCELERATED);
+
+    if (!display->renderer) {
+        fprintf(stderr, "%s(): failed to create renderer\n", __func__);
+        exit(2);
+    }
+
+    /* Render the whole screen with black color */
+    SDL_SetRenderDrawColor(display->renderer, 0, 0, 0, 255);
+    SDL_RenderClear(display->renderer);
+    SDL_RenderPresent(display->renderer);
+
+    /* Create event handling thread */
+    ((struct display_info *) data)->ev_thread =
+        SDL_CreateThread(event_thread, NULL, data);
+
+    while (1) {
+        SDL_LockMutex(display->img_mtx);
+
+        /* Wait until the image is arrived */
+        while (SDL_CondWaitTimeout(display->img_cond, display->img_mtx,
+                                   SDL_COND_TIMEOUT))
+            ;
+
+        /* Render image */
+        display->surface = SDL_CreateRGBSurfaceWithFormatFrom(
+            resource->image, resource->width, resource->height,
+            resource->bits_per_pixel, resource->stride, display->sdl_format);
+        display->texture =
+            SDL_CreateTextureFromSurface(display->renderer, display->surface);
+        SDL_RenderCopy(display->renderer, display->texture, NULL, NULL);
+        SDL_RenderPresent(display->renderer);
+        SDL_DestroyTexture(display->texture);
+
+        SDL_UnlockMutex(display->img_mtx);
+    }
+}
+
+void window_init(void)
+{
+    if (SDL_Init(SDL_INIT_VIDEO) < 0) {
+        fprintf(stderr, "%s(): failed to initialize SDL\n", __func__);
+        exit(2);
+    }
+
+    for (int i = 0; i < display_cnt; i++) {
+        displays[i].img_mtx = SDL_CreateMutex();
+        displays[i].img_cond = SDL_CreateCond();
+
+        displays[i].win_thread =
+            SDL_CreateThread(window_thread, NULL, (void *) &displays[i]);
+        SDL_DetachThread(displays[i].win_thread);
+    }
+}
+
+void window_lock(uint32_t id)
+{
+    SDL_LockMutex(displays[id].img_mtx);
+}
+
+void window_unlock(uint32_t id)
+{
+    SDL_UnlockMutex(displays[id].img_mtx);
+}
+
+static bool virtio_gpu_to_sdl_format(uint32_t virtio_gpu_format,
+                                     uint32_t *sdl_format)
+{
+    switch (virtio_gpu_format) {
+    case VIRTIO_GPU_FORMAT_B8G8R8A8_UNORM:
+        *sdl_format = SDL_PIXELFORMAT_ARGB8888;
+        return true;
+    case VIRTIO_GPU_FORMAT_B8G8R8X8_UNORM:
+        *sdl_format = SDL_PIXELFORMAT_XRGB8888;
+        return true;
+    case VIRTIO_GPU_FORMAT_A8R8G8B8_UNORM:
+        *sdl_format = SDL_PIXELFORMAT_BGRA8888;
+        return true;
+    case VIRTIO_GPU_FORMAT_X8R8G8B8_UNORM:
+        *sdl_format = SDL_PIXELFORMAT_BGRX8888;
+        return true;
+    case VIRTIO_GPU_FORMAT_R8G8B8A8_UNORM:
+        *sdl_format = SDL_PIXELFORMAT_ABGR8888;
+        return true;
+    case VIRTIO_GPU_FORMAT_X8B8G8R8_UNORM:
+        *sdl_format = SDL_PIXELFORMAT_RGBX8888;
+        return true;
+    case VIRTIO_GPU_FORMAT_A8B8G8R8_UNORM:
+        *sdl_format = SDL_PIXELFORMAT_RGBA8888;
+        return true;
+    case VIRTIO_GPU_FORMAT_R8G8B8X8_UNORM:
+        *sdl_format = SDL_PIXELFORMAT_XBGR8888;
+        return true;
+    default:
+        return false;
+    }
+}
+
+void window_render(struct gpu_resource *resource)
+{
+    int id = resource->scanout_id;
+
+    /* Resource update */
+    memcpy(&displays[id].resource, resource, sizeof(struct gpu_resource));
+    bool legal_format =
+        virtio_gpu_to_sdl_format(resource->format, &displays[id].sdl_format);
+
+    if (legal_format)
+        SDL_CondSignal(displays[id].img_cond);
+}
diff --git a/src/devices/virtio_window.h b/src/devices/virtio_window.h
new file mode 100644
index 0000000..c2c53f7
--- /dev/null
+++ b/src/devices/virtio_window.h
@@ -0,0 +1,20 @@
+#pragma once
+
+#if SEMU_HAS(VIRTIOGPU)
+/* Public interface to the vgpu_resource_2d structure */
+struct gpu_resource {
+    uint32_t scanout_id;
+    uint32_t format;
+    uint32_t width;
+    uint32_t height;
+    uint32_t stride;
+    uint32_t bits_per_pixel;
+    uint32_t *image;
+};
+
+void window_init(void);
+void window_add(uint32_t width, uint32_t height);
+void window_render(struct gpu_resource *resource);
+void window_lock(uint32_t id);
+void window_unlock(uint32_t id);
+#endif
diff --git a/src/main.c b/src/main.c
index 7cbe407..8e5e681 100644
--- a/src/main.c
+++ b/src/main.c
@@ -39,6 +39,7 @@ along with this program.  If not, see <https://www.gnu.org/licenses/>.
 #include "devices/eth-oc.h"
 #include "devices/rtl8169.h"
 #include "devices/i2c-oc.h"
+#include "devices/shm.h"
 
 #include <stdio.h>
 #include <inttypes.h>
@@ -74,33 +75,42 @@ static void print_help(void)
            "\n"
            "Usage: rvvm [bootrom] [-m 256M] [-k kernel] [-i drive.img] ...\n"
            "\n"
-           "    [bootrom]        Machine bootrom (OpenSBI, BBL, etc)\n"
-           "    -m, -mem 1G      Memory amount, default: 256M\n"
-           "    -s, -smp 4       Cores count, default: 1\n"
+           "    [bootrom]             Machine bootrom (OpenSBI, BBL, etc)\n"
+           "    -bootrom ...          Same as [bootrom]\n"
+           "    -bios ...             Same as [bootrom]\n"
+           "    -m, -mem 1G           Memory amount, default: 256M\n"
+           "    -s, -smp 4            Cores count, default: 1\n"
 #ifdef USE_RV64
-           "    -rv32            Enable 32-bit RISC-V, 64-bit by default\n"
+           "    -rv32                 Enable 32-bit RISC-V, 64-bit by default\n"
 #endif
-           "    -k, -kernel ...  Load S-mode kernel payload (Linux, U-Boot, etc)\n"
-           "    -i, -image  ...  Attach NVMe storage image (For compatibility reasons)\n"
-           "    -cmdline    ...  Override default kernel command line\n"
-           "    -append     ...  Modify kernel command line\n"
-           "    -nvme       ...  Explicitly attach storage image as NVMe device\n"
-           "    -ata        ...  Explicitly attach storage image as ATA (IDE) device\n"
-           "    -serial     ...  Add more serial ports\n"
+           "    -k, -kernel ...       Load S-mode kernel payload (Linux, U-Boot, etc)\n"
+           "    -i, -image ...        Attach NVMe storage image (For compatibility reasons)\n"
+           "    -cmdline ...          Override default kernel command line\n"
+           "    -append ...           Modify kernel command line\n"
+           "    -nvme ...             Explicitly attach storage image as NVMe device\n"
+           "    -ata ...              Explicitly attach storage image as ATA (IDE) device\n"
+           "    -serial ...           Add more serial ports\n"
 #ifdef USE_FB
-           "    -res 1280x720    Change framebuffer resoulution\n"
-           "    -nogui           Disable framebuffer GUI\n"
+           "    -res 1280x720         Change framebuffer resoulution\n"
+           "    -nogui                Disable framebuffer GUI\n"
 #endif
-           "    -dtb ...         Pass custom DTB to the machine\n"
+#ifdef USE_NET
+           "    -nonet                Disable network access\n"
+#endif
+           "    -dtb ...              Pass custom DTB to the machine\n"
 #ifdef USE_FDT
-           "    -dumpdtb ...     Dump autogenerated DTB to file\n"
+           "    -dumpdtb ...          Dump autogenerated DTB to file\n"
 #endif
 #ifdef USE_JIT
-           "    -jitcache 16M    Per-core JIT cache size\n"
-           "    -nojit           Disable RVJIT\n"
+           "    -jitcache 16M         Per-core JIT cache size\n"
+           "    -nojit                Disable RVJIT\n"
 #endif
-           "    -v, -verbose     Enable verbose logging\n"
-           "    -h, -help        Show this help message\n"
+           "    -shm_data path        Expose <path> to guest as a non-executable read-only file\n"
+           "    -shm_exe path         Expose <path> to guest as an executable read-only file\n"
+           "    -shm_id name          Specify a guest id </dev/rvvm_shm/name> with 'name' as <name>\n"
+           "                          Must come after -shm_data or -shm_exe"
+           "    -v, -verbose          Enable verbose logging\n"
+           "    -h, -help             Show this help message\n"
 #if defined(_WIN32) && !defined(UNDER_CE)
            "\n";
     WriteConsoleW(GetStdHandle(STD_OUTPUT_HANDLE), help, wcslen(help), NULL, NULL);
@@ -162,6 +172,10 @@ static bool rvvm_cli_configure(rvvm_machine_t* machine, int argc, const char** a
     if (rvvm_getarg("k") && !rvvm_load_kernel(machine, rvvm_getarg("k"))) return false;
     if (rvvm_getarg("kernel") && !rvvm_load_kernel(machine, rvvm_getarg("kernel"))) return false;
     if (rvvm_getarg("dtb") && !rvvm_load_dtb(machine, rvvm_getarg("dtb"))) return false;
+    
+    const char * shm_data_path = NULL;
+    const char * shm_exe_path = NULL;
+    const char * shm_id = NULL;
 
     for (int i=1; i<argc; i+=arg_size) {
         arg_size = get_arg(argv + i, &arg_name, &arg_val);
@@ -196,6 +210,44 @@ static bool rvvm_cli_configure(rvvm_machine_t* machine, int argc, const char** a
         } else if (cmp_arg(arg_name, "vfio_pci")) {
             if (!pci_vfio_init_auto(machine, arg_val)) return false;
         }
+        else if (cmp_arg(arg_name, "shm_id")) {
+        	if (shm_data_path == NULL && shm_exe_path == NULL) {
+        		rvvm_error("Please insert any shm_ argument except shm_id, before this shm_id argument");
+        		return false;
+        	}
+        	shm_id = arg_val;
+            if (shm_exe_path == NULL ? !shm_init_data(machine, shm_data_path, shm_id) : !shm_init_exe(machine, shm_exe_path, shm_id)) {
+                rvvm_error("Failed to attach shm path \"%s\" with guest name /dev/rvvm_shm/%s", shm_exe_path == NULL ? shm_data_path : shm_exe_path, shm_id);
+                return false;
+            }
+            shm_data_path = NULL;
+            shm_exe_path = NULL;
+            shm_id = NULL;
+        }
+        else if (cmp_arg(arg_name, "shm_data")) {
+        	if (shm_data_path != NULL) {
+        		rvvm_error("A seperator -shm_id was not encountered between the last -shm_data argument and this shm_data argument");
+        		return false;
+        	}
+        	else if (shm_exe_path != NULL) {
+        		rvvm_error("A seperator -shm_id was not encountered between the last -shm_exe argument and this shm_data argument");
+        		return false;
+        	}
+            shm_data_path = arg_val;
+            shm_exe_path = NULL;
+        }
+        else if (cmp_arg(arg_name, "shm_exe")) {
+        	if (shm_data_path != NULL) {
+        		rvvm_error("A seperator -shm_id was not encountered between the last -shm_data argument and this shm_exe argument");
+        		return false;
+        	}
+        	else if (shm_exe_path != NULL) {
+        		rvvm_error("A seperator -shm_id was not encountered between the last -shm_exe argument and this shm_exe argument");
+        		return false;
+        	}
+            shm_data_path = NULL;
+            shm_exe_path = arg_val;
+        }
     }
     if (rvvm_getarg("dumpdtb")) rvvm_dump_dtb(machine, rvvm_getarg("dumpdtb"));
     return true;
