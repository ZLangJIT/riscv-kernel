From 71a0984df9cb2d69a7f153f6c73e20d58f49a70a Mon Sep 17 00:00:00 2001
From: root <root@localhost.localdomain>
Date: Sun, 22 Sep 2024 15:11:42 +0000
Subject: [PATCH 1/1] c

---
 app/build.gradle                              |    6 +-
 .../kernel}/ExampleInstrumentedTest.kt        |    4 +-
 app/src/main/AndroidManifest.xml              |    2 +-
 app/src/main/CMakeLists.txt                   |    5 +-
 app/src/main/assets/uboot                     |  Bin 0 -> 2835064 bytes
 .../main/java/alpine/term/ExtraKeysView.java  |    2 +-
 .../main/java/alpine/term/HelpActivity.java   |    2 +-
 .../java/alpine/term/TerminalActivity.java    |    2 +-
 .../java/alpine/term/TerminalController.java  |    2 +-
 .../term/TerminalControllerService.java       |    2 +-
 .../java/alpine/term/TerminalService.java     |    2 +-
 .../term/terminal_view/TerminalView.java      |    4 +-
 .../java/libengine/AppInstanceAndroidBase.cpp |   70 +
 .../java/libengine/AppInstanceAndroidBase.h   |   27 +
 app/src/main/java/libengine/CMakeLists.txt    |   41 +
 .../java/libengine/DiligentLog/CMakeLists.txt |  332 ++
 app/src/main/java/libengine/DiligentLog/Log.h |   71 +
 .../Platforms/Android/CMakeLists.txt          |   46 +
 .../Android/interface/AndroidDebug.hpp        |   43 +
 .../Android/interface/AndroidFileSystem.hpp   |   99 +
 .../Android/interface/AndroidNativeWindow.h   |   39 +
 .../interface/AndroidPlatformDefinitions.h    |   40 +
 .../Android/interface/AndroidPlatformMisc.hpp |   36 +
 .../Platforms/Android/src/AndroidDebug.cpp    |   62 +
 .../Android/src/AndroidFileSystem.cpp         |  359 ++
 .../Platforms/Apple/CMakeLists.txt            |   73 +
 .../Platforms/Apple/interface/AppleDebug.hpp  |   43 +
 .../Apple/interface/AppleFileSystem.hpp       |   53 +
 .../interface/ApplePlatformDefinitions.h      |   44 +
 .../Apple/interface/ApplePlatformMisc.hpp     |   36 +
 .../Apple/interface/CFObjectWrapper.hpp       |   53 +
 .../Apple/interface/IOSNativeWindow.h         |   48 +
 .../Apple/interface/MacOSNativeWindow.h       |   48 +
 .../Apple/interface/TVOSNativeWindow.h        |   47 +
 .../Platforms/Apple/src/AppleDebug.mm         |   59 +
 .../Platforms/Apple/src/AppleFileSystem.cpp   |  150 +
 .../Platforms/Basic/CMakeLists.txt            |   52 +
 .../Basic/interface/BasicAtomics.hpp          |   69 +
 .../Basic/interface/BasicFileSystem.hpp       |  108 +
 .../Basic/interface/BasicPlatformDebug.hpp    |   46 +
 .../Basic/interface/BasicPlatformMisc.hpp     |   69 +
 .../Basic/interface/DebugUtilities.hpp        |  108 +
 .../Basic/interface/StandardFile.hpp          |   55 +
 .../Platforms/Basic/src/BasicFileSystem.cpp   |  143 +
 .../Basic/src/BasicPlatformDebug.cpp          |   75 +
 .../Platforms/Basic/src/StandardFile.cpp      |  123 +
 .../DiligentLog/Platforms/CMakeLists.txt      |   40 +
 .../Platforms/Linux/CMakeLists.txt            |   44 +
 .../Platforms/Linux/interface/LinuxDebug.hpp  |   43 +
 .../Linux/interface/LinuxFileSystem.hpp       |   53 +
 .../Linux/interface/LinuxNativeWindow.h       |   42 +
 .../interface/LinuxPlatformDefinitions.h      |   44 +
 .../Linux/interface/LinuxPlatformMisc.hpp     |  102 +
 .../Platforms/Linux/src/LinuxDebug.cpp        |   61 +
 .../Platforms/Linux/src/LinuxFileSystem.cpp   |   89 +
 .../DiligentLog/Platforms/UWP/CMakeLists.txt  |   46 +
 .../Platforms/UWP/interface/UWPDebug.hpp      |   43 +
 .../Platforms/UWP/interface/UWPDefinitions.h  |   30 +
 .../Platforms/UWP/interface/UWPFileSystem.hpp |   80 +
 .../Platforms/UWP/interface/UWPNativeWindow.h |   49 +
 .../Platforms/UWP/src/UWPDebug.cpp            |   89 +
 .../Platforms/UWP/src/UWPFileSystem.cpp       |  277 ++
 .../Platforms/Win32/CMakeLists.txt            |   47 +
 .../Win32/interface/Win32Atomics.hpp          |   55 +
 .../Platforms/Win32/interface/Win32Debug.hpp  |   43 +
 .../Win32/interface/Win32FileSystem.hpp       |  136 +
 .../Win32/interface/Win32NativeWindow.h       |   48 +
 .../interface/Win32PlatformDefinitions.h      |   30 +
 .../Win32/interface/Win32PlatformMisc.hpp     |  141 +
 .../Platforms/Win32/src/Win32Atomics.cpp      |   67 +
 .../Platforms/Win32/src/Win32Debug.cpp        |   91 +
 .../Platforms/Win32/src/Win32FileSystem.cpp   |  392 ++
 .../Platforms/interface/Atomics.hpp           |   43 +
 .../Platforms/interface/FileSystem.hpp        |   66 +
 .../Platforms/interface/NativeWindow.h        |   98 +
 .../Platforms/interface/PlatformDebug.hpp     |   54 +
 .../Platforms/interface/PlatformDefinitions.h |  100 +
 .../Platforms/interface/PlatformMisc.hpp      |   52 +
 .../DiligentLog/Primitives/CMakeLists.txt     |   49 +
 .../Primitives/interface/BasicTypes.h         |   69 +
 .../Primitives/interface/CommonDefinitions.h  |  107 +
 .../Primitives/interface/DataBlob.h           |   84 +
 .../Primitives/interface/DebugOutput.h        |   72 +
 .../interface/DefineGlobalFuncHelperMacros.h  |   41 +
 .../interface/DefineInterfaceHelperMacros.h   |   90 +
 .../Primitives/interface/Errors.hpp           |  165 +
 .../Primitives/interface/FileStream.h         |   90 +
 .../Primitives/interface/FlagEnum.h           |   53 +
 .../Primitives/interface/FormatString.hpp     |  103 +
 .../Primitives/interface/InterfaceID.h        |   59 +
 .../Primitives/interface/MemoryAllocator.h    |   81 +
 .../DiligentLog/Primitives/interface/Object.h |  120 +
 .../Primitives/interface/ReferenceCounters.h  |  165 +
 .../interface/UndefGlobalFuncHelperMacros.h   |   28 +
 .../interface/UndefInterfaceHelperMacros.h    |   37 +
 .../Primitives/src/DebugOutput.cpp            |   40 +
 .../DiligentLog/Primitives/src/test.cpp       |   35 +
 .../java/libengine/DiligentLog/common.cpp     |   25 +
 app/src/main/java/libengine/JVM_MANAGER.cpp   |   45 +
 app/src/main/java/libengine/JVM_MANAGER.h     |   26 +
 .../RVVM/.github/ISSUE_TEMPLATE/bug_report.md |   39 +
 .../.github/ISSUE_TEMPLATE/feature_request.md |   25 +
 .../RVVM/.github/codeql/codeql-config.yml     |   19 +
 .../RVVM/.github/workflows/build.yml          |   73 +
 .../RVVM/.github/workflows/codeql.yml         |   41 +
 app/src/main/java/libengine/RVVM/.gitignore   |   39 +
 .../main/java/libengine/RVVM/.gitlab-ci.yml   |  290 ++
 .../main/java/libengine/RVVM/CMakeLists.txt   |  298 ++
 app/src/main/java/libengine/RVVM/LICENSE-GPL  |  674 +++
 app/src/main/java/libengine/RVVM/LICENSE-MPL  |  373 ++
 app/src/main/java/libengine/RVVM/Makefile     |  360 ++
 app/src/main/java/libengine/RVVM/README.md    |  142 +
 app/src/main/java/libengine/RVVM/boot.sh      |    7 +
 app/src/main/java/libengine/RVVM/make.sh      |    1 +
 app/src/main/java/libengine/RVVM/make_asan.sh |    1 +
 .../main/java/libengine/RVVM/make_release.sh  |    1 +
 .../main/java/libengine/RVVM/make_valgrind.sh |    1 +
 .../main/java/libengine/RVVM/src/atomics.h    |  877 ++++
 .../bindings/jni/lekkit/rvvm/Framebuffer.java |   48 +
 .../bindings/jni/lekkit/rvvm/GoldfishRTC.java |   16 +
 .../bindings/jni/lekkit/rvvm/HIDKeyboard.java |  242 +
 .../bindings/jni/lekkit/rvvm/HIDMouse.java    |   65 +
 .../src/bindings/jni/lekkit/rvvm/I2CBus.java  |   22 +
 .../bindings/jni/lekkit/rvvm/IGPIODevice.java |   18 +
 .../jni/lekkit/rvvm/IRemovableDevice.java     |   14 +
 .../bindings/jni/lekkit/rvvm/MMIOBase.java    |   27 +
 .../bindings/jni/lekkit/rvvm/MMIODevice.java  |   35 +
 .../bindings/jni/lekkit/rvvm/MTDFlash.java    |   16 +
 .../bindings/jni/lekkit/rvvm/NS16550A.java    |   16 +
 .../bindings/jni/lekkit/rvvm/NVMeDrive.java   |   16 +
 .../src/bindings/jni/lekkit/rvvm/PCIBus.java  |   22 +
 .../bindings/jni/lekkit/rvvm/PCIDevice.java   |   35 +
 .../src/bindings/jni/lekkit/rvvm/PLIC.java    |   22 +
 .../src/bindings/jni/lekkit/rvvm/RTL8169.java |   16 +
 .../bindings/jni/lekkit/rvvm/RVVMMachine.java |  155 +
 .../bindings/jni/lekkit/rvvm/RVVMNative.java  |  117 +
 .../bindings/jni/lekkit/rvvm/SiFiveGPIO.java  |   47 +
 .../src/bindings/jni/lekkit/rvvm/Syscon.java  |   16 +
 .../RVVM/src/bindings/jni/rvvm_jni.c          |  487 ++
 .../RVVM/src/bindings/jni/tiny-jni.h          |  717 +++
 .../RVVM/src/bindings/libretro/libretro.c     |  539 +++
 .../RVVM/src/bindings/libretro/libretro.h     | 3964 +++++++++++++++++
 .../src/bindings/libretro/rvvm_libretro.info  |   24 +
 .../main/java/libengine/RVVM/src/bit_ops.h    |  377 ++
 app/src/main/java/libengine/RVVM/src/blk_io.c |  468 ++
 app/src/main/java/libengine/RVVM/src/blk_io.h |  158 +
 .../main/java/libengine/RVVM/src/compiler.h   |  265 ++
 .../java/libengine/RVVM/src/cpu/fpu_lib.h     |  266 ++
 .../RVVM/src/cpu/riscv64_interpreter.c        |   26 +
 .../libengine/RVVM/src/cpu/riscv_atomics.h    |  214 +
 .../java/libengine/RVVM/src/cpu/riscv_base.h  |  968 ++++
 .../libengine/RVVM/src/cpu/riscv_compressed.h |  612 +++
 .../java/libengine/RVVM/src/cpu/riscv_fpu.h   |  673 +++
 .../RVVM/src/cpu/riscv_interpreter.c          |   19 +
 .../RVVM/src/cpu/riscv_interpreter.h          |  118 +
 .../java/libengine/RVVM/src/cpu/riscv_jit.h   |  408 ++
 .../java/libengine/RVVM/src/devices/ata.c     |  865 ++++
 .../java/libengine/RVVM/src/devices/ata.h     |   34 +
 .../java/libengine/RVVM/src/devices/chardev.h |   91 +
 .../libengine/RVVM/src/devices/chardev_term.c |  302 ++
 .../java/libengine/RVVM/src/devices/clint.c   |  168 +
 .../java/libengine/RVVM/src/devices/clint.h   |   29 +
 .../java/libengine/RVVM/src/devices/eth-oc.c  |  564 +++
 .../java/libengine/RVVM/src/devices/eth-oc.h  |   33 +
 .../libengine/RVVM/src/devices/framebuffer.c  |   83 +
 .../libengine/RVVM/src/devices/framebuffer.h  |   98 +
 .../libengine/RVVM/src/devices/gpio-sifive.c  |  331 ++
 .../libengine/RVVM/src/devices/gpio-sifive.h  |   34 +
 .../libengine/RVVM/src/devices/gpio_api.h     |   68 +
 .../libengine/RVVM/src/devices/gui_window.c   |  292 ++
 .../libengine/RVVM/src/devices/gui_window.h   |   65 +
 .../RVVM/src/devices/haiku_window.cpp         |  360 ++
 .../libengine/RVVM/src/devices/hid-keyboard.c |  204 +
 .../libengine/RVVM/src/devices/hid-mouse.c    |  315 ++
 .../java/libengine/RVVM/src/devices/hid_api.h |  289 ++
 .../java/libengine/RVVM/src/devices/hid_dev.h |   62 +
 .../java/libengine/RVVM/src/devices/i2c-hid.c |  425 ++
 .../java/libengine/RVVM/src/devices/i2c-hid.h |   27 +
 .../java/libengine/RVVM/src/devices/i2c-oc.c  |  276 ++
 .../java/libengine/RVVM/src/devices/i2c-oc.h  |   54 +
 .../libengine/RVVM/src/devices/mtd-physmap.c  |  106 +
 .../libengine/RVVM/src/devices/mtd-physmap.h  |   36 +
 .../libengine/RVVM/src/devices/ns16550a.c     |  258 ++
 .../libengine/RVVM/src/devices/ns16550a.h     |   34 +
 .../java/libengine/RVVM/src/devices/nvme.c    |  621 +++
 .../java/libengine/RVVM/src/devices/nvme.h    |   29 +
 .../java/libengine/RVVM/src/devices/pci-bus.c |  489 ++
 .../java/libengine/RVVM/src/devices/pci-bus.h |   84 +
 .../libengine/RVVM/src/devices/pci-vfio.c     |  435 ++
 .../libengine/RVVM/src/devices/pci-vfio.h     |   26 +
 .../java/libengine/RVVM/src/devices/plic.c    |  466 ++
 .../java/libengine/RVVM/src/devices/plic.h    |   43 +
 .../libengine/RVVM/src/devices/ps2-altera.c   |  143 +
 .../libengine/RVVM/src/devices/ps2-altera.h   |   30 +
 .../libengine/RVVM/src/devices/ps2-keyboard.c |  484 ++
 .../libengine/RVVM/src/devices/ps2-mouse.c    |  381 ++
 .../libengine/RVVM/src/devices/rtc-ds1742.c   |  120 +
 .../libengine/RVVM/src/devices/rtc-ds1742.h   |   30 +
 .../libengine/RVVM/src/devices/rtc-goldfish.c |  144 +
 .../libengine/RVVM/src/devices/rtc-goldfish.h |   32 +
 .../java/libengine/RVVM/src/devices/rtl8169.c |  530 +++
 .../java/libengine/RVVM/src/devices/rtl8169.h |   28 +
 .../libengine/RVVM/src/devices/sdl_window.c   |  666 +++
 .../java/libengine/RVVM/src/devices/syscon.c  |   86 +
 .../java/libengine/RVVM/src/devices/syscon.h  |   29 +
 .../java/libengine/RVVM/src/devices/tap_api.h |   60 +
 .../libengine/RVVM/src/devices/tap_linux.c    |  183 +
 .../libengine/RVVM/src/devices/tap_user.c     | 1158 +++++
 .../libengine/RVVM/src/devices/win32window.c  |  313 ++
 .../RVVM/src/devices/x11window_xlib.c         |  772 ++++
 app/src/main/java/libengine/RVVM/src/dlib.c   |  153 +
 app/src/main/java/libengine/RVVM/src/dlib.h   |   45 +
 .../main/java/libengine/RVVM/src/elf_load.c   |  151 +
 .../main/java/libengine/RVVM/src/elf_load.h   |   43 +
 app/src/main/java/libengine/RVVM/src/fdtlib.c |  375 ++
 app/src/main/java/libengine/RVVM/src/fdtlib.h |   91 +
 .../main/java/libengine/RVVM/src/fpu_ops.h    |   95 +
 app/src/main/java/libengine/RVVM/src/gd32.c   |  204 +
 .../main/java/libengine/RVVM/src/hashmap.c    |   98 +
 .../main/java/libengine/RVVM/src/hashmap.h    |  135 +
 app/src/main/java/libengine/RVVM/src/main.c   |  318 ++
 .../main/java/libengine/RVVM/src/mem_ops.h    |  298 ++
 .../main/java/libengine/RVVM/src/networking.c |  945 ++++
 .../main/java/libengine/RVVM/src/networking.h |  118 +
 .../main/java/libengine/RVVM/src/ringbuf.c    |  118 +
 .../main/java/libengine/RVVM/src/ringbuf.h    |   60 +
 app/src/main/java/libengine/RVVM/src/riscv.h  |    7 +
 .../main/java/libengine/RVVM/src/riscv_cpu.c  |  157 +
 .../main/java/libengine/RVVM/src/riscv_cpu.h  |   81 +
 .../main/java/libengine/RVVM/src/riscv_csr.c  |  698 +++
 .../main/java/libengine/RVVM/src/riscv_csr.h  |  348 ++
 .../main/java/libengine/RVVM/src/riscv_hart.c |  371 ++
 .../main/java/libengine/RVVM/src/riscv_hart.h |  106 +
 .../main/java/libengine/RVVM/src/riscv_mmu.c  |  716 +++
 .../main/java/libengine/RVVM/src/riscv_mmu.h  |  372 ++
 .../main/java/libengine/RVVM/src/riscv_priv.c |  238 +
 .../main/java/libengine/RVVM/src/riscv_priv.h |   27 +
 .../java/libengine/RVVM/src/rvjit/rvjit.c     |  297 ++
 .../java/libengine/RVVM/src/rvjit/rvjit.h     |  245 +
 .../java/libengine/RVVM/src/rvjit/rvjit_arm.h |  953 ++++
 .../libengine/RVVM/src/rvjit/rvjit_arm64.h    | 1358 ++++++
 .../libengine/RVVM/src/rvjit/rvjit_emit.c     |  925 ++++
 .../libengine/RVVM/src/rvjit/rvjit_emit.h     |  316 ++
 .../libengine/RVVM/src/rvjit/rvjit_riscv.h    | 1089 +++++
 .../java/libengine/RVVM/src/rvjit/rvjit_x86.h | 1868 ++++++++
 .../main/java/libengine/RVVM/src/rvtimer.c    |  297 ++
 .../main/java/libengine/RVVM/src/rvtimer.h    |  101 +
 app/src/main/java/libengine/RVVM/src/rvvm.c   |  915 ++++
 app/src/main/java/libengine/RVVM/src/rvvm.h   |  252 ++
 .../java/libengine/RVVM/src/rvvm_isolation.c  |  567 +++
 .../java/libengine/RVVM/src/rvvm_isolation.h  |   63 +
 .../main/java/libengine/RVVM/src/rvvm_types.h |   73 +
 .../main/java/libengine/RVVM/src/rvvm_user.c  | 1803 ++++++++
 .../main/java/libengine/RVVM/src/rvvm_user.h  |   25 +
 .../main/java/libengine/RVVM/src/rvvmlib.h    |  295 ++
 .../main/java/libengine/RVVM/src/spinlock.c   |  112 +
 .../main/java/libengine/RVVM/src/spinlock.h   |   96 +
 .../main/java/libengine/RVVM/src/stacktrace.c |  149 +
 .../main/java/libengine/RVVM/src/stacktrace.h |   24 +
 .../main/java/libengine/RVVM/src/threading.c  |  515 +++
 .../main/java/libengine/RVVM/src/threading.h  |   54 +
 app/src/main/java/libengine/RVVM/src/utils.c  |  440 ++
 app/src/main/java/libengine/RVVM/src/utils.h  |  152 +
 app/src/main/java/libengine/RVVM/src/vector.h |  109 +
 .../main/java/libengine/RVVM/src/vma_ops.c    |  403 ++
 .../main/java/libengine/RVVM/src/vma_ops.h    |   63 +
 app/src/main/java/libengine/native.cpp        |  206 +
 .../main/java/linux/kernel/MainActivity.kt    |  184 +
 .../pro => linux/kernel}/UpdatingTextView.kt  |    2 +-
 .../java/media/player/pro/MainActivity.kt     |  170 -
 .../EGLSurfaceView.java                       | 2426 ++++++++++
 .../EGLTextureView.java                       | 2406 ++++++++++
 .../graphical/tool/kit/Cleaner.java           |   39 +
 .../tool/kit/DiligentEngineView.java          |  189 +
 app/src/main/res/values/strings.xml           |    2 +-
 .../pro => linux/kernel}/ExampleUnitTest.kt   |    2 +-
 settings.gradle                               |    2 +-
 277 files changed, 59759 insertions(+), 189 deletions(-)
 rename app/src/androidTest/java/{media/player/pro => linux/kernel}/ExampleInstrumentedTest.kt (86%)
 create mode 100644 app/src/main/assets/uboot
 create mode 100644 app/src/main/java/libengine/AppInstanceAndroidBase.cpp
 create mode 100644 app/src/main/java/libengine/AppInstanceAndroidBase.h
 create mode 100644 app/src/main/java/libengine/CMakeLists.txt
 create mode 100644 app/src/main/java/libengine/DiligentLog/CMakeLists.txt
 create mode 100644 app/src/main/java/libengine/DiligentLog/Log.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Android/CMakeLists.txt
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Android/interface/AndroidDebug.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Android/interface/AndroidFileSystem.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Android/interface/AndroidNativeWindow.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Android/interface/AndroidPlatformDefinitions.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Android/interface/AndroidPlatformMisc.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Android/src/AndroidDebug.cpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Android/src/AndroidFileSystem.cpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Apple/CMakeLists.txt
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/AppleDebug.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/AppleFileSystem.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/ApplePlatformDefinitions.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/ApplePlatformMisc.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/CFObjectWrapper.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/IOSNativeWindow.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/MacOSNativeWindow.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/TVOSNativeWindow.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Apple/src/AppleDebug.mm
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Apple/src/AppleFileSystem.cpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Basic/CMakeLists.txt
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/BasicAtomics.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/BasicFileSystem.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/BasicPlatformDebug.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/BasicPlatformMisc.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/DebugUtilities.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/StandardFile.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Basic/src/BasicFileSystem.cpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Basic/src/BasicPlatformDebug.cpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Basic/src/StandardFile.cpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/CMakeLists.txt
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Linux/CMakeLists.txt
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Linux/interface/LinuxDebug.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Linux/interface/LinuxFileSystem.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Linux/interface/LinuxNativeWindow.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Linux/interface/LinuxPlatformDefinitions.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Linux/interface/LinuxPlatformMisc.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Linux/src/LinuxDebug.cpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Linux/src/LinuxFileSystem.cpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/UWP/CMakeLists.txt
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/UWP/interface/UWPDebug.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/UWP/interface/UWPDefinitions.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/UWP/interface/UWPFileSystem.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/UWP/interface/UWPNativeWindow.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/UWP/src/UWPDebug.cpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/UWP/src/UWPFileSystem.cpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Win32/CMakeLists.txt
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32Atomics.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32Debug.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32FileSystem.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32NativeWindow.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32PlatformDefinitions.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32PlatformMisc.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Win32/src/Win32Atomics.cpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Win32/src/Win32Debug.cpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Win32/src/Win32FileSystem.cpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/interface/Atomics.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/interface/FileSystem.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/interface/NativeWindow.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/interface/PlatformDebug.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/interface/PlatformDefinitions.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/interface/PlatformMisc.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Primitives/CMakeLists.txt
 create mode 100644 app/src/main/java/libengine/DiligentLog/Primitives/interface/BasicTypes.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Primitives/interface/CommonDefinitions.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Primitives/interface/DataBlob.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Primitives/interface/DebugOutput.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Primitives/interface/DefineGlobalFuncHelperMacros.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Primitives/interface/DefineInterfaceHelperMacros.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Primitives/interface/Errors.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Primitives/interface/FileStream.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Primitives/interface/FlagEnum.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Primitives/interface/FormatString.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Primitives/interface/InterfaceID.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Primitives/interface/MemoryAllocator.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Primitives/interface/Object.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Primitives/interface/ReferenceCounters.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Primitives/interface/UndefGlobalFuncHelperMacros.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Primitives/interface/UndefInterfaceHelperMacros.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Primitives/src/DebugOutput.cpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Primitives/src/test.cpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/common.cpp
 create mode 100644 app/src/main/java/libengine/JVM_MANAGER.cpp
 create mode 100644 app/src/main/java/libengine/JVM_MANAGER.h
 create mode 100644 app/src/main/java/libengine/RVVM/.github/ISSUE_TEMPLATE/bug_report.md
 create mode 100644 app/src/main/java/libengine/RVVM/.github/ISSUE_TEMPLATE/feature_request.md
 create mode 100644 app/src/main/java/libengine/RVVM/.github/codeql/codeql-config.yml
 create mode 100644 app/src/main/java/libengine/RVVM/.github/workflows/build.yml
 create mode 100644 app/src/main/java/libengine/RVVM/.github/workflows/codeql.yml
 create mode 100644 app/src/main/java/libengine/RVVM/.gitignore
 create mode 100644 app/src/main/java/libengine/RVVM/.gitlab-ci.yml
 create mode 100644 app/src/main/java/libengine/RVVM/CMakeLists.txt
 create mode 100644 app/src/main/java/libengine/RVVM/LICENSE-GPL
 create mode 100644 app/src/main/java/libengine/RVVM/LICENSE-MPL
 create mode 100644 app/src/main/java/libengine/RVVM/Makefile
 create mode 100644 app/src/main/java/libengine/RVVM/README.md
 create mode 100755 app/src/main/java/libengine/RVVM/boot.sh
 create mode 100755 app/src/main/java/libengine/RVVM/make.sh
 create mode 100755 app/src/main/java/libengine/RVVM/make_asan.sh
 create mode 100755 app/src/main/java/libengine/RVVM/make_release.sh
 create mode 100755 app/src/main/java/libengine/RVVM/make_valgrind.sh
 create mode 100644 app/src/main/java/libengine/RVVM/src/atomics.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/Framebuffer.java
 create mode 100644 app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/GoldfishRTC.java
 create mode 100644 app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/HIDKeyboard.java
 create mode 100644 app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/HIDMouse.java
 create mode 100644 app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/I2CBus.java
 create mode 100644 app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/IGPIODevice.java
 create mode 100644 app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/IRemovableDevice.java
 create mode 100644 app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/MMIOBase.java
 create mode 100644 app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/MMIODevice.java
 create mode 100644 app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/MTDFlash.java
 create mode 100644 app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/NS16550A.java
 create mode 100644 app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/NVMeDrive.java
 create mode 100644 app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/PCIBus.java
 create mode 100644 app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/PCIDevice.java
 create mode 100644 app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/PLIC.java
 create mode 100644 app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/RTL8169.java
 create mode 100644 app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/RVVMMachine.java
 create mode 100644 app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/RVVMNative.java
 create mode 100644 app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/SiFiveGPIO.java
 create mode 100644 app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/Syscon.java
 create mode 100644 app/src/main/java/libengine/RVVM/src/bindings/jni/rvvm_jni.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/bindings/jni/tiny-jni.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/bindings/libretro/libretro.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/bindings/libretro/libretro.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/bindings/libretro/rvvm_libretro.info
 create mode 100644 app/src/main/java/libengine/RVVM/src/bit_ops.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/blk_io.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/blk_io.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/compiler.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/cpu/fpu_lib.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/cpu/riscv64_interpreter.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/cpu/riscv_atomics.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/cpu/riscv_base.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/cpu/riscv_compressed.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/cpu/riscv_fpu.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/cpu/riscv_interpreter.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/cpu/riscv_interpreter.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/cpu/riscv_jit.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/ata.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/ata.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/chardev.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/chardev_term.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/clint.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/clint.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/eth-oc.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/eth-oc.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/framebuffer.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/framebuffer.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/gpio-sifive.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/gpio-sifive.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/gpio_api.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/gui_window.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/gui_window.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/haiku_window.cpp
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/hid-keyboard.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/hid-mouse.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/hid_api.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/hid_dev.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/i2c-hid.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/i2c-hid.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/i2c-oc.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/i2c-oc.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/mtd-physmap.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/mtd-physmap.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/ns16550a.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/ns16550a.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/nvme.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/nvme.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/pci-bus.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/pci-bus.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/pci-vfio.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/pci-vfio.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/plic.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/plic.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/ps2-altera.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/ps2-altera.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/ps2-keyboard.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/ps2-mouse.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/rtc-ds1742.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/rtc-ds1742.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/rtc-goldfish.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/rtc-goldfish.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/rtl8169.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/rtl8169.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/sdl_window.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/syscon.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/syscon.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/tap_api.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/tap_linux.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/tap_user.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/win32window.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/devices/x11window_xlib.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/dlib.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/dlib.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/elf_load.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/elf_load.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/fdtlib.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/fdtlib.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/fpu_ops.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/gd32.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/hashmap.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/hashmap.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/main.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/mem_ops.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/networking.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/networking.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/ringbuf.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/ringbuf.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/riscv.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/riscv_cpu.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/riscv_cpu.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/riscv_csr.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/riscv_csr.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/riscv_hart.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/riscv_hart.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/riscv_mmu.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/riscv_mmu.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/riscv_priv.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/riscv_priv.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/rvjit/rvjit.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/rvjit/rvjit.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/rvjit/rvjit_arm.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/rvjit/rvjit_arm64.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/rvjit/rvjit_emit.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/rvjit/rvjit_emit.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/rvjit/rvjit_riscv.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/rvjit/rvjit_x86.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/rvtimer.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/rvtimer.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/rvvm.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/rvvm.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/rvvm_isolation.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/rvvm_isolation.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/rvvm_types.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/rvvm_user.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/rvvm_user.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/rvvmlib.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/spinlock.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/spinlock.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/stacktrace.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/stacktrace.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/threading.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/threading.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/utils.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/utils.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/vector.h
 create mode 100644 app/src/main/java/libengine/RVVM/src/vma_ops.c
 create mode 100644 app/src/main/java/libengine/RVVM/src/vma_ops.h
 create mode 100644 app/src/main/java/libengine/native.cpp
 create mode 100644 app/src/main/java/linux/kernel/MainActivity.kt
 rename app/src/main/java/{media/player/pro => linux/kernel}/UpdatingTextView.kt (98%)
 delete mode 100644 app/src/main/java/media/player/pro/MainActivity.kt
 create mode 100644 app/src/main/java/smallville7123/EGLSurfaceView_EGLTextureView/EGLSurfaceView.java
 create mode 100644 app/src/main/java/smallville7123/EGLSurfaceView_EGLTextureView/EGLTextureView.java
 create mode 100644 app/src/main/java/smallville7123/graphical/tool/kit/Cleaner.java
 create mode 100644 app/src/main/java/smallville7123/graphical/tool/kit/DiligentEngineView.java
 rename app/src/test/java/{media/player/pro => linux/kernel}/ExampleUnitTest.kt (92%)

diff --git a/app/build.gradle b/app/build.gradle
index 8365cc7a..f022aa78 100755
--- a/app/build.gradle
+++ b/app/build.gradle
@@ -15,11 +15,11 @@ android { // main settings for your application
     }
 
     defaultConfig {
-        applicationId "media.player.pro"
+        applicationId "linux.kernel"
         minSdkVersion 26
         targetSdkVersion 29
-        versionCode 1
-        versionName "1.0"
+        versionCode 2
+        versionName "1.1"
 
         testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
 
diff --git a/app/src/androidTest/java/media/player/pro/ExampleInstrumentedTest.kt b/app/src/androidTest/java/linux/kernel/ExampleInstrumentedTest.kt
similarity index 86%
rename from app/src/androidTest/java/media/player/pro/ExampleInstrumentedTest.kt
rename to app/src/androidTest/java/linux/kernel/ExampleInstrumentedTest.kt
index d467abb6..9c5b658f 100644
--- a/app/src/androidTest/java/media/player/pro/ExampleInstrumentedTest.kt
+++ b/app/src/androidTest/java/linux/kernel/ExampleInstrumentedTest.kt
@@ -1,4 +1,4 @@
-package media.player.pro
+package linux.kernel
 
 import androidx.test.platform.app.InstrumentationRegistry
 import androidx.test.ext.junit.runners.AndroidJUnit4
@@ -19,6 +19,6 @@ class ExampleInstrumentedTest {
     fun useAppContext() {
         // Context of the app under test.
         val appContext = InstrumentationRegistry.getInstrumentation().targetContext
-        assertEquals("media.player.pro", appContext.packageName)
+        assertEquals("linux.kernel", appContext.packageName)
     }
 }
diff --git a/app/src/main/AndroidManifest.xml b/app/src/main/AndroidManifest.xml
index 6843690f..5180a236 100644
--- a/app/src/main/AndroidManifest.xml
+++ b/app/src/main/AndroidManifest.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="media.player.pro" >
+    package="linux.kernel" >
 
     <uses-feature android:name="android.hardware.touchscreen" android:required="false" />
 
diff --git a/app/src/main/CMakeLists.txt b/app/src/main/CMakeLists.txt
index 8e8e3779..9b980553 100644
--- a/app/src/main/CMakeLists.txt
+++ b/app/src/main/CMakeLists.txt
@@ -4,4 +4,7 @@ cmake_minimum_required(VERSION 3.4.1)
 add_subdirectory(java/alpine/term/jni)
 
 # AudioEngine
-add_subdirectory(java/libmedia)
\ No newline at end of file
+#add_subdirectory(java/libmedia)
+
+# EngineView
+add_subdirectory(java/libengine)
diff --git a/app/src/main/assets/uboot b/app/src/main/assets/uboot
new file mode 100644
index 0000000000000000000000000000000000000000..d37529a34df288e3112bb77ec9d4be474a08c547
GIT binary patch
literal 2835064
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
z0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZ
zfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&U
zAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C7
z2oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N
z0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+
z009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBly
zK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF
z5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk
z1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs
z0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZ
zfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&U
zAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C7
z2oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N
z0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+
z009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBly
zK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF
z5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk
z1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs
z0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZ
zfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&U
zAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C7
z2oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N
z0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+
z009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBly
zK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF
z5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk
z1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs
z0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZ
zfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&U
zAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C7
z2oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N
z0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+
z009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBly
zK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF
z5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk
z1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs
z0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZ
zfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&U
zAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C7
z2oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N
z0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+
z009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBly
zK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF
z5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk
z1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs
z0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZ
zfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&U
zAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C7
z2oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N
z0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+
z009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBly
zK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF
z5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk
z1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs
z0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZ
zfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&U
zAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C7
z2oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N
z0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+
z009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBly
zK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF
z5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk
z1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs
z0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZ
zfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&U
zAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C7
z2oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N
z0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+
z009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBly
zK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF
z5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk
z1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs
z0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZ
zfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&U
zAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C7
z2oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N
z0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+
z009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBly
zK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF
z5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk
z1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs
z0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZ
zfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&U
zAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C7
z2oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N
z0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+
z009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBly
zK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF
z5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk
z1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs
z0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZ
zfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&U
zAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C7
z2oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N
z0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+
z009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBly
zK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF
z5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk
z1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs
z0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZ
zfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&U
zAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C7
z2oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N
z0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+
z009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBly
zK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF
z5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk
z1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs
z0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZ
zfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&U
zAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C7
z2oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N
z0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+
z009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBly
zK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF
z5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk
z1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs
z0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZ
zfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&U
zAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C7
z2oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N
z0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+
z009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBly
zK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF
z5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk
z1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs
z0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZ
zfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&U
zAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C7
z2oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N
z0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+
z009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBly
zK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF
z5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk
z1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs
z0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZ
zfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&U
zAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C7
z2oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N
z0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+
z009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBly
zK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF
z5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk
z1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs
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

literal 0
HcmV?d00001

diff --git a/app/src/main/java/alpine/term/ExtraKeysView.java b/app/src/main/java/alpine/term/ExtraKeysView.java
index 4acd2731..66bda478 100644
--- a/app/src/main/java/alpine/term/ExtraKeysView.java
+++ b/app/src/main/java/alpine/term/ExtraKeysView.java
@@ -37,7 +37,7 @@ import android.widget.ToggleButton;
 import java.util.concurrent.ScheduledExecutorService;
 
 import alpine.term.terminal_view.TerminalView;
-import media.player.pro.R;
+import linux.kernel.R;
 
 /**
  * A view showing extra keys (such as Escape, Ctrl, Alt) not normally available on an Android soft
diff --git a/app/src/main/java/alpine/term/HelpActivity.java b/app/src/main/java/alpine/term/HelpActivity.java
index afe757ce..8409d9e0 100644
--- a/app/src/main/java/alpine/term/HelpActivity.java
+++ b/app/src/main/java/alpine/term/HelpActivity.java
@@ -30,7 +30,7 @@ import android.webkit.WebViewClient;
 import android.widget.ProgressBar;
 import android.widget.RelativeLayout;
 
-import media.player.pro.BuildConfig;
+import linux.kernel.BuildConfig;
 
 /**
  * Basic embedded browser for viewing help pages.
diff --git a/app/src/main/java/alpine/term/TerminalActivity.java b/app/src/main/java/alpine/term/TerminalActivity.java
index fb48b3cd..b95e611a 100644
--- a/app/src/main/java/alpine/term/TerminalActivity.java
+++ b/app/src/main/java/alpine/term/TerminalActivity.java
@@ -34,7 +34,7 @@ import android.widget.Button;
 import android.widget.RelativeLayout;
 import android.widget.TextView;
 
-import media.player.pro.R;
+import linux.kernel.R;
 
 /**
  * A terminal emulator activity.
diff --git a/app/src/main/java/alpine/term/TerminalController.java b/app/src/main/java/alpine/term/TerminalController.java
index 0c1b079e..3430621f 100644
--- a/app/src/main/java/alpine/term/TerminalController.java
+++ b/app/src/main/java/alpine/term/TerminalController.java
@@ -51,7 +51,7 @@ import alpine.term.emulator.TerminalColors;
 import alpine.term.emulator.TerminalSession;
 import alpine.term.emulator.TextStyle;
 import alpine.term.terminal_view.TerminalView;
-import media.player.pro.R;
+import linux.kernel.R;
 
 public class TerminalController {
 
diff --git a/app/src/main/java/alpine/term/TerminalControllerService.java b/app/src/main/java/alpine/term/TerminalControllerService.java
index 80a203b2..c1b7d750 100644
--- a/app/src/main/java/alpine/term/TerminalControllerService.java
+++ b/app/src/main/java/alpine/term/TerminalControllerService.java
@@ -34,7 +34,7 @@ import java.util.Locale;
 
 import alpine.term.emulator.JNI;
 import alpine.term.emulator.TerminalSession;
-import media.player.pro.R;
+import linux.kernel.R;
 
 public class TerminalControllerService extends LibService_Service_Connection {
 
diff --git a/app/src/main/java/alpine/term/TerminalService.java b/app/src/main/java/alpine/term/TerminalService.java
index 814319c6..121cb2a6 100644
--- a/app/src/main/java/alpine/term/TerminalService.java
+++ b/app/src/main/java/alpine/term/TerminalService.java
@@ -46,7 +46,7 @@ import java.util.List;
 import alpine.term.emulator.JNI;
 import alpine.term.emulator.TerminalSession;
 import alpine.term.emulator.TerminalSession.SessionChangedCallback;
-import media.player.pro.R;
+import linux.kernel.R;
 
 import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;
 
diff --git a/app/src/main/java/alpine/term/terminal_view/TerminalView.java b/app/src/main/java/alpine/term/terminal_view/TerminalView.java
index 4b0dc43e..61dcfb59 100644
--- a/app/src/main/java/alpine/term/terminal_view/TerminalView.java
+++ b/app/src/main/java/alpine/term/terminal_view/TerminalView.java
@@ -62,7 +62,7 @@ import libclient_service.LibService_Messenger;
 
 import alpine.term.Config;
 import alpine.term.LogUtils;
-import media.player.pro.R;
+import linux.kernel.R;
 import alpine.term.emulator.KeyHandler;
 import alpine.term.emulator.TerminalBuffer;
 import alpine.term.emulator.TerminalEmulator;
@@ -1543,4 +1543,4 @@ public final class TerminalView extends View {
             }
         }
     }
-}
\ No newline at end of file
+}
diff --git a/app/src/main/java/libengine/AppInstanceAndroidBase.cpp b/app/src/main/java/libengine/AppInstanceAndroidBase.cpp
new file mode 100644
index 00000000..6ce1454d
--- /dev/null
+++ b/app/src/main/java/libengine/AppInstanceAndroidBase.cpp
@@ -0,0 +1,70 @@
+//
+// Created by Matthew Good on 29/6/21.
+//
+
+#include "DiligentLog/Log.h"
+#include "AppInstanceAndroidBase.h"
+
+void AppInstanceAndroidBase::onEglSetup (JNIEnv * jenv, jobject classInstance, jstring name, jstring signature)
+{
+    if (!jvmManager.getJVM(jenv)) {
+        Log::Error("failed to get JavaVM");
+        return;
+    }
+    if (!jvmManager.attachJVM()) {
+        Log::Error("failed to attach JVM");
+        return;
+    }
+    jObject = jvmManager.globalRef(jenv, classInstance);
+    jClass = jvmManager.globalRef(jenv, jenv->GetObjectClass(jObject));
+    jboolean isCopy1, isCopy2;
+    
+    if (name == nullptr) {
+        Log::Error("cannot use a null name (0x0)");
+        return;
+    }
+    
+    if (signature == nullptr) {
+        Log::Error("cannot use a null signature (0x0)");
+        return;
+    }
+    
+    const char * n = jvmManager.jenv->GetStringUTFChars(name, &isCopy1);
+    if (n == nullptr) {
+        Log::Error("cannot get UTF chars from name");
+        return;
+    }
+    
+    const char * s = jvmManager.jenv->GetStringUTFChars(signature, &isCopy2);
+    if (s == nullptr) {
+        Log::Error("cannot get UTF chars from signature");
+        jvmManager.jenv->ReleaseStringUTFChars(name, n);
+        return;
+    }
+    
+    jSwapBuffers = jvmManager.jenv->GetMethodID(jClass, n, s);
+    
+    jvmManager.jenv->ReleaseStringUTFChars(name, n);
+    jvmManager.jenv->ReleaseStringUTFChars(name, s);
+    
+    if (jSwapBuffers == nullptr) {
+        Log::Error(
+                "cannot find method with name '", name, "', and signature '", signature, "'"
+        );
+    }
+}
+
+void AppInstanceAndroidBase::onEglTearDown ()
+{
+    jvmManager.jenv->DeleteGlobalRef(jClass);
+    jvmManager.jenv->DeleteGlobalRef(jObject);
+    jvmManager.detachJVM();
+    jSwapBuffers = nullptr;
+}
+
+void AppInstanceAndroidBase::swapBuffers ()
+{
+    if (jSwapBuffers != nullptr) {
+        jvmManager.jenv->CallVoidMethod(jObject, jSwapBuffers);
+    }
+}
diff --git a/app/src/main/java/libengine/AppInstanceAndroidBase.h b/app/src/main/java/libengine/AppInstanceAndroidBase.h
new file mode 100644
index 00000000..860ddd6e
--- /dev/null
+++ b/app/src/main/java/libengine/AppInstanceAndroidBase.h
@@ -0,0 +1,27 @@
+//
+// Created by Matthew Good on 29/6/21.
+//
+
+#ifndef GRAPHICAL_TOOL_KIT_APPINSTANCEANDROIDBASE_H
+#define GRAPHICAL_TOOL_KIT_APPINSTANCEANDROIDBASE_H
+
+#include "JVM_MANAGER.h"
+
+class AppInstanceAndroidBase
+{
+public:
+    JVM_MANAGER jvmManager;
+    jobject jObject;
+    jclass jClass;
+    jmethodID jSwapBuffers;
+
+    // delete called on non-final that has virtual functions but non-virtual destructor
+    virtual ~AppInstanceAndroidBase() = default;
+    virtual void swapBuffers();
+
+    virtual void onEglSetup(JNIEnv *jenv, jobject classInstance, jstring name, jstring signature);
+    virtual void onEglTearDown();
+};
+
+
+#endif //GRAPHICAL_TOOL_KIT_APPINSTANCEANDROIDBASE_H
diff --git a/app/src/main/java/libengine/CMakeLists.txt b/app/src/main/java/libengine/CMakeLists.txt
new file mode 100644
index 00000000..e7301023
--- /dev/null
+++ b/app/src/main/java/libengine/CMakeLists.txt
@@ -0,0 +1,41 @@
+cmake_minimum_required(VERSION 3.4.1)
+
+set(CMAKE_CXX_STANDARD 11)
+set(CMAKE_CXX_STANDARD_REQUIRED ON)
+set(CMAKE_CXX_EXTENSIONS OFF)
+
+set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/OUTPUT)
+set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_DEBUG ${CMAKE_ARCHIVE_OUTPUT_DIRECTORY})
+set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_RELEASE ${CMAKE_ARCHIVE_OUTPUT_DIRECTORY})
+set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_ARCHIVE_OUTPUT_DIRECTORY})
+set(CMAKE_LIBRARY_OUTPUT_DIRECTORY_DEBUG ${CMAKE_ARCHIVE_OUTPUT_DIRECTORY})
+set(CMAKE_LIBRARY_OUTPUT_DIRECTORY_RELEASE ${CMAKE_ARCHIVE_OUTPUT_DIRECTORY})
+
+set(PLATFORM_ANDROID ON)
+
+add_subdirectory(DiligentLog)
+
+add_library (
+        native-lib SHARED
+        native.cpp
+        JVM_MANAGER.cpp
+        AppInstanceAndroidBase.cpp
+)
+
+target_link_libraries (
+        native-lib
+        aaudio
+        log
+        android
+        jnigraphics
+        GLESv3
+        m
+        Diligent-Log
+)
+
+add_subdirectory(RVVM)
+add_dependencies(native-lib rvvm_cli)
+add_custom_command(TARGET native-lib
+                   POST_BUILD
+                   COMMAND ${CMAKE_COMMAND} -E copy $<TARGET_FILE:rvvm_cli> ${CMAKE_CURRENT_SOURCE_DIR}/../../assets/rvvm
+)
diff --git a/app/src/main/java/libengine/DiligentLog/CMakeLists.txt b/app/src/main/java/libengine/DiligentLog/CMakeLists.txt
new file mode 100644
index 00000000..2053abe3
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/CMakeLists.txt
@@ -0,0 +1,332 @@
+# For more information about using CMake with Android Studio, read the
+# documentation: https://d.android.com/studio/projects/add-native-code.html
+
+# Sets the minimum version of CMake required to build the native library.
+
+cmake_minimum_required(VERSION 3.10.2)
+
+# Declares and names the project.
+
+project(Diligent-Log)
+
+# Define GNU standard installation directories such as CMAKE_INSTALL_INCLUDEDIR, CMAKE_INSTALL_LIBDIR, etc.
+include(GNUInstallDirs)
+
+set_property(GLOBAL PROPERTY USE_FOLDERS ON)
+
+if(NOT CMAKE_BUILD_TYPE)
+    set(CMAKE_BUILD_TYPE Debug CACHE STRING "" FORCE)
+    message(STATUS "CMAKE_BUILD_TYPE is not specified, default to Debug. Note that this is only relevant for single-configuration generators (such as Makefile Generators and Ninja).")
+endif()
+
+set(DEBUG_CONFIGURATIONS DEBUG CACHE INTERNAL "Debug configurations")
+set(RELEASE_CONFIGURATIONS RELEASE RELWITHDEBINFO MINSIZEREL CACHE INTERNAL "Release configurations")
+
+if(BUILD_CONFIGURATION_FILE)
+    message("Using build configuration file " ${CUSTOM_BUILD_SCRIPT})
+    include(${CMAKE_SOURCE_DIR}/${BUILD_CONFIGURATION_FILE})
+
+    if(COMMAND custom_configure_build)
+        custom_configure_build()
+    else()
+        message("custom_configure_build() function not found in " ${CUSTOM_BUILD_SCRIPT})
+    endif()
+endif()
+
+# Generate XCode schemes
+set(CMAKE_XCODE_GENERATE_SCHEME TRUE)
+# Make malloc write 0xAA to newly allocated memory and 0x55 to deallocated memory
+set(CMAKE_XCODE_SCHEME_MALLOC_SCRIBBLE YES)
+# Place guard pages on each side of large (4096 bytes or more) buffers
+set(CMAKE_XCODE_SCHEME_MALLOC_GUARD_EDGES YES)
+
+if("${CMAKE_SIZEOF_VOID_P}" EQUAL "8")
+    set(ARCH 64 CACHE INTERNAL "64-bit architecture")
+else()
+    set(ARCH 32 CACHE INTERNAL "32-bit architecture")
+endif()
+
+# we need to rename due to conflics, normally this would link with PublicBuildSettings
+# however PublicBuildSettings is related to Diligent Backends
+add_library(Diligent-BuildSettings__LOG INTERFACE)
+target_link_libraries(Diligent-BuildSettings__LOG INTERFACE)
+
+if (NOT PLATFORM_HAS_BEEN_DEFINED)
+    if(WIN32)
+        if(${CMAKE_SYSTEM_NAME} STREQUAL "WindowsStore")
+            target_compile_definitions(Diligent-BuildSettings__LOG INTERFACE -DPLATFORM_UNIVERSAL_WINDOWS)
+            set(PLATFORM_UNIVERSAL_WINDOWS TRUE CACHE INTERNAL "Target platform: Windows Store")
+            message("Target platform: Universal Windows. SDK Version: " ${CMAKE_SYSTEM_VERSION})
+        else()
+            target_compile_definitions(Diligent-BuildSettings__LOG INTERFACE -DPLATFORM_WIN32)
+            set(PLATFORM_WIN32 TRUE CACHE INTERNAL "Target platform: Win32") #WIN32 is a variable, so we cannot use string "WIN32"
+            message("Target platform: Win32. SDK Version: " ${CMAKE_SYSTEM_VERSION})
+        endif()
+    else()
+        if(${CMAKE_SYSTEM_NAME} STREQUAL "Android")
+            target_compile_definitions(Diligent-BuildSettings__LOG INTERFACE -DPLATFORM_ANDROID)
+            set(PLATFORM_ANDROID TRUE CACHE INTERNAL "Target platform: Android")
+            message("Target platform: Android")
+        elseif(${CMAKE_SYSTEM_NAME} STREQUAL "Linux")
+            target_compile_definitions(Diligent-BuildSettings__LOG INTERFACE -DPLATFORM_LINUX)
+            set(PLATFORM_LINUX TRUE CACHE INTERNAL "Target platform: Linux")
+            message("Target Platform: Linux")
+        elseif(${CMAKE_SYSTEM_NAME} STREQUAL "Darwin")
+            if(IOS)
+                target_compile_definitions(Diligent-BuildSettings__LOG INTERFACE -DPLATFORM_IOS)
+                set(PLATFORM_IOS TRUE CACHE INTERNAL "Target platform: iOS")
+                message("Target Platform: iOS")
+            else()
+                target_compile_definitions(Diligent-BuildSettings__LOG INTERFACE -DPLATFORM_MACOS)
+                set(PLATFORM_MACOS TRUE CACHE INTERNAL "Target platform: MacOS")
+                message("Target Platform: MacOS")
+            endif()
+        elseif(${CMAKE_SYSTEM_NAME} STREQUAL "iOS")
+            target_compile_definitions(Diligent-BuildSettings__LOG INTERFACE -DPLATFORM_IOS)
+            set(PLATFORM_IOS TRUE CACHE INTERNAL "Target platform: iOS")
+            message("Target Platform: iOS")
+        elseif(${CMAKE_SYSTEM_NAME} STREQUAL "tvOS")
+            target_compile_definitions(Diligent-BuildSettings__LOG INTERFACE -DPLATFORM_TVOS)
+            set(PLATFORM_TVOS TRUE CACHE INTERNAL "Target platform: tvOS")
+            message("Target Platform: tvOS")
+        else()
+            message(FATAL_ERROR "Unsupported platform")
+        endif()
+    endif(WIN32)
+
+    if(PLATFORM_MACOS OR PLATFORM_IOS OR PLATFORM_TVOS)
+        target_compile_definitions(Diligent-BuildSettings__LOG INTERFACE -DPLATFORM_APPLE -DGL_SILENCE_DEPRECATION)
+        set(PLATFORM_APPLE TRUE CACHE INTERNAL "Apple platform (macOS, iOS, or tvOS)")
+    endif()
+
+    set(PLATFORM_HAS_BEEN_DEFINED TRUE "Platform has been defined")
+endif()
+
+foreach(DBG_CONFIG ${DEBUG_CONFIGURATIONS})
+    target_compile_definitions(Diligent-BuildSettings__LOG INTERFACE "$<$<CONFIG:${DBG_CONFIG}>:_DEBUG;DEBUG>")
+endforeach()
+
+foreach(REL_CONFIG ${RELEASE_CONFIGURATIONS})
+    target_compile_definitions(Diligent-BuildSettings__LOG INTERFACE "$<$<CONFIG:${REL_CONFIG}>:NDEBUG>")
+endforeach()
+
+if(MSVC)
+    # For msvc, enable level 4 warnings and treat warnings as errors, except for
+    # - w4100 - unreferenced formal parameter
+    # - w4505 - unreferenced local function has been removed
+    # - w4201 - nonstandard extension used: nameless struct/union
+    target_compile_options(Diligent-BuildSettings__LOG INTERFACE /W4 /WX /wd4100 /wd4505 /wd4201 /MP)
+    # In all release modes also:
+    # - disable w4189 - local variable is initialized but not referenced
+    # - Disable RTTI (/GR-)
+    # - Enable whole program optimization (/GL)
+    # - Enable string pooling (/GF)
+    set(MSVC_ALL_RELEASE_COMPILE_OPTIONS /wd4189 /GR- /GL /GF)
+    #target_compile_options(Diligent-BuildSettings__LOG INTERFACE "$<$<CONFIG:RELEASE>:/wd4189 /Ot")
+    # In RELEASE mode:
+    # - Set favor fast code option (/Ot)
+    # - Enable intrinsic functions (/Oi)
+    # - Maximize Speed (/O2)
+    # - Inline any suitable function (/Ob2)
+    set(MSVC_RELEASE_COMPILE_OPTIONS ${MSVC_ALL_RELEASE_COMPILE_OPTIONS} /Ot /Oi /Ob2 /O2)
+    set(MSVC_RELWITHDEBINFO_COMPILE_OPTIONS ${MSVC_RELEASE_COMPILE_OPTIONS})
+    # In MINSIZEREL mode set favor small code option (/Os)
+    set(MSVC_MINSIZEREL_COMPILE_OPTIONS ${MSVC_ALL_RELEASE_COMPILE_OPTIONS} /Os)
+    target_compile_options(Diligent-BuildSettings__LOG INTERFACE "$<$<CONFIG:RELEASE>:${MSVC_RELEASE_COMPILE_OPTIONS}>")
+    target_compile_options(Diligent-BuildSettings__LOG INTERFACE "$<$<CONFIG:MINSIZEREL>:${MSVC_MINSIZEREL_COMPILE_OPTIONS}>")
+    target_compile_options(Diligent-BuildSettings__LOG INTERFACE "$<$<CONFIG:RELWITHDEBINFO>:${MSVC_RELWITHDEBINFO_COMPILE_OPTIONS}>")
+    # !!!NOTE!!! For some reason above is the only form of generator expression that works
+    # For instance, this way
+    # target_compile_options(Diligent-BuildSettings__LOG INTERFACE "$<$<CONFIG:RELEASE>:/Ot>")
+    # does not work as expected
+else()
+    # Todo: use __attribute__((always_inline)), but it needs to be defined in a header file
+    target_compile_definitions(Diligent-BuildSettings__LOG INTERFACE __forceinline=inline)
+endif(MSVC)
+
+
+if (CMAKE_CXX_COMPILER_ID MATCHES "Clang" OR
+        CMAKE_CXX_COMPILER_ID MATCHES "GNU")
+    if(PLATFORM_APPLE)
+        set(WHOLE_ARCHIVE_FLAG "-Wl,-all_load" CACHE INTERNAL "all_load flag")
+        set(NO_WHOLE_ARCHIVE_FLAG "-Wl,-noall_load" CACHE INTERNAL "noall_load flag")
+    else()
+        set(WHOLE_ARCHIVE_FLAG "-Wl,--whole-archive" CACHE INTERNAL "whole-archive flag")
+        set(NO_WHOLE_ARCHIVE_FLAG "-Wl,--no-whole-archive" CACHE INTERNAL "no-whole-archive flag")
+    endif()
+else()
+    set(WHOLE_ARCHIVE_FLAG "")
+    set(NO_WHOLE_ARCHIVE_FLAG "")
+endif()
+
+if (CMAKE_CXX_COMPILER_ID MATCHES "Clang")
+    target_compile_options(Diligent-BuildSettings__LOG INTERFACE
+            # All warnings are errors
+            -Werror
+            # Some extra warnings
+            -Wall -Wextra -Wuninitialized -Wconditional-uninitialized -Wextra-tokens -Wpointer-arith -Wloop-analysis -Wunused
+            # Disable few warnings
+            -Wno-overloaded-virtual -Wno-incompatible-pointer-types-discards-qualifiers -Wno-unknown-pragmas
+            -Wno-zero-as-null-pointer-constant -Wno-unused-parameter
+            )
+    set(CLANG_RELEASE_OPTIONS -Wno-unused-variable)
+    target_compile_options(Diligent-BuildSettings__LOG INTERFACE $<$<NOT:$<CONFIG:Debug>>:${CLANG_RELEASE_OPTIONS}>)
+
+    if ((PLATFORM_IOS  AND CMAKE_OSX_SYSROOT STREQUAL "iphonesimulator")  OR PLATFORM_IOS_SIMULATOR OR
+    (PLATFORM_TVOS AND CMAKE_OSX_SYSROOT STREQUAL "appletvsimulator") OR PLATFORM_TVOS_SIMULATOR)
+        # There is a known long-standing issue in simulator SDK:
+        # the compiler generates a lot of bogus warnings in Metal
+        # headers about unavailable API
+        target_compile_options(Diligent-BuildSettings__LOG
+                INTERFACE
+                -Wno-error=unguarded-availability-new
+                )
+    endif()
+endif()
+
+# Returns path to the target relative to CMake root
+function(get_target_relative_dir__LOG _TARGET _DIR)
+    get_target_property(TARGET_SOURCE_DIR ${_TARGET} SOURCE_DIR)
+    file(RELATIVE_PATH TARGET_RELATIVE_PATH "${CMAKE_SOURCE_DIR}" "${TARGET_SOURCE_DIR}")
+    set(${_DIR} ${TARGET_RELATIVE_PATH} PARENT_SCOPE)
+endfunction()
+
+# Performs installation steps for the core library
+function(install_core_lib__LOG _TARGET)
+    get_target_relative_dir__LOG(${_TARGET} TARGET_RELATIVE_PATH)
+
+    get_target_property(TARGET_TYPE ${_TARGET} TYPE)
+    if(TARGET_TYPE STREQUAL STATIC_LIBRARY)
+        list(APPEND DILIGENT_CORE_INSTALL_LIBS_LIST ${_TARGET})
+        set(DILIGENT_CORE_INSTALL_LIBS_LIST ${DILIGENT_CORE_INSTALL_LIBS_LIST} CACHE INTERNAL "Core libraries installation list")
+    elseif(TARGET_TYPE STREQUAL SHARED_LIBRARY)
+        install(TARGETS				 ${_TARGET}
+                ARCHIVE DESTINATION "${CMAKE_INSTALL_LIBDIR}/${DILIGENT_CORE_DIR}/$<CONFIG>"
+                LIBRARY DESTINATION "${CMAKE_INSTALL_LIBDIR}/${DILIGENT_CORE_DIR}/$<CONFIG>"
+                RUNTIME DESTINATION "${CMAKE_INSTALL_BINDIR}/${DILIGENT_CORE_DIR}/$<CONFIG>"
+                )
+        if (DILIGENT_INSTALL_PDB)
+            install(FILES $<TARGET_PDB_FILE:${_TARGET}> DESTINATION "${CMAKE_INSTALL_BINDIR}/${DILIGENT_CORE_DIR}/$<CONFIG>" OPTIONAL)
+        endif()
+    endif()
+
+    if(EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/interface")
+        install(DIRECTORY    interface
+                DESTINATION  "${CMAKE_INSTALL_INCLUDEDIR}/${TARGET_RELATIVE_PATH}/"
+                )
+    endif()
+endfunction()
+
+function(set_common_target_properties__LOG TARGET)
+
+    if(COMMAND custom_pre_configure_target)
+        custom_pre_configure_target(${TARGET})
+        if(TARGET_CONFIGURATION_COMPLETE)
+            return()
+        endif()
+    endif()
+
+    get_target_property(TARGET_TYPE ${TARGET} TYPE)
+
+    if(MSVC)
+        # For msvc, enable link-time code generation for release builds (I was not able to
+        # find any way to set these settings through interface library BuildSettings)
+        if(TARGET_TYPE STREQUAL STATIC_LIBRARY)
+
+            foreach(REL_CONFIG ${RELEASE_CONFIGURATIONS})
+                set_target_properties(${TARGET} PROPERTIES
+                        STATIC_LIBRARY_FLAGS_${REL_CONFIG} /LTCG
+                        )
+            endforeach()
+
+        else()
+
+            foreach(REL_CONFIG ${RELEASE_CONFIGURATIONS})
+                set_target_properties(${TARGET} PROPERTIES
+                        LINK_FLAGS_${REL_CONFIG} "/LTCG /OPT:REF /INCREMENTAL:NO"
+                        )
+            endforeach()
+
+            if(PLATFORM_UNIVERSAL_WINDOWS)
+                # On UWP, disable incremental link to avoid linker warnings
+                foreach(DBG_CONFIG ${DEBUG_CONFIGURATIONS})
+                    set_target_properties(${TARGET} PROPERTIES
+                            LINK_FLAGS_${DBG_CONFIG} "/INCREMENTAL:NO"
+                            )
+                endforeach()
+            endif()
+        endif()
+    else()
+        set_target_properties(${TARGET} PROPERTIES
+                CXX_VISIBILITY_PRESET hidden # -fvisibility=hidden
+                C_VISIBILITY_PRESET hidden # -fvisibility=hidden
+                VISIBILITY_INLINES_HIDDEN TRUE
+
+                # Without -fPIC option GCC fails to link static libraries into dynamic library:
+                #  -fPIC
+                #      If supported for the target machine, emit position-independent code, suitable for
+                #      dynamic linking and avoiding any limit on the size of the global offset table.
+                POSITION_INDEPENDENT_CODE ON
+
+                # It is crucial to set CXX_STANDARD flag to only affect c++ files and avoid failures compiling c-files:
+                # error: invalid argument '-std=c++14' not allowed with 'C/ObjC'
+                CXX_STANDARD 14
+                CXX_STANDARD_REQUIRED ON
+
+                C_STANDARD 11
+                )
+
+        if(NOT MINGW_BUILD)
+            # Do not disable extensions when building with MinGW!
+            set_target_properties(${TARGET} PROPERTIES
+                    CXX_EXTENSIONS OFF
+                    )
+        endif()
+    endif()
+
+    if(COMMAND custom_post_configure_target)
+        custom_post_configure_target(${TARGET})
+    endif()
+
+endfunction()
+
+if(PLATFORM_MACOS)
+    find_library(APP_KIT AppKit)
+    if (NOT APP_KIT)
+        message(FATAL_ERROR "AppKit not found")
+    endif()
+elseif(PLATFORM_IOS)
+    find_library(CORE_FOUNDATION CoreFoundation)
+    if(NOT CORE_FOUNDATION)
+        message(FATAL_ERROR "Cannot find CoreFoundation framework")
+    endif()
+
+    find_library(FOUNDATION Foundation)
+    if(NOT FOUNDATION)
+        message(FATAL_ERROR "Cannot find Foundation framework")
+    endif()
+elseif(PLATFORM_TVOS)
+    find_library(CORE_FOUNDATION CoreFoundation)
+    if(NOT CORE_FOUNDATION)
+        message(FATAL_ERROR "Cannot find CoreFoundation framework")
+    endif()
+
+    find_library(FOUNDATION Foundation)
+    if(NOT FOUNDATION)
+        message(FATAL_ERROR "Cannot find Foundation framework")
+    endif()
+endif()
+
+add_subdirectory(Primitives)
+add_subdirectory(Platforms)
+
+add_library(
+        Diligent-Log SHARED
+        common.cpp
+)
+
+target_link_libraries(
+        Diligent-Log
+        Diligent-Primitives
+        Diligent-TargetPlatform
+)
diff --git a/app/src/main/java/libengine/DiligentLog/Log.h b/app/src/main/java/libengine/DiligentLog/Log.h
new file mode 100644
index 00000000..e902ac0f
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Log.h
@@ -0,0 +1,71 @@
+//
+// Created by Matthew Good on 29/7/21.
+//
+
+#ifndef GRAPHICAL_TOOL_KIT_LOG_H
+#define GRAPHICAL_TOOL_KIT_LOG_H
+
+#include <sstream>
+
+class Log {
+public:
+    enum SEVERITY {
+        INFO,
+        ERROR,
+        FATAL
+    };
+
+private:
+    template <typename SSType, typename ArgType>
+    static void FormatStrSS(SSType& ss, const ArgType& Arg)
+    {
+        ss << Arg;
+    }
+
+    template <typename SSType, typename FirstArgType, typename... RestArgsType>
+    static void FormatStrSS(SSType& ss, const FirstArgType& FirstArg, const RestArgsType&... RestArgs)
+    {
+        FormatStrSS(ss, FirstArg);
+        FormatStrSS(ss, RestArgs...); // recursive call using pack expansion syntax
+    }
+
+public:
+    static void Log_String(const SEVERITY & severity, const char * msg);
+    static void Log_String(const SEVERITY & severity, const std::string & msg);
+
+    template <typename... RestArgsType>
+    static std::string FormatString(const RestArgsType&... Args)
+    {
+        std::stringstream ss;
+        FormatStrSS(ss, Args...);
+        return ss.str();
+    }
+
+    template<typename... RestArgsType>
+    static void Log_With_Severity(const SEVERITY & severity, const RestArgsType &... Args) {
+        std::string msg = FormatString(Args...);
+        Log_String(severity, msg);
+    }
+
+    template<typename... RestArgsType>
+    static void Debug(const RestArgsType &... Args) {
+        Log_With_Severity(INFO, Args...);
+    }
+
+    template<typename... RestArgsType>
+    static void Info(const RestArgsType &... Args) {
+        Log_With_Severity(INFO, Args...);
+    }
+
+    template<typename... RestArgsType>
+    static void Error(const RestArgsType &... Args) {
+        Log_With_Severity(ERROR, Args...);
+    }
+
+    template<typename... RestArgsType>
+    static void Error_And_Throw(const RestArgsType &... Args) {
+        Log_With_Severity(FATAL, Args...);
+    }
+};
+
+#endif //GRAPHICAL_TOOL_KIT_LOG_H
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Android/CMakeLists.txt b/app/src/main/java/libengine/DiligentLog/Platforms/Android/CMakeLists.txt
new file mode 100644
index 00000000..f782a566
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Android/CMakeLists.txt
@@ -0,0 +1,46 @@
+cmake_minimum_required (VERSION 3.6)
+
+project(Diligent-AndroidPlatform_LOG CXX)
+
+set(INTERFACE 
+    interface/AndroidDebug.hpp
+    interface/AndroidFileSystem.hpp
+    interface/AndroidPlatformDefinitions.h
+    interface/AndroidPlatformMisc.hpp
+    interface/AndroidNativeWindow.h
+)
+
+set(SOURCE 
+    src/AndroidDebug.cpp
+    src/AndroidFileSystem.cpp
+)
+
+add_library(Diligent-AndroidPlatform_LOG ${SOURCE} ${INTERFACE} ${PLATFORM_INTERFACE_HEADERS})
+set_common_target_properties__LOG(Diligent-AndroidPlatform_LOG)
+
+target_include_directories(Diligent-AndroidPlatform_LOG
+PUBLIC
+    interface
+)
+
+target_link_libraries(Diligent-AndroidPlatform_LOG
+PRIVATE
+    log
+    android
+    Diligent-BuildSettings__LOG 
+PUBLIC
+    Diligent-PlatformInterface
+    Diligent-BasicPlatform_LOG
+)
+
+source_group("src" FILES ${SOURCE})
+source_group("include" FILES ${INCLUDE})
+source_group("interface" FILES ${PLATFORM_INTERFACE_HEADERS})
+
+set_target_properties(Diligent-AndroidPlatform_LOG PROPERTIES
+    FOLDER DiligentLog/Platforms
+)
+
+if(DILIGENT_INSTALL_CORE)
+    install_core_lib__LOG(Diligent-AndroidPlatform_LOG)
+endif()
\ No newline at end of file
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Android/interface/AndroidDebug.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/Android/interface/AndroidDebug.hpp
new file mode 100644
index 00000000..cef4bdab
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Android/interface/AndroidDebug.hpp
@@ -0,0 +1,43 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../Basic/interface/BasicPlatformDebug.hpp"
+
+struct AndroidDebug : public BasicPlatformDebug
+{
+    static void AssertionFailed(const Diligent::Char* Message,
+                                const char*           Function, // type of __FUNCTION__
+                                const char*           File,     // type of __FILE__
+                                int                   Line);
+    static void OutputDebugMessage(Diligent::DEBUG_MESSAGE_SEVERITY Severity,
+                                   const Diligent::Char*            Message,
+                                   const char*                      Function, // type of __FUNCTION__
+                                   const char*                      File,     // type of __FILE__
+                                   int                              Line);
+};
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Android/interface/AndroidFileSystem.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/Android/interface/AndroidFileSystem.hpp
new file mode 100644
index 00000000..cd352477
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Android/interface/AndroidFileSystem.hpp
@@ -0,0 +1,99 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include <memory>
+#include <vector>
+#include <fstream>
+#include <android/asset_manager.h>
+
+#include "../../Basic/interface/BasicFileSystem.hpp"
+#include "../../Primitives/interface/DataBlob.h"
+
+struct ANativeActivity;
+struct AAssetManager;
+
+class AndroidFile : public BasicFile
+{
+public:
+    AndroidFile(const FileOpenAttribs& OpenAttribs);
+    ~AndroidFile();
+
+    void Read(Diligent::IDataBlob* pData);
+
+    bool Read(void* Data, size_t BufferSize);
+
+    bool Write(const void* Data, size_t BufferSize);
+
+    size_t GetSize() { return m_Size; }
+
+    size_t GetPos();
+
+    void SetPos(size_t Offset, FilePosOrigin Origin);
+
+    static bool Open(const char* FileName, std::ifstream& IFS, AAsset*& AssetFile, size_t& Size);
+
+private:
+    std::ifstream m_IFS;
+    AAsset*       m_AssetFile = nullptr;
+    size_t        m_Size      = 0;
+};
+
+
+/// Android file system implementation.
+struct AndroidFileSystem : public BasicFileSystem
+{
+public:
+    /// Initializes the file system.
+
+    /// \param [in] NativeActivity          - Pointer to the native activity object (ANativeActivity).
+    /// \param [in] NativeActivityClassName - Native activity class name.
+    /// \param [in] AssetManager            - Pointer to the asset manager (AAssetManager).
+    ///
+    /// \remarks The file system can be initialized to use either native activity or asset manager, or both.
+    ///          When NativeActivity is not null, the file system will try to use it first when openining files.
+    ///          It will then resort to using the asset manager. When NativeActivity is not null, but AssetManager
+    ///          parameter is null, the file system will use the asset manager from the activity.
+    ///          If NativeActivity is null, the file system will only use the asset manager.
+    static void Init(struct ANativeActivity* NativeActivity,
+                     const char*             NativeActivityClassName,
+                     struct AAssetManager*   AssetManager);
+
+
+    static AndroidFile*          OpenFile(const FileOpenAttribs& OpenAttribs);
+    static inline Diligent::Char GetSlashSymbol() { return '/'; }
+
+    static bool FileExists(const Diligent::Char* strFilePath);
+    static bool PathExists(const Diligent::Char* strPath);
+
+    static bool CreateDirectory(const Diligent::Char* strPath);
+    static void ClearDirectory(const Diligent::Char* strPath);
+    static void DeleteFile(const Diligent::Char* strPath);
+
+    static std::vector<std::unique_ptr<FindFileData>> Search(const Diligent::Char* SearchPattern);
+};
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Android/interface/AndroidNativeWindow.h b/app/src/main/java/libengine/DiligentLog/Platforms/Android/interface/AndroidNativeWindow.h
new file mode 100644
index 00000000..16e8badd
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Android/interface/AndroidNativeWindow.h
@@ -0,0 +1,39 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../../Primitives/interface/CommonDefinitions.h"
+
+DILIGENT_BEGIN_NAMESPACE(Diligent)
+
+struct AndroidNativeWindow
+{
+    void* pAWindow DEFAULT_INITIALIZER(nullptr);
+};
+
+DILIGENT_END_NAMESPACE // namespace Diligent
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Android/interface/AndroidPlatformDefinitions.h b/app/src/main/java/libengine/DiligentLog/Platforms/Android/interface/AndroidPlatformDefinitions.h
new file mode 100644
index 00000000..6a912ac2
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Android/interface/AndroidPlatformDefinitions.h
@@ -0,0 +1,40 @@
+/*     Copyright 2015-2018 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF ANY PROPRIETARY RIGHTS.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../../Primitives/interface/CommonDefinitions.h"
+
+#if DILIGENT_C_INTERFACE
+
+#    define _countof(arr) (sizeof(arr) / sizeof(arr[0]))
+
+#else
+
+#    include <cstddef>
+
+template <typename _CountofType, std::size_t _SizeOfArray>
+char (*__countof_helper(_CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];
+#    define _countof(_Array) (sizeof(*__countof_helper(_Array)) + 0)
+
+#endif
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Android/interface/AndroidPlatformMisc.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/Android/interface/AndroidPlatformMisc.hpp
new file mode 100644
index 00000000..22dac338
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Android/interface/AndroidPlatformMisc.hpp
@@ -0,0 +1,36 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../Basic/interface/BasicPlatformMisc.hpp"
+#include "../../Basic/interface/DebugUtilities.hpp"
+#include "../../Linux/interface/LinuxPlatformMisc.hpp"
+
+struct AndroidMisc : public LinuxMisc
+{
+};
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Android/src/AndroidDebug.cpp b/app/src/main/java/libengine/DiligentLog/Platforms/Android/src/AndroidDebug.cpp
new file mode 100644
index 00000000..ff824847
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Android/src/AndroidDebug.cpp
@@ -0,0 +1,62 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#include "AndroidDebug.hpp"
+#include "FormatString.hpp"
+#include <android/log.h>
+#include <csignal>
+
+using namespace Diligent;
+
+void AndroidDebug::AssertionFailed(const Char* Message, const char* Function, const char* File, int Line)
+{
+    auto AssertionFailedMessage = FormatAssertionFailedMessage(Message, Function, File, Line);
+    OutputDebugMessage(DEBUG_MESSAGE_SEVERITY_ERROR, AssertionFailedMessage.c_str(), nullptr, nullptr, 0);
+
+    raise(SIGTRAP);
+};
+
+
+void AndroidDebug::OutputDebugMessage(DEBUG_MESSAGE_SEVERITY Severity, const Char* Message, const char* Function, const char* File, int Line)
+{
+    auto msg = FormatDebugMessage(Severity, Message, Function, File, Line);
+
+    static const android_LogPriority Priorities[] = {ANDROID_LOG_INFO, ANDROID_LOG_WARN, ANDROID_LOG_ERROR, ANDROID_LOG_FATAL};
+    __android_log_print(Priorities[static_cast<int>(Severity)], "Diligent Engine", "%s", msg.c_str());
+}
+
+void DebugAssertionFailed(const Char* Message, const char* Function, const char* File, int Line)
+{
+    AndroidDebug::AssertionFailed(Message, Function, File, Line);
+}
+
+namespace Diligent
+{
+
+DebugMessageCallbackType DebugMessageCallback = AndroidDebug::OutputDebugMessage;
+
+}
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Android/src/AndroidFileSystem.cpp b/app/src/main/java/libengine/DiligentLog/Platforms/Android/src/AndroidFileSystem.cpp
new file mode 100644
index 00000000..cee264eb
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Android/src/AndroidFileSystem.cpp
@@ -0,0 +1,359 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#include <string>
+#include <android/native_activity.h>
+
+#include "AndroidFileSystem.hpp"
+#include "Errors.hpp"
+#include "DebugUtilities.hpp"
+
+
+namespace
+{
+
+class JNIMiniHelper
+{
+public:
+    static void Init(ANativeActivity* activity, std::string activity_class_name, AAssetManager* asset_manager)
+    {
+        VERIFY(activity != nullptr || asset_manager != nullptr, "Activity and asset manager can't both be null");
+
+        auto& TheHelper                = GetInstance();
+        TheHelper.activity_            = activity;
+        TheHelper.activity_class_name_ = std::move(activity_class_name);
+        TheHelper.asset_manager_       = asset_manager;
+        if (TheHelper.asset_manager_ == nullptr && TheHelper.activity_ != nullptr)
+        {
+            TheHelper.asset_manager_ = TheHelper.activity_->assetManager;
+        }
+    }
+
+    static JNIMiniHelper& GetInstance()
+    {
+        static JNIMiniHelper helper;
+        return helper;
+    }
+
+
+    bool OpenFile(const char* fileName, std::ifstream& IFS, AAsset*& AssetFile, size_t& FileSize)
+    {
+        if (activity_ == nullptr && asset_manager_ == nullptr)
+        {
+            LOG_ERROR_MESSAGE("JNIMiniHelper has not been initialized. Call init() to initialize the helper");
+            return false;
+        }
+
+        // Lock mutex
+        std::lock_guard<std::mutex> lock(mutex_);
+
+        if (activity_ != nullptr)
+        {
+            // First, try reading from externalFileDir;
+            std::string ExternalFilesPath;
+            {
+                JNIEnv* env          = nullptr;
+                bool    DetachThread = AttachCurrentThread(env);
+                if (jstring jstr_path = GetExternalFilesDirJString(env))
+                {
+                    const char* path  = env->GetStringUTFChars(jstr_path, nullptr);
+                    ExternalFilesPath = std::string(path);
+                    if (fileName[0] != '/')
+                    {
+                        ExternalFilesPath.append("/");
+                    }
+                    ExternalFilesPath.append(fileName);
+                    env->ReleaseStringUTFChars(jstr_path, path);
+                    env->DeleteLocalRef(jstr_path);
+                }
+                if (DetachThread)
+                    DetachCurrentThread();
+            }
+
+            IFS.open(ExternalFilesPath.c_str(), std::ios::binary);
+        }
+
+        if (IFS && IFS.is_open())
+        {
+            IFS.seekg(0, std::ifstream::end);
+            FileSize = IFS.tellg();
+            IFS.seekg(0, std::ifstream::beg);
+            return true;
+        }
+        else if (asset_manager_ != nullptr)
+        {
+            // Fallback to assetManager
+            AssetFile = AAssetManager_open(asset_manager_, fileName, AASSET_MODE_BUFFER);
+            if (!AssetFile)
+            {
+                return false;
+            }
+            uint8_t* data = (uint8_t*)AAsset_getBuffer(AssetFile);
+            if (data == nullptr)
+            {
+                AAsset_close(AssetFile);
+
+                LOG_ERROR_MESSAGE("Failed to open: ", fileName);
+                return false;
+            }
+            FileSize = AAsset_getLength(AssetFile);
+            return true;
+        }
+        else
+        {
+            return false;
+        }
+    }
+
+    /*
+     * Attach current thread
+     * In Android, the thread doesn't have to be 'Detach' current thread
+     * as application process is only killed and VM does not shut down
+     */
+    bool AttachCurrentThread(JNIEnv*& env)
+    {
+        env = nullptr;
+        if (activity_->vm->GetEnv((void**)&env, JNI_VERSION_1_4) == JNI_OK)
+            return false; // Already attached
+        activity_->vm->AttachCurrentThread(&env, nullptr);
+        pthread_key_create((int32_t*)activity_, DetachCurrentThreadDtor);
+        return true;
+    }
+
+    /*
+     * Unregister this thread from the VM
+     */
+    static void DetachCurrentThreadDtor(void* p)
+    {
+        LOG_INFO_MESSAGE("detached current thread");
+        auto* activity = reinterpret_cast<ANativeActivity*>(p);
+        activity->vm->DetachCurrentThread();
+    }
+
+private:
+    JNIMiniHelper()
+    {
+    }
+
+    ~JNIMiniHelper()
+    {
+    }
+
+    // clang-format off
+    JNIMiniHelper           (const JNIMiniHelper&) = delete;
+    JNIMiniHelper& operator=(const JNIMiniHelper&) = delete;
+    JNIMiniHelper           (JNIMiniHelper&&)      = delete;
+    JNIMiniHelper& operator=(JNIMiniHelper&&)      = delete;
+    // clang-format on
+
+    jstring GetExternalFilesDirJString(JNIEnv* env)
+    {
+        if (activity_ == nullptr)
+        {
+            LOG_ERROR_MESSAGE("JNIHelper has not been initialized. Call init() to initialize the helper");
+            return NULL;
+        }
+
+        jstring obj_Path = nullptr;
+        // Invoking getExternalFilesDir() java API
+        jclass    cls_Env  = env->FindClass(activity_class_name_.c_str());
+        jmethodID mid      = env->GetMethodID(cls_Env, "getExternalFilesDir", "(Ljava/lang/String;)Ljava/io/File;");
+        jobject   obj_File = env->CallObjectMethod(activity_->clazz, mid, NULL);
+        if (obj_File)
+        {
+            jclass    cls_File    = env->FindClass("java/io/File");
+            jmethodID mid_getPath = env->GetMethodID(cls_File, "getPath", "()Ljava/lang/String;");
+            obj_Path              = (jstring)env->CallObjectMethod(obj_File, mid_getPath);
+            env->DeleteLocalRef(cls_File);
+            env->DeleteLocalRef(obj_File);
+        }
+        env->DeleteLocalRef(cls_Env);
+        return obj_Path;
+    }
+
+    void DetachCurrentThread()
+    {
+        activity_->vm->DetachCurrentThread();
+    }
+
+    ANativeActivity* activity_ = nullptr;
+    std::string      activity_class_name_;
+    AAssetManager*   asset_manager_ = nullptr;
+
+    // mutex for synchronization
+    // This class uses singleton pattern and can be invoked from multiple threads,
+    // each methods locks the mutex for a thread safety
+    mutable std::mutex mutex_;
+};
+
+
+} // namespace
+
+
+bool AndroidFile::Open(const char* FileName, std::ifstream& IFS, AAsset*& AssetFile, size_t& Size)
+{
+    return JNIMiniHelper::GetInstance().OpenFile(FileName, IFS, AssetFile, Size);
+}
+
+AndroidFile::AndroidFile(const FileOpenAttribs& OpenAttribs) :
+    BasicFile(OpenAttribs, AndroidFileSystem::GetSlashSymbol())
+{
+    auto FullPath = m_OpenAttribs.strFilePath;
+    if (!Open(FullPath, m_IFS, m_AssetFile, m_Size))
+    {
+        LOG_ERROR_AND_THROW("Failed to open file ", FullPath);
+    }
+}
+
+AndroidFile::~AndroidFile()
+{
+    if (m_IFS && m_IFS.is_open())
+        m_IFS.close();
+
+    if (m_AssetFile != nullptr)
+        AAsset_close(m_AssetFile);
+}
+
+void AndroidFile::Read(Diligent::IDataBlob* pData)
+{
+    pData->Resize(GetSize());
+    Read(pData->GetDataPtr(), pData->GetSize());
+}
+
+bool AndroidFile::Read(void* Data, size_t BufferSize)
+{
+    VERIFY(BufferSize == m_Size, "Only whole file reads are currently supported");
+
+    if (m_IFS && m_IFS.is_open())
+    {
+        m_IFS.read((char*)Data, BufferSize);
+        return true;
+    }
+    else if (m_AssetFile != nullptr)
+    {
+        const uint8_t* src_data = (uint8_t*)AAsset_getBuffer(m_AssetFile);
+        off_t          FileSize = AAsset_getLength(m_AssetFile);
+        if (FileSize > static_cast<off_t>(BufferSize))
+        {
+            LOG_WARNING_MESSAGE("Requested buffer size (", BufferSize, ") exceeds file size (", FileSize, ")");
+            BufferSize = FileSize;
+        }
+        memcpy(Data, src_data, BufferSize);
+        return true;
+    }
+    else
+    {
+        return false;
+    }
+}
+
+bool AndroidFile::Write(const void* Data, size_t BufferSize)
+{
+    UNSUPPORTED("Not implemented");
+
+    return false;
+}
+
+size_t AndroidFile::GetPos()
+{
+    UNSUPPORTED("Not implemented");
+
+    return 0;
+}
+
+void AndroidFile::SetPos(size_t Offset, FilePosOrigin Origin)
+{
+    UNSUPPORTED("Not implemented");
+}
+
+
+void AndroidFileSystem::Init(ANativeActivity* NativeActivity, const char* NativeActivityClassName, AAssetManager* AssetManager)
+{
+    JNIMiniHelper::Init(NativeActivity, NativeActivityClassName != nullptr ? NativeActivityClassName : "", AssetManager);
+}
+
+AndroidFile* AndroidFileSystem::OpenFile(const FileOpenAttribs& OpenAttribs)
+{
+    AndroidFile* pFile = nullptr;
+    try
+    {
+        pFile = new AndroidFile(OpenAttribs);
+    }
+    catch (const std::runtime_error& err)
+    {
+    }
+
+    return pFile;
+}
+
+
+bool AndroidFileSystem::FileExists(const Diligent::Char* strFilePath)
+{
+    std::ifstream   IFS;
+    AAsset*         AssetFile = nullptr;
+    size_t          Size      = 0;
+    FileOpenAttribs OpenAttribs;
+    OpenAttribs.strFilePath = strFilePath;
+    BasicFile   DummyFile(OpenAttribs, AndroidFileSystem::GetSlashSymbol());
+    const auto& Path   = DummyFile.GetPath(); // This is necessary to correct slashes
+    bool        Exists = AndroidFile::Open(Path.c_str(), IFS, AssetFile, Size);
+
+    if (IFS && IFS.is_open())
+        IFS.close();
+    if (AssetFile != nullptr)
+        AAsset_close(AssetFile);
+
+    return Exists;
+}
+
+bool AndroidFileSystem::PathExists(const Diligent::Char* strPath)
+{
+    UNSUPPORTED("Not implemented");
+    return false;
+}
+
+bool AndroidFileSystem::CreateDirectory(const Diligent::Char* strPath)
+{
+    UNSUPPORTED("Not implemented");
+    return false;
+}
+
+void AndroidFileSystem::ClearDirectory(const Diligent::Char* strPath)
+{
+    UNSUPPORTED("Not implemented");
+}
+
+void AndroidFileSystem::DeleteFile(const Diligent::Char* strPath)
+{
+    UNSUPPORTED("Not implemented");
+}
+
+std::vector<std::unique_ptr<FindFileData>> AndroidFileSystem::Search(const Diligent::Char* SearchPattern)
+{
+    UNSUPPORTED("Not implemented");
+    return std::vector<std::unique_ptr<FindFileData>>();
+}
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Apple/CMakeLists.txt b/app/src/main/java/libengine/DiligentLog/Platforms/Apple/CMakeLists.txt
new file mode 100644
index 00000000..634db60a
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Apple/CMakeLists.txt
@@ -0,0 +1,73 @@
+cmake_minimum_required (VERSION 3.6)
+
+project(Diligent-ApplePlatform CXX)
+
+if(PLATFORM_MACOS)
+    set(APPLE_NATIVE_WINDOW_H interface/MacOSNativeWindow.h)
+elseif(PLATFORM_IOS)
+    set(APPLE_NATIVE_WINDOW_H interface/IOSNativeWindow.h)
+elseif(PLATFORM_TVOS)
+    set(APPLE_NATIVE_WINDOW_H interface/TVOSNativeWindow.h)
+endif()
+
+set(INTERFACE
+    interface/CFObjectWrapper.hpp
+    interface/AppleDebug.hpp
+    interface/AppleFileSystem.hpp
+    interface/ApplePlatformDefinitions.h
+    interface/ApplePlatformMisc.hpp
+    ${APPLE_NATIVE_WINDOW_H}
+)
+
+set(SOURCE
+    src/AppleDebug.mm
+    src/AppleFileSystem.cpp
+)
+
+
+add_library(Diligent-ApplePlatform ${SOURCE} ${INTERFACE} ${PLATFORM_INTERFACE_HEADERS})
+set_common_target_properties__LOG(Diligent-ApplePlatform)
+
+target_include_directories(Diligent-ApplePlatform
+PUBLIC
+    interface
+)
+
+target_link_libraries(Diligent-ApplePlatform
+PRIVATE
+    Diligent-BuildSettings__LOG 
+PUBLIC
+    Diligent-BasicPlatform_LOG
+    Diligent-PlatformInterface
+)
+
+if(PLATFORM_MACOS)
+    target_link_libraries(Diligent-ApplePlatform
+    PRIVATE
+        ${APP_KIT}
+    )
+elseif(PLATFORM_IOS)
+    target_link_libraries(Diligent-ApplePlatform
+    PRIVATE
+        ${CORE_FOUNDATION}
+        ${FOUNDATION}
+    )
+elseif(PLATFORM_TVOS)
+    target_link_libraries(Diligent-ApplePlatform
+    PRIVATE
+        ${CORE_FOUNDATION}
+        ${FOUNDATION}
+    )
+endif()
+
+source_group("src" FILES ${SOURCE})
+source_group("include" FILES ${INCLUDE})
+source_group("interface" FILES ${PLATFORM_INTERFACE_HEADERS})
+
+set_target_properties(Diligent-ApplePlatform PROPERTIES
+    FOLDER DiligentLog/Platforms
+)
+
+if(DILIGENT_INSTALL_CORE)
+    install_core_lib__LOG(Diligent-ApplePlatform)
+endif()
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/AppleDebug.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/AppleDebug.hpp
new file mode 100644
index 00000000..1f99b2e8
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/AppleDebug.hpp
@@ -0,0 +1,43 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../Basic/interface/BasicPlatformDebug.hpp"
+
+struct AppleDebug : public BasicPlatformDebug
+{
+    static void AssertionFailed(const Diligent::Char* Message,
+                                const char*           Function, // type of __FUNCTION__
+                                const char*           File,     // type of __FILE__
+                                int                   Line);
+    static void OutputDebugMessage(Diligent::DEBUG_MESSAGE_SEVERITY Severity,
+                                   const Diligent::Char*            Message,
+                                   const char*                      Function, // type of __FUNCTION__
+                                   const char*                      File,     // type of __FILE__
+                                   int                              Line);
+};
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/AppleFileSystem.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/AppleFileSystem.hpp
new file mode 100644
index 00000000..71528b0a
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/AppleFileSystem.hpp
@@ -0,0 +1,53 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include <memory>
+#include <vector>
+
+#include "../../Basic/interface/BasicFileSystem.hpp"
+#include "../../Basic/interface/StandardFile.hpp"
+
+using AppleFile = StandardFile;
+
+struct AppleFileSystem : public BasicFileSystem
+{
+public:
+    static AppleFile* OpenFile(const FileOpenAttribs& OpenAttribs);
+
+    static inline Diligent::Char GetSlashSymbol() { return '/'; }
+
+    static bool FileExists(const Diligent::Char* strFilePath);
+    static bool PathExists(const Diligent::Char* strPath);
+
+    static bool CreateDirectory(const Diligent::Char* strPath);
+    static void ClearDirectory(const Diligent::Char* strPath);
+    static void DeleteFile(const Diligent::Char* strPath);
+
+    static std::vector<std::unique_ptr<FindFileData>> Search(const Diligent::Char* SearchPattern);
+};
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/ApplePlatformDefinitions.h b/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/ApplePlatformDefinitions.h
new file mode 100644
index 00000000..6038471a
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/ApplePlatformDefinitions.h
@@ -0,0 +1,44 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../../Primitives/interface/CommonDefinitions.h"
+
+#if DILIGENT_C_INTERFACE
+
+#    define _countof(arr) (sizeof(arr) / sizeof(arr[0]))
+
+#else
+
+#    include <cstddef>
+
+template <typename _CountofType, std::size_t _SizeOfArray>
+char (*__countof_helper(_CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];
+#    define _countof(_Array) (sizeof(*__countof_helper(_Array)) + 0)
+
+#endif
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/ApplePlatformMisc.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/ApplePlatformMisc.hpp
new file mode 100644
index 00000000..6e434e45
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/ApplePlatformMisc.hpp
@@ -0,0 +1,36 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../Basic/interface/BasicPlatformMisc.hpp"
+#include "../../Basic/interface/DebugUtilities.hpp"
+#include "../../Linux/interface/LinuxPlatformMisc.hpp"
+
+struct AppleMisc : public LinuxMisc
+{
+};
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/CFObjectWrapper.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/CFObjectWrapper.hpp
new file mode 100644
index 00000000..8d9a3d15
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/CFObjectWrapper.hpp
@@ -0,0 +1,53 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+template <typename CFType>
+class CFObjectWrapper
+{
+public:
+    CFObjectWrapper(CFType obj) :
+        m_Obj{obj}
+    {}
+
+    ~CFObjectWrapper()
+    {
+        if (m_Obj != NULL)
+        {
+            CFRelease(m_Obj);
+        }
+    }
+
+    operator CFType() { return m_Obj; }
+
+private:
+    CFType m_Obj;
+};
+
+using CFStringWrapper = CFObjectWrapper<CFStringRef>;
+using CFURLWrapper    = CFObjectWrapper<CFURLRef>;
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/IOSNativeWindow.h b/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/IOSNativeWindow.h
new file mode 100644
index 00000000..71a37c91
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/IOSNativeWindow.h
@@ -0,0 +1,48 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../../Primitives/interface/CommonDefinitions.h"
+
+DILIGENT_BEGIN_NAMESPACE(Diligent)
+
+struct IOSNativeWindow
+{
+    void* pCALayer DEFAULT_INITIALIZER(nullptr);
+
+#if DILIGENT_CPP_INTERFACE
+    IOSNativeWindow() noexcept
+    {}
+
+    explicit IOSNativeWindow(void* _pCALayer) noexcept :
+        pCALayer{_pCALayer}
+    {}
+#endif
+};
+
+DILIGENT_END_NAMESPACE // namespace Diligent
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/MacOSNativeWindow.h b/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/MacOSNativeWindow.h
new file mode 100644
index 00000000..592575d8
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/MacOSNativeWindow.h
@@ -0,0 +1,48 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../../Primitives/interface/CommonDefinitions.h"
+
+DILIGENT_BEGIN_NAMESPACE(Diligent)
+
+struct MacOSNativeWindow
+{
+    void* pNSView DEFAULT_INITIALIZER(nullptr);
+
+#if DILIGENT_CPP_INTERFACE
+    MacOSNativeWindow() noexcept
+    {}
+
+    explicit MacOSNativeWindow(void* _pNSView) noexcept :
+        pNSView(_pNSView)
+    {}
+#endif
+};
+
+DILIGENT_END_NAMESPACE // namespace Diligent
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/TVOSNativeWindow.h b/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/TVOSNativeWindow.h
new file mode 100644
index 00000000..c502515c
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/TVOSNativeWindow.h
@@ -0,0 +1,47 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../../Primitives/interface/CommonDefinitions.h"
+
+DILIGENT_BEGIN_NAMESPACE(Diligent)
+
+struct TVOSNativeWindow
+{
+    void* pCALayer DEFAULT_INITIALIZER(nullptr);
+
+#if DILIGENT_CPP_INTERFACE
+    TVOSNativeWindow() noexcept
+    {}
+
+    explicit TVOSNativeWindow(void* _pCALayer) noexcept :
+        pCALayer{_pCALayer}
+    {}
+#endif
+};
+
+DILIGENT_END_NAMESPACE // namespace Diligent
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Apple/src/AppleDebug.mm b/app/src/main/java/libengine/DiligentLog/Platforms/Apple/src/AppleDebug.mm
new file mode 100644
index 00000000..60f71f4e
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Apple/src/AppleDebug.mm
@@ -0,0 +1,59 @@
+/*     Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF ANY PROPRIETARY RIGHTS.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#include <csignal>
+#include <iostream>
+
+#import <Foundation/Foundation.h>
+
+#include "AppleDebug.hpp"
+#include "FormatString.hpp"
+
+using namespace Diligent;
+
+void AppleDebug :: AssertionFailed( const Char *Message, const char *Function, const char *File, int Line )
+{
+    auto AssertionFailedMessage = FormatAssertionFailedMessage(Message, Function, File, Line);
+    OutputDebugMessage(DEBUG_MESSAGE_SEVERITY_ERROR, AssertionFailedMessage.c_str(), nullptr, nullptr, 0);
+
+    raise( SIGTRAP );
+};
+
+
+void AppleDebug::OutputDebugMessage(DEBUG_MESSAGE_SEVERITY Severity, const Char *Message, const char *Function, const char *File, int Line)
+{
+    auto msg = FormatDebugMessage(Severity, Message, Function, File, Line);
+    // NSLog truncates the log at 1024 symbols
+    printf("%s", msg.c_str());
+    //NSLog(@"%s", str.c_str());
+}
+
+void DebugAssertionFailed(const Diligent::Char* Message, const char* Function, const char* File, int Line)
+{
+    AppleDebug :: AssertionFailed( Message, Function, File, Line );
+}
+
+namespace Diligent
+{
+DebugMessageCallbackType DebugMessageCallback = AppleDebug::OutputDebugMessage;
+}
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Apple/src/AppleFileSystem.cpp b/app/src/main/java/libengine/DiligentLog/Platforms/Apple/src/AppleFileSystem.cpp
new file mode 100644
index 00000000..1d9664c3
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Apple/src/AppleFileSystem.cpp
@@ -0,0 +1,150 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#include <stdio.h>
+#include <unistd.h>
+#include <cstdio>
+#include <CoreFoundation/CoreFoundation.h>
+
+#include "CFObjectWrapper.hpp"
+
+#include "AppleFileSystem.hpp"
+#include "Errors.hpp"
+#include "DebugUtilities.hpp"
+
+namespace
+{
+
+std::string FindResource(const std::string& FilePath)
+{
+    std::string dir, name;
+    BasicFileSystem::SplitFilePath(FilePath, &dir, &name);
+    auto        dotPos = name.find(".");
+    std::string type   = (dotPos != std::string::npos) ? name.substr(dotPos + 1) : "";
+    if (dotPos != std::string::npos)
+        name.erase(dotPos);
+
+    // Naming convention established by Core Foundation library:
+    // * If a function name contains the word "Create" or "Copy", you own the object.
+    // * If a function name contains the word "Get", you do not own the object.
+    // If you own an object, it is your responsibility to relinquish ownership
+    // (using CFRelease) when you have finished with it.
+    // https://developer.apple.com/library/content/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html
+
+    // get bundle and CFStrings
+    CFBundleRef     mainBundle       = CFBundleGetMainBundle();
+    CFStringWrapper cf_resource_path = CFStringCreateWithCString(NULL, dir.c_str(), kCFStringEncodingUTF8);
+    CFStringWrapper cf_filename      = CFStringCreateWithCString(NULL, name.c_str(), kCFStringEncodingUTF8);
+    CFStringWrapper cf_file_type     = CFStringCreateWithCString(NULL, type.c_str(), kCFStringEncodingUTF8);
+    CFURLWrapper    cf_url_resource  = CFBundleCopyResourceURL(mainBundle, cf_filename, cf_file_type, cf_resource_path);
+    std::string     resource_path;
+    if (cf_url_resource != NULL)
+    {
+        CFStringWrapper cf_url_string = CFURLCopyFileSystemPath(cf_url_resource, kCFURLPOSIXPathStyle);
+        const char*     url_string    = CFStringGetCStringPtr(cf_url_string, kCFStringEncodingUTF8);
+        resource_path                 = url_string;
+    }
+    return resource_path;
+}
+
+} // namespace
+
+AppleFile* AppleFileSystem::OpenFile(const FileOpenAttribs& OpenAttribs)
+{
+    // Try to find the file in the bundle first
+    std::string path(OpenAttribs.strFilePath);
+    CorrectSlashes(path, AppleFileSystem::GetSlashSymbol());
+    auto resource_path = FindResource(path);
+
+    AppleFile* pFile = nullptr;
+    if (!resource_path.empty())
+    {
+        try
+        {
+            FileOpenAttribs BundleResourceOpenAttribs = OpenAttribs;
+            BundleResourceOpenAttribs.strFilePath     = resource_path.c_str();
+            pFile                                     = new AppleFile(BundleResourceOpenAttribs, AppleFileSystem::GetSlashSymbol());
+        }
+        catch (const std::runtime_error& err)
+        {
+        }
+    }
+
+    if (pFile == nullptr)
+    {
+        try
+        {
+            pFile = new AppleFile(OpenAttribs, AppleFileSystem::GetSlashSymbol());
+        }
+        catch (const std::runtime_error& err)
+        {
+        }
+    }
+    return pFile;
+}
+
+
+bool AppleFileSystem::FileExists(const Diligent::Char* strFilePath)
+{
+    std::string path(strFilePath);
+    CorrectSlashes(path, AppleFileSystem::GetSlashSymbol());
+    auto resource_path = FindResource(path);
+
+    if (!FindResource(path).empty())
+        return true;
+
+    auto res = access(path.c_str(), F_OK);
+    return res == 0;
+}
+
+bool AppleFileSystem::PathExists(const Diligent::Char* strPath)
+{
+    UNSUPPORTED("Not implemented");
+    return false;
+}
+
+bool AppleFileSystem::CreateDirectory(const Diligent::Char* strPath)
+{
+    UNSUPPORTED("Not implemented");
+    return false;
+}
+
+void AppleFileSystem::ClearDirectory(const Diligent::Char* strPath)
+{
+    UNSUPPORTED("Not implemented");
+}
+
+void AppleFileSystem::DeleteFile(const Diligent::Char* strPath)
+{
+    remove(strPath);
+}
+
+std::vector<std::unique_ptr<FindFileData>> AppleFileSystem::Search(const Diligent::Char* SearchPattern)
+{
+    UNSUPPORTED("Not implemented");
+    return std::vector<std::unique_ptr<FindFileData>>();
+}
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Basic/CMakeLists.txt b/app/src/main/java/libengine/DiligentLog/Platforms/Basic/CMakeLists.txt
new file mode 100644
index 00000000..70827549
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Basic/CMakeLists.txt
@@ -0,0 +1,52 @@
+cmake_minimum_required (VERSION 3.6)
+
+project(Diligent-BasicPlatform_LOG CXX)
+
+set(SOURCE 
+    src/BasicFileSystem.cpp
+    src/BasicPlatformDebug.cpp
+)
+
+set(INTERFACE 
+    interface/BasicAtomics.hpp
+    interface/BasicFileSystem.hpp
+    interface/BasicPlatformDebug.hpp
+    interface/BasicPlatformMisc.hpp
+    interface/DebugUtilities.hpp
+)
+
+if(PLATFORM_LINUX OR PLATFORM_WIN32 OR PLATFORM_APPLE)
+    list(APPEND SOURCE src/StandardFile.cpp)
+    list(APPEND INTERFACE interface/StandardFile.hpp)
+endif()
+
+add_library(Diligent-BasicPlatform_LOG STATIC ${SOURCE} ${INTERFACE})
+set_common_target_properties__LOG(Diligent-BasicPlatform_LOG)
+
+target_include_directories(Diligent-BasicPlatform_LOG
+PUBLIC
+    interface
+)
+
+target_link_libraries(Diligent-BasicPlatform_LOG
+PRIVATE
+    Diligent-BuildSettings__LOG 
+PUBLIC
+    Diligent-Primitives
+)
+
+source_group("src" FILES ${SOURCE})
+source_group("interface" FILES ${INTERFACE})
+
+set_target_properties(Diligent-BasicPlatform_LOG PROPERTIES
+    FOLDER DiligentLog/Platforms
+)
+
+
+if(DILIGENT_INSTALL_CORE)
+    install_core_lib__LOG(Diligent-BasicPlatform_LOG)
+    get_target_relative_dir__LOG(Diligent-BasicPlatform_LOG BASIC_PLATFORM_DIR)
+    install(DIRECTORY    "../interface"
+            DESTINATION  "${CMAKE_INSTALL_INCLUDEDIR}/${BASIC_PLATFORM_DIR}/../"
+    )
+endif()
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/BasicAtomics.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/BasicAtomics.hpp
new file mode 100644
index 00000000..2ae640ec
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/BasicAtomics.hpp
@@ -0,0 +1,69 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include <atomic>
+
+struct BasicAtomics
+{
+    using Long        = long;
+    using AtomicLong  = std::atomic<Long>;
+    using Int64       = int64_t;
+    using AtomicInt64 = std::atomic<Int64>;
+
+    // The function returns the resulting INCREMENTED value.
+    template <typename Type>
+    static inline Type AtomicIncrement(std::atomic<Type>& Val)
+    {
+        return ++Val;
+    }
+
+    // The function returns the resulting DECREMENTED value.
+    template <typename Type>
+    static inline Type AtomicDecrement(std::atomic<Type>& Val)
+    {
+        return --Val;
+    }
+
+    // The function compares the Destination value with the Comparand value. If the Destination value is equal
+    // to the Comparand value, the Exchange value is stored in the address specified by Destination.
+    // Otherwise, no operation is performed.
+    // The function returns the initial value of the Destination parameter
+    template <typename Type>
+    static inline Type AtomicCompareExchange(std::atomic<Type>& Destination, Type Exchange, Type Comparand)
+    {
+        Destination.compare_exchange_strong(Comparand, Exchange);
+        return Comparand;
+    }
+
+    template <typename Type>
+    static inline Type AtomicAdd(std::atomic<Type>& Destination, Type Val)
+    {
+        return std::atomic_fetch_add(&Destination, Val);
+    }
+};
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/BasicFileSystem.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/BasicFileSystem.hpp
new file mode 100644
index 00000000..40e67e23
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/BasicFileSystem.hpp
@@ -0,0 +1,108 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include <vector>
+#include "../../../Primitives/interface/BasicTypes.h"
+
+enum class EFileAccessMode
+{
+    Read,
+    Overwrite,
+    Append
+};
+
+enum class FilePosOrigin
+{
+    Start,
+    Curr,
+    End
+};
+
+
+struct FileOpenAttribs
+{
+    const Diligent::Char* strFilePath;
+    EFileAccessMode       AccessMode;
+    FileOpenAttribs(const Diligent::Char* Path   = nullptr,
+                    EFileAccessMode       Access = EFileAccessMode::Read) :
+        strFilePath{Path},
+        AccessMode{Access}
+    {}
+};
+
+class BasicFile
+{
+public:
+    BasicFile(const FileOpenAttribs& OpenAttribs, Diligent::Char SlashSymbol);
+    virtual ~BasicFile();
+
+    const Diligent::String& GetPath() { return m_Path; }
+
+protected:
+    Diligent::String GetOpenModeStr();
+
+    FileOpenAttribs  m_OpenAttribs;
+    Diligent::String m_Path;
+};
+
+struct FindFileData
+{
+    virtual const Diligent::Char* Name() const        = 0;
+    virtual bool                  IsDirectory() const = 0;
+
+    virtual ~FindFileData() {}
+};
+
+struct BasicFileSystem
+{
+public:
+    static BasicFile* OpenFile(FileOpenAttribs& OpenAttribs);
+    static void       ReleaseFile(BasicFile*);
+
+    static std::string GetFullPath(const Diligent::Char* strFilePath);
+
+    static bool FileExists(const Diligent::Char* strFilePath);
+
+    static void SetWorkingDirectory(const Diligent::Char* strWorkingDir) { m_strWorkingDirectory = strWorkingDir; }
+
+    static const Diligent::String& GetWorkingDirectory() { return m_strWorkingDirectory; }
+
+    static Diligent::Char GetSlashSymbol();
+
+    static void CorrectSlashes(Diligent::String& Path, Diligent::Char SlashSymbol);
+
+    static void SplitFilePath(const Diligent::String& FullName,
+                              Diligent::String*       Path,
+                              Diligent::String*       Name);
+
+    static bool IsPathAbsolute(const Diligent::Char* strPath);
+
+protected:
+    static Diligent::String m_strWorkingDirectory;
+};
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/BasicPlatformDebug.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/BasicPlatformDebug.hpp
new file mode 100644
index 00000000..c44ef7cb
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/BasicPlatformDebug.hpp
@@ -0,0 +1,46 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../../Primitives/interface/Errors.hpp"
+
+struct BasicPlatformDebug
+{
+    static Diligent::String FormatAssertionFailedMessage(const Diligent::Char* Message,
+                                                         const char*           Function, // type of __FUNCTION__
+                                                         const char*           File,     // type of __FILE__
+                                                         int                   Line);
+    static Diligent::String FormatDebugMessage(Diligent::DEBUG_MESSAGE_SEVERITY Severity,
+                                               const Diligent::Char*            Message,
+                                               const char*                      Function, // type of __FUNCTION__
+                                               const char*                      File,     // type of __FILE__
+                                               int                              Line);
+};
+
+// Forward declarations of platform-specific debug functions
+void DebugAssertionFailed(const Diligent::Char* Message, const char* Function, const char* File, int Line);
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/BasicPlatformMisc.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/BasicPlatformMisc.hpp
new file mode 100644
index 00000000..5692cf9d
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/BasicPlatformMisc.hpp
@@ -0,0 +1,69 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../../Primitives/interface/BasicTypes.h"
+
+struct BasicPlatformMisc
+{
+    template <typename Type>
+    static Diligent::Uint32 GetMSB(Type Val)
+    {
+        if (Val == 0) return sizeof(Type) * 8;
+
+        Diligent::Uint32 MSB = sizeof(Type) * 8 - 1;
+        while (!(Val & (Type{1} << MSB)))
+            --MSB;
+
+        return MSB;
+    }
+
+    template <typename Type>
+    static Diligent::Uint32 GetLSB(Type Val)
+    {
+        if (Val == 0) return sizeof(Type) * 8;
+
+        Diligent::Uint32 LSB = 0;
+        while (!(Val & (Type{1} << LSB)))
+            ++LSB;
+
+        return LSB;
+    }
+
+    template <typename Type>
+    static Diligent::Uint32 CountOneBits(Type Val)
+    {
+        Diligent::Uint32 bits = 0;
+        while (Val != 0)
+        {
+            Val &= (Val - 1);
+            ++bits;
+        }
+        return bits;
+    }
+};
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/DebugUtilities.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/DebugUtilities.hpp
new file mode 100644
index 00000000..5ad0f0d5
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/DebugUtilities.hpp
@@ -0,0 +1,108 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../../Primitives/interface/FormatString.hpp"
+#include "../../../Primitives/interface/Errors.hpp"
+#include "BasicPlatformDebug.hpp"
+
+#ifdef DILIGENT_DEBUG
+
+#    include <typeinfo>
+
+#    define ASSERTION_FAILED(Message, ...)                                       \
+        do                                                                       \
+        {                                                                        \
+            auto msg = Diligent::FormatString(Message, ##__VA_ARGS__);           \
+            DebugAssertionFailed(msg.c_str(), __FUNCTION__, __FILE__, __LINE__); \
+        } while (false)
+
+#    define VERIFY(Expr, Message, ...)                    \
+        do                                                \
+        {                                                 \
+            if (!(Expr))                                  \
+            {                                             \
+                ASSERTION_FAILED(Message, ##__VA_ARGS__); \
+            }                                             \
+        } while (false)
+
+#    define UNEXPECTED  ASSERTION_FAILED
+#    define UNSUPPORTED ASSERTION_FAILED
+
+#    define VERIFY_EXPR(Expr) VERIFY(Expr, "Debug expression failed:\n", #    Expr)
+
+
+template <typename DstType, typename SrcType>
+void CheckDynamicType(SrcType* pSrcPtr)
+{
+    VERIFY(pSrcPtr == nullptr || dynamic_cast<DstType*>(pSrcPtr) != nullptr, "Dynamic type cast failed. Src typeid: \'", typeid(*pSrcPtr).name(), "\' Dst typeid: \'", typeid(DstType).name(), '\'');
+}
+#    define CHECK_DYNAMIC_TYPE(DstType, pSrcPtr) \
+        do                                       \
+        {                                        \
+            CheckDynamicType<DstType>(pSrcPtr);  \
+        } while (false)
+
+
+#else
+
+// clang-format off
+#    define CHECK_DYNAMIC_TYPE(...) do{}while(false)
+#    define VERIFY(...)do{}while(false)
+#    define UNEXPECTED(...)do{}while(false)
+#    define UNSUPPORTED(...)do{}while(false)
+#    define VERIFY_EXPR(...)do{}while(false)
+// clang-format on
+
+#endif
+
+#if defined(DILIGENT_DEBUG)
+#    define DEV_CHECK_ERR VERIFY
+#elif defined(DILIGENT_DEVELOPMENT)
+#    define DEV_CHECK_ERR CHECK_ERR
+#else
+// clang-format off
+#    define DEV_CHECK_ERR(...)do{}while(false)
+// clang-format on
+#endif
+
+#define DEV_ERROR(...) DEV_CHECK_ERR(false, __VA_ARGS__)
+
+#ifdef DILIGENT_DEVELOPMENT
+
+#    define DEV_CHECK_WARN CHECK_WARN
+#    define DEV_CHECK_INFO CHECK_INFO
+
+#else
+
+// clang-format off
+#    define DEV_CHECK_WARN(...)do{}while(false)
+#    define DEV_CHECK_INFO(...)do{}while(false)
+// clang-format on
+
+#endif
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/StandardFile.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/StandardFile.hpp
new file mode 100644
index 00000000..f567bec7
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/StandardFile.hpp
@@ -0,0 +1,55 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include <stdio.h>
+
+#include "../../../Primitives/interface/DataBlob.h"
+#include "BasicFileSystem.hpp"
+
+class StandardFile : public BasicFile
+{
+public:
+    StandardFile(const FileOpenAttribs& OpenAttribs, Diligent::Char SlashSymbol);
+    virtual ~StandardFile() override;
+
+    void Read(Diligent::IDataBlob* pData);
+
+    bool Read(void* Data, size_t Size);
+
+    bool Write(const void* Data, size_t Size);
+
+    size_t GetSize();
+
+    size_t GetPos();
+
+    void SetPos(size_t Offset, FilePosOrigin Origin);
+
+protected:
+    FILE* m_pFile = nullptr;
+};
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Basic/src/BasicFileSystem.cpp b/app/src/main/java/libengine/DiligentLog/Platforms/Basic/src/BasicFileSystem.cpp
new file mode 100644
index 00000000..23993e3a
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Basic/src/BasicFileSystem.cpp
@@ -0,0 +1,143 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#include "BasicFileSystem.hpp"
+#include "DebugUtilities.hpp"
+#include <algorithm>
+
+Diligent::String BasicFileSystem::m_strWorkingDirectory;
+
+BasicFile::BasicFile(const FileOpenAttribs& OpenAttribs, Diligent::Char SlashSymbol) :
+    m_OpenAttribs{OpenAttribs},
+    m_Path{BasicFileSystem::GetFullPath(OpenAttribs.strFilePath)}
+{
+    BasicFileSystem::CorrectSlashes(m_Path, SlashSymbol);
+
+    m_OpenAttribs.strFilePath = m_Path.c_str();
+}
+
+BasicFile::~BasicFile()
+{
+}
+
+Diligent::String BasicFile::GetOpenModeStr()
+{
+    std::string OpenModeStr;
+    switch (m_OpenAttribs.AccessMode)
+    {
+        // clang-format off
+        case EFileAccessMode::Read:      OpenModeStr += 'r'; break;
+        case EFileAccessMode::Overwrite: OpenModeStr += 'w'; break;
+        case EFileAccessMode::Append:    OpenModeStr += 'a'; break;
+        // clang-format on
+        default: break;
+    }
+
+    // Always open file in binary mode. Text mode is platform-specific
+    OpenModeStr += 'b';
+
+    return OpenModeStr;
+}
+
+
+std::string BasicFileSystem::GetFullPath(const Diligent::Char* strFilePath)
+{
+    std::string FullPath = m_strWorkingDirectory;
+    auto        len      = FullPath.length();
+    if (len > 0 && FullPath[len - 1] != '\\')
+    {
+        FullPath += '\\';
+    }
+    FullPath += strFilePath;
+    return FullPath;
+}
+
+BasicFile* BasicFileSystem::OpenFile(FileOpenAttribs& OpenAttribs)
+{
+    return nullptr;
+}
+
+void BasicFileSystem::ReleaseFile(BasicFile* pFile)
+{
+    if (pFile)
+        delete pFile;
+}
+
+bool BasicFileSystem::FileExists(const Diligent::Char* strFilePath)
+{
+    return false;
+}
+
+Diligent::Char BasicFileSystem::GetSlashSymbol()
+{
+    UNSUPPORTED("Unsupported");
+    return 0;
+}
+
+void BasicFileSystem::CorrectSlashes(Diligent::String& Path, Diligent::Char SlashSymbol)
+{
+    VERIFY(SlashSymbol == '\\' || SlashSymbol == '/',
+           "Incorrect slash symbol");
+    Diligent::Char RevSlashSym = (SlashSymbol == '\\') ? '/' : '\\';
+    std::replace(Path.begin(), Path.end(), RevSlashSym, SlashSymbol);
+}
+
+void BasicFileSystem::SplitFilePath(const Diligent::String& FullName,
+                                    Diligent::String*       Path,
+                                    Diligent::String*       Name)
+{
+    auto LastSlashPos = FullName.find_last_of("/\\");
+    if (Path)
+    {
+        if (LastSlashPos != Diligent::String::npos)
+            *Path = FullName.substr(0, LastSlashPos);
+        else
+            *Path = "";
+    }
+
+    if (Name)
+    {
+        if (LastSlashPos != Diligent::String::npos)
+            *Name = FullName.substr(LastSlashPos + 1);
+        else
+            *Name = FullName;
+    }
+}
+
+bool BasicFileSystem::IsPathAbsolute(const Diligent::Char* strPath)
+{
+    if (strPath == nullptr || strPath[0] == 0)
+        return false;
+
+#if PLATFORM_WIN32 || PLATFORM_UNIVERSAL_WINDOWS
+    return strPath[1] == ':' && (strPath[2] == '\\' || strPath[2] == '/');
+#elif PLATFORM_LINUX || PLATFORM_MACOS || PLATFORM_IOS || PLATFORM_TVOS || PLATFORM_ANDROID
+    return strPath[0] == '/';
+#else
+#    error Unknown platform.
+#endif
+}
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Basic/src/BasicPlatformDebug.cpp b/app/src/main/java/libengine/DiligentLog/Platforms/Basic/src/BasicPlatformDebug.cpp
new file mode 100644
index 00000000..afc32c82
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Basic/src/BasicPlatformDebug.cpp
@@ -0,0 +1,75 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#include "BasicPlatformDebug.hpp"
+#include "FormatString.hpp"
+#include "BasicFileSystem.hpp"
+#include <iostream>
+
+using namespace Diligent;
+
+String BasicPlatformDebug::FormatAssertionFailedMessage(const char* Message,
+                                                        const char* Function, // type of __FUNCTION__
+                                                        const char* File,     // type of __FILE__
+                                                        int         Line)
+{
+    String FileName;
+    BasicFileSystem::SplitFilePath(File, nullptr, &FileName);
+    return Diligent::FormatString("Debug assertion failed in ", Function, "(), file ", FileName, ", line ", Line, ":\n", Message);
+}
+
+String BasicPlatformDebug::FormatDebugMessage(DEBUG_MESSAGE_SEVERITY Severity,
+                                              const Char*            Message,
+                                              const char*            Function, // type of __FUNCTION__
+                                              const char*            File,     // type of __FILE__
+                                              int                    Line)
+{
+    std::stringstream msg_ss;
+
+    static const Char* const strSeverities[] = {"Info", "Warning", "ERROR", "CRITICAL ERROR"};
+    const auto*              MessageSevery   = strSeverities[static_cast<int>(Severity)];
+
+    msg_ss << "Diligent Engine: " << MessageSevery;
+    if (Function != nullptr || File != nullptr)
+    {
+        msg_ss << " in ";
+        if (Function != nullptr)
+        {
+            msg_ss << Function << "()";
+            if (File != nullptr)
+                msg_ss << " (";
+        }
+
+        if (File != nullptr)
+        {
+            msg_ss << File << ", " << Line << ')';
+        }
+    }
+    msg_ss << ": " << Message << '\n';
+
+    return msg_ss.str();
+}
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Basic/src/StandardFile.cpp b/app/src/main/java/libengine/DiligentLog/Platforms/Basic/src/StandardFile.cpp
new file mode 100644
index 00000000..f996e01d
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Basic/src/StandardFile.cpp
@@ -0,0 +1,123 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#include "StandardFile.hpp"
+#include "DebugUtilities.hpp"
+#include "Errors.hpp"
+
+StandardFile::StandardFile(const FileOpenAttribs& OpenAttribs, Diligent::Char SlashSymbol) :
+    BasicFile{OpenAttribs, SlashSymbol},
+    m_pFile{nullptr}
+{
+#if PLATFORM_LINUX || PLATFORM_MACOS || PLATFORM_IOS || PLATFORM_TVOS
+    auto OpenModeStr = GetOpenModeStr();
+    m_pFile          = fopen(m_OpenAttribs.strFilePath, OpenModeStr.c_str());
+    if (m_pFile == nullptr)
+    {
+        LOG_ERROR_AND_THROW("Failed to open file ", m_OpenAttribs.strFilePath,
+                            "\nThe following error occurred: ", strerror(errno));
+    }
+#endif
+}
+
+StandardFile::~StandardFile()
+{
+    if (m_pFile)
+    {
+        fclose(m_pFile);
+        m_pFile = nullptr;
+    }
+}
+
+void StandardFile::Read(Diligent::IDataBlob* pData)
+{
+    VERIFY_EXPR(pData != nullptr);
+    auto FileSize = GetSize();
+    pData->Resize(FileSize);
+    auto Res = Read(pData->GetDataPtr(), pData->GetSize());
+    VERIFY(Res, "Failed to read ", FileSize, " bytes from file");
+    (void)Res;
+}
+
+bool StandardFile::Read(void* Data, size_t Size)
+{
+    VERIFY(m_pFile, "File is not opened");
+    if (!m_pFile)
+        return false;
+    auto BytesRead = fread(Data, 1, Size, m_pFile);
+
+    return BytesRead == Size;
+}
+
+bool StandardFile::Write(const void* Data, size_t Size)
+{
+    VERIFY(m_pFile, "File is not opened");
+    if (!m_pFile)
+        return false;
+    auto BytesWritten = fwrite(Data, 1, Size, m_pFile);
+
+    return BytesWritten == Size;
+}
+
+size_t StandardFile::GetSize()
+{
+    auto OrigPos = ftell(m_pFile);
+    fseek(m_pFile, 0, SEEK_END);
+    auto FileSize = ftell(m_pFile);
+
+    fseek(m_pFile, OrigPos, SEEK_SET);
+    return FileSize;
+}
+
+size_t StandardFile::GetPos()
+{
+    VERIFY(m_pFile, "File is not opened");
+    if (!m_pFile)
+        return 0;
+
+    return ftell(m_pFile);
+}
+
+void StandardFile::SetPos(size_t Offset, FilePosOrigin Origin)
+{
+    VERIFY(m_pFile, "File is not opened");
+    if (!m_pFile)
+        return;
+
+    int orig = SEEK_SET;
+    switch (Origin)
+    {
+        // clang-format off
+        case FilePosOrigin::Start: orig = SEEK_SET; break;
+        case FilePosOrigin::Curr:  orig = SEEK_CUR; break;
+        case FilePosOrigin::End:   orig = SEEK_END; break;
+        // clang-format on
+        default: UNEXPECTED("Unknown origin");
+    }
+
+    fseek(m_pFile, static_cast<long>(Offset), orig);
+}
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/CMakeLists.txt b/app/src/main/java/libengine/DiligentLog/Platforms/CMakeLists.txt
new file mode 100644
index 00000000..d50d1469
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/CMakeLists.txt
@@ -0,0 +1,40 @@
+cmake_minimum_required (VERSION 3.6)
+
+add_library(Diligent-PlatformInterface INTERFACE)
+
+target_include_directories(Diligent-PlatformInterface INTERFACE interface)
+
+set(PLATFORM_INTERFACE_HEADERS
+	../interface/Atomics.hpp
+	../interface/FileSystem.hpp
+	../interface/PlatformDebug.hpp
+	../interface/PlatformDefinitions.h
+	../interface/PlatformMisc.hpp
+	../interface/NativeWindow.h
+)
+
+add_subdirectory(Basic)
+
+set(WAS_SHARED ${BUILD_SHARED_LIBS})
+set(BUILD_SHARED_LIBS OFF CACHE BOOL " " FORCE)
+
+if(PLATFORM_WIN32)
+	add_subdirectory(Win32)
+	add_library(Diligent-TargetPlatform ALIAS Diligent-Win32Platform)
+elseif(PLATFORM_UNIVERSAL_WINDOWS)
+	add_subdirectory(UWP)
+	add_library(Diligent-TargetPlatform ALIAS Diligent-UniversalWindowsPlatform)
+elseif(PLATFORM_ANDROID)
+	add_subdirectory(Android)
+	add_library(Diligent-TargetPlatform ALIAS Diligent-AndroidPlatform_LOG)
+elseif(PLATFORM_LINUX)
+	add_subdirectory(Linux)
+	add_library(Diligent-TargetPlatform ALIAS Diligent-LinuxPlatform)
+elseif(PLATFORM_APPLE)
+	add_subdirectory(Apple)
+	add_library(Diligent-TargetPlatform ALIAS Diligent-ApplePlatform)
+else()
+	message(FATAL_ERROR "No PLATFORM_XXX variable defined. Make sure that 'DiligentCore' folder is processed first")
+endif()
+
+set(BUILD_SHARED_LIBS ${WAS_SHARED} CACHE BOOL " " FORCE)
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Linux/CMakeLists.txt b/app/src/main/java/libengine/DiligentLog/Platforms/Linux/CMakeLists.txt
new file mode 100644
index 00000000..f77f676e
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Linux/CMakeLists.txt
@@ -0,0 +1,44 @@
+cmake_minimum_required (VERSION 3.6)
+
+project(Diligent-LinuxPlatform CXX)
+
+set(INTERFACE 
+    interface/LinuxDebug.hpp
+    interface/LinuxFileSystem.hpp
+    interface/LinuxPlatformDefinitions.h
+    interface/LinuxPlatformMisc.hpp
+    interface/LinuxNativeWindow.h
+)
+
+set(SOURCE 
+    src/LinuxDebug.cpp
+    src/LinuxFileSystem.cpp
+)
+
+add_library(Diligent-LinuxPlatform ${SOURCE} ${INTERFACE} ${PLATFORM_INTERFACE_HEADERS})
+set_common_target_properties__LOG(Diligent-LinuxPlatform)
+
+target_include_directories(Diligent-LinuxPlatform 
+PUBLIC
+    interface
+)
+
+target_link_libraries(Diligent-LinuxPlatform 
+PRIVATE
+    Diligent-BuildSettings__LOG 
+PUBLIC
+    Diligent-BasicPlatform_LOG
+    Diligent-PlatformInterface
+)
+
+source_group("src" FILES ${SOURCE})
+source_group("include" FILES ${INCLUDE})
+source_group("interface" FILES ${PLATFORM_INTERFACE_HEADERS})
+
+set_target_properties(Diligent-LinuxPlatform PROPERTIES
+    FOLDER DiligentLog/Platforms
+)
+
+if(DILIGENT_INSTALL_CORE)
+    install_core_lib__LOG(Diligent-LinuxPlatform)
+endif()
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Linux/interface/LinuxDebug.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/Linux/interface/LinuxDebug.hpp
new file mode 100644
index 00000000..68a91e37
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Linux/interface/LinuxDebug.hpp
@@ -0,0 +1,43 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../Basic/interface/BasicPlatformDebug.hpp"
+
+struct LinuxDebug : public BasicPlatformDebug
+{
+    static void AssertionFailed(const Diligent::Char* Message,
+                                const char*           Function, // type of __FUNCTION__
+                                const char*           File,     // type of __FILE__
+                                int                   Line);
+    static void OutputDebugMessage(Diligent::DEBUG_MESSAGE_SEVERITY Severity,
+                                   const Diligent::Char*            Message,
+                                   const char*                      Function, // type of __FUNCTION__
+                                   const char*                      File,     // type of __FILE__
+                                   int                              Line);
+};
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Linux/interface/LinuxFileSystem.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/Linux/interface/LinuxFileSystem.hpp
new file mode 100644
index 00000000..9025360c
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Linux/interface/LinuxFileSystem.hpp
@@ -0,0 +1,53 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include <memory>
+#include <vector>
+
+#include "../../Basic/interface/BasicFileSystem.hpp"
+#include "../../Basic/interface/StandardFile.hpp"
+
+using LinuxFile = StandardFile;
+
+struct LinuxFileSystem : public BasicFileSystem
+{
+public:
+    static LinuxFile* OpenFile(const FileOpenAttribs& OpenAttribs);
+
+    static inline Diligent::Char GetSlashSymbol() { return '/'; }
+
+    static bool FileExists(const Diligent::Char* strFilePath);
+    static bool PathExists(const Diligent::Char* strPath);
+
+    static bool CreateDirectory(const Diligent::Char* strPath);
+    static void ClearDirectory(const Diligent::Char* strPath);
+    static void DeleteFile(const Diligent::Char* strPath);
+
+    static std::vector<std::unique_ptr<FindFileData>> Search(const Diligent::Char* SearchPattern);
+};
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Linux/interface/LinuxNativeWindow.h b/app/src/main/java/libengine/DiligentLog/Platforms/Linux/interface/LinuxNativeWindow.h
new file mode 100644
index 00000000..a7d1b87c
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Linux/interface/LinuxNativeWindow.h
@@ -0,0 +1,42 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../../Primitives/interface/CommonDefinitions.h"
+#include "../../../Primitives/interface/BasicTypes.h"
+
+DILIGENT_BEGIN_NAMESPACE(Diligent)
+
+struct LinuxNativeWindow
+{
+    Uint32 WindowId      DEFAULT_INITIALIZER(0);
+    void* pDisplay       DEFAULT_INITIALIZER(nullptr);
+    void* pXCBConnection DEFAULT_INITIALIZER(nullptr);
+};
+
+DILIGENT_END_NAMESPACE // namespace Diligent
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Linux/interface/LinuxPlatformDefinitions.h b/app/src/main/java/libengine/DiligentLog/Platforms/Linux/interface/LinuxPlatformDefinitions.h
new file mode 100644
index 00000000..6038471a
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Linux/interface/LinuxPlatformDefinitions.h
@@ -0,0 +1,44 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../../Primitives/interface/CommonDefinitions.h"
+
+#if DILIGENT_C_INTERFACE
+
+#    define _countof(arr) (sizeof(arr) / sizeof(arr[0]))
+
+#else
+
+#    include <cstddef>
+
+template <typename _CountofType, std::size_t _SizeOfArray>
+char (*__countof_helper(_CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];
+#    define _countof(_Array) (sizeof(*__countof_helper(_Array)) + 0)
+
+#endif
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Linux/interface/LinuxPlatformMisc.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/Linux/interface/LinuxPlatformMisc.hpp
new file mode 100644
index 00000000..3df07bc9
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Linux/interface/LinuxPlatformMisc.hpp
@@ -0,0 +1,102 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../Basic/interface/BasicPlatformMisc.hpp"
+#include "../../Basic/interface/DebugUtilities.hpp"
+
+struct LinuxMisc : public BasicPlatformMisc
+{
+    static Diligent::Uint32 GetMSB(Diligent::Uint32 Val)
+    {
+        if (Val == 0) return 32;
+
+        // Returns the number of leading 0-bits in x, starting at the
+        // most significant bit position. If x is 0, the result is undefined.
+        int  LeadingZeros = __builtin_clz(Val);
+        auto MSB          = static_cast<Diligent::Uint32>(31 - LeadingZeros);
+        VERIFY_EXPR(MSB == BasicPlatformMisc::GetMSB(Val));
+
+        return MSB;
+    }
+
+    static Diligent::Uint32 GetLSB(Diligent::Uint32 Val)
+    {
+        if (Val == 0) return 32;
+
+        // Returns the number of trailing 0-bits in x, starting at the
+        // least significant bit position. If x is 0, the result is undefined.
+        auto TrailingZeros = __builtin_ctz(Val);
+        auto LSB           = static_cast<Diligent::Uint32>(TrailingZeros);
+        VERIFY_EXPR(LSB == BasicPlatformMisc::GetLSB(Val));
+
+        return LSB;
+    }
+
+    static Diligent::Uint32 GetMSB(Diligent::Uint64 Val)
+    {
+        if (Val == 0) return 64;
+
+        // Returns the number of leading 0-bits in x, starting at the
+        // most significant bit position. If x is 0, the result is undefined.
+        int  LeadingZeros = __builtin_clzll(Val);
+        auto MSB          = static_cast<Diligent::Uint32>(63 - LeadingZeros);
+        VERIFY_EXPR(MSB == BasicPlatformMisc::GetMSB(Val));
+
+        return MSB;
+    }
+
+    static Diligent::Uint32 GetLSB(Diligent::Uint64 Val)
+    {
+        if (Val == 0) return 64;
+
+        // Returns the number of trailing 0-bits in x, starting at the
+        // least significant bit position. If x is 0, the result is undefined.
+        auto TrailingZeros = __builtin_ctzll(Val);
+        auto LSB           = static_cast<Diligent::Uint32>(TrailingZeros);
+        VERIFY_EXPR(LSB == BasicPlatformMisc::GetLSB(Val));
+
+        return LSB;
+    }
+
+    static Diligent::Uint32 CountOneBits(Diligent::Uint32 Val)
+    {
+        // Returns the number of 1-bits in x.
+        auto bits = static_cast<Diligent::Uint32>(__builtin_popcount(Val));
+        VERIFY_EXPR(bits == BasicPlatformMisc::CountOneBits(Val));
+        return bits;
+    }
+
+    static Diligent::Uint32 CountOneBits(Diligent::Uint64 Val)
+    {
+        // Returns the number of 1-bits in x.
+        auto bits = static_cast<Diligent::Uint32>(__builtin_popcountll(Val));
+        VERIFY_EXPR(bits == BasicPlatformMisc::CountOneBits(Val));
+        return bits;
+    }
+};
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Linux/src/LinuxDebug.cpp b/app/src/main/java/libengine/DiligentLog/Platforms/Linux/src/LinuxDebug.cpp
new file mode 100644
index 00000000..1145f1f0
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Linux/src/LinuxDebug.cpp
@@ -0,0 +1,61 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#include <csignal>
+#include <iostream>
+
+#include "LinuxDebug.hpp"
+#include "FormatString.hpp"
+
+using namespace Diligent;
+
+void LinuxDebug ::AssertionFailed(const Char* Message, const char* Function, const char* File, int Line)
+{
+    auto AssertionFailedMessage = FormatAssertionFailedMessage(Message, Function, File, Line);
+    OutputDebugMessage(DEBUG_MESSAGE_SEVERITY_ERROR, AssertionFailedMessage.c_str(), nullptr, nullptr, 0);
+
+    raise(SIGTRAP);
+};
+
+
+void LinuxDebug::OutputDebugMessage(DEBUG_MESSAGE_SEVERITY Severity, const Char* Message, const char* Function, const char* File, int Line)
+{
+    auto msg = FormatDebugMessage(Severity, Message, Function, File, Line);
+    std::cerr << msg;
+}
+
+void DebugAssertionFailed(const Diligent::Char* Message, const char* Function, const char* File, int Line)
+{
+    LinuxDebug ::AssertionFailed(Message, Function, File, Line);
+}
+
+namespace Diligent
+{
+
+DebugMessageCallbackType DebugMessageCallback = LinuxDebug::OutputDebugMessage;
+
+}
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Linux/src/LinuxFileSystem.cpp b/app/src/main/java/libengine/DiligentLog/Platforms/Linux/src/LinuxFileSystem.cpp
new file mode 100644
index 00000000..1e0582a6
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Linux/src/LinuxFileSystem.cpp
@@ -0,0 +1,89 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#include <stdio.h>
+#include <unistd.h>
+#include <cstdio>
+
+#include "LinuxFileSystem.hpp"
+#include "Errors.hpp"
+#include "DebugUtilities.hpp"
+
+LinuxFile* LinuxFileSystem::OpenFile(const FileOpenAttribs& OpenAttribs)
+{
+    LinuxFile* pFile = nullptr;
+    try
+    {
+        pFile = new LinuxFile(OpenAttribs, LinuxFileSystem::GetSlashSymbol());
+    }
+    catch (const std::runtime_error& err)
+    {
+    }
+    return pFile;
+}
+
+
+bool LinuxFileSystem::FileExists(const Diligent::Char* strFilePath)
+{
+    FileOpenAttribs OpenAttribs;
+    OpenAttribs.strFilePath = strFilePath;
+    BasicFile   DummyFile(OpenAttribs, LinuxFileSystem::GetSlashSymbol());
+    const auto& Path   = DummyFile.GetPath(); // This is necessary to correct slashes
+    FILE*       pFile  = fopen(Path.c_str(), "r");
+    bool        Exists = (pFile != nullptr);
+    if (Exists)
+        fclose(pFile);
+    return Exists;
+}
+
+bool LinuxFileSystem::PathExists(const Diligent::Char* strPath)
+{
+    UNSUPPORTED("Not implemented");
+    return false;
+}
+
+bool LinuxFileSystem::CreateDirectory(const Diligent::Char* strPath)
+{
+    UNSUPPORTED("Not implemented");
+    return false;
+}
+
+void LinuxFileSystem::ClearDirectory(const Diligent::Char* strPath)
+{
+    UNSUPPORTED("Not implemented");
+}
+
+void LinuxFileSystem::DeleteFile(const Diligent::Char* strPath)
+{
+    remove(strPath);
+}
+
+std::vector<std::unique_ptr<FindFileData>> LinuxFileSystem::Search(const Diligent::Char* SearchPattern)
+{
+    UNSUPPORTED("Not implemented");
+    return std::vector<std::unique_ptr<FindFileData>>();
+}
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/UWP/CMakeLists.txt b/app/src/main/java/libengine/DiligentLog/Platforms/UWP/CMakeLists.txt
new file mode 100644
index 00000000..ce52bbb0
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/UWP/CMakeLists.txt
@@ -0,0 +1,46 @@
+cmake_minimum_required (VERSION 3.8)
+
+project(Diligent-UniversalWindowsPlatform CXX)
+
+set(INTERFACE 
+    interface/UWPDebug.hpp
+    interface/UWPFileSystem.hpp
+    interface/UWPDefinitions.h
+    interface/UWPNativeWindow.h
+    ../Win32/interface/Win32Atomics.hpp
+)
+
+set(SOURCE 
+    src/UWPDebug.cpp
+    src/UWPFileSystem.cpp
+    ../Win32/src/Win32Atomics.cpp
+)
+
+add_library(Diligent-UniversalWindowsPlatform ${SOURCE} ${INTERFACE} ${PLATFORM_INTERFACE_HEADERS})
+set_common_target_properties__LOG(Diligent-UniversalWindowsPlatform)
+
+target_include_directories(Diligent-UniversalWindowsPlatform 
+PUBLIC
+    ../Win32/interface
+    interface
+)
+
+target_link_libraries(Diligent-UniversalWindowsPlatform 
+PRIVATE
+    Diligent-BuildSettings__LOG 
+PUBLIC
+    Diligent-BasicPlatform_LOG
+    Diligent-PlatformInterface
+)
+
+source_group("src" FILES ${SOURCE})
+source_group("interface\\UWP" FILES ${INTERFACE})
+source_group("interface\\common" FILES ${PLATFORM_INTERFACE_HEADERS})
+
+set_target_properties(Diligent-UniversalWindowsPlatform PROPERTIES
+    FOLDER DiligentLog/Platforms
+)
+
+if(DILIGENT_INSTALL_CORE)
+    install_core_lib__LOG(Diligent-UniversalWindowsPlatform)
+endif()
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/UWP/interface/UWPDebug.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/UWP/interface/UWPDebug.hpp
new file mode 100644
index 00000000..31e77041
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/UWP/interface/UWPDebug.hpp
@@ -0,0 +1,43 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../Basic/interface/BasicPlatformDebug.hpp"
+
+struct WindowsStoreDebug : public BasicPlatformDebug
+{
+    static void AssertionFailed(const Diligent::Char* Message,
+                                const char*           Function, // type of __FUNCTION__
+                                const char*           File,     // type of __FILE__
+                                int                   Line);
+    static void OutputDebugMessage(Diligent::DEBUG_MESSAGE_SEVERITY Severity,
+                                   const Diligent::Char*            Message,
+                                   const char*                      Function, // type of __FUNCTION__
+                                   const char*                      File,     // type of __FILE__
+                                   int                              Line);
+};
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/UWP/interface/UWPDefinitions.h b/app/src/main/java/libengine/DiligentLog/Platforms/UWP/interface/UWPDefinitions.h
new file mode 100644
index 00000000..ca1e60b1
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/UWP/interface/UWPDefinitions.h
@@ -0,0 +1,30 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../../Primitives/interface/CommonDefinitions.h"
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/UWP/interface/UWPFileSystem.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/UWP/interface/UWPFileSystem.hpp
new file mode 100644
index 00000000..978b07cf
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/UWP/interface/UWPFileSystem.hpp
@@ -0,0 +1,80 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include <memory>
+
+#include "../../Basic/interface/BasicFileSystem.hpp"
+#include "../../../Primitives/interface/DataBlob.h"
+
+// Do not include windows headers here as they will mess up CreateDirectory()
+// and DeleteFile() functions!
+//#define NOMINMAX
+//#include <wrl.h>
+
+class WindowsStoreFile : public BasicFile
+{
+public:
+    WindowsStoreFile(const FileOpenAttribs& OpenAttribs);
+    ~WindowsStoreFile();
+
+    void Read(Diligent::IDataBlob* pData);
+
+    bool Read(void* Data, size_t BufferSize);
+
+    void Write(Diligent::IDataBlob* pData);
+    bool Write(const void* Data, size_t BufferSize);
+
+    size_t GetSize();
+
+    size_t GetPos();
+
+    void SetPos(size_t Offset, FilePosOrigin Origin);
+
+private:
+    // We have to do such tricks, because we cannot #include <wrl.h>
+    // to avoid name clashes.
+    std::unique_ptr<class FileHandleWrapper> m_FileHandle;
+};
+
+struct WindowsStoreFileSystem : public BasicFileSystem
+{
+public:
+    static WindowsStoreFile* OpenFile(const FileOpenAttribs& OpenAttribs);
+
+    static inline Diligent::Char GetSlashSymbol() { return '\\'; }
+
+    static bool FileExists(const Diligent::Char* strFilePath);
+    static bool PathExists(const Diligent::Char* strPath);
+
+    static bool CreateDirectory(const Diligent::Char* strPath);
+    static void ClearDirectory(const Diligent::Char* strPath);
+    static void DeleteFile(const Diligent::Char* strPath);
+
+    static std::vector<std::unique_ptr<FindFileData>> Search(const Diligent::Char* SearchPattern);
+};
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/UWP/interface/UWPNativeWindow.h b/app/src/main/java/libengine/DiligentLog/Platforms/UWP/interface/UWPNativeWindow.h
new file mode 100644
index 00000000..53e6032d
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/UWP/interface/UWPNativeWindow.h
@@ -0,0 +1,49 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../../Primitives/interface/CommonDefinitions.h"
+
+DILIGENT_BEGIN_NAMESPACE(Diligent)
+
+struct UWPNativeWindow
+{
+    /// Windows::UI::Core::CoreWindow
+    void* pCoreWindow DEFAULT_INITIALIZER(nullptr);
+
+#if DILIGENT_CPP_INTERFACE
+    UWPNativeWindow() noexcept
+    {}
+
+    explicit UWPNativeWindow(void* _pCoreWindow) noexcept :
+        pCoreWindow{_pCoreWindow}
+    {}
+#endif
+};
+
+DILIGENT_END_NAMESPACE // namespace Diligent
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/UWP/src/UWPDebug.cpp b/app/src/main/java/libengine/DiligentLog/Platforms/UWP/src/UWPDebug.cpp
new file mode 100644
index 00000000..2641966e
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/UWP/src/UWPDebug.cpp
@@ -0,0 +1,89 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#include "UWPDebug.hpp"
+#include "FormatString.hpp"
+#include <csignal>
+
+#define NOMINMAX
+#include <windows.h>
+
+using namespace Diligent;
+
+void WindowsStoreDebug ::AssertionFailed(const Diligent::Char* Message, const char* Function, const char* File, int Line)
+{
+    auto AssertionFailedMessage = FormatAssertionFailedMessage(Message, Function, File, Line);
+    OutputDebugMessage(DEBUG_MESSAGE_SEVERITY_ERROR, AssertionFailedMessage.c_str(), nullptr, nullptr, 0);
+
+    __debugbreak();
+    //int nCode = MessageBoxA(NULL,
+    //                        FullMsg.c_str(),
+    //                        "Runtime assertion failed",
+    //                        MB_TASKMODAL|MB_ICONHAND|MB_ABORTRETRYIGNORE|MB_SETFOREGROUND);
+
+    //// Abort: abort the program
+    //if (nCode == IDABORT)
+    //{
+    //    // raise abort signal
+    //    raise(SIGABRT);
+
+    //    // We usually won't get here, but it's possible that
+    //    //  SIGABRT was ignored.  So exit the program anyway.
+    //    exit(3);
+    //}
+
+    //// Retry: call the debugger
+    //if (nCode == IDRETRY)
+    //{
+    //    DebugBreak();
+    //    /* return to user code */
+    //    return;
+    //}
+
+    //// Ignore: continue execution
+    //if (nCode == IDIGNORE)
+    //    return;
+};
+
+
+void WindowsStoreDebug::OutputDebugMessage(DEBUG_MESSAGE_SEVERITY Severity, const Char* Message, const char* Function, const char* File, int Line)
+{
+    auto msg = FormatDebugMessage(Severity, Message, Function, File, Line);
+    OutputDebugStringA(msg.c_str());
+}
+
+void DebugAssertionFailed(const Diligent::Char* Message, const char* Function, const char* File, int Line)
+{
+    WindowsStoreDebug ::AssertionFailed(Message, Function, File, Line);
+}
+
+namespace Diligent
+{
+
+DebugMessageCallbackType DebugMessageCallback = WindowsStoreDebug::OutputDebugMessage;
+
+}
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/UWP/src/UWPFileSystem.cpp b/app/src/main/java/libengine/DiligentLog/Platforms/UWP/src/UWPFileSystem.cpp
new file mode 100644
index 00000000..3460bca4
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/UWP/src/UWPFileSystem.cpp
@@ -0,0 +1,277 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#include "UWPFileSystem.hpp"
+#include "Errors.hpp"
+#include "../../Common/interface/StringTools.hpp"
+#include "DebugUtilities.hpp"
+
+
+// Windows headers define CreateDirectory and DeleteFile as macros.
+// So we need to do some tricks to avoid name mess.
+bool CreateDirectoryImpl(const Diligent::Char* strPath);
+
+bool WindowsStoreFileSystem::CreateDirectory(const Diligent::Char* strPath)
+{
+    return CreateDirectoryImpl(strPath);
+}
+
+void DeleteFileImpl(const Diligent::Char* strPath);
+
+void WindowsStoreFileSystem::DeleteFile(const Diligent::Char* strPath)
+{
+    return DeleteFileImpl(strPath);
+}
+
+
+#define NOMINMAX
+#include <wrl.h>
+
+using namespace Diligent;
+using namespace Microsoft::WRL;
+
+class FileHandleWrapper
+{
+public:
+    Wrappers::FileHandle FH;
+};
+
+WindowsStoreFile::WindowsStoreFile(const FileOpenAttribs& OpenAttribs) :
+    BasicFile(OpenAttribs, WindowsStoreFileSystem::GetSlashSymbol()),
+    m_FileHandle(new FileHandleWrapper)
+{
+    CREATEFILE2_EXTENDED_PARAMETERS extendedParams = {0};
+
+    extendedParams.dwSize               = sizeof(CREATEFILE2_EXTENDED_PARAMETERS);
+    extendedParams.dwFileAttributes     = FILE_ATTRIBUTE_NORMAL;
+    extendedParams.dwFileFlags          = FILE_FLAG_SEQUENTIAL_SCAN;
+    extendedParams.dwSecurityQosFlags   = SECURITY_ANONYMOUS;
+    extendedParams.lpSecurityAttributes = nullptr;
+    extendedParams.hTemplateFile        = nullptr;
+
+    auto  wstrPath           = Diligent::WidenString(m_OpenAttribs.strFilePath);
+    DWORD dwDesiredAccess    = 0;
+    DWORD dwShareMode        = 0;
+    DWORD dwCreateDeposition = 0;
+    switch (OpenAttribs.AccessMode)
+    {
+        case EFileAccessMode::Read:
+            dwDesiredAccess = GENERIC_READ;
+            // In Windows 8.1, the file cannot be opened if it is not shared!
+            dwShareMode        = FILE_SHARE_READ;
+            dwCreateDeposition = OPEN_EXISTING;
+            break;
+
+        case EFileAccessMode::Overwrite:
+            dwDesiredAccess    = GENERIC_WRITE;
+            dwShareMode        = 0;
+            dwCreateDeposition = CREATE_ALWAYS;
+            break;
+
+        case EFileAccessMode::Append:
+            dwDesiredAccess    = GENERIC_WRITE;
+            dwShareMode        = 0;
+            dwCreateDeposition = OPEN_ALWAYS;
+            break;
+
+        default:
+            UNEXPECTED("Unknown file access mode");
+            break;
+    }
+    m_FileHandle->FH.Attach(CreateFile2(
+        wstrPath.c_str(),
+        dwDesiredAccess,
+        dwShareMode,
+        dwCreateDeposition,
+        &extendedParams));
+
+    if (m_FileHandle->FH.Get() == INVALID_HANDLE_VALUE)
+    {
+        LOG_ERROR_AND_THROW("Failed to open file ", m_OpenAttribs.strFilePath);
+    }
+}
+
+WindowsStoreFile::~WindowsStoreFile()
+{
+}
+
+bool WindowsStoreFile::Read(void* Data, size_t BufferSize)
+{
+    DWORD BytesRead = 0;
+    if (!ReadFile(
+            m_FileHandle->FH.Get(),
+            Data,
+            static_cast<DWORD>(BufferSize),
+            &BytesRead,
+            nullptr))
+    {
+        return false;
+    }
+
+    return BytesRead == BufferSize;
+}
+
+size_t WindowsStoreFile::GetSize()
+{
+    FILE_STANDARD_INFO fileInfo = {0};
+    if (!GetFileInformationByHandleEx(
+            m_FileHandle->FH.Get(),
+            FileStandardInfo,
+            &fileInfo,
+            sizeof(fileInfo)))
+    {
+        LOG_ERROR_AND_THROW("Failed to get file info");
+    }
+
+    if (fileInfo.EndOfFile.HighPart != 0)
+    {
+        LOG_ERROR_AND_THROW("File is too large to be read");
+    }
+
+    return fileInfo.EndOfFile.LowPart;
+}
+
+void WindowsStoreFile::Read(Diligent::IDataBlob* pData)
+{
+    pData->Resize(GetSize());
+
+    if (!Read(pData->GetDataPtr(), pData->GetSize()))
+    {
+        LOG_ERROR_AND_THROW("Failed to read data from file");
+    }
+}
+
+void WindowsStoreFile::Write(Diligent::IDataBlob* pData)
+{
+    DWORD numBytesWritten;
+    if (!WriteFile(
+            m_FileHandle->FH.Get(),
+            pData->GetDataPtr(),
+            static_cast<DWORD>(pData->GetSize()),
+            &numBytesWritten,
+            nullptr) ||
+        numBytesWritten != pData->GetSize())
+    {
+        LOG_ERROR_AND_THROW("Failed to write data to file");
+    }
+}
+
+bool WindowsStoreFile::Write(const void* Data, size_t BufferSize)
+{
+    UNSUPPORTED("Not implemented");
+    return false;
+}
+
+size_t WindowsStoreFile::GetPos()
+{
+    UNSUPPORTED("Not implemented");
+    return 0;
+}
+
+void WindowsStoreFile::SetPos(size_t Offset, FilePosOrigin Origin)
+{
+    UNSUPPORTED("Not implemented");
+}
+
+
+WindowsStoreFile* WindowsStoreFileSystem::OpenFile(const FileOpenAttribs& OpenAttribs)
+{
+    WindowsStoreFile* pFile = nullptr;
+    try
+    {
+        pFile = new WindowsStoreFile(OpenAttribs);
+    }
+    catch (const std::runtime_error& /*err*/)
+    {
+    }
+
+    return pFile;
+}
+
+bool WindowsStoreFileSystem::FileExists(const Diligent::Char* strFilePath)
+{
+    FileOpenAttribs OpenAttribs;
+    OpenAttribs.AccessMode  = EFileAccessMode::Read;
+    OpenAttribs.strFilePath = strFilePath;
+    BasicFile   DummyFile(OpenAttribs, WindowsStoreFileSystem::GetSlashSymbol());
+    const auto& Path = DummyFile.GetPath();
+
+    CREATEFILE2_EXTENDED_PARAMETERS extendedParams = {0};
+
+    extendedParams.dwSize               = sizeof(CREATEFILE2_EXTENDED_PARAMETERS);
+    extendedParams.dwFileAttributes     = FILE_ATTRIBUTE_NORMAL;
+    extendedParams.dwFileFlags          = FILE_FLAG_SEQUENTIAL_SCAN;
+    extendedParams.dwSecurityQosFlags   = SECURITY_ANONYMOUS;
+    extendedParams.lpSecurityAttributes = nullptr;
+    extendedParams.hTemplateFile        = nullptr;
+
+    auto wstrPath = Diligent::WidenString(Path);
+
+    auto Handle = CreateFile2(
+        wstrPath.c_str(),
+        GENERIC_READ,
+        FILE_SHARE_READ,
+        OPEN_EXISTING,
+        &extendedParams);
+    bool Exists = false;
+    if (Handle != INVALID_HANDLE_VALUE)
+    {
+        CloseHandle(Handle);
+        Exists = true;
+    }
+    return Exists;
+}
+
+
+bool WindowsStoreFileSystem::PathExists(const Diligent::Char* strPath)
+{
+    UNSUPPORTED("Not implemented");
+    return false;
+}
+
+void WindowsStoreFileSystem::ClearDirectory(const Diligent::Char* strPath)
+{
+    UNSUPPORTED("Not implemented");
+}
+
+
+bool CreateDirectoryImpl(const Diligent::Char* strPath)
+{
+    UNSUPPORTED("Not implemented");
+    return false;
+}
+
+void DeleteFileImpl(const Diligent::Char* strPath)
+{
+    UNSUPPORTED("Not implemented");
+}
+
+std::vector<std::unique_ptr<FindFileData>> WindowsStoreFileSystem::Search(const Diligent::Char* SearchPattern)
+{
+    UNSUPPORTED("Not implemented");
+    return std::vector<std::unique_ptr<FindFileData>>();
+}
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Win32/CMakeLists.txt b/app/src/main/java/libengine/DiligentLog/Platforms/Win32/CMakeLists.txt
new file mode 100644
index 00000000..fd213a65
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Win32/CMakeLists.txt
@@ -0,0 +1,47 @@
+cmake_minimum_required (VERSION 3.3)
+
+project(WindowsPlatform CXX)
+
+set(INTERFACE
+    interface/Win32Atomics.hpp
+    interface/Win32Debug.hpp
+    interface/Win32FileSystem.hpp
+    interface/Win32PlatformDefinitions.h
+    interface/Win32PlatformMisc.hpp
+    interface/Win32NativeWindow.h
+)
+
+set(SOURCE 
+    src/Win32Atomics.cpp
+    src/Win32Debug.cpp
+    src/Win32FileSystem.cpp
+)
+
+add_library(Diligent-Win32Platform ${SOURCE} ${INTERFACE} ${PLATFORM_INTERFACE_HEADERS})
+set_common_target_properties__LOG(Diligent-Win32Platform)
+
+target_include_directories(Diligent-Win32Platform 
+PUBLIC
+    interface
+)
+
+target_link_libraries(Diligent-Win32Platform 
+PUBLIC
+    Diligent-BasicPlatform_LOG
+    Diligent-PlatformInterface
+PRIVATE
+    Diligent-BuildSettings
+    Shlwapi.lib
+)
+
+source_group("src" FILES ${SOURCE})
+source_group("interface\\win32" FILES ${INTERFACE})
+source_group("interface\\common" FILES ${PLATFORM_INTERFACE_HEADERS})
+
+set_target_properties(Diligent-Win32Platform PROPERTIES
+    FOLDER DiligentLog/Platforms
+)
+
+if(DILIGENT_INSTALL_CORE)
+    install_core_lib__LOG(Diligent-Win32Platform)
+endif()
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32Atomics.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32Atomics.hpp
new file mode 100644
index 00000000..987fef7f
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32Atomics.hpp
@@ -0,0 +1,55 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+struct WindowsAtomics
+{
+    // Use windows-specific atomics. Standard atomic eventually call
+    // the same functions, but introduce significant overhead
+    using Long        = long;
+    using AtomicLong  = volatile long;
+    using Int64       = long long;
+    using AtomicInt64 = volatile long long;
+
+    // The function returns the resulting INCREMENTED value.
+    static Long  AtomicIncrement(AtomicLong& Val);
+    static Int64 AtomicIncrement(AtomicInt64& Val);
+
+    // The function returns the resulting DECREMENTED value.
+    static Long  AtomicDecrement(AtomicLong& Val);
+    static Int64 AtomicDecrement(AtomicInt64& Val);
+
+    // The function compares the Destination value with the Comparand value. If the Destination value is equal
+    // to the Comparand value, the Exchange value is stored in the address specified by Destination.
+    // Otherwise, no operation is performed.
+    // The function returns the initial value of the Destination parameter
+    static Long AtomicCompareExchange(AtomicLong& Destination, Long Exchange, Long Comparand);
+
+    static Long  AtomicAdd(AtomicLong& Destination, Long Val);
+    static Int64 AtomicAdd(AtomicInt64& Destination, Int64 Val);
+};
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32Debug.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32Debug.hpp
new file mode 100644
index 00000000..47fa2c8b
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32Debug.hpp
@@ -0,0 +1,43 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../Basic/interface/BasicPlatformDebug.hpp"
+
+struct WindowsDebug : public BasicPlatformDebug
+{
+    static void AssertionFailed(const Diligent::Char* Message,
+                                const char*           Function, // type of __FUNCTION__
+                                const char*           File,     // type of __FILE__
+                                int                   Line);
+    static void OutputDebugMessage(Diligent::DEBUG_MESSAGE_SEVERITY Severity,
+                                   const Diligent::Char*            Message,
+                                   const char*                      Function, // type of __FUNCTION__
+                                   const char*                      File,     // type of __FILE__
+                                   int                              Line);
+};
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32FileSystem.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32FileSystem.hpp
new file mode 100644
index 00000000..480655fe
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32FileSystem.hpp
@@ -0,0 +1,136 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include <memory>
+#include "../../Basic/interface/BasicFileSystem.hpp"
+#include "../../Basic/interface/StandardFile.hpp"
+#include "../../../Primitives/interface/FlagEnum.h"
+
+class WindowsFile : public StandardFile
+{
+public:
+    WindowsFile(const FileOpenAttribs& OpenAttribs);
+};
+
+enum FILE_DIALOG_FLAGS : Diligent::Uint32
+{
+    FILE_DIALOG_FLAG_NONE = 0x000,
+
+    /// Prevents the system from adding a link to the selected file in the file system
+    /// directory that contains the user's most recently used documents.
+    FILE_DIALOG_FLAG_DONT_ADD_TO_RECENT = 0x001,
+
+    /// Only existing files can be opened
+    FILE_DIALOG_FLAG_FILE_MUST_EXIST = 0x002,
+
+    /// Restores the current directory to its original value if the user changed the
+    /// directory while searching for files.
+    FILE_DIALOG_FLAG_NO_CHANGE_DIR = 0x004,
+
+    /// Causes the Save As dialog box to show a message box if the selected file already exists.
+    FILE_DIALOG_FLAG_OVERWRITE_PROMPT = 0x008
+};
+DEFINE_FLAG_ENUM_OPERATORS(FILE_DIALOG_FLAGS);
+
+enum FILE_DIALOG_TYPE : Diligent::Uint32
+{
+    FILE_DIALOG_TYPE_OPEN,
+    FILE_DIALOG_TYPE_SAVE
+};
+
+struct FileDialogAttribs
+{
+    FILE_DIALOG_TYPE  Type  = FILE_DIALOG_TYPE_OPEN;
+    FILE_DIALOG_FLAGS Flags = FILE_DIALOG_FLAG_NONE;
+
+    const char* Title  = nullptr;
+    const char* Filter = nullptr;
+
+    FileDialogAttribs() noexcept {}
+
+    explicit FileDialogAttribs(FILE_DIALOG_TYPE _Type) noexcept :
+        Type{_Type}
+    {
+        switch (Type)
+        {
+            case FILE_DIALOG_TYPE_OPEN:
+                Flags = FILE_DIALOG_FLAG_DONT_ADD_TO_RECENT | FILE_DIALOG_FLAG_FILE_MUST_EXIST | FILE_DIALOG_FLAG_NO_CHANGE_DIR;
+                break;
+
+            case FILE_DIALOG_TYPE_SAVE:
+                Flags = FILE_DIALOG_FLAG_DONT_ADD_TO_RECENT | FILE_DIALOG_FLAG_OVERWRITE_PROMPT | FILE_DIALOG_FLAG_NO_CHANGE_DIR;
+                break;
+        }
+    }
+};
+
+struct WindowsFileSystem : public BasicFileSystem
+{
+public:
+    static WindowsFile* OpenFile(const FileOpenAttribs& OpenAttribs);
+
+    static inline Diligent::Char GetSlashSymbol() { return '\\'; }
+
+    static bool FileExists(const Diligent::Char* strFilePath);
+    static bool PathExists(const Diligent::Char* strPath);
+
+    static bool CreateDirectory(const Diligent::Char* strPath);
+    static void ClearDirectory(const Diligent::Char* strPath, bool Recursive = false);
+    static void DeleteFile(const Diligent::Char* strPath);
+    static void DeleteDirectory(const Diligent::Char* strPath);
+    static bool IsDirectory(const Diligent::Char* strPath);
+
+    static std::vector<std::unique_ptr<FindFileData>> Search(const Diligent::Char* SearchPattern);
+
+    static std::string FileDialog(const FileDialogAttribs& DialogAttribs);
+
+    static std::string GetCurrentDirectory();
+
+
+    /// Returns a relative path from one file or folder to another.
+
+    /// \param [in]  strPathFrom     - Path that defines the start of the relative path.
+    ///                                If this parameter is null, current directory will be used.
+    /// \param [in]  IsFromDirectory - Indicates if strPathFrom is a directory.
+    ///                                Ignored if strPathFrom is null (in which case current directory
+    ///                                is used).
+    /// \param [in]  strPathTo       - Path that defines the endpoint of the relative path.
+    ///                                This parameter must not be null.
+    /// \param [in]  IsToDirectory   - Indicates if strPathTo is a directory.
+    /// \param [out] RelativePath    - Relative path from strPathFrom to strPathTo.
+    ///                                If no relative path exists, strPathFrom will be returned.
+    ///
+    /// \return                        true if the relative path exists (i.e. strPathFrom and strPathTo
+    ///                                have a common prefix), and false otherwise.
+    static bool GetRelativePath(const Diligent::Char* strPathFrom,
+                                bool                  IsFromDirectory,
+                                const Diligent::Char* strPathTo,
+                                bool                  IsToDirectory,
+                                std::string&          RelativePath);
+};
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32NativeWindow.h b/app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32NativeWindow.h
new file mode 100644
index 00000000..ae3d7a8e
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32NativeWindow.h
@@ -0,0 +1,48 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence),
+ *  contract, or otherwise, unless required by applicable law (such as deliberate
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental,
+ *  or consequential damages of any character arising as a result of this License or
+ *  out of the use or inability to use the software (including but not limited to damages
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and
+ *  all other commercial damages or losses), even if such Contributor has been advised
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../../Primitives/interface/CommonDefinitions.h"
+
+DILIGENT_BEGIN_NAMESPACE(Diligent)
+
+struct Win32NativeWindow
+{
+    void* hWnd DEFAULT_INITIALIZER(nullptr);
+
+#if DILIGENT_CPP_INTERFACE
+    Win32NativeWindow() noexcept
+    {}
+
+    explicit Win32NativeWindow(void* _hWnd) noexcept :
+        hWnd{_hWnd}
+    {}
+#endif
+};
+
+DILIGENT_END_NAMESPACE // namespace Diligent
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32PlatformDefinitions.h b/app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32PlatformDefinitions.h
new file mode 100644
index 00000000..ca1e60b1
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32PlatformDefinitions.h
@@ -0,0 +1,30 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../../Primitives/interface/CommonDefinitions.h"
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32PlatformMisc.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32PlatformMisc.hpp
new file mode 100644
index 00000000..c23a7135
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32PlatformMisc.hpp
@@ -0,0 +1,141 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../Basic/interface/BasicPlatformMisc.hpp"
+#include "../../../Platforms/Basic/interface/DebugUtilities.hpp"
+
+#include <intrin.h>
+
+struct WindowsMisc : public BasicPlatformMisc
+{
+    inline static Diligent::Uint32 GetMSB(Diligent::Uint32 Val)
+    {
+        if (Val == 0) return 32;
+
+        unsigned long MSB = 32;
+        _BitScanReverse(&MSB, Val);
+        VERIFY_EXPR(MSB == BasicPlatformMisc::GetMSB(Val));
+
+        return MSB;
+    }
+
+    inline static Diligent::Uint32 GetMSB(Diligent::Uint64 Val)
+    {
+        if (Val == 0) return 64;
+
+        unsigned long MSB = 64;
+#if _WIN64
+        _BitScanReverse64(&MSB, Val);
+#else
+        Diligent::Uint32 high = static_cast<Diligent::Uint32>((Val >> 32) & 0xFFFFFFFF);
+        if (high != 0)
+        {
+            MSB = 32 + GetMSB(high);
+        }
+        else
+        {
+            Diligent::Uint32 low = static_cast<Diligent::Uint32>(Val & 0xFFFFFFFF);
+            VERIFY_EXPR(low != 0);
+            MSB = GetMSB(low);
+        }
+#endif
+        VERIFY_EXPR(MSB == BasicPlatformMisc::GetMSB(Val));
+
+        return MSB;
+    }
+
+    inline static Diligent::Uint32 GetLSB(Diligent::Uint32 Val)
+    {
+        if (Val == 0) return 32;
+
+        unsigned long LSB = 32;
+        _BitScanForward(&LSB, Val);
+        VERIFY_EXPR(LSB == BasicPlatformMisc::GetLSB(Val));
+
+        return LSB;
+    }
+
+    inline static Diligent::Uint32 GetLSB(Diligent::Uint64 Val)
+    {
+        if (Val == 0) return 64;
+
+        unsigned long LSB = 64;
+#if _WIN64
+        _BitScanForward64(&LSB, Val);
+#else
+        Diligent::Uint32 low = static_cast<Diligent::Uint32>(Val & 0xFFFFFFFF);
+        if (low != 0)
+        {
+            LSB = GetLSB(low);
+        }
+        else
+        {
+            Diligent::Uint32 high = static_cast<Diligent::Uint32>((Val >> 32) & 0xFFFFFFFF);
+            VERIFY_EXPR(high != 0);
+            LSB = 32 + GetLSB(high);
+        }
+#endif
+
+        VERIFY_EXPR(LSB == BasicPlatformMisc::GetLSB(Val));
+        return LSB;
+    }
+
+    inline static Diligent::Uint32 CountOneBits(Diligent::Uint32 Val)
+    {
+#if defined _M_ARM || defined _M_ARM64
+        // MSVC _CountOneBits intrinsics undefined for ARM64
+        // Cast bits to 8x8 datatype and use VCNT on result
+        const uint8x8_t Vsum = vcnt_u8(vcreate_u8(static_cast<uint64_t>(Val)));
+        // Pairwise sums: 8x8 -> 16x4 -> 32x2
+        auto Bits = static_cast<Diligent::Uint32>(vget_lane_u32(vpaddl_u16(vpaddl_u8(Vsum)), 0));
+#else
+        auto Bits = __popcnt(Val);
+#endif
+        VERIFY_EXPR(Bits == BasicPlatformMisc::CountOneBits(Val));
+        return Bits;
+    }
+
+    inline static Diligent::Uint32 CountOneBits(Diligent::Uint64 Val)
+    {
+#if defined _M_ARM || defined _M_ARM64
+        // Cast bits to 8x8 datatype and use VCNT on result
+        const uint8x8_t Vsum = vcnt_u8(vcreate_u8(Val));
+        // Pairwise sums: 8x8 -> 16x4 -> 32x2 -> 64x1
+        auto Bits = static_cast<Diligent::Uint32>(vget_lane_u64(vpaddl_u32(vpaddl_u16(vpaddl_u8(Vsum))), 0));
+#elif _WIN64
+        auto Bits = __popcnt64(Val);
+#else
+        auto Bits =
+            CountOneBits(static_cast<Diligent::Uint32>((Val >> 0) & 0xFFFFFFFF)) +
+            CountOneBits(static_cast<Diligent::Uint32>((Val >> 32) & 0xFFFFFFFF));
+#endif
+        VERIFY_EXPR(Bits == BasicPlatformMisc::CountOneBits(Val));
+        return static_cast<Diligent::Uint32>(Bits);
+    }
+};
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Win32/src/Win32Atomics.cpp b/app/src/main/java/libengine/DiligentLog/Platforms/Win32/src/Win32Atomics.cpp
new file mode 100644
index 00000000..fcf3c903
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Win32/src/Win32Atomics.cpp
@@ -0,0 +1,67 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#include "Win32Atomics.hpp"
+
+#include <Windows.h>
+
+// The function returns the resulting INCREMENTED value.
+WindowsAtomics::Long WindowsAtomics::AtomicIncrement(AtomicLong& Val)
+{
+    return InterlockedIncrement(&Val);
+}
+
+WindowsAtomics::Int64 WindowsAtomics::AtomicIncrement(AtomicInt64& Val)
+{
+    return InterlockedIncrement64(&Val);
+}
+
+// The function returns the resulting DECREMENTED value.
+WindowsAtomics::Long WindowsAtomics::AtomicDecrement(AtomicLong& Val)
+{
+    return InterlockedDecrement(&Val);
+}
+
+WindowsAtomics::Int64 WindowsAtomics::AtomicDecrement(AtomicInt64& Val)
+{
+    return InterlockedDecrement64(&Val);
+}
+
+WindowsAtomics::Long WindowsAtomics::AtomicCompareExchange(AtomicLong& Destination, Long Exchange, Long Comparand)
+{
+    return InterlockedCompareExchange(&Destination, Exchange, Comparand);
+}
+
+WindowsAtomics::Long WindowsAtomics::AtomicAdd(AtomicLong& Destination, Long Val)
+{
+    return InterlockedAdd(&Destination, Val);
+}
+
+WindowsAtomics::Int64 WindowsAtomics::AtomicAdd(AtomicInt64& Destination, Int64 Val)
+{
+    return InterlockedAdd64(&Destination, Val);
+}
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Win32/src/Win32Debug.cpp b/app/src/main/java/libengine/DiligentLog/Platforms/Win32/src/Win32Debug.cpp
new file mode 100644
index 00000000..7dfad268
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Win32/src/Win32Debug.cpp
@@ -0,0 +1,91 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#include "Win32Debug.hpp"
+#include "FormatString.hpp"
+#include <csignal>
+#include <iostream>
+#include <Windows.h>
+
+using namespace Diligent;
+
+void WindowsDebug::AssertionFailed(const Diligent::Char* Message, const char* Function, const char* File, int Line)
+{
+    auto AssertionFailedMessage = FormatAssertionFailedMessage(Message, Function, File, Line);
+    OutputDebugMessage(DEBUG_MESSAGE_SEVERITY_ERROR, AssertionFailedMessage.c_str(), nullptr, nullptr, 0);
+
+    int nCode = MessageBoxA(NULL,
+                            AssertionFailedMessage.c_str(),
+                            "Runtime assertion failed",
+                            MB_TASKMODAL | MB_ICONHAND | MB_ABORTRETRYIGNORE | MB_SETFOREGROUND);
+
+    // Abort: abort the program
+    if (nCode == IDABORT)
+    {
+        // raise abort signal
+        raise(SIGABRT);
+
+        // We usually won't get here, but it's possible that
+        //  SIGABRT was ignored.  So exit the program anyway.
+        exit(3);
+    }
+
+    // Retry: call the debugger
+    if (nCode == IDRETRY)
+    {
+        DebugBreak();
+        // return to user code
+        return;
+    }
+
+    // Ignore: continue execution
+    if (nCode == IDIGNORE)
+        return;
+};
+
+void WindowsDebug::OutputDebugMessage(DEBUG_MESSAGE_SEVERITY Severity, const Char* Message, const char* Function, const char* File, int Line)
+{
+    auto msg = FormatDebugMessage(Severity, Message, Function, File, Line);
+    OutputDebugStringA(msg.c_str());
+
+    if (Severity == DEBUG_MESSAGE_SEVERITY_ERROR || Severity == DEBUG_MESSAGE_SEVERITY_FATAL_ERROR)
+        std::cerr << msg;
+    else
+        std::cout << msg;
+}
+
+void DebugAssertionFailed(const Diligent::Char* Message, const char* Function, const char* File, int Line)
+{
+    WindowsDebug::AssertionFailed(Message, Function, File, Line);
+}
+
+namespace Diligent
+{
+
+DebugMessageCallbackType DebugMessageCallback = WindowsDebug::OutputDebugMessage;
+
+}
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Win32/src/Win32FileSystem.cpp b/app/src/main/java/libengine/DiligentLog/Platforms/Win32/src/Win32FileSystem.cpp
new file mode 100644
index 00000000..aa60fe44
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Win32/src/Win32FileSystem.cpp
@@ -0,0 +1,392 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#include "Win32FileSystem.hpp"
+#include "Errors.hpp"
+#include "../../Common/interface/StringTools.hpp"
+
+// We can't use namespace Diligent before #including <Windows.h> because Diligent::INTERFACE_ID will confilct with windows InterfaceID
+//using namespace Diligent;
+
+// Windows.h defines CreateDirectory and DeleteFile as macros.
+// So we need to do some tricks to avoid name mess.
+static bool CreateDirectoryImpl(const Diligent::Char* strPath);
+
+bool WindowsFileSystem::CreateDirectory(const Diligent::Char* strPath)
+{
+    return CreateDirectoryImpl(strPath);
+}
+
+static void DeleteFileImpl(const Diligent::Char* strPath);
+
+void WindowsFileSystem::DeleteFile(const Diligent::Char* strPath)
+{
+    DeleteFileImpl(strPath);
+}
+
+static std::string GetCurrentDirectoryImpl();
+
+std::string WindowsFileSystem::GetCurrentDirectory()
+{
+    return GetCurrentDirectoryImpl();
+}
+
+#include <Windows.h>
+#include <Shlwapi.h>
+#pragma comment(lib, "Shlwapi.lib")
+
+using namespace Diligent;
+
+static std::vector<wchar_t> UTF8ToUTF16(LPCSTR lpUTF8)
+{
+    // When last parameter is 0, the function returns the required buffer size, in characters,
+    // including any terminating null character.
+    auto                 nChars = MultiByteToWideChar(CP_UTF8, 0, lpUTF8, -1, NULL, 0);
+    std::vector<wchar_t> wstr(nChars);
+    MultiByteToWideChar(CP_UTF8, 0, lpUTF8, -1, wstr.data(), nChars);
+    return wstr;
+}
+
+WindowsFile::WindowsFile(const FileOpenAttribs& OpenAttribs) :
+    StandardFile(OpenAttribs, WindowsFileSystem::GetSlashSymbol())
+{
+    VERIFY_EXPR(m_pFile == nullptr);
+    auto OpenModeStr = WidenString(GetOpenModeStr());
+
+    for (;;)
+    {
+        auto    UTF16FilePath = UTF8ToUTF16(m_OpenAttribs.strFilePath);
+        errno_t err           = _wfopen_s(&m_pFile, UTF16FilePath.data(), OpenModeStr.c_str());
+        if (err == 0)
+        {
+            break;
+        }
+        else if (err == ENFILE || // Too many files open in system
+                 err == EMFILE)   // Too many open files
+        {
+            // No more file descriptors are available: we have to wait
+            //g_SystemMetricsStream << "Failed to open file " << FileName;
+            //g_SystemMetricsStream << "\nWaiting 50 ms...\n";
+            Sleep(50);
+            continue;
+        }
+        else
+        {
+            char errstr[128];
+            strerror_s(errstr, _countof(errstr), err);
+            LOG_ERROR_AND_THROW("Failed to open file ", m_OpenAttribs.strFilePath,
+                                "\nThe following error occurred: ", errstr);
+        }
+    }
+}
+
+WindowsFile* WindowsFileSystem::OpenFile(const FileOpenAttribs& OpenAttribs)
+{
+    WindowsFile* pFile = nullptr;
+    try
+    {
+        pFile = new WindowsFile(OpenAttribs);
+    }
+    catch (const std::runtime_error& /*err*/)
+    {
+    }
+
+    return pFile;
+}
+
+bool WindowsFileSystem::FileExists(const Char* strFilePath)
+{
+    if (!PathExists(strFilePath))
+        return false;
+
+    auto FileAttribs = GetFileAttributesA(strFilePath);
+    if (FileAttribs == INVALID_FILE_ATTRIBUTES)
+        return false;
+
+    return (FileAttribs & FILE_ATTRIBUTE_DIRECTORY) == 0;
+}
+
+static bool CreateDirectoryImpl(const Char* strPath)
+{
+    // Test all parent directories
+    std::string            DirectoryPath = strPath;
+    std::string::size_type SlashPos      = std::wstring::npos;
+    const auto             SlashSym      = WindowsFileSystem::GetSlashSymbol();
+    WindowsFileSystem::CorrectSlashes(DirectoryPath, SlashSym);
+
+    do
+    {
+        SlashPos = DirectoryPath.find(SlashSym, (SlashPos != std::string::npos) ? SlashPos + 1 : 0);
+
+        std::string ParentDir = (SlashPos != std::wstring::npos) ? DirectoryPath.substr(0, SlashPos) : DirectoryPath;
+        if (!WindowsFileSystem::PathExists(ParentDir.c_str()))
+        {
+            // If there is no directory, create it
+            if (!::CreateDirectoryA(ParentDir.c_str(), NULL))
+                return false;
+        }
+    } while (SlashPos != std::string::npos);
+
+    return true;
+}
+
+void WindowsFileSystem::ClearDirectory(const Char* strPath, bool Recursive)
+{
+    WIN32_FIND_DATAA ffd;
+    HANDLE           hFind = INVALID_HANDLE_VALUE;
+
+    // Find the first file in the directory.
+    std::string Directory(strPath);
+    if (Directory.length() > 0 && Directory.back() != GetSlashSymbol())
+        Directory.push_back(GetSlashSymbol());
+
+    auto SearchPattern = Directory + "*";
+    hFind              = FindFirstFileA(SearchPattern.c_str(), &ffd);
+
+    if (INVALID_HANDLE_VALUE == hFind)
+    {
+        LOG_ERROR_MESSAGE("FindFirstFile failed with error code ", GetLastError());
+        return;
+    }
+
+    // List all the files in the directory
+    do
+    {
+        if (ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
+        {
+            if (Recursive)
+            {
+                // Skip '.' and anything that begins with '..'
+                if (!((ffd.cFileName[0] == '.' && ffd.cFileName[1] == 0) || (ffd.cFileName[0] == '.' && ffd.cFileName[1] == '.')))
+                {
+                    auto SubDirName = Directory + ffd.cFileName;
+                    ClearDirectory(SubDirName.c_str(), Recursive);
+
+                    if (RemoveDirectoryA(SubDirName.c_str()) == FALSE)
+                    {
+                        LOG_ERROR_MESSAGE("Failed to remove directory '", SubDirName, "'. Error code: ", GetLastError());
+                    }
+                }
+            }
+        }
+        else
+        {
+            auto FileName = Directory + ffd.cFileName;
+            DeleteFileImpl(FileName.c_str());
+        }
+    } while (FindNextFileA(hFind, &ffd) != 0);
+
+    FindClose(hFind);
+}
+
+
+static void DeleteFileImpl(const Char* strPath)
+{
+    if (SetFileAttributesA(strPath, FILE_ATTRIBUTE_NORMAL) == FALSE)
+    {
+        LOG_WARNING_MESSAGE("Failed to set FILE_ATTRIBUTE_NORMAL for file '", strPath, "'. Error code: ", GetLastError());
+    }
+
+    if (DeleteFileA(strPath) == FALSE)
+    {
+        LOG_ERROR_MESSAGE("Failed to delete file '", strPath, "'. Error code: ", GetLastError());
+    }
+}
+
+void WindowsFileSystem::DeleteDirectory(const Diligent::Char* strPath)
+{
+    ClearDirectory(strPath, true);
+
+    if (RemoveDirectoryA(strPath) == FALSE)
+    {
+        LOG_ERROR_MESSAGE("Failed to remove directory '", strPath, "'. Error code: ", GetLastError());
+    }
+}
+
+
+bool WindowsFileSystem::PathExists(const Char* strPath)
+{
+    return PathFileExistsA(strPath) != FALSE;
+}
+
+struct WndFindFileData : public FindFileData
+{
+    virtual const Char* Name() const override { return ffd.cFileName; }
+
+    virtual bool IsDirectory() const override { return (ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0; }
+
+    WIN32_FIND_DATAA ffd;
+
+    WndFindFileData(const WIN32_FIND_DATAA& _ffd) :
+        ffd{_ffd} {}
+};
+
+std::vector<std::unique_ptr<FindFileData>> WindowsFileSystem::Search(const Char* SearchPattern)
+{
+    std::vector<std::unique_ptr<FindFileData>> SearchRes;
+
+    WIN32_FIND_DATAA ffd;
+    // Find the first file in the directory.
+    auto hFind = FindFirstFileA(SearchPattern, &ffd);
+
+    if (INVALID_HANDLE_VALUE == hFind)
+    {
+        return SearchRes;
+    }
+
+    // List all the files in the directory
+    do
+    {
+        SearchRes.emplace_back(new WndFindFileData(ffd));
+    } while (FindNextFileA(hFind, &ffd) != 0);
+
+    auto dwError = GetLastError();
+    if (dwError != ERROR_NO_MORE_FILES)
+    {
+        //ErrorHandler(TEXT("FindFirstFile"));
+    }
+
+    FindClose(hFind);
+
+    return SearchRes;
+}
+
+static DWORD FileDialogFlagsToOFNFlags(FILE_DIALOG_FLAGS FileDialogFlags)
+{
+    DWORD OFNFlags = 0;
+    while (FileDialogFlags != FILE_DIALOG_FLAG_NONE)
+    {
+        auto Flag = FileDialogFlags & ~static_cast<FILE_DIALOG_FLAGS>(static_cast<Uint32>(FileDialogFlags) - 1);
+        switch (Flag)
+        {
+            case FILE_DIALOG_FLAG_DONT_ADD_TO_RECENT:
+                OFNFlags |= OFN_DONTADDTORECENT;
+                break;
+
+            case FILE_DIALOG_FLAG_FILE_MUST_EXIST:
+                OFNFlags |= OFN_FILEMUSTEXIST;
+                break;
+
+            case FILE_DIALOG_FLAG_NO_CHANGE_DIR:
+                OFNFlags |= OFN_NOCHANGEDIR;
+                break;
+
+            case FILE_DIALOG_FLAG_OVERWRITE_PROMPT:
+                OFNFlags |= OFN_OVERWRITEPROMPT;
+                break;
+
+            default:
+                UNEXPECTED("Unknown file dialog flag (", Flag, ")");
+        }
+        FileDialogFlags &= ~Flag;
+    }
+    return OFNFlags;
+}
+
+std::string WindowsFileSystem::FileDialog(const FileDialogAttribs& DialogAttribs)
+{
+    OPENFILENAMEA ofn = {};
+
+    char buffer[1024] = {};
+    ofn.lStructSize   = sizeof(ofn);
+    ofn.lpstrFilter   = DialogAttribs.Filter;
+    ofn.lpstrFile     = buffer;
+    ofn.nMaxFile      = _countof(buffer);
+    ofn.lpstrTitle    = DialogAttribs.Title;
+    ofn.Flags         = FileDialogFlagsToOFNFlags(DialogAttribs.Flags);
+
+    std::string FileName;
+    if (DialogAttribs.Type == FILE_DIALOG_TYPE_OPEN ? GetOpenFileNameA(&ofn) : GetSaveFileNameA(&ofn))
+    {
+        FileName = buffer;
+    }
+    return FileName;
+}
+
+bool WindowsFileSystem::IsDirectory(const Diligent::Char* strPath)
+{
+    if (!PathExists(strPath))
+    {
+        LOG_WARNING_MESSAGE("Path '", strPath, "' does not exist. Use PathExists function to check if path exists.");
+        return false;
+    }
+
+    return (GetFileAttributesA(strPath) & FILE_ATTRIBUTE_DIRECTORY) != 0;
+}
+
+std::string GetCurrentDirectoryImpl()
+{
+    std::string CurrDir;
+
+    // If the function succeeds, the return value specifies the number of characters that
+    // are written to the buffer, NOT including the terminating null character.
+    // HOWEVER, if the buffer that is pointed to by lpBuffer is not large enough,
+    // the return value specifies the required size of the buffer, in characters,
+    // INCLUDING the null-terminating character.
+    // https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getcurrentdirectory
+    auto BufferSize = GetCurrentDirectoryA(0, nullptr);
+
+    if (BufferSize > 1)
+    {
+        // Note that std::string::resize(n) resizes the string to a length of n characters.
+        CurrDir.resize(BufferSize - 1);
+
+        // BufferSize must include room for a terminating null character.
+        auto NumChars = GetCurrentDirectoryA(BufferSize, &CurrDir[0]);
+        VERIFY_EXPR(CurrDir.length() == NumChars);
+    }
+    return CurrDir;
+}
+
+bool WindowsFileSystem::GetRelativePath(const Diligent::Char* strPathFrom,
+                                        bool                  IsFromDirectory,
+                                        const Diligent::Char* strPathTo,
+                                        bool                  IsToDirectory,
+                                        std::string&          RelativePath)
+{
+    VERIFY_EXPR(strPathTo != nullptr);
+
+    // https://docs.microsoft.com/en-us/windows/win32/api/shlwapi/nf-shlwapi-pathrelativepathtoa
+    char strRelativePath[MAX_PATH];
+
+    auto Res = PathRelativePathToA(strRelativePath,
+                                   strPathFrom != nullptr ? strPathFrom : GetCurrentDirectoryImpl().c_str(),
+                                   (strPathFrom == nullptr || IsFromDirectory) ? FILE_ATTRIBUTE_DIRECTORY : FILE_ATTRIBUTE_NORMAL,
+                                   strPathTo,
+                                   IsToDirectory ? FILE_ATTRIBUTE_DIRECTORY : FILE_ATTRIBUTE_NORMAL);
+
+    if (Res != FALSE)
+    {
+        RelativePath = strRelativePath;
+    }
+    else
+    {
+        RelativePath = strPathFrom;
+    }
+
+    return Res != FALSE;
+}
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/interface/Atomics.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/interface/Atomics.hpp
new file mode 100644
index 00000000..38d20289
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/interface/Atomics.hpp
@@ -0,0 +1,43 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "PlatformDefinitions.h"
+
+#if PLATFORM_WIN32 || PLATFORM_UNIVERSAL_WINDOWS
+
+#    include "../Win32/interface/Win32Atomics.hpp"
+using Atomics = WindowsAtomics;
+
+#else
+
+// Use c++11 standard atomics
+#    include "../Basic/interface/BasicAtomics.hpp"
+using Atomics = BasicAtomics;
+
+#endif
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/interface/FileSystem.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/interface/FileSystem.hpp
new file mode 100644
index 00000000..6a26d2d8
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/interface/FileSystem.hpp
@@ -0,0 +1,66 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "PlatformDefinitions.h"
+
+#if PLATFORM_WIN32
+
+#    include "../Win32/interface/Win32FileSystem.hpp"
+using FileSystem = WindowsFileSystem;
+using CFile      = WindowsFile;
+
+#elif PLATFORM_UNIVERSAL_WINDOWS
+
+#    include "../UWP/interface/UWPFileSystem.hpp"
+using FileSystem = WindowsStoreFileSystem;
+using CFile      = WindowsStoreFile;
+
+#elif PLATFORM_ANDROID
+
+#    include "../Android/interface/AndroidFileSystem.hpp"
+using FileSystem = AndroidFileSystem;
+using CFile      = AndroidFile;
+
+#elif PLATFORM_LINUX
+
+#    include "../Linux/interface/LinuxFileSystem.hpp"
+using FileSystem = LinuxFileSystem;
+using CFile      = LinuxFile;
+
+#elif PLATFORM_MACOS || PLATFORM_IOS || PLATFORM_TVOS
+
+#    include "../Apple/interface/AppleFileSystem.hpp"
+using FileSystem = AppleFileSystem;
+using CFile      = AppleFile;
+
+#else
+
+#    error Unknown platform. Please define one of the following macros as 1:  PLATFORM_WIN32, PLATFORM_UNIVERSAL_WINDOWS, PLATFORM_ANDROID, PLATFORM_LINUX, PLATFORM_MACOS, PLATFORM_IOS, PLATFORM_TVOS.
+
+#endif
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/interface/NativeWindow.h b/app/src/main/java/libengine/DiligentLog/Platforms/interface/NativeWindow.h
new file mode 100644
index 00000000..15ef778f
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/interface/NativeWindow.h
@@ -0,0 +1,98 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "PlatformDefinitions.h"
+
+#if PLATFORM_WIN32
+
+#    include "../Win32/interface/Win32NativeWindow.h"
+
+#elif PLATFORM_UNIVERSAL_WINDOWS
+
+#    include "../UWP/interface/UWPNativeWindow.h"
+
+#elif PLATFORM_ANDROID
+
+#    include "../Android/interface/AndroidNativeWindow.h"
+
+#elif PLATFORM_LINUX
+
+#    include "../Linux/interface/LinuxNativeWindow.h"
+
+#elif PLATFORM_MACOS
+
+#    include "../Apple/interface/MacOSNativeWindow.h"
+
+#elif PLATFORM_IOS
+
+#    include "../Apple/interface/IOSNativeWindow.h"
+
+#elif PLATFORM_TVOS
+
+#    include "../Apple/interface/TVOSNativeWindow.h"
+
+#else
+#    error Unknown platform. Please define one of the following macros as 1: PLATFORM_WIN32, PLATFORM_UNIVERSAL_WINDOWS, PLATFORM_ANDROID, PLATFORM_LINUX, PLATFORM_MACOS, PLATFORM_IOS, PLATFORM_TVOS.
+#endif
+
+DILIGENT_BEGIN_NAMESPACE(Diligent)
+
+#if PLATFORM_WIN32
+
+typedef struct Win32NativeWindow NativeWindow;
+
+#elif PLATFORM_UNIVERSAL_WINDOWS
+
+typedef struct UWPNativeWindow NativeWindow;
+
+#elif PLATFORM_ANDROID
+
+typedef struct AndroidNativeWindow NativeWindow;
+
+#elif PLATFORM_LINUX
+
+typedef struct LinuxNativeWindow NativeWindow;
+
+#elif PLATFORM_MACOS
+
+typedef struct MacOSNativeWindow NativeWindow;
+
+#elif PLATFORM_IOS
+
+typedef struct IOSNativeWindow NativeWindow;
+
+#elif PLATFORM_TVOS
+
+typedef struct TVOSNativeWindow NativeWindow;
+
+#else
+#    error Unknown platform. Please define one of the following macros as 1: PLATFORM_WIN32, PLATFORM_UNIVERSAL_WINDOWS, PLATFORM_ANDROID, PLATFORM_LINUX, PLATFORM_MACOS, PLATFORM_IOS, PLATFORM_TVOS.
+#endif
+
+DILIGENT_END_NAMESPACE // namespace Diligent
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/interface/PlatformDebug.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/interface/PlatformDebug.hpp
new file mode 100644
index 00000000..f1552cd9
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/interface/PlatformDebug.hpp
@@ -0,0 +1,54 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "PlatformDefinitions.h"
+
+#if PLATFORM_WIN32
+#    include "../Win32/interface/Win32Debug.hpp"
+using PlatformDebug = WindowsDebug;
+
+#elif PLATFORM_UNIVERSAL_WINDOWS
+#    include "../UWP/interface/UWPDebug.hpp"
+using PlatformDebug = WindowsStoreDebug;
+
+#elif PLATFORM_ANDROID
+#    include "../Android/interface/AndroidDebug.hpp"
+using PlatformDebug = AndroidDebug;
+
+#elif PLATFORM_LINUX
+#    include "../Linux/interface/LinuxDebug.hpp"
+using PlatformDebug = LinuxDebug;
+
+#elif PLATFORM_MACOS || PLATFORM_IOS || PLATFORM_TVOS
+#    include "../Apple/interface/AppleDebug.hpp"
+using PlatformDebug = AppleDebug;
+
+#else
+#    error Unknown platform. Please define one of the following macros as 1:  PLATFORM_WIN32, PLATFORM_UNIVERSAL_WINDOWS, PLATFORM_ANDROID, PLATFORM_LINUX, PLATFORM_MACOS, PLATFORM_IOS, PLATFORM_TVOS.
+#endif
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/interface/PlatformDefinitions.h b/app/src/main/java/libengine/DiligentLog/Platforms/interface/PlatformDefinitions.h
new file mode 100644
index 00000000..23a5b920
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/interface/PlatformDefinitions.h
@@ -0,0 +1,100 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#if defined(ANDROID)
+#    ifndef PLATFORM_ANDROID
+#        define PLATFORM_ANDROID 1
+#    endif
+#endif
+
+#if !PLATFORM_WIN32 && !PLATFORM_UNIVERSAL_WINDOWS && !PLATFORM_ANDROID && !PLATFORM_LINUX && !PLATFORM_MACOS && !PLATFORM_IOS && !PLATFORM_TVOS
+#    error Unknown platform. Please define one of the following macros as 1:  PLATFORM_WIN32, PLATFORM_UNIVERSAL_WINDOWS, PLATFORM_ANDROID, PLATFORM_LINUX, PLATFORM_MACOS, PLATFORM_IOS, PLATFORM_TVOS.
+#endif
+
+#if PLATFORM_WIN32
+
+#    if PLATFORM_UNIVERSAL_WINDOWS || PLATFORM_ANDROID || PLATFORM_LINUX || PLATFORM_MACOS || PLATFORM_IOS || PLATFORM_TVOS
+#        error Conflicting platform macros
+#    endif
+
+#    include "../Win32/interface/Win32PlatformDefinitions.h"
+
+#elif PLATFORM_UNIVERSAL_WINDOWS
+
+#    if PLATFORM_WIN32 || PLATFORM_ANDROID || PLATFORM_LINUX || PLATFORM_MACOS || PLATFORM_IOS || PLATFORM_TVOS
+#        error Conflicting platform macros
+#    endif
+
+#    include "../UWP/interface/UWPDefinitions.h"
+
+#elif PLATFORM_ANDROID
+
+#    if PLATFORM_WIN32 || PLATFORM_UNIVERSAL_WINDOWS || PLATFORM_LINUX || PLATFORM_MACOS || PLATFORM_IOS || PLATFORM_TVOS
+#        error Conflicting platform macros
+#    endif
+
+#    include "../Android/interface/AndroidPlatformDefinitions.h"
+
+#elif PLATFORM_LINUX
+
+#    if PLATFORM_WIN32 || PLATFORM_UNIVERSAL_WINDOWS || PLATFORM_ANDROID || PLATFORM_MACOS || PLATFORM_IOS || PLATFORM_TVOS
+#        error Conflicting platform macros
+#    endif
+
+#    include "../Linux/interface/LinuxPlatformDefinitions.h"
+
+#elif PLATFORM_MACOS
+
+#    if PLATFORM_WIN32 || PLATFORM_UNIVERSAL_WINDOWS || PLATFORM_ANDROID || PLATFORM_LINUX || PLATFORM_IOS || PLATFORM_TVOS
+#        error Conflicting platform macros
+#    endif
+
+#    include "../Apple/interface/ApplePlatformDefinitions.h"
+
+#elif PLATFORM_IOS
+
+#    if PLATFORM_WIN32 || PLATFORM_UNIVERSAL_WINDOWS || PLATFORM_ANDROID || PLATFORM_LINUX || PLATFORM_MACOS || PLATFORM_TVOS
+#        error Conflicting platform macros
+#    endif
+
+#    include "../Apple/interface/ApplePlatformDefinitions.h"
+
+#elif PLATFORM_TVOS
+
+#    if PLATFORM_WIN32 || PLATFORM_UNIVERSAL_WINDOWS || PLATFORM_ANDROID || PLATFORM_LINUX || PLATFORM_MACOS || PLATFORM_IOS
+#        error Conflicting platform macros
+#    endif
+
+#    include "../Apple/interface/ApplePlatformDefinitions.h"
+
+#else
+
+#    error Unsupported platform
+
+#endif
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/interface/PlatformMisc.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/interface/PlatformMisc.hpp
new file mode 100644
index 00000000..c8043a9b
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/interface/PlatformMisc.hpp
@@ -0,0 +1,52 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "PlatformDefinitions.h"
+
+#if PLATFORM_WIN32 || PLATFORM_UNIVERSAL_WINDOWS
+#    include "../Win32/interface/Win32PlatformMisc.hpp"
+using PlatformMisc = WindowsMisc;
+
+#elif PLATFORM_ANDROID
+#    include "../Android/interface/AndroidPlatformMisc.hpp"
+using PlatformMisc = AndroidMisc;
+
+#elif PLATFORM_LINUX
+#    include "../Linux/interface/LinuxPlatformMisc.hpp"
+using PlatformMisc = LinuxMisc;
+
+#elif PLATFORM_MACOS || PLATFORM_IOS || PLATFORM_TVOS
+#    include "../Apple/interface/ApplePlatformMisc.hpp"
+using PlatformMisc = AppleMisc;
+
+#else
+
+#    error Unknown platform. Please define one of the following macros as 1:  PLATFORM_WIN32, PLATFORM_UNIVERSAL_WINDOWS, PLATFORM_ANDROID, PLATFORM_LINUX, PLATFORM_MACOS, PLATFORM_IOS, PLATFORM_TVOS.
+
+#endif
diff --git a/app/src/main/java/libengine/DiligentLog/Primitives/CMakeLists.txt b/app/src/main/java/libengine/DiligentLog/Primitives/CMakeLists.txt
new file mode 100644
index 00000000..a2bc4529
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Primitives/CMakeLists.txt
@@ -0,0 +1,49 @@
+cmake_minimum_required (VERSION 3.6)
+
+project(Diligent-Primitives CXX)
+
+set(SOURCE
+    src/DebugOutput.cpp
+    src/test.cpp
+)
+
+set(INTERFACE
+    interface/BasicTypes.h
+    interface/CommonDefinitions.h
+    interface/DataBlob.h
+    interface/DebugOutput.h
+    interface/DefineGlobalFuncHelperMacros.h
+    interface/DefineInterfaceHelperMacros.h
+    interface/FlagEnum.h
+    interface/Errors.hpp
+    interface/FileStream.h
+    interface/FormatString.hpp
+    interface/InterfaceID.h
+    interface/MemoryAllocator.h
+    interface/Object.h
+    interface/ReferenceCounters.h
+    interface/UndefGlobalFuncHelperMacros.h
+    interface/UndefInterfaceHelperMacros.h
+)
+
+# This should be an interface library. However, CMake does not show
+# interface libraries in an IDE, so we have to create a static library instead
+add_library(Diligent-Primitives STATIC ${INTERFACE} ${SOURCE})
+set_common_target_properties__LOG(Diligent-Primitives)
+
+target_link_libraries(Diligent-Primitives
+PRIVATE
+    Diligent-BuildSettings__LOG
+)
+
+target_include_directories(Diligent-Primitives
+PUBLIC
+    interface
+)
+
+source_group("interface" FILES ${INTERFACE})
+source_group("src" FILES ${SOURCE})
+
+if(DILIGENT_INSTALL_CORE)
+    install_core_lib__LOG(Diligent-Primitives)
+endif()
\ No newline at end of file
diff --git a/app/src/main/java/libengine/DiligentLog/Primitives/interface/BasicTypes.h b/app/src/main/java/libengine/DiligentLog/Primitives/interface/BasicTypes.h
new file mode 100644
index 00000000..fd324344
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Primitives/interface/BasicTypes.h
@@ -0,0 +1,69 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "CommonDefinitions.h"
+
+#if DILIGENT_C_INTERFACE
+#    include <stdint.h>
+#    include <stdbool.h>
+#    include <stddef.h>
+#else
+#    include <cstdint>
+#    include <string>
+#endif
+
+DILIGENT_BEGIN_NAMESPACE(Diligent)
+
+typedef float Float32; ///< 32-bit float
+
+typedef int64_t Int64; ///< 64-bit signed integer
+typedef int32_t Int32; ///< 32-bit signed integer
+typedef int16_t Int16; ///< 16-bit signed integer
+typedef int8_t  Int8;  ///< 8-bit signed integer
+
+typedef uint64_t Uint64; ///< 64-bit unsigned integer
+typedef uint32_t Uint32; ///< 32-bit unsigned integer
+typedef uint16_t Uint16; ///< 16-bit unsigned integer
+typedef uint8_t  Uint8;  ///< 8-bit unsigned integer
+
+typedef size_t      SizeType;
+typedef void*       PVoid;
+typedef const void* CPVoid;
+
+typedef bool Bool; ///< Boolean
+
+static const Bool False = false;
+static const Bool True  = true;
+
+typedef char Char;
+#if !DILIGENT_C_INTERFACE
+using String = std::basic_string<Char>; ///< String variable
+#endif
+
+DILIGENT_END_NAMESPACE // namespace Diligent
diff --git a/app/src/main/java/libengine/DiligentLog/Primitives/interface/CommonDefinitions.h b/app/src/main/java/libengine/DiligentLog/Primitives/interface/CommonDefinitions.h
new file mode 100644
index 00000000..483ae86f
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Primitives/interface/CommonDefinitions.h
@@ -0,0 +1,107 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+/// \file
+/// Common definitions
+
+#ifndef DILIGENT_C_INTERFACE
+#    ifdef __cplusplus
+#        define DILIGENT_C_INTERFACE 0
+#    else
+#        define DILIGENT_C_INTERFACE 1
+#    endif
+#endif
+
+#ifdef _MSC_VER
+// Note that MSVC x86 compiler by default uses __this call for class member functions
+#    define DILIGENT_CALL_TYPE __cdecl
+#else
+#    define DILIGENT_CALL_TYPE
+#endif
+
+#if DILIGENT_C_INTERFACE
+
+#    define DILIGENT_BEGIN_NAMESPACE(Name)
+#    define DILIGENT_END_NAMESPACE
+
+#    define DILIGENT_TYPED_ENUM(EnumName, EnumType) \
+        typedef EnumType EnumName;                  \
+        enum _##EnumName
+
+#    define DILIGENT_DERIVE(TypeName) \
+        {                             \
+            struct TypeName _##TypeName;
+
+#    define DEFAULT_INITIALIZER(x)
+
+#    define DILIGENT_GLOBAL_FUNCTION(FuncName) Diligent_##FuncName
+
+#    define DILIGENT_BEGIN_INTERFACE(Iface, Base) \
+        typedef struct Iface                      \
+        {                                         \
+            struct Iface##Vtbl* pVtbl;            \
+        } Iface;                                  \
+        struct Iface##Methods
+
+#    define DEFAULT_VALUE(x)
+
+#    define CALL_IFACE_METHOD(Iface, Method, This, ...) (This)->pVtbl->Iface.Method((I##Iface*)(This), ##__VA_ARGS__)
+
+// Two levels of indirection are required to concatenate expanded macros
+#    define DILIGENT_CONCATENATE0(X, Y) X##Y
+#    define DILIGENT_CONCATENATE(X, Y)  DILIGENT_CONCATENATE0(X, Y)
+
+#else
+
+#    define DILIGENT_BEGIN_NAMESPACE(Name) \
+        namespace Name                     \
+        {
+
+#    define DILIGENT_END_NAMESPACE }
+
+#    define DILIGENT_TYPED_ENUM(EnumName, EnumType) enum EnumName : EnumType
+
+#    define DILIGENT_DERIVE(TypeName) : public TypeName \
+        {
+
+#    define DEFAULT_INITIALIZER(x) = x
+
+#    define DILIGENT_GLOBAL_FUNCTION(FuncName) FuncName
+
+#    define DILIGENT_BEGIN_INTERFACE(Name, Base) struct Name : public Base
+
+#    define DEFAULT_VALUE(x) = x
+
+#endif
+
+#if DILIGENT_C_INTERFACE
+#    define DILIGENT_CPP_INTERFACE 0
+#else
+#    define DILIGENT_CPP_INTERFACE 1
+#endif
diff --git a/app/src/main/java/libengine/DiligentLog/Primitives/interface/DataBlob.h b/app/src/main/java/libengine/DiligentLog/Primitives/interface/DataBlob.h
new file mode 100644
index 00000000..04f387ab
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Primitives/interface/DataBlob.h
@@ -0,0 +1,84 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+/// \file
+/// Defines Diligent::IDataBlob interface
+
+#include "Object.h"
+
+DILIGENT_BEGIN_NAMESPACE(Diligent)
+
+
+// {F578FF0D-ABD2-4514-9D32-7CB454D4A73B}
+static const struct INTERFACE_ID IID_DataBlob =
+    {0xf578ff0d, 0xabd2, 0x4514, {0x9d, 0x32, 0x7c, 0xb4, 0x54, 0xd4, 0xa7, 0x3b}};
+
+// clang-format off
+
+#define DILIGENT_INTERFACE_NAME IDataBlob
+#include "DefineInterfaceHelperMacros.h"
+
+#define IDataBlobInclusiveMethods \
+    IObjectInclusiveMethods;      \
+    IDataBlobMethods DataBlob
+
+/// Base interface for a file stream
+DILIGENT_BEGIN_INTERFACE(IDataBlob, IObject)
+{
+    /// Sets the size of the internal data buffer
+    VIRTUAL void METHOD(Resize)(THIS_
+                                size_t NewSize) PURE;
+
+    /// Returns the size of the internal data buffer
+    VIRTUAL size_t METHOD(GetSize)(THIS) CONST PURE;
+
+    /// Returns the pointer to the internal data buffer
+    VIRTUAL void* METHOD(GetDataPtr)(THIS) PURE;
+
+    /// Returns const pointer to the internal data buffer
+    VIRTUAL const void* METHOD(GetConstDataPtr)(THIS) CONST PURE;
+};
+DILIGENT_END_INTERFACE
+
+#include "UndefInterfaceHelperMacros.h"
+
+#if DILIGENT_C_INTERFACE
+
+// clang-format off
+
+#    define IDataBlob_Resize(This, ...)      CALL_IFACE_METHOD(DataBlob, Resize,          This, __VA_ARGS__)
+#    define IDataBlob_GetSize(This)          CALL_IFACE_METHOD(DataBlob, GetSize,         This)
+#    define IDataBlob_GetDataPtr(This)       CALL_IFACE_METHOD(DataBlob, GetDataPtr,      This)
+#    define IDataBlob_GetConstDataPtr(This)  CALL_IFACE_METHOD(DataBlob, GetConstDataPtr, This)
+
+// clang-format on
+
+#endif
+
+DILIGENT_END_NAMESPACE // namespace Diligent
diff --git a/app/src/main/java/libengine/DiligentLog/Primitives/interface/DebugOutput.h b/app/src/main/java/libengine/DiligentLog/Primitives/interface/DebugOutput.h
new file mode 100644
index 00000000..7c3857cc
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Primitives/interface/DebugOutput.h
@@ -0,0 +1,72 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "BasicTypes.h"
+
+DILIGENT_BEGIN_NAMESPACE(Diligent)
+
+/// Describes debug message severity
+enum DEBUG_MESSAGE_SEVERITY
+{
+    /// Information message
+    DEBUG_MESSAGE_SEVERITY_INFO = 0,
+
+    /// Warning message
+    DEBUG_MESSAGE_SEVERITY_WARNING,
+
+    /// Error, with potential recovery
+    DEBUG_MESSAGE_SEVERITY_ERROR,
+
+    /// Fatal error - recovery is not possible
+    DEBUG_MESSAGE_SEVERITY_FATAL_ERROR
+};
+
+
+/// Type of the debug message callback function
+
+/// \param [in] Severity - Message severity
+/// \param [in] Message - Debug message
+/// \param [in] Function - Name of the function or nullptr
+/// \param [in] File - File name or nullptr
+/// \param [in] Line - Line number
+typedef void (*DebugMessageCallbackType)(enum DEBUG_MESSAGE_SEVERITY Severity,
+                                         const Char*                 Message,
+                                         const Char*                 Function,
+                                         const Char*                 File,
+                                         int                         Line);
+extern DebugMessageCallbackType DebugMessageCallback;
+
+
+/// Sets the debug message callback function
+
+/// \note This function needs to be called for every executable module that
+///       wants to use the callback.
+void SetDebugMessageCallback(DebugMessageCallbackType DbgMessageCallback);
+
+DILIGENT_END_NAMESPACE // namespace Diligent
diff --git a/app/src/main/java/libengine/DiligentLog/Primitives/interface/DefineGlobalFuncHelperMacros.h b/app/src/main/java/libengine/DiligentLog/Primitives/interface/DefineGlobalFuncHelperMacros.h
new file mode 100644
index 00000000..a35649b0
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Primitives/interface/DefineGlobalFuncHelperMacros.h
@@ -0,0 +1,41 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#include "CommonDefinitions.h"
+
+#pragma push_macro("REF")
+#undef REF
+
+#if DILIGENT_C_INTERFACE
+
+#    define REF *
+
+#else
+
+#    define REF &
+
+#endif
diff --git a/app/src/main/java/libengine/DiligentLog/Primitives/interface/DefineInterfaceHelperMacros.h b/app/src/main/java/libengine/DiligentLog/Primitives/interface/DefineInterfaceHelperMacros.h
new file mode 100644
index 00000000..51a3e319
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Primitives/interface/DefineInterfaceHelperMacros.h
@@ -0,0 +1,90 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#include "CommonDefinitions.h"
+
+#ifndef DILIGENT_INTERFACE_NAME
+#    error Interface name is undefined
+#endif
+
+#pragma push_macro("THIS")
+#pragma push_macro("THIS_")
+#pragma push_macro("VIRTUAL")
+#pragma push_macro("CONST")
+#pragma push_macro("PURE")
+#pragma push_macro("REF")
+#pragma push_macro("METHOD")
+
+#undef THIS
+#undef THIS_
+#undef VIRTUAL
+#undef CONST
+#undef PURE
+#undef REF
+#undef METHOD
+
+#if DILIGENT_C_INTERFACE
+
+#    define THIS  struct DILIGENT_INTERFACE_NAME*
+#    define THIS_ struct DILIGENT_INTERFACE_NAME*,
+#    define VIRTUAL
+#    define CONST
+#    define PURE
+#    define REF          *
+#    define METHOD(Name) (DILIGENT_CALL_TYPE * Name)
+
+// Suppose that DILIGENT_INTERFACE_NAME == Iface, then DILIGENT_END_INTERFACE macro below will expand to the following:
+//
+//      typedef struct IfaceMethods IfaceMethods;
+//      typedef struct IfaceVtbl
+//      {
+//          IfaceInclusiveMethods;
+//      } IfaceVtbl;
+//
+// IfaceInclusiveMethods macro must be properly defined
+
+// clang-format off
+#    define DILIGENT_END_INTERFACE\
+        typedef struct DILIGENT_CONCATENATE(DILIGENT_INTERFACE_NAME, Methods) DILIGENT_CONCATENATE(DILIGENT_INTERFACE_NAME, Methods); \
+        typedef struct DILIGENT_CONCATENATE(DILIGENT_INTERFACE_NAME, Vtbl)  \
+        {                                                                   \
+            DILIGENT_CONCATENATE(DILIGENT_INTERFACE_NAME, InclusiveMethods);\
+        } DILIGENT_CONCATENATE(DILIGENT_INTERFACE_NAME, Vtbl);
+// clang-format on
+
+#else
+
+#    define THIS
+#    define THIS_
+#    define VIRTUAL      virtual
+#    define CONST        const
+#    define PURE         = 0
+#    define REF          &
+#    define METHOD(Name) DILIGENT_CALL_TYPE Name
+#    define DILIGENT_END_INTERFACE
+
+#endif
diff --git a/app/src/main/java/libengine/DiligentLog/Primitives/interface/Errors.hpp b/app/src/main/java/libengine/DiligentLog/Primitives/interface/Errors.hpp
new file mode 100644
index 00000000..64887ae1
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Primitives/interface/Errors.hpp
@@ -0,0 +1,165 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include <stdexcept>
+#include <string>
+#include <iostream>
+
+#include "DebugOutput.h"
+#include "FormatString.hpp"
+
+namespace Diligent
+{
+
+template <bool>
+void ThrowIf(std::string&&)
+{
+}
+
+template <>
+inline void ThrowIf<true>(std::string&& msg)
+{
+    throw std::runtime_error(std::move(msg));
+}
+
+template <bool bThrowException, typename... ArgsType>
+void LogError(bool IsFatal, const char* Function, const char* FullFilePath, int Line, const ArgsType&... Args)
+{
+    std::string FileName(FullFilePath);
+
+    auto LastSlashPos = FileName.find_last_of("/\\");
+    if (LastSlashPos != std::string::npos)
+        FileName.erase(0, LastSlashPos + 1);
+    auto Msg = FormatString(Args...);
+    if (DebugMessageCallback != nullptr)
+    {
+        DebugMessageCallback(IsFatal ? DEBUG_MESSAGE_SEVERITY_FATAL_ERROR : DEBUG_MESSAGE_SEVERITY_ERROR, Msg.c_str(), Function, FileName.c_str(), Line);
+    }
+    else
+    {
+        // No callback set - output to cerr
+        std::cerr << "Diligent Engine: " << (IsFatal ? "Fatal Error" : "Error") << " in " << Function << "() (" << FileName << ", " << Line << "): " << Msg << '\n';
+    }
+    ThrowIf<bThrowException>(std::move(Msg));
+}
+
+} // namespace Diligent
+
+
+
+#define LOG_ERROR(...)                                                                                 \
+    do                                                                                                 \
+    {                                                                                                  \
+        Diligent::LogError<false>(/*IsFatal=*/false, __FUNCTION__, __FILE__, __LINE__, ##__VA_ARGS__); \
+    } while (false)
+
+
+#define LOG_FATAL_ERROR(...)                                                                          \
+    do                                                                                                \
+    {                                                                                                 \
+        Diligent::LogError<false>(/*IsFatal=*/true, __FUNCTION__, __FILE__, __LINE__, ##__VA_ARGS__); \
+    } while (false)
+
+#define LOG_ERROR_ONCE(...)             \
+    do                                  \
+    {                                   \
+        static bool IsFirstTime = true; \
+        if (IsFirstTime)                \
+        {                               \
+            LOG_ERROR(##__VA_ARGS__);   \
+            IsFirstTime = false;        \
+        }                               \
+    } while (false)
+
+
+#define LOG_ERROR_AND_THROW(...)                                                                      \
+    do                                                                                                \
+    {                                                                                                 \
+        Diligent::LogError<true>(/*IsFatal=*/false, __FUNCTION__, __FILE__, __LINE__, ##__VA_ARGS__); \
+    } while (false)
+
+#define LOG_FATAL_ERROR_AND_THROW(...)                                                               \
+    do                                                                                               \
+    {                                                                                                \
+        Diligent::LogError<true>(/*IsFatal=*/true, __FUNCTION__, __FILE__, __LINE__, ##__VA_ARGS__); \
+    } while (false)
+
+
+#define LOG_DEBUG_MESSAGE(Severity, ...)                                                                                            \
+    do                                                                                                                              \
+    {                                                                                                                               \
+        auto _msg = Diligent::FormatString(__VA_ARGS__);                                                                            \
+        if (Diligent::DebugMessageCallback != nullptr) Diligent::DebugMessageCallback(Severity, _msg.c_str(), nullptr, nullptr, 0); \
+    } while (false)
+
+#define LOG_FATAL_ERROR_MESSAGE(...) LOG_DEBUG_MESSAGE(Diligent::DEBUG_MESSAGE_SEVERITY_FATAL_ERROR, ##__VA_ARGS__)
+#define LOG_ERROR_MESSAGE(...)       LOG_DEBUG_MESSAGE(Diligent::DEBUG_MESSAGE_SEVERITY_ERROR, ##__VA_ARGS__)
+#define LOG_WARNING_MESSAGE(...)     LOG_DEBUG_MESSAGE(Diligent::DEBUG_MESSAGE_SEVERITY_WARNING, ##__VA_ARGS__)
+#define LOG_INFO_MESSAGE(...)        LOG_DEBUG_MESSAGE(Diligent::DEBUG_MESSAGE_SEVERITY_INFO, ##__VA_ARGS__)
+
+
+#define LOG_DEBUG_MESSAGE_ONCE(Severity, ...)           \
+    do                                                  \
+    {                                                   \
+        static bool IsFirstTime = true;                 \
+        if (IsFirstTime)                                \
+        {                                               \
+            LOG_DEBUG_MESSAGE(Severity, ##__VA_ARGS__); \
+            IsFirstTime = false;                        \
+        }                                               \
+    } while (false)
+
+#define LOG_FATAL_ERROR_MESSAGE_ONCE(...) LOG_DEBUG_MESSAGE_ONCE(Diligent::DEBUG_MESSAGE_SEVERITY_FATAL_ERROR, ##__VA_ARGS__)
+#define LOG_ERROR_MESSAGE_ONCE(...)       LOG_DEBUG_MESSAGE_ONCE(Diligent::DEBUG_MESSAGE_SEVERITY_ERROR, ##__VA_ARGS__)
+#define LOG_WARNING_MESSAGE_ONCE(...)     LOG_DEBUG_MESSAGE_ONCE(Diligent::DEBUG_MESSAGE_SEVERITY_WARNING, ##__VA_ARGS__)
+#define LOG_INFO_MESSAGE_ONCE(...)        LOG_DEBUG_MESSAGE_ONCE(Diligent::DEBUG_MESSAGE_SEVERITY_INFO, ##__VA_ARGS__)
+
+
+#define CHECK(Expr, Severity, ...)                      \
+    do                                                  \
+    {                                                   \
+        if (!(Expr))                                    \
+        {                                               \
+            LOG_DEBUG_MESSAGE(Severity, ##__VA_ARGS__); \
+        }                                               \
+    } while (false)
+
+#define CHECK_FATAL_ERR(Expr, ...) CHECK(Expr, Diligent::DEBUG_MESSAGE_SEVERITY_FATAL_ERROR, ##__VA_ARGS__)
+#define CHECK_ERR(Expr, ...)       CHECK(Expr, Diligent::DEBUG_MESSAGE_SEVERITY_ERROR, ##__VA_ARGS__)
+#define CHECK_WARN(Expr, ...)      CHECK(Expr, Diligent::DEBUG_MESSAGE_SEVERITY_WARNING, ##__VA_ARGS__)
+#define CHECK_INFO(Expr, ...)      CHECK(Expr, Diligent::DEBUG_MESSAGE_SEVERITY_INFO, ##__VA_ARGS__)
+
+#define CHECK_THROW(Expr, ...)                  \
+    do                                          \
+    {                                           \
+        if (!(Expr))                            \
+        {                                       \
+            LOG_ERROR_AND_THROW(##__VA_ARGS__); \
+        }                                       \
+    } while (false)
diff --git a/app/src/main/java/libengine/DiligentLog/Primitives/interface/FileStream.h b/app/src/main/java/libengine/DiligentLog/Primitives/interface/FileStream.h
new file mode 100644
index 00000000..0ef223fb
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Primitives/interface/FileStream.h
@@ -0,0 +1,90 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+/// \file
+/// Defines Diligent::IFileStream interface
+
+#include "Object.h"
+#include "DataBlob.h"
+
+DILIGENT_BEGIN_NAMESPACE(Diligent)
+
+/// IFileStream interface unique identifier
+// {E67F386C-6A5A-4A24-A0CE-C66435465D41}
+static const struct INTERFACE_ID IID_FileStream =
+    {0xe67f386c, 0x6a5a, 0x4a24, {0xa0, 0xce, 0xc6, 0x64, 0x35, 0x46, 0x5d, 0x41}};
+
+// clang-format off
+
+#define DILIGENT_INTERFACE_NAME IFileStream
+#include "DefineInterfaceHelperMacros.h"
+
+#define IFileStreamInclusiveMethods \
+    IObjectInclusiveMethods;        \
+    IFileStreamMethods FileStream
+
+/// Base interface for a file stream
+DILIGENT_BEGIN_INTERFACE(IFileStream, IObject)
+{
+    /// Reads data from the stream
+    VIRTUAL bool METHOD(Read)(THIS_
+                              void*  Data,
+                              size_t BufferSize) PURE;
+
+    VIRTUAL void METHOD(ReadBlob)(THIS_
+                                  IDataBlob* pData) PURE;
+
+    /// Writes data to the stream
+    VIRTUAL bool METHOD(Write)(THIS_
+                               const void* Data, 
+                               size_t      Size) PURE;
+
+    VIRTUAL size_t METHOD(GetSize)(THIS) PURE;
+
+    VIRTUAL bool METHOD(IsValid)(THIS) PURE;
+};
+DILIGENT_END_INTERFACE
+
+#include "UndefInterfaceHelperMacros.h"
+
+#if DILIGENT_C_INTERFACE
+
+// clang-format off
+
+#    define IFileStream_Read(This, ...)     CALL_IFACE_METHOD(FileStream, Read,     This, __VA_ARGS__)
+#    define IFileStream_ReadBlob(This, ...) CALL_IFACE_METHOD(FileStream, ReadBlob, This, __VA_ARGS__)
+#    define IFileStream_Write(This, ...)    CALL_IFACE_METHOD(FileStream, Write,    This, __VA_ARGS__)
+#    define IFileStream_GetSize(This)       CALL_IFACE_METHOD(FileStream, GetSize,  This)
+#    define IFileStream_IsValid(This)       CALL_IFACE_METHOD(FileStream, IsValid,  This)
+
+// clang-format on
+
+#endif
+
+DILIGENT_END_NAMESPACE // namespace Diligent
diff --git a/app/src/main/java/libengine/DiligentLog/Primitives/interface/FlagEnum.h b/app/src/main/java/libengine/DiligentLog/Primitives/interface/FlagEnum.h
new file mode 100644
index 00000000..b97e013a
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Primitives/interface/FlagEnum.h
@@ -0,0 +1,53 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "BasicTypes.h"
+
+#if DILIGENT_C_INTERFACE
+
+#    define DEFINE_FLAG_ENUM_OPERATORS(ENUMTYPE)
+
+#else
+
+template <typename EnumType>
+using _UNDERLYING_ENUM_T = typename std::underlying_type<EnumType>::type;
+
+#    define DEFINE_FLAG_ENUM_OPERATORS(ENUMTYPE)                                                                                                                                                                      \
+        extern "C++"                                                                                                                                                                                                  \
+        {                                                                                                                                                                                                             \
+            inline ENUMTYPE&          operator|=(ENUMTYPE& a, ENUMTYPE b) { return reinterpret_cast<ENUMTYPE&>(reinterpret_cast<_UNDERLYING_ENUM_T<ENUMTYPE>&>(a) |= static_cast<_UNDERLYING_ENUM_T<ENUMTYPE>>(b)); } \
+            inline ENUMTYPE&          operator&=(ENUMTYPE& a, ENUMTYPE b) { return reinterpret_cast<ENUMTYPE&>(reinterpret_cast<_UNDERLYING_ENUM_T<ENUMTYPE>&>(a) &= static_cast<_UNDERLYING_ENUM_T<ENUMTYPE>>(b)); } \
+            inline ENUMTYPE&          operator^=(ENUMTYPE& a, ENUMTYPE b) { return reinterpret_cast<ENUMTYPE&>(reinterpret_cast<_UNDERLYING_ENUM_T<ENUMTYPE>&>(a) ^= static_cast<_UNDERLYING_ENUM_T<ENUMTYPE>>(b)); } \
+            inline constexpr ENUMTYPE operator|(ENUMTYPE a, ENUMTYPE b) { return static_cast<ENUMTYPE>(static_cast<_UNDERLYING_ENUM_T<ENUMTYPE>>(a) | static_cast<_UNDERLYING_ENUM_T<ENUMTYPE>>(b)); }                \
+            inline constexpr ENUMTYPE operator&(ENUMTYPE a, ENUMTYPE b) { return static_cast<ENUMTYPE>(static_cast<_UNDERLYING_ENUM_T<ENUMTYPE>>(a) & static_cast<_UNDERLYING_ENUM_T<ENUMTYPE>>(b)); }                \
+            inline constexpr ENUMTYPE operator^(ENUMTYPE a, ENUMTYPE b) { return static_cast<ENUMTYPE>(static_cast<_UNDERLYING_ENUM_T<ENUMTYPE>>(a) ^ static_cast<_UNDERLYING_ENUM_T<ENUMTYPE>>(b)); }                \
+            inline constexpr ENUMTYPE operator~(ENUMTYPE a) { return static_cast<ENUMTYPE>(~static_cast<_UNDERLYING_ENUM_T<ENUMTYPE>>(a)); }                                                                          \
+        }
+
+#endif
diff --git a/app/src/main/java/libengine/DiligentLog/Primitives/interface/FormatString.hpp b/app/src/main/java/libengine/DiligentLog/Primitives/interface/FormatString.hpp
new file mode 100644
index 00000000..bc42aa76
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Primitives/interface/FormatString.hpp
@@ -0,0 +1,103 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include <sstream>
+#include <iomanip>
+
+namespace Diligent
+{
+
+template <typename SSType>
+void FormatStrSS(SSType& ss)
+{
+}
+
+template <typename SSType, typename ArgType>
+void FormatStrSS(SSType& ss, const ArgType& Arg)
+{
+    ss << Arg;
+}
+
+template <typename SSType, typename FirstArgType, typename... RestArgsType>
+void FormatStrSS(SSType& ss, const FirstArgType& FirstArg, const RestArgsType&... RestArgs)
+{
+    FormatStrSS(ss, FirstArg);
+    FormatStrSS(ss, RestArgs...); // recursive call using pack expansion syntax
+}
+
+template <typename... RestArgsType>
+std::string FormatString(const RestArgsType&... Args)
+{
+    std::stringstream ss;
+    FormatStrSS(ss, Args...);
+    return ss.str();
+}
+
+template <typename Type>
+struct MemorySizeFormatter
+{
+    MemorySizeFormatter(Type _size, int _precision, Type _ref_size) :
+        size{_size},
+        precision{_precision},
+        ref_size{_ref_size}
+    {}
+    Type size      = 0;
+    int  precision = 0;
+    Type ref_size  = 0;
+};
+
+template <typename Type>
+MemorySizeFormatter<Type> FormatMemorySize(Type _size, int _precision = 0, Type _ref_size = 0)
+{
+    return MemorySizeFormatter<Type>{_size, _precision, _ref_size};
+}
+
+template <typename SSType, typename Type>
+void FormatStrSS(SSType& ss, const MemorySizeFormatter<Type>& Arg)
+{
+    auto ref_size = Arg.ref_size != 0 ? Arg.ref_size : Arg.size;
+    if (ref_size >= (1 << 30))
+    {
+        ss << std::fixed << std::setprecision(Arg.precision) << static_cast<double>(Arg.size) / double{1 << 30} << " GB";
+    }
+    else if (ref_size >= (1 << 20))
+    {
+        ss << std::fixed << std::setprecision(Arg.precision) << static_cast<double>(Arg.size) / double{1 << 20} << " MB";
+    }
+    else if (ref_size >= (1 << 10))
+    {
+        ss << std::fixed << std::setprecision(Arg.precision) << static_cast<double>(Arg.size) / double{1 << 10} << " KB";
+    }
+    else
+    {
+        ss << Arg.size << (((Arg.size & 0x01) == 0x01) ? " Byte" : " Bytes");
+    }
+}
+
+} // namespace Diligent
diff --git a/app/src/main/java/libengine/DiligentLog/Primitives/interface/InterfaceID.h b/app/src/main/java/libengine/DiligentLog/Primitives/interface/InterfaceID.h
new file mode 100644
index 00000000..aca1a64d
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Primitives/interface/InterfaceID.h
@@ -0,0 +1,59 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include <string.h>
+#include "BasicTypes.h"
+
+/// Unique identification structures
+DILIGENT_BEGIN_NAMESPACE(Diligent)
+
+/// Unique interface identifier
+struct INTERFACE_ID
+{
+    Uint32 Data1;
+    Uint16 Data2;
+    Uint16 Data3;
+    Uint8  Data4[8];
+
+#if DILIGENT_CPP_INTERFACE
+    bool operator==(const INTERFACE_ID& rhs) const
+    {
+        return Data1 == rhs.Data1 &&
+            Data2 == rhs.Data2 &&
+            Data3 == rhs.Data3 &&
+            memcmp(Data4, rhs.Data4, sizeof(Data4)) == 0;
+    }
+#endif
+};
+typedef struct INTERFACE_ID INTERFACE_ID;
+
+/// Unknown interface
+static const INTERFACE_ID IID_Unknown = {0, 0, 0, {0, 0, 0, 0, 0, 0, 0, 0}};
+
+DILIGENT_END_NAMESPACE // namespace Diligent
diff --git a/app/src/main/java/libengine/DiligentLog/Primitives/interface/MemoryAllocator.h b/app/src/main/java/libengine/DiligentLog/Primitives/interface/MemoryAllocator.h
new file mode 100644
index 00000000..af660f0d
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Primitives/interface/MemoryAllocator.h
@@ -0,0 +1,81 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+/// \file
+/// Defines Diligent::IMemoryAllocator interface
+
+#include "BasicTypes.h"
+
+DILIGENT_BEGIN_NAMESPACE(Diligent)
+
+
+#if DILIGENT_CPP_INTERFACE
+
+/// Base interface for a raw memory allocator
+struct IMemoryAllocator
+{
+    /// Allocates block of memory
+    virtual void* Allocate(size_t Size, const Char* dbgDescription, const char* dbgFileName, const Int32 dbgLineNumber) = 0;
+
+    /// Releases memory
+    virtual void Free(void* Ptr) = 0;
+};
+
+#else
+
+struct IMemoryAllocator;
+
+// clang-format off
+
+struct IMemoryAllocatorMethods
+{
+    void* (*Allocate) (struct IMemoryAllocator*, size_t Size, const Char* dbgDescription, const char* dbgFileName, const Int32 dbgLineNumber);
+    void  (*Free)     (struct IMemoryAllocator*, void* Ptr);
+};
+
+struct IMemoryAllocatorVtbl
+{
+    struct IMemoryAllocatorMethods MemoryAllocator;
+};
+
+// clang-format on
+
+typedef struct IMemoryAllocator
+{
+    struct IMemoryAllocatorVtbl* pVtbl;
+} IMemoryAllocator;
+
+// clang-format off
+
+#    define IMemoryAllocator_Allocate(This, ...) CALL_IFACE_METHOD(MemoryAllocator, Allocate, This, __VA_ARGS__)
+#    define IMemoryAllocator_Free(This, ...)     CALL_IFACE_METHOD(MemoryAllocator, Free,     This, __VA_ARGS__)
+
+#endif
+
+DILIGENT_END_NAMESPACE // namespace Diligent
diff --git a/app/src/main/java/libengine/DiligentLog/Primitives/interface/Object.h b/app/src/main/java/libengine/DiligentLog/Primitives/interface/Object.h
new file mode 100644
index 00000000..20a4ad98
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Primitives/interface/Object.h
@@ -0,0 +1,120 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+/// \file
+/// Defines Diligent::IObject interface
+
+#include "InterfaceID.h"
+#include "ReferenceCounters.h"
+
+DILIGENT_BEGIN_NAMESPACE(Diligent)
+
+#if DILIGENT_CPP_INTERFACE
+
+/// Base interface for all dynamic objects in the engine
+struct IObject
+{
+    /// Queries the specific interface.
+
+    /// \param [in] IID - Unique identifier of the requested interface.
+    /// \param [out] ppInterface - Memory address where the pointer to the requested interface will be written.
+    ///                            If the interface is not supported, null pointer will be returned.
+    /// \remark The method increments the number of strong references by 1. The interface must be
+    ///         released by a call to Release() method when it is no longer needed.
+    virtual void DILIGENT_CALL_TYPE QueryInterface(const INTERFACE_ID& IID, IObject** ppInterface) = 0;
+
+
+    /// Increments the number of strong references by 1.
+
+    /// \remark This method is equivalent to GetReferenceCounters()->AddStrongRef().\n
+    ///         The method is thread-safe and does not require explicit synchronization.
+    /// \return The number of strong references after incrementing the counter.
+    /// \note   In a multithreaded environment, the returned number may not be reliable
+    ///         as other threads may simultaneously change the actual value of the counter.
+    virtual ReferenceCounterValueType DILIGENT_CALL_TYPE AddRef() = 0;
+
+
+    /// Decrements the number of strong references by 1 and destroys the object when the
+    /// counter reaches zero.
+
+    /// \remark This method is equivalent to GetReferenceCounters()->ReleaseStrongRef().\n
+    ///         The method is thread-safe and does not require explicit synchronization.
+    /// \return The number of strong references after decrementing the counter.
+    /// \note   In a multithreaded environment, the returned number may not be reliable
+    ///         as other threads may simultaneously change the actual value of the counter.
+    ///         The only reliable value is 0 as the object is destroyed when the last
+    ///         strong reference is released.
+    virtual ReferenceCounterValueType DILIGENT_CALL_TYPE Release() = 0;
+
+
+    /// Returns the pointer to IReferenceCounters interface of the associated
+    /// reference counters object. The method does *NOT* increment
+    /// the number of strong references to the returned object.
+    virtual IReferenceCounters* DILIGENT_CALL_TYPE GetReferenceCounters() const = 0;
+};
+
+#else
+
+struct IObject;
+
+// clang-format off
+
+typedef struct IObjectMethods
+{
+    void                       (*QueryInterface)      (struct IObject*, const struct INTERFACE_ID* IID, struct IObject** ppInterface);
+    ReferenceCounterValueType  (*AddRef)              (struct IObject*);
+    ReferenceCounterValueType  (*Release)             (struct IObject*);
+    struct IReferenceCounters* (*GetReferenceCounters)(struct IObject*);
+} IObjectMethods;
+
+#define IObjectInclusiveMethods IObjectMethods Object
+
+typedef struct IObjectVtbl
+{
+    IObjectInclusiveMethods;
+} IObjectVtbl;
+
+// clang-format on
+
+typedef struct IObject
+{
+    struct IObjectVtbl* pVtbl;
+} IObject;
+
+// clang-format off
+
+#    define IObject_QueryInterface(This, ...) CALL_IFACE_METHOD(Object, QueryInterface, This, __VA_ARGS__)
+#    define IObject_AddRef(This)              CALL_IFACE_METHOD(Object, AddRef,         This)
+#    define IObject_Release(This)             CALL_IFACE_METHOD(Object, Release,        This)
+
+// clang-format on
+
+#endif
+
+DILIGENT_END_NAMESPACE // namespace Diligent
diff --git a/app/src/main/java/libengine/DiligentLog/Primitives/interface/ReferenceCounters.h b/app/src/main/java/libengine/DiligentLog/Primitives/interface/ReferenceCounters.h
new file mode 100644
index 00000000..0ac50791
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Primitives/interface/ReferenceCounters.h
@@ -0,0 +1,165 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+/// \file
+/// Defines Diligent::IReferenceCounters interface
+
+#include "InterfaceID.h"
+
+DILIGENT_BEGIN_NAMESPACE(Diligent)
+
+typedef long ReferenceCounterValueType;
+
+#if DILIGENT_CPP_INTERFACE
+
+/// Base interface for a reference counter object that stores the number of strong and
+/// weak references and the pointer to the object. It is necessary to separate reference
+/// counters from the object to support weak pointers.
+class IReferenceCounters
+{
+public:
+    /// Increments the number of strong references by 1.
+
+    /// \return The number of strong references after incrementing the counter.
+    /// \remark The method is thread-safe and does not require explicit synchronization.
+    /// \note   In a multithreaded environment, the returned number may not be reliable
+    ///         as other threads may simultaneously change the actual value of the counter.
+    virtual ReferenceCounterValueType AddStrongRef() = 0;
+
+
+    /// Decrements the number of strong references by 1 and destroys the referenced object
+    /// when the counter reaches zero. If there are no more weak references, destroys the
+    /// reference counters object itself.
+
+    /// \return The number of strong references after decrementing the counter.
+    /// \remark The referenced object is destroyed when the last strong reference is released.\n
+    ///         If there are no more weak references, the reference counters object itself is
+    ///         also destroyed.\n
+    ///         The method is thread-safe and does not require explicit synchronization.
+    /// \note   In a multithreaded environment, the returned number may not be reliable
+    ///         as other threads may simultaneously change the actual value of the counter.
+    ///         The only reliable value is 0 as the object is destroyed when the last
+    ///         strong reference is released.
+    virtual ReferenceCounterValueType ReleaseStrongRef() = 0;
+
+
+    /// Increments the number of weak references by 1.
+
+    /// \return The number of weak references after incrementing the counter.
+    /// \remark The method is thread-safe and does not require explicit synchronization.
+    /// \note   In a multithreaded environment, the returned number may not be reliable
+    ///         as other threads may simultaneously change the actual value of the counter.
+    virtual ReferenceCounterValueType AddWeakRef() = 0;
+
+
+    /// Decrements the number of weak references by 1. If there are no more strong and weak
+    /// references, destroys the reference counters object itself.
+
+    /// \return The number of weak references after decrementing the counter.
+    /// \remark The method is thread-safe and does not require explicit synchronization.
+    /// \note   In a multithreaded environment, the returned number may not be reliable
+    ///         as other threads may simultaneously change the actual value of the counter.
+    virtual ReferenceCounterValueType ReleaseWeakRef() = 0;
+
+
+    /// Gets the pointer to the IUnknown interface of the referenced object.
+
+    /// \param [out] ppObject - Memory address where the pointer to the object
+    ///                         will be stored.
+    /// \remark If the object was destroyed, nullptr will be written to *ppObject.
+    ///         If the object was not released, the pointer to the object's IUnknown interface
+    ///         will be stored. In this case, the number of strong references to the object
+    ///         will be incremented by 1.\n
+    ///         The method is thread-safe and does not require explicit synchronization.
+    virtual void GetObject(struct IObject** ppObject) = 0;
+
+
+    /// Returns the number of outstanding strong references.
+
+    /// \return The number of strong references.
+    /// \note   In a multithreaded environment, the returned number may not be reliable
+    ///         as other threads may simultaneously change the actual value of the counter.
+    ///         The only reliable value is 0 as the object is destroyed when the last
+    ///         strong reference is released.
+    virtual ReferenceCounterValueType GetNumStrongRefs() const = 0;
+
+
+    /// Returns the number of outstanding weak references.
+
+    /// \return The number of weak references.
+    /// \note   In a multithreaded environment, the returned number may not be reliable
+    ///         as other threads may simultaneously change the actual value of the counter.
+    virtual ReferenceCounterValueType GetNumWeakRefs() const = 0;
+};
+
+#else
+
+struct IObject;
+struct IReferenceCounters;
+
+// clang-format off
+
+typedef struct IReferenceCountersMethods
+{
+    ReferenceCounterValueType (*AddStrongRef)      (struct IReferenceCounters*);
+    ReferenceCounterValueType (*ReleaseStrongRef)  (struct IReferenceCounters*);
+    ReferenceCounterValueType (*AddWeakRef)        (struct IReferenceCounters*);
+    ReferenceCounterValueType (*ReleaseWeakRef)    (struct IReferenceCounters*);
+    void                      (*GetObject)         (struct IReferenceCounters*, struct IObject** ppObject);
+    ReferenceCounterValueType (*GetNumStrongRefs)  (struct IReferenceCounters*);
+    ReferenceCounterValueType (*GetNumWeakRefs)    (struct IReferenceCounters*);
+} IReferenceCountersMethods;
+
+typedef struct IReferenceCountersVtbl
+{
+    IReferenceCountersMethods ReferenceCounters;
+} IReferenceCountersVtbl;
+
+// clang-format on
+
+typedef struct IReferenceCounters
+{
+    struct IReferenceCountersVtbl* pVtbl;
+} IReferenceCounters;
+
+// clang-format off
+
+#    define IReferenceCounters_AddStrongRef(This)      CALL_IFACE_METHOD(ReferenceCounters, AddStrongRef,     This)
+#    define IReferenceCounters_ReleaseStrongRef(This)  CALL_IFACE_METHOD(ReferenceCounters, ReleaseStrongRef, This)
+#    define IReferenceCounters_AddWeakRef(This)        CALL_IFACE_METHOD(ReferenceCounters, AddWeakRef,       This)
+#    define IReferenceCounters_ReleaseWeakRef(This)    CALL_IFACE_METHOD(ReferenceCounters, ReleaseWeakRef,   This)
+#    define IReferenceCounters_GetObject(This, ...)    CALL_IFACE_METHOD(ReferenceCounters, GetObject,        This, __VA_ARGS__)
+#    define IReferenceCounters_GetNumStrongRefs(This)  CALL_IFACE_METHOD(ReferenceCounters, GetNumStrongRefs, This)
+#    define IReferenceCounters_GetNumWeakRefs(This)    CALL_IFACE_METHOD(ReferenceCounters, GetNumWeakRefs,   This)
+
+// clang-format on
+
+#endif
+
+DILIGENT_END_NAMESPACE // namespace Diligent
diff --git a/app/src/main/java/libengine/DiligentLog/Primitives/interface/UndefGlobalFuncHelperMacros.h b/app/src/main/java/libengine/DiligentLog/Primitives/interface/UndefGlobalFuncHelperMacros.h
new file mode 100644
index 00000000..6d189ea7
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Primitives/interface/UndefGlobalFuncHelperMacros.h
@@ -0,0 +1,28 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma pop_macro("REF")
diff --git a/app/src/main/java/libengine/DiligentLog/Primitives/interface/UndefInterfaceHelperMacros.h b/app/src/main/java/libengine/DiligentLog/Primitives/interface/UndefInterfaceHelperMacros.h
new file mode 100644
index 00000000..6ab8fc99
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Primitives/interface/UndefInterfaceHelperMacros.h
@@ -0,0 +1,37 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma pop_macro("THIS")
+#pragma pop_macro("THIS_")
+#pragma pop_macro("VIRTUAL")
+#pragma pop_macro("CONST")
+#pragma pop_macro("PURE")
+#pragma pop_macro("REF")
+#pragma pop_macro("METHOD")
+
+#undef DILIGENT_INTERFACE_NAME
+#undef DILIGENT_END_INTERFACE
diff --git a/app/src/main/java/libengine/DiligentLog/Primitives/src/DebugOutput.cpp b/app/src/main/java/libengine/DiligentLog/Primitives/src/DebugOutput.cpp
new file mode 100644
index 00000000..2882af50
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Primitives/src/DebugOutput.cpp
@@ -0,0 +1,40 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence),
+ *  contract, or otherwise, unless required by applicable law (such as deliberate
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental,
+ *  or consequential damages of any character arising as a result of this License or
+ *  out of the use or inability to use the software (including but not limited to damages
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and
+ *  all other commercial damages or losses), even if such Contributor has been advised
+ *  of the possibility of such damages.
+ */
+
+#include "DebugOutput.h"
+
+namespace Diligent
+{
+
+void SetDebugMessageCallback(DebugMessageCallbackType DbgMessageCallback)
+{
+    // DebugMessageCallback variable is defined in every platform-specific implementation file
+    // and initialized with the platform-specific callback
+    DebugMessageCallback = DbgMessageCallback;
+}
+
+} // namespace Diligent
diff --git a/app/src/main/java/libengine/DiligentLog/Primitives/src/test.cpp b/app/src/main/java/libengine/DiligentLog/Primitives/src/test.cpp
new file mode 100644
index 00000000..d63d7572
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Primitives/src/test.cpp
@@ -0,0 +1,35 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence),
+ *  contract, or otherwise, unless required by applicable law (such as deliberate
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental,
+ *  or consequential damages of any character arising as a result of this License or
+ *  out of the use or inability to use the software (including but not limited to damages
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and
+ *  all other commercial damages or losses), even if such Contributor has been advised
+ *  of the possibility of such damages.
+ */
+
+#include "BasicTypes.h"
+#include "InterfaceID.h"
+#include "ReferenceCounters.h"
+#include "Object.h"
+#include "MemoryAllocator.h"
+#include "FormatString.hpp"
+#include "FileStream.h"
+#include "DataBlob.h"
diff --git a/app/src/main/java/libengine/DiligentLog/common.cpp b/app/src/main/java/libengine/DiligentLog/common.cpp
new file mode 100644
index 00000000..62748999
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/common.cpp
@@ -0,0 +1,25 @@
+//
+// Created by Matthew Good on 29/7/21.
+//
+
+#include "Log.h"
+#include "Primitives/interface/Errors.hpp"
+
+void Log::Log_String(const Log::SEVERITY & severity, const char * msg) {
+    if (Diligent::DebugMessageCallback != nullptr) {
+        Diligent::DebugMessageCallback(
+                severity == Log::INFO ? Diligent::DEBUG_MESSAGE_SEVERITY_INFO
+                                      : (
+                        severity == Log::ERROR ? Diligent::DEBUG_MESSAGE_SEVERITY_ERROR
+                                               : Diligent::DEBUG_MESSAGE_SEVERITY_FATAL_ERROR
+                ), msg, nullptr, nullptr, 0
+        );
+    }
+    if (severity == Log::FATAL) {
+        throw std::runtime_error(msg);
+    }
+}
+
+void Log::Log_String(const Log::SEVERITY & severity, const std::string & msg) {
+    Log_String(severity, msg.c_str());
+}
diff --git a/app/src/main/java/libengine/JVM_MANAGER.cpp b/app/src/main/java/libengine/JVM_MANAGER.cpp
new file mode 100644
index 00000000..6102a854
--- /dev/null
+++ b/app/src/main/java/libengine/JVM_MANAGER.cpp
@@ -0,0 +1,45 @@
+//
+// Created by Matthew Good on 29/6/21.
+//
+
+#include "JVM_MANAGER.h"
+
+JVM_MANAGER::JVM_MANAGER() {
+    jvm = nullptr;
+    jenv = nullptr;
+    needsToDetach = false;
+    jvmArgs.version = JNI_VERSION_1_6;
+}
+
+bool JVM_MANAGER::getJVM(JNIEnv *env) {
+    return env->GetJavaVM(&jvm) == JNI_OK;
+}
+
+bool JVM_MANAGER::attachJVM() {
+    // checks if current env needs attaching or it is already attached
+    jint res = jvm->GetEnv((void**)&jenv, JNI_VERSION_1_6);
+    if (res == JNI_EDETACHED) {
+        // Supported but not attached yet, needs to call AttachCurrentThread
+        res = jvm->AttachCurrentThread(&jenv, &jvmArgs);
+        if (res == JNI_OK) {
+            needsToDetach = true;
+        } else {
+            // Failed to attach, cancel
+            return false;
+        }
+    } else if (JNI_OK == res) {
+        // Current thread already attached, do not attach 'again' (just to save the attachedHere flag)
+        // We make sure to keep attached = 0
+        needsToDetach = false;
+    } else {
+        // JNI_EVERSION, specified version is not supported cancel this..
+        return false;
+    }
+    return true;
+}
+
+void JVM_MANAGER::detachJVM() {
+    if (needsToDetach) {
+        jvm->DetachCurrentThread();
+    }
+}
diff --git a/app/src/main/java/libengine/JVM_MANAGER.h b/app/src/main/java/libengine/JVM_MANAGER.h
new file mode 100644
index 00000000..b16824db
--- /dev/null
+++ b/app/src/main/java/libengine/JVM_MANAGER.h
@@ -0,0 +1,26 @@
+//
+// Created by Matthew Good on 29/6/21.
+//
+
+#ifndef GRAPHICAL_TOOL_KIT_JVM_MANAGER_H
+#define GRAPHICAL_TOOL_KIT_JVM_MANAGER_H
+#include <jni.h>
+
+class JVM_MANAGER {
+public:
+    JavaVM * jvm;
+    JNIEnv* jenv;
+    JavaVMAttachArgs jvmArgs;
+    bool needsToDetach;
+    
+    JVM_MANAGER();
+    bool getJVM(JNIEnv * env);
+    bool attachJVM();
+    void detachJVM();
+    
+    template <typename J, typename O> O globalRef(J j, O o) {
+        return reinterpret_cast<O>(j->NewGlobalRef(o));
+    }
+};
+
+#endif //GRAPHICAL_TOOL_KIT_JVM_MANAGER_H
diff --git a/app/src/main/java/libengine/RVVM/.github/ISSUE_TEMPLATE/bug_report.md b/app/src/main/java/libengine/RVVM/.github/ISSUE_TEMPLATE/bug_report.md
new file mode 100644
index 00000000..f3bd2c0e
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/.github/ISSUE_TEMPLATE/bug_report.md
@@ -0,0 +1,39 @@
+---
+name: Bug report
+about: Create a report to help us improve
+title: ''
+labels: bug
+assignees: ''
+
+---
+
+### The issue
+- This doesn't work right ...
+
+### Steps to reproduce
+- Use this guest image ...
+- Run `rvvm fw_jump.bin -m 1G -k ...`
+- Wait till the guest boots
+- Run this command ...
+- Observe the issue
+
+### Investigation
+- I stumbled upon this when ...
+- This worked previously
+- This may have been caused by a recent commit
+
+### Workarounds
+- The issue doesn't manifest when we disable ...
+- Reverting this commit fixes it
+
+### Suggested fix / Expected behavior
+- This may be fixed by ...
+- According to RISC-V spec ...
+- I think it should be done like this ...
+
+### Additional info
+- Reference RVVM commit (Shown in `rvvm -h`, guest `/proc/cpuinfo`, machine name)
+- Host OS/Architecture (If applies)
+- Links to additional material
+
+Feel free to remove unused sections
diff --git a/app/src/main/java/libengine/RVVM/.github/ISSUE_TEMPLATE/feature_request.md b/app/src/main/java/libengine/RVVM/.github/ISSUE_TEMPLATE/feature_request.md
new file mode 100644
index 00000000..82a1cef2
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/.github/ISSUE_TEMPLATE/feature_request.md
@@ -0,0 +1,25 @@
+---
+name: Feature request
+about: Suggest an idea for this project
+title: ''
+labels: enhancement
+assignees: ''
+
+---
+
+### Exact requirements
+- I want to improve efficiency of ...
+
+### Suggested solution
+- Emulate this device ...
+- Switch to it in default RVVM board ...
+
+### Expected results and side effects
+- The Linux guests will be using driver ...
+- This enables networking with Haiku guests ...
+- This may break some guests which ...
+- This could improve performance on Windows hosts
+
+### Alternatives
+- Existing RVVM solution differs to this ...
+- Another project X solves this by ...
diff --git a/app/src/main/java/libengine/RVVM/.github/codeql/codeql-config.yml b/app/src/main/java/libengine/RVVM/.github/codeql/codeql-config.yml
new file mode 100644
index 00000000..7b313a35
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/.github/codeql/codeql-config.yml
@@ -0,0 +1,19 @@
+name: "CodeQL config"
+queries:
+  - uses: security-extended
+  - uses: security-and-quality
+query-filters:
+  - exclude:
+      id: cpp/path-injection
+  - exclude:
+      id: cpp/commented-out-code
+  - exclude:
+      id: cpp/long-switch
+  - exclude:
+      id: cpp/equality-on-floats
+  - exclude:
+      id: cpp/include-non-header
+  - exclude:
+      id: cpp/complex-block
+  - exclude:
+      id: cpp/trivial-switch
diff --git a/app/src/main/java/libengine/RVVM/.github/workflows/build.yml b/app/src/main/java/libengine/RVVM/.github/workflows/build.yml
new file mode 100644
index 00000000..e04f5d5b
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/.github/workflows/build.yml
@@ -0,0 +1,73 @@
+name: Build
+
+on:
+  workflow_dispatch:
+  push:
+    branches: [ "staging" ]
+  pull_request:
+    branches: [ "staging" ]
+  schedule:
+    - cron: "0 0 * * *"
+
+env:
+  CFLAGS: -Werror
+
+jobs:
+  linux-build:
+    runs-on: ubuntu-24.04
+    steps:
+    - name: Checkout
+      uses: actions/checkout@v4.1.1
+    - name: Install libX11
+      run: sudo DEBIAN_FRONTEND=noninteractive apt-get install -yq --no-install-recommends libx11-dev libxext-dev
+    - name: Build
+      run: make lib all
+    - name: Run RISC-V Tests
+      run: timeout 600 make lib all test
+    - name: Upload Artifacts
+      uses: actions/upload-artifact@v4.3.1
+      with:
+        retention-days: 5
+        name: rvvm_linux_x86_64
+        path: |
+          release.linux.x86_64/rvvm_x86_64
+          release.linux.x86_64/librvvm.so
+          release.linux.x86_64/librvvm_static.a
+
+  win32-build:
+    runs-on: ubuntu-24.04
+    steps:
+    - name: Checkout
+      uses: actions/checkout@v4.1.1
+    - name: Set up MinGW
+      run: sudo DEBIAN_FRONTEND=noninteractive apt-get install -yq --no-install-recommends gcc-mingw-w64-x86-64-win32
+    - name: Build
+      run: make CC=x86_64-w64-mingw32-gcc lib all
+    - name: Upload Artifacts
+      uses: actions/upload-artifact@v4.3.1
+      with:
+        retention-days: 5
+        name: rvvm_win32_x86_64
+        path: |
+          release.windows.x86_64/rvvm_x86_64.exe
+          release.windows.x86_64/librvvm.dll
+          release.windows.x86_64/librvvm_static.a
+
+  macos-build:
+    runs-on: macos-12
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v4.1.1
+      - name: Install SDL
+        run: brew install sdl12-compat
+      - name: Build
+        run: make lib all
+      - name: Upload Artifacts
+        uses: actions/upload-artifact@v4.3.1
+        with:
+          retention-days: 5
+          name: rvvm_macos_x86_64
+          path: |
+            release.darwin.x86_64/rvvm_x86_64
+            release.darwin.x86_64/librvvm.dylib
+            release.darwin.x86_64/librvvm_static.a
diff --git a/app/src/main/java/libengine/RVVM/.github/workflows/codeql.yml b/app/src/main/java/libengine/RVVM/.github/workflows/codeql.yml
new file mode 100644
index 00000000..1f1dbfa4
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/.github/workflows/codeql.yml
@@ -0,0 +1,41 @@
+name: "CodeQL"
+
+on:
+  push:
+    branches: [ "staging" ]
+  pull_request:
+    branches: [ "staging" ]
+  schedule:
+    - cron: "52 7 * * 4"
+
+jobs:
+  analyze:
+    name: Analyze
+    runs-on: ubuntu-22.04
+    permissions:
+      actions: read
+      contents: read
+      security-events: write
+
+    strategy:
+      fail-fast: false
+      matrix:
+        language: [ cpp ]
+
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v3
+
+      - name: Initialize CodeQL
+        uses: github/codeql-action/init@v2
+        with:
+          languages: cpp
+          config-file: ./.github/codeql/codeql-config.yml
+
+      - name: Autobuild
+        uses: github/codeql-action/autobuild@v2
+
+      - name: Perform CodeQL Analysis
+        uses: github/codeql-action/analyze@v2
+        with:
+          category: "/language:${{ matrix.language }}"
diff --git a/app/src/main/java/libengine/RVVM/.gitignore b/app/src/main/java/libengine/RVVM/.gitignore
new file mode 100644
index 00000000..4c530931
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/.gitignore
@@ -0,0 +1,39 @@
+#
+# To clean up the repo, run `git clean -Xdf`
+#
+
+# Makefile default build paths
+/release.*/
+/debug.*/
+
+# CMake default build path
+/build/
+
+# CMake garbage if someone tries in-source build
+CMakeFiles/
+CMakeCache.txt
+cmake_install.cmake
+Makefile*
+
+# Assets for WASM build
+/wasm/
+
+# Temporary local stuff
+/tmp/
+
+# Kate editor temp files
+*.kate-swp
+
+# Other editors that people might use
+/.vscode/
+
+# Patches stuff
+/*.patch
+*.rej
+*.orig
+
+# Random stuff on Windows build host
+NUL
+
+# Explicitly allow our main makefile
+!/Makefile
diff --git a/app/src/main/java/libengine/RVVM/.gitlab-ci.yml b/app/src/main/java/libengine/RVVM/.gitlab-ci.yml
new file mode 100644
index 00000000..a2efc6a1
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/.gitlab-ci.yml
@@ -0,0 +1,290 @@
+# DESCRIPTION: GitLab CI/CD for libRetro (NOT FOR GitLab-proper)
+
+##############################################################################
+################################# BOILERPLATE ################################
+##############################################################################
+
+# Core definitions
+.core-defs:
+  variables:
+    CORENAME: rvvm
+    CORE_ARGS: -DBUILD_LIBRETRO=ON -DCMAKE_BUILD_TYPE=Release
+
+.core-defs-osx:
+  extends: .core-defs
+  variables:
+    CORE_ARGS: -DBUILD_LIBRETRO=ON -DCMAKE_BUILD_TYPE=Release -G Xcode
+    EXTRA_PATH: Release
+
+# Inclusion templates, required for the build to work
+include:
+  ################################## DESKTOPS ################################
+  # Windows
+  - project: 'libretro-infrastructure/ci-templates'
+    file: '/windows-cmake-mingw.yml'
+
+  # DJGPP
+  - project: 'libretro-infrastructure/ci-templates'
+    file: '/djgpp-static-cmake.yml'
+
+  # MacOS
+  - project: 'libretro-infrastructure/ci-templates'
+    file: 'osx-cmake-x86.yml'
+
+  # MacOS
+  - project: 'libretro-infrastructure/ci-templates'
+    file: 'osx-cmake-arm64.yml'
+
+  # MacOS (PPC)
+  - project: 'libretro-infrastructure/ci-templates'
+    file: 'osx-cmake-ppc.yml'
+
+  # Linux
+  - project: 'libretro-infrastructure/ci-templates'
+    file: '/linux-cmake.yml'
+
+  ################################## CELLULAR ################################
+  # Android
+  - project: 'libretro-infrastructure/ci-templates'
+    file: '/android-cmake.yml'
+
+  # iOS
+  - project: 'libretro-infrastructure/ci-templates'
+    file: '/ios-cmake.yml'
+
+  ################################## CONSOLES ################################
+  # Libnx
+  - project: 'libretro-infrastructure/ci-templates'
+    file: '/libnx-static-cmake.yml'
+
+  # CTR (3DS)
+  - project: 'libretro-infrastructure/ci-templates'
+    file: '/ctr-static-cmake.yml'
+
+  # PSP
+  - project: 'libretro-infrastructure/ci-templates'
+    file: '/psp-static-cmake.yml'
+
+  # PS2
+  - project: 'libretro-infrastructure/ci-templates'
+    file: '/ps2-static-cmake.yml'
+
+  # VITA
+  - project: 'libretro-infrastructure/ci-templates'
+    file: '/vita-static-cmake.yml'
+
+  # Dingux
+  - project: 'libretro-infrastructure/ci-templates'
+    file: '/dingux-cmake.yml'
+
+  # WiiU
+  - project: 'libretro-infrastructure/ci-templates'
+    file: '/wiiu-static-cmake.yml'
+
+  # Wii
+  - project: 'libretro-infrastructure/ci-templates'
+    file: '/wii-static-cmake.yml'
+
+  # Gamecube
+  - project: 'libretro-infrastructure/ci-templates'
+    file: '/ngc-static-cmake.yml'
+
+  # tvOS
+  - project: 'libretro-infrastructure/ci-templates'
+    file: '/tvos-cmake.yml'
+
+  ################################## MISC ####################################
+  # Emscripten
+  - project: 'libretro-infrastructure/ci-templates'
+    file: '/emscripten-static-cmake.yml'
+
+# Stages for building
+stages:
+  - build-prepare
+  - build-shared
+  - build-static
+
+##############################################################################
+#################################### STAGES ##################################
+##############################################################################
+#
+################################### DESKTOPS #################################
+# Windows 64-bit
+libretro-build-windows-x64:
+  extends:
+    - .libretro-windows-cmake-x86_64
+    - .core-defs
+
+# Windows 32-bit
+libretro-build-windows-i686:
+  extends:
+    - .libretro-windows-cmake-x86
+    - .core-defs
+
+# DJGPP
+libretro-build-djgpp-i586:
+  extends:
+    - .libretro-djgpp-static-cmake-retroarch-master
+    - .core-defs
+
+# Linux 64-bit
+libretro-build-linux-x64:
+  extends:
+    - .libretro-linux-cmake-x86_64
+    - .core-defs
+
+# Linux 32-bit
+libretro-build-linux-i686:
+  extends:
+    - .libretro-linux-cmake-x86
+    - .core-defs
+
+# MacOS 32-bit
+libretro-build-osx-x86:
+  extends:
+    - .libretro-osx-cmake-x86
+    - .core-defs-osx
+
+# MacOS 64-bit
+libretro-build-osx-x64:
+  extends:
+    - .libretro-osx-cmake-x86_64
+    - .core-defs-osx
+
+# MacOS ARM64
+libretro-build-osx-arm64:
+  extends:
+    - .libretro-osx-cmake-arm64
+    - .core-defs-osx
+
+# MacOS PPC
+libretro-build-osx-ppc:
+  extends:
+    - .libretro-osx-cmake-ppc
+    - .core-defs
+
+################################### CELLULAR #################################
+# Android ARMv7a
+android-armeabi-v7a:
+  extends:
+    - .libretro-android-cmake-armeabi-v7a
+    - .core-defs
+
+# Android ARMv8a
+android-arm64-v8a:
+  extends:
+    - .libretro-android-cmake-arm64-v8a
+    - .core-defs
+
+# Android 64-bit x86
+android-x86_64:
+  extends:
+    - .libretro-android-cmake-x86_64
+    - .core-defs
+
+# Android 32-bit x86
+android-x86:
+  extends:
+    - .libretro-android-cmake-x86
+    - .core-defs
+
+# iOS arm64
+libretro-build-ios-arm64:
+  extends:
+    - .libretro-ios-cmake-arm64
+    - .core-defs
+
+# iOS armv7
+libretro-build-ios9:
+  extends:
+    - .libretro-ios-cmake-ios9
+    - .core-defs
+
+################################### CONSOLES #################################
+# Libnx
+libretro-build-libnx-aarch64:
+  extends:
+    - .libretro-libnx-static-cmake-retroarch-master
+    - .core-defs
+
+# CTR (3ds)
+libretro-build-ctr:
+  extends:
+    - .libretro-ctr-static-cmake-retroarch-master
+    - .core-defs
+
+# PSP
+libretro-build-psp:
+  extends:
+    - .libretro-psp-static-cmake-retroarch-master
+    - .core-defs
+
+# PS2
+libretro-build-ps2:
+  extends:
+    - .libretro-ps2-static-cmake-retroarch-master
+    - .core-defs
+
+# Wii
+libretro-build-wii:
+  extends:
+    - .libretro-wii-static-cmake-retroarch-master
+    - .core-defs
+
+# Gamecube
+libretro-build-ngc:
+  extends:
+    - .libretro-ngc-static-cmake-retroarch-master
+    - .core-defs
+
+# VITA
+libretro-build-vita:
+  extends:
+    - .libretro-vita-static-cmake-retroarch-master
+    - .core-defs
+
+# Dingux
+libretro-build-dingux-mips32:
+  extends:
+    - .libretro-dingux-cmake-mips32
+    - .core-defs
+
+libretro-build-dingux-odbeta-mips32:
+  extends:
+    - .libretro-dingux-odbeta-cmake-mips32
+    - .core-defs
+
+libretro-build-rs90-odbeta-mips32:
+  extends:
+    - .libretro-rs90-odbeta-cmake-mips32
+    - .core-defs
+
+libretro-build-retrofw-mips32:
+  extends:
+    - .libretro-retrofw-odbeta-cmake-mips32
+    - .core-defs
+
+libretro-build-miyoo-arm32:
+  extends:
+    - .libretro-miyoo-cmake-arm32
+    - .core-defs
+
+# iOS arm64
+libretro-build-tvos-arm64:
+  extends:
+    - .libretro-tvos-cmake-arm64
+    - .core-defs
+
+# WiiU
+libretro-build-wiiu:
+  extends:
+    - .libretro-wiiu-static-cmake-retroarch-master
+    - .core-defs
+
+################################### MISC #####################################
+
+# Emscripten
+libretro-build-emscripten:
+  extends:
+    - .libretro-emscripten-static-cmake-retroarch-master
+    - .core-defs
diff --git a/app/src/main/java/libengine/RVVM/CMakeLists.txt b/app/src/main/java/libengine/RVVM/CMakeLists.txt
new file mode 100644
index 00000000..2c3ba1da
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/CMakeLists.txt
@@ -0,0 +1,298 @@
+# CMake configuration file for those who don't like Make (like I do)
+# Prev-maintainer: cerg2010cerg2010
+
+cmake_minimum_required(VERSION 3.9)
+
+set(RVVM_VERSION 0.7)
+set(DESCRIPTION "RISC-V Virtual Machine")
+set(HOMEPAGE_URL "https://github.com/LekKit/RVVM")
+project(RVVM VERSION ${RVVM_VERSION} LANGUAGES C CXX)
+
+option(RVVM_USE_RV64 "Use RV64 CPU" ON)
+option(RVVM_USE_FPU "Use floating-point instructions" ON)
+option(RVVM_USE_JIT "Use RVJIT Just-in-time compiler" ON)
+option(RVVM_USE_GUI "Use framebuffer GUI" ON)
+option(RVVM_USE_SDL2 "Use SDL2 windowing backend" OFF)
+option(RVVM_USE_NET "Use networking" ON)
+option(RVVM_USE_TAP_LINUX "Use Linux TAP (deprecated)" OFF)
+option(RVVM_USE_FDT "Use Flattened Device Tree generation" ON)
+option(RVVM_USE_PCI "Use ATA over PCI, PIO mode is used otherwise" ON)
+option(RVVM_USE_SPINLOCK_DEBUG "Use spinlock debugging" ON)
+option(RVVM_USE_PRECISE_FS "Use precise FPU status tracking" OFF)
+option(RVVM_USE_LIB "Build shared librvvm library" OFF)
+option(RVVM_USE_JNI "Enable JNI bindings in librvvm (Very tiny size impact)" OFF)
+option(RVVM_USE_ISOLATION "Enable seccomp/pledge isolation measures" ON)
+option(BUILD_LIBRETRO "Build a libretro core" OFF)
+option(LIBRETRO_STATIC "Statically link the libretro core" OFF)
+
+if(NOT WIN32)
+	# Fancy coloring
+	string(ASCII 27 VT_ESC)
+	set(COLOR_RESET   "${VT_ESC}[m")
+	set(COLOR_BOLD    "${VT_ESC}[1m")
+	set(COLOR_RED     "${VT_ESC}[1;31m")
+	set(COLOR_GREEN   "${VT_ESC}[1;32m")
+	set(COLLOR_YELLOW "${VT_ESC}[1;33m")
+	set(COLOR_BLUE    "${VT_ESC}[1;34m")
+endif()
+
+if (${CMAKE_SOURCE_DIR} STREQUAL ${CMAKE_BINARY_DIR})
+	message(FATAL_ERROR "CMake in-source build is not allowed, see README")
+endif()
+
+if (NOT CMAKE_BUILD_TYPE AND NOT EXISTS ${CMAKE_BINARY_DIR}/CMakeCache.txt)
+	message(STATUS "${COLLOR_YELLOW}Setting build type to Release as none was specified${COLOR_RESET}")
+	set(CMAKE_BUILD_TYPE "Release" CACHE STRING "Choose the type of build." FORCE)
+	set(CMAKE_CONFIGURATION_TYPES "Debug" "Release" "MinSizeRel" "RelWithDebInfo")
+endif()
+
+set(RVVM_SRC_DIR "${RVVM_SOURCE_DIR}/src")
+
+# Get commit id
+find_package(Git)
+execute_process(COMMAND
+  "${GIT_EXECUTABLE}" describe --match=NeVeRmAtCh_TaG --always --dirty
+  WORKING_DIRECTORY "${CMAKE_SOURCE_DIR}"
+  RESULT_VARIABLE RESULT
+  OUTPUT_VARIABLE RVVM_COMMIT
+  ERROR_QUIET OUTPUT_STRIP_TRAILING_WHITESPACE)
+if (RESULT)
+	message(WARNING "Couldn't determine upstream git commit!")
+	set(RVVM_COMMIT "unknown")
+endif()
+
+# Common pseudo-library to pass parameters to other targets
+add_library(rvvm_common INTERFACE)
+target_include_directories(rvvm_common INTERFACE "${RVVM_SRC_DIR}")
+target_compile_definitions(rvvm_common INTERFACE "RVVM_VERSION=\"${RVVM_VERSION}-${RVVM_COMMIT}\"")
+if (MSVC)
+	# Suppress warnings: casts between int sizes, unsigned minus, cast after shift
+	target_compile_definitions(rvvm_common INTERFACE _CRT_SECURE_NO_WARNINGS)
+	target_compile_options(rvvm_common INTERFACE /wd4267 /wd4244 /wd4146 /wd4334)
+	# Use static runtime
+	set(buildflags CMAKE_C_FLAGS_DEBUG CMAKE_C_FLAGS_MINSIZEREL CMAKE_C_FLAGS_RELEASE CMAKE_C_FLAGS_RELWITHDEBINFO
+			CMAKE_CXX_FLAGS_DEBUG CMAKE_CXX_FLAGS_MINSIZEREL CMAKE_CXX_FLAGS_RELEASE CMAKE_CXX_FLAGS_RELWITHDEBINFO)
+	foreach(buildflag ${buildflags})
+		if(${buildflag} MATCHES "/MD")
+			string(REGEX REPLACE "/MD" "/MT" ${buildflag} "${${buildflag}}")
+		endif()
+	endforeach()
+endif()
+
+# Enable LTO
+include(CheckIPOSupported)
+check_ipo_supported(RESULT RVVM_LTO)
+if (RVVM_LTO)
+	# CMAKE_INTERPROCEDURAL_OPTIMIZATION sets the default value of IPO
+	# flag on new targets, so we set it and restore it at the end.
+	set(RVVM_OLD_IPO ${CMAKE_INTERPROCEDURAL_OPTIMIZATION})
+	set(CMAKE_INTERPROCEDURAL_OPTIMIZATION ON)
+	# Enable parallel LTO
+	if (CMAKE_C_COMPILER_ID MATCHES "Clang")
+		set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -flto=thin")
+	elseif (CMAKE_C_COMPILER_ID MATCHES "GNU")
+		set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -flto=auto")
+	endif()
+endif()
+
+if (CMAKE_C_COMPILER_ID MATCHES "GNU|Clang")
+	# Warning options (Strict safety/portability, stack/object size limits)
+	# -Wbad-function-cast, -Wcast-align, -Wdouble-promotion need fixes in codebase
+	add_compile_options(-Wall -Wextra -Wshadow -Wvla -Wpointer-arith -Walloca -Wduplicated-cond)
+	add_compile_options(-Wtrampolines -Wlarger-than=1048576 -Wframe-larger-than=32768 -Werror=return-type)
+	if (NOT CMAKE_BUILD_TYPE MATCHES "Debug")
+		# Optimization options
+		add_compile_options(-O3 -DNDEBUG)
+	endif()
+	# Disable unsafe FPU optimizations, hide internal symbols
+	add_compile_options(-fvisibility=hidden -fno-math-errno -frounding-math)
+	if (CMAKE_C_COMPILER_ID MATCHES "Clang")
+		# Shut off bogus warnings on older Clang
+		add_compile_options(-Wno-unsupported-floating-point-opt -Wno-unknown-warning-option -Wno-ignored-optimization-argument)
+	endif()
+endif()
+
+if (UNIX)
+	find_package(Threads REQUIRED)
+	target_link_libraries(rvvm_common INTERFACE Threads::Threads)
+	# Link librt, libatomic if we have them
+	find_library(RVVM_RT_LIB rt)
+	if (RVVM_RT_LIB)
+		target_link_libraries(rvvm_common INTERFACE rt)
+	endif()
+	find_library(RVVM_ATOMIC_LIB atomic)
+	if (RVVM_ATOMIC_LIB)
+		target_link_libraries(rvvm_common INTERFACE ${RVVM_ATOMIC_LIB})
+	endif()
+endif()
+
+# General sources
+file(GLOB RVVM_SRC LIST_DIRECTORIES FALSE CONFIGURE_DEPENDS
+	"${RVVM_SRC_DIR}/*.c"
+	"${RVVM_SRC_DIR}/cpu/riscv_*.c"
+)
+set(RVVM_MAIN_SRC "${RVVM_SRC_DIR}/main.c")
+set(RVVM_NETWORKING_SRC "${RVVM_SRC_DIR}/networking.c")
+list(REMOVE_ITEM RVVM_SRC ${RVVM_MAIN_SRC} ${RVVM_NETWORKING_SRC})
+
+if (RVVM_USE_RV64)
+	file(GLOB RVVM_RV64_SRC LIST_DIRECTORIES FALSE CONFIGURE_DEPENDS
+		"${RVVM_SRC_DIR}/cpu/riscv64_*.c"
+	)
+	target_compile_definitions(rvvm_common INTERFACE USE_RV64)
+	list(APPEND RVVM_SRC ${RVVM_RV64_SRC})
+endif()
+
+if (RVVM_USE_FPU)
+	target_compile_definitions(rvvm_common INTERFACE USE_FPU)
+
+	# Link libm library if we have it
+	find_library(RVVM_M_LIB m)
+	if (RVVM_M_LIB)
+		target_link_libraries(rvvm_common INTERFACE ${RVVM_M_LIB})
+	endif()
+endif()
+
+# Check JIT support for target
+if (RVVM_USE_JIT AND NOT MSVC)
+	execute_process(COMMAND ${CMAKE_C_COMPILER} -dumpmachine RESULT_VARIABLE RESULT OUTPUT_VARIABLE TRIPLET ERROR_QUIET)
+	if (RESULT)
+		message(WARNING "Couldn't determine target triplet! If build fails, disable USE_JIT")
+	else()
+		if (NOT TRIPLET MATCHES "^(x86|amd64|i386|aarch64|arm|riscv)")
+			message(WARNING "Unsupported RVJIT target! RVJIT won't be built")
+			set(RVVM_USE_JIT OFF)
+		endif()
+	endif()
+endif()
+
+# RVJIT sources
+if (RVVM_USE_JIT)
+	file(GLOB RVVM_RVJIT_SRC LIST_DIRECTORIES FALSE CONFIGURE_DEPENDS
+		"${RVVM_SRC_DIR}/rvjit/*.c"
+	)
+	list(APPEND RVVM_SRC ${RVVM_RVJIT_SRC})
+	target_compile_definitions(rvvm_common INTERFACE USE_JIT)
+endif()
+
+# Device sources
+file(GLOB RVVM_DEVICES_SRC LIST_DIRECTORIES FALSE CONFIGURE_DEPENDS
+	"${RVVM_SRC_DIR}/devices/*.c"
+)
+set(RVVM_XCB_SRC "${RVVM_SRC_DIR}/devices/x11window_xcb.c")
+set(RVVM_XLIB_SRC "${RVVM_SRC_DIR}/devices/x11window_xlib.c")
+set(RVVM_WIN32_SRC "${RVVM_SRC_DIR}/devices/win32window.c")
+set(RVVM_HAIKU_SRC "${RVVM_SRC_DIR}/devices/haiku_window.cpp")
+set(RVVM_SDL_SRC "${RVVM_SRC_DIR}/devices/sdl_window.c")
+set(RVVM_TAP_LINUX_SRC "${RVVM_SRC_DIR}/devices/tap_linux.c")
+set(RVVM_TAP_USER_SRC "${RVVM_SRC_DIR}/devices/tap_user.c")
+list(REMOVE_ITEM RVVM_DEVICES_SRC
+	${RVVM_XLIB_SRC}
+	${RVVM_WIN32_SRC}
+	${RVVM_HAIKU_SRC}
+	${RVVM_SDL_SRC}
+	${RVVM_TAP_LINUX_SRC}
+	${RVVM_TAP_USER_SRC})
+
+if (RVVM_USE_GUI AND (NOT BUILD_LIBRETRO))
+	target_compile_definitions(rvvm_common INTERFACE USE_GUI)
+	if (RVVM_USE_SDL2 OR APPLE OR SERENITY)
+		# RVVM uses dynamic libSDL probing at compile and runtime
+		list(APPEND RVVM_DEVICES_SRC ${RVVM_SDL_SRC})
+		target_compile_definitions(rvvm_common INTERFACE USE_SDL=2)
+	endif()
+	if (HAIKU)
+		list(APPEND RVVM_DEVICES_SRC ${RVVM_HAIKU_SRC})
+		find_library(RVVM_BE_LIB be REQUIRED)
+		target_link_libraries(rvvm_common INTERFACE ${RVVM_BE_LIB})
+	endif()
+	if (WIN32)
+		list(APPEND RVVM_DEVICES_SRC ${RVVM_WIN32_SRC})
+		target_link_libraries(rvvm_common INTERFACE gdi32)
+	endif()
+	if (NOT APPLE AND NOT HAIKU AND NOT SERENITY AND NOT ANDROID)
+		# RVVM uses dynamic libX11 probing at compile and runtime
+		list(APPEND RVVM_DEVICES_SRC ${RVVM_XLIB_SRC})
+		target_compile_definitions(rvvm_common INTERFACE USE_X11)
+	endif()
+endif()
+
+if (RVVM_USE_NET)
+	list(APPEND RVVM_SRC ${RVVM_NETWORKING_SRC})
+	target_compile_definitions(rvvm_common INTERFACE USE_NET)
+	if (WIN32)
+		target_link_libraries(rvvm_common INTERFACE ws2_32)
+	elseif (HAIKU)
+		target_link_libraries(rvvm_common INTERFACE network)
+	elseif(CMAKE_SYSTEM_NAME STREQUAL "SunOS") # Solaris, Illumos, etc
+		target_link_libraries(rvvm_common INTERFACE socket)
+	endif()
+
+	if (RVVM_USE_TAP_LINUX AND CMAKE_SYSTEM_NAME STREQUAL "Linux")
+		list(APPEND RVVM_DEVICES_SRC ${RVVM_TAP_LINUX_SRC})
+		target_compile_definitions(rvvm_common INTERFACE USE_TAP_LINUX)
+	else()
+		list(APPEND RVVM_DEVICES_SRC ${RVVM_TAP_USER_SRC})
+		if (RVVM_USE_TAP_LINUX)
+			message(WARNING "TAP is supported only on Linux, building userland networking")
+		endif()
+	endif()
+endif()
+
+if (RVVM_USE_LIB AND RVVM_USE_JNI)
+	list(APPEND RVVM_SRC "${RVVM_SRC_DIR}/bindings/jni/rvvm_jni.c")
+endif()
+
+if (RVVM_USE_ISOLATION)
+	target_compile_definitions(rvvm_common INTERFACE USE_ISOLATION)
+endif()
+
+if (RVVM_USE_FDT)
+	target_compile_definitions(rvvm_common INTERFACE USE_FDT)
+endif()
+
+if (RVVM_USE_PCI)
+	target_compile_definitions(rvvm_common INTERFACE USE_PCI)
+endif()
+
+if (RVVM_USE_SPINLOCK_DEBUG)
+	target_compile_definitions(rvvm_common INTERFACE USE_SPINLOCK_DEBUG)
+endif()
+
+if (RVVM_USE_PRECISE_FS)
+	target_compile_definitions(rvvm_common INTERFACE USE_PRECISE_FS)
+endif()
+
+if (NOT BUILD_LIBRETRO)
+	# Main executable
+	add_executable(rvvm_cli ${RVVM_MAIN_SRC} ${RVVM_SRC} ${RVVM_DEVICES_SRC})
+	target_link_libraries(rvvm_cli PRIVATE rvvm_common)
+	set_target_properties(rvvm_cli PROPERTIES OUTPUT_NAME rvvm)
+else()
+	# libretro core
+	set(RVVM_LIBRETRO_SRC "${RVVM_SRC_DIR}/bindings/libretro/libretro.c")
+	if (LIBRETRO_STATIC)
+		add_library(rvvm_libretro STATIC ${RVVM_LIBRETRO_SRC} ${RVVM_SRC} ${RVVM_DEVICES_SRC})
+	else()
+		add_library(rvvm_libretro SHARED ${RVVM_LIBRETRO_SRC} ${RVVM_SRC} ${RVVM_DEVICES_SRC})
+	endif()
+	target_link_libraries(rvvm_libretro PRIVATE rvvm_common)
+	if (RVVM_USE_NET)
+		target_compile_definitions(rvvm_libretro PRIVATE USE_NET)
+	endif()
+
+	# Follow naming conventions for libretro cores
+	set_target_properties(rvvm_libretro PROPERTIES PREFIX "")
+	if (ANDROID)
+		set_target_properties(rvvm_libretro PROPERTIES SUFFIX "_android.so")
+	elseif (EMSCRIPTEN)
+		set_target_properties(rvvm_libretro PROPERTIES SUFFIX "${LIBRETRO_SUFFIX}.bc")
+	elseif (LIBRETRO_STATIC)
+		set_target_properties(rvvm_libretro PROPERTIES SUFFIX "${LIBRETRO_SUFFIX}.a")
+	endif ()
+endif()
+
+# Restore IPO setting
+if (RVVM_LTO)
+	set(CMAKE_INTERPROCEDURAL_OPTIMIZATION ${RVVM_OLD_IPO})
+endif()
diff --git a/app/src/main/java/libengine/RVVM/LICENSE-GPL b/app/src/main/java/libengine/RVVM/LICENSE-GPL
new file mode 100644
index 00000000..f288702d
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/LICENSE-GPL
@@ -0,0 +1,674 @@
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 3, 29 June 2007
+
+ Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The GNU General Public License is a free, copyleft license for
+software and other kinds of works.
+
+  The licenses for most software and other practical works are designed
+to take away your freedom to share and change the works.  By contrast,
+the GNU General Public License is intended to guarantee your freedom to
+share and change all versions of a program--to make sure it remains free
+software for all its users.  We, the Free Software Foundation, use the
+GNU General Public License for most of our software; it applies also to
+any other work released this way by its authors.  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+them if you wish), that you receive source code or can get it if you
+want it, that you can change the software or use pieces of it in new
+free programs, and that you know you can do these things.
+
+  To protect your rights, we need to prevent others from denying you
+these rights or asking you to surrender the rights.  Therefore, you have
+certain responsibilities if you distribute copies of the software, or if
+you modify it: responsibilities to respect the freedom of others.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must pass on to the recipients the same
+freedoms that you received.  You must make sure that they, too, receive
+or can get the source code.  And you must show them these terms so they
+know their rights.
+
+  Developers that use the GNU GPL protect your rights with two steps:
+(1) assert copyright on the software, and (2) offer you this License
+giving you legal permission to copy, distribute and/or modify it.
+
+  For the developers' and authors' protection, the GPL clearly explains
+that there is no warranty for this free software.  For both users' and
+authors' sake, the GPL requires that modified versions be marked as
+changed, so that their problems will not be attributed erroneously to
+authors of previous versions.
+
+  Some devices are designed to deny users access to install or run
+modified versions of the software inside them, although the manufacturer
+can do so.  This is fundamentally incompatible with the aim of
+protecting users' freedom to change the software.  The systematic
+pattern of such abuse occurs in the area of products for individuals to
+use, which is precisely where it is most unacceptable.  Therefore, we
+have designed this version of the GPL to prohibit the practice for those
+products.  If such problems arise substantially in other domains, we
+stand ready to extend this provision to those domains in future versions
+of the GPL, as needed to protect the freedom of users.
+
+  Finally, every program is threatened constantly by software patents.
+States should not allow patents to restrict development and use of
+software on general-purpose computers, but in those that do, we wish to
+avoid the special danger that patents applied to a free program could
+make it effectively proprietary.  To prevent this, the GPL assures that
+patents cannot be used to render the program non-free.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                       TERMS AND CONDITIONS
+
+  0. Definitions.
+
+  "This License" refers to version 3 of the GNU General Public License.
+
+  "Copyright" also means copyright-like laws that apply to other kinds of
+works, such as semiconductor masks.
+
+  "The Program" refers to any copyrightable work licensed under this
+License.  Each licensee is addressed as "you".  "Licensees" and
+"recipients" may be individuals or organizations.
+
+  To "modify" a work means to copy from or adapt all or part of the work
+in a fashion requiring copyright permission, other than the making of an
+exact copy.  The resulting work is called a "modified version" of the
+earlier work or a work "based on" the earlier work.
+
+  A "covered work" means either the unmodified Program or a work based
+on the Program.
+
+  To "propagate" a work means to do anything with it that, without
+permission, would make you directly or secondarily liable for
+infringement under applicable copyright law, except executing it on a
+computer or modifying a private copy.  Propagation includes copying,
+distribution (with or without modification), making available to the
+public, and in some countries other activities as well.
+
+  To "convey" a work means any kind of propagation that enables other
+parties to make or receive copies.  Mere interaction with a user through
+a computer network, with no transfer of a copy, is not conveying.
+
+  An interactive user interface displays "Appropriate Legal Notices"
+to the extent that it includes a convenient and prominently visible
+feature that (1) displays an appropriate copyright notice, and (2)
+tells the user that there is no warranty for the work (except to the
+extent that warranties are provided), that licensees may convey the
+work under this License, and how to view a copy of this License.  If
+the interface presents a list of user commands or options, such as a
+menu, a prominent item in the list meets this criterion.
+
+  1. Source Code.
+
+  The "source code" for a work means the preferred form of the work
+for making modifications to it.  "Object code" means any non-source
+form of a work.
+
+  A "Standard Interface" means an interface that either is an official
+standard defined by a recognized standards body, or, in the case of
+interfaces specified for a particular programming language, one that
+is widely used among developers working in that language.
+
+  The "System Libraries" of an executable work include anything, other
+than the work as a whole, that (a) is included in the normal form of
+packaging a Major Component, but which is not part of that Major
+Component, and (b) serves only to enable use of the work with that
+Major Component, or to implement a Standard Interface for which an
+implementation is available to the public in source code form.  A
+"Major Component", in this context, means a major essential component
+(kernel, window system, and so on) of the specific operating system
+(if any) on which the executable work runs, or a compiler used to
+produce the work, or an object code interpreter used to run it.
+
+  The "Corresponding Source" for a work in object code form means all
+the source code needed to generate, install, and (for an executable
+work) run the object code and to modify the work, including scripts to
+control those activities.  However, it does not include the work's
+System Libraries, or general-purpose tools or generally available free
+programs which are used unmodified in performing those activities but
+which are not part of the work.  For example, Corresponding Source
+includes interface definition files associated with source files for
+the work, and the source code for shared libraries and dynamically
+linked subprograms that the work is specifically designed to require,
+such as by intimate data communication or control flow between those
+subprograms and other parts of the work.
+
+  The Corresponding Source need not include anything that users
+can regenerate automatically from other parts of the Corresponding
+Source.
+
+  The Corresponding Source for a work in source code form is that
+same work.
+
+  2. Basic Permissions.
+
+  All rights granted under this License are granted for the term of
+copyright on the Program, and are irrevocable provided the stated
+conditions are met.  This License explicitly affirms your unlimited
+permission to run the unmodified Program.  The output from running a
+covered work is covered by this License only if the output, given its
+content, constitutes a covered work.  This License acknowledges your
+rights of fair use or other equivalent, as provided by copyright law.
+
+  You may make, run and propagate covered works that you do not
+convey, without conditions so long as your license otherwise remains
+in force.  You may convey covered works to others for the sole purpose
+of having them make modifications exclusively for you, or provide you
+with facilities for running those works, provided that you comply with
+the terms of this License in conveying all material for which you do
+not control copyright.  Those thus making or running the covered works
+for you must do so exclusively on your behalf, under your direction
+and control, on terms that prohibit them from making any copies of
+your copyrighted material outside their relationship with you.
+
+  Conveying under any other circumstances is permitted solely under
+the conditions stated below.  Sublicensing is not allowed; section 10
+makes it unnecessary.
+
+  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
+
+  No covered work shall be deemed part of an effective technological
+measure under any applicable law fulfilling obligations under article
+11 of the WIPO copyright treaty adopted on 20 December 1996, or
+similar laws prohibiting or restricting circumvention of such
+measures.
+
+  When you convey a covered work, you waive any legal power to forbid
+circumvention of technological measures to the extent such circumvention
+is effected by exercising rights under this License with respect to
+the covered work, and you disclaim any intention to limit operation or
+modification of the work as a means of enforcing, against the work's
+users, your or third parties' legal rights to forbid circumvention of
+technological measures.
+
+  4. Conveying Verbatim Copies.
+
+  You may convey verbatim copies of the Program's source code as you
+receive it, in any medium, provided that you conspicuously and
+appropriately publish on each copy an appropriate copyright notice;
+keep intact all notices stating that this License and any
+non-permissive terms added in accord with section 7 apply to the code;
+keep intact all notices of the absence of any warranty; and give all
+recipients a copy of this License along with the Program.
+
+  You may charge any price or no price for each copy that you convey,
+and you may offer support or warranty protection for a fee.
+
+  5. Conveying Modified Source Versions.
+
+  You may convey a work based on the Program, or the modifications to
+produce it from the Program, in the form of source code under the
+terms of section 4, provided that you also meet all of these conditions:
+
+    a) The work must carry prominent notices stating that you modified
+    it, and giving a relevant date.
+
+    b) The work must carry prominent notices stating that it is
+    released under this License and any conditions added under section
+    7.  This requirement modifies the requirement in section 4 to
+    "keep intact all notices".
+
+    c) You must license the entire work, as a whole, under this
+    License to anyone who comes into possession of a copy.  This
+    License will therefore apply, along with any applicable section 7
+    additional terms, to the whole of the work, and all its parts,
+    regardless of how they are packaged.  This License gives no
+    permission to license the work in any other way, but it does not
+    invalidate such permission if you have separately received it.
+
+    d) If the work has interactive user interfaces, each must display
+    Appropriate Legal Notices; however, if the Program has interactive
+    interfaces that do not display Appropriate Legal Notices, your
+    work need not make them do so.
+
+  A compilation of a covered work with other separate and independent
+works, which are not by their nature extensions of the covered work,
+and which are not combined with it such as to form a larger program,
+in or on a volume of a storage or distribution medium, is called an
+"aggregate" if the compilation and its resulting copyright are not
+used to limit the access or legal rights of the compilation's users
+beyond what the individual works permit.  Inclusion of a covered work
+in an aggregate does not cause this License to apply to the other
+parts of the aggregate.
+
+  6. Conveying Non-Source Forms.
+
+  You may convey a covered work in object code form under the terms
+of sections 4 and 5, provided that you also convey the
+machine-readable Corresponding Source under the terms of this License,
+in one of these ways:
+
+    a) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by the
+    Corresponding Source fixed on a durable physical medium
+    customarily used for software interchange.
+
+    b) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by a
+    written offer, valid for at least three years and valid for as
+    long as you offer spare parts or customer support for that product
+    model, to give anyone who possesses the object code either (1) a
+    copy of the Corresponding Source for all the software in the
+    product that is covered by this License, on a durable physical
+    medium customarily used for software interchange, for a price no
+    more than your reasonable cost of physically performing this
+    conveying of source, or (2) access to copy the
+    Corresponding Source from a network server at no charge.
+
+    c) Convey individual copies of the object code with a copy of the
+    written offer to provide the Corresponding Source.  This
+    alternative is allowed only occasionally and noncommercially, and
+    only if you received the object code with such an offer, in accord
+    with subsection 6b.
+
+    d) Convey the object code by offering access from a designated
+    place (gratis or for a charge), and offer equivalent access to the
+    Corresponding Source in the same way through the same place at no
+    further charge.  You need not require recipients to copy the
+    Corresponding Source along with the object code.  If the place to
+    copy the object code is a network server, the Corresponding Source
+    may be on a different server (operated by you or a third party)
+    that supports equivalent copying facilities, provided you maintain
+    clear directions next to the object code saying where to find the
+    Corresponding Source.  Regardless of what server hosts the
+    Corresponding Source, you remain obligated to ensure that it is
+    available for as long as needed to satisfy these requirements.
+
+    e) Convey the object code using peer-to-peer transmission, provided
+    you inform other peers where the object code and Corresponding
+    Source of the work are being offered to the general public at no
+    charge under subsection 6d.
+
+  A separable portion of the object code, whose source code is excluded
+from the Corresponding Source as a System Library, need not be
+included in conveying the object code work.
+
+  A "User Product" is either (1) a "consumer product", which means any
+tangible personal property which is normally used for personal, family,
+or household purposes, or (2) anything designed or sold for incorporation
+into a dwelling.  In determining whether a product is a consumer product,
+doubtful cases shall be resolved in favor of coverage.  For a particular
+product received by a particular user, "normally used" refers to a
+typical or common use of that class of product, regardless of the status
+of the particular user or of the way in which the particular user
+actually uses, or expects or is expected to use, the product.  A product
+is a consumer product regardless of whether the product has substantial
+commercial, industrial or non-consumer uses, unless such uses represent
+the only significant mode of use of the product.
+
+  "Installation Information" for a User Product means any methods,
+procedures, authorization keys, or other information required to install
+and execute modified versions of a covered work in that User Product from
+a modified version of its Corresponding Source.  The information must
+suffice to ensure that the continued functioning of the modified object
+code is in no case prevented or interfered with solely because
+modification has been made.
+
+  If you convey an object code work under this section in, or with, or
+specifically for use in, a User Product, and the conveying occurs as
+part of a transaction in which the right of possession and use of the
+User Product is transferred to the recipient in perpetuity or for a
+fixed term (regardless of how the transaction is characterized), the
+Corresponding Source conveyed under this section must be accompanied
+by the Installation Information.  But this requirement does not apply
+if neither you nor any third party retains the ability to install
+modified object code on the User Product (for example, the work has
+been installed in ROM).
+
+  The requirement to provide Installation Information does not include a
+requirement to continue to provide support service, warranty, or updates
+for a work that has been modified or installed by the recipient, or for
+the User Product in which it has been modified or installed.  Access to a
+network may be denied when the modification itself materially and
+adversely affects the operation of the network or violates the rules and
+protocols for communication across the network.
+
+  Corresponding Source conveyed, and Installation Information provided,
+in accord with this section must be in a format that is publicly
+documented (and with an implementation available to the public in
+source code form), and must require no special password or key for
+unpacking, reading or copying.
+
+  7. Additional Terms.
+
+  "Additional permissions" are terms that supplement the terms of this
+License by making exceptions from one or more of its conditions.
+Additional permissions that are applicable to the entire Program shall
+be treated as though they were included in this License, to the extent
+that they are valid under applicable law.  If additional permissions
+apply only to part of the Program, that part may be used separately
+under those permissions, but the entire Program remains governed by
+this License without regard to the additional permissions.
+
+  When you convey a copy of a covered work, you may at your option
+remove any additional permissions from that copy, or from any part of
+it.  (Additional permissions may be written to require their own
+removal in certain cases when you modify the work.)  You may place
+additional permissions on material, added by you to a covered work,
+for which you have or can give appropriate copyright permission.
+
+  Notwithstanding any other provision of this License, for material you
+add to a covered work, you may (if authorized by the copyright holders of
+that material) supplement the terms of this License with terms:
+
+    a) Disclaiming warranty or limiting liability differently from the
+    terms of sections 15 and 16 of this License; or
+
+    b) Requiring preservation of specified reasonable legal notices or
+    author attributions in that material or in the Appropriate Legal
+    Notices displayed by works containing it; or
+
+    c) Prohibiting misrepresentation of the origin of that material, or
+    requiring that modified versions of such material be marked in
+    reasonable ways as different from the original version; or
+
+    d) Limiting the use for publicity purposes of names of licensors or
+    authors of the material; or
+
+    e) Declining to grant rights under trademark law for use of some
+    trade names, trademarks, or service marks; or
+
+    f) Requiring indemnification of licensors and authors of that
+    material by anyone who conveys the material (or modified versions of
+    it) with contractual assumptions of liability to the recipient, for
+    any liability that these contractual assumptions directly impose on
+    those licensors and authors.
+
+  All other non-permissive additional terms are considered "further
+restrictions" within the meaning of section 10.  If the Program as you
+received it, or any part of it, contains a notice stating that it is
+governed by this License along with a term that is a further
+restriction, you may remove that term.  If a license document contains
+a further restriction but permits relicensing or conveying under this
+License, you may add to a covered work material governed by the terms
+of that license document, provided that the further restriction does
+not survive such relicensing or conveying.
+
+  If you add terms to a covered work in accord with this section, you
+must place, in the relevant source files, a statement of the
+additional terms that apply to those files, or a notice indicating
+where to find the applicable terms.
+
+  Additional terms, permissive or non-permissive, may be stated in the
+form of a separately written license, or stated as exceptions;
+the above requirements apply either way.
+
+  8. Termination.
+
+  You may not propagate or modify a covered work except as expressly
+provided under this License.  Any attempt otherwise to propagate or
+modify it is void, and will automatically terminate your rights under
+this License (including any patent licenses granted under the third
+paragraph of section 11).
+
+  However, if you cease all violation of this License, then your
+license from a particular copyright holder is reinstated (a)
+provisionally, unless and until the copyright holder explicitly and
+finally terminates your license, and (b) permanently, if the copyright
+holder fails to notify you of the violation by some reasonable means
+prior to 60 days after the cessation.
+
+  Moreover, your license from a particular copyright holder is
+reinstated permanently if the copyright holder notifies you of the
+violation by some reasonable means, this is the first time you have
+received notice of violation of this License (for any work) from that
+copyright holder, and you cure the violation prior to 30 days after
+your receipt of the notice.
+
+  Termination of your rights under this section does not terminate the
+licenses of parties who have received copies or rights from you under
+this License.  If your rights have been terminated and not permanently
+reinstated, you do not qualify to receive new licenses for the same
+material under section 10.
+
+  9. Acceptance Not Required for Having Copies.
+
+  You are not required to accept this License in order to receive or
+run a copy of the Program.  Ancillary propagation of a covered work
+occurring solely as a consequence of using peer-to-peer transmission
+to receive a copy likewise does not require acceptance.  However,
+nothing other than this License grants you permission to propagate or
+modify any covered work.  These actions infringe copyright if you do
+not accept this License.  Therefore, by modifying or propagating a
+covered work, you indicate your acceptance of this License to do so.
+
+  10. Automatic Licensing of Downstream Recipients.
+
+  Each time you convey a covered work, the recipient automatically
+receives a license from the original licensors, to run, modify and
+propagate that work, subject to this License.  You are not responsible
+for enforcing compliance by third parties with this License.
+
+  An "entity transaction" is a transaction transferring control of an
+organization, or substantially all assets of one, or subdividing an
+organization, or merging organizations.  If propagation of a covered
+work results from an entity transaction, each party to that
+transaction who receives a copy of the work also receives whatever
+licenses to the work the party's predecessor in interest had or could
+give under the previous paragraph, plus a right to possession of the
+Corresponding Source of the work from the predecessor in interest, if
+the predecessor has it or can get it with reasonable efforts.
+
+  You may not impose any further restrictions on the exercise of the
+rights granted or affirmed under this License.  For example, you may
+not impose a license fee, royalty, or other charge for exercise of
+rights granted under this License, and you may not initiate litigation
+(including a cross-claim or counterclaim in a lawsuit) alleging that
+any patent claim is infringed by making, using, selling, offering for
+sale, or importing the Program or any portion of it.
+
+  11. Patents.
+
+  A "contributor" is a copyright holder who authorizes use under this
+License of the Program or a work on which the Program is based.  The
+work thus licensed is called the contributor's "contributor version".
+
+  A contributor's "essential patent claims" are all patent claims
+owned or controlled by the contributor, whether already acquired or
+hereafter acquired, that would be infringed by some manner, permitted
+by this License, of making, using, or selling its contributor version,
+but do not include claims that would be infringed only as a
+consequence of further modification of the contributor version.  For
+purposes of this definition, "control" includes the right to grant
+patent sublicenses in a manner consistent with the requirements of
+this License.
+
+  Each contributor grants you a non-exclusive, worldwide, royalty-free
+patent license under the contributor's essential patent claims, to
+make, use, sell, offer for sale, import and otherwise run, modify and
+propagate the contents of its contributor version.
+
+  In the following three paragraphs, a "patent license" is any express
+agreement or commitment, however denominated, not to enforce a patent
+(such as an express permission to practice a patent or covenant not to
+sue for patent infringement).  To "grant" such a patent license to a
+party means to make such an agreement or commitment not to enforce a
+patent against the party.
+
+  If you convey a covered work, knowingly relying on a patent license,
+and the Corresponding Source of the work is not available for anyone
+to copy, free of charge and under the terms of this License, through a
+publicly available network server or other readily accessible means,
+then you must either (1) cause the Corresponding Source to be so
+available, or (2) arrange to deprive yourself of the benefit of the
+patent license for this particular work, or (3) arrange, in a manner
+consistent with the requirements of this License, to extend the patent
+license to downstream recipients.  "Knowingly relying" means you have
+actual knowledge that, but for the patent license, your conveying the
+covered work in a country, or your recipient's use of the covered work
+in a country, would infringe one or more identifiable patents in that
+country that you have reason to believe are valid.
+
+  If, pursuant to or in connection with a single transaction or
+arrangement, you convey, or propagate by procuring conveyance of, a
+covered work, and grant a patent license to some of the parties
+receiving the covered work authorizing them to use, propagate, modify
+or convey a specific copy of the covered work, then the patent license
+you grant is automatically extended to all recipients of the covered
+work and works based on it.
+
+  A patent license is "discriminatory" if it does not include within
+the scope of its coverage, prohibits the exercise of, or is
+conditioned on the non-exercise of one or more of the rights that are
+specifically granted under this License.  You may not convey a covered
+work if you are a party to an arrangement with a third party that is
+in the business of distributing software, under which you make payment
+to the third party based on the extent of your activity of conveying
+the work, and under which the third party grants, to any of the
+parties who would receive the covered work from you, a discriminatory
+patent license (a) in connection with copies of the covered work
+conveyed by you (or copies made from those copies), or (b) primarily
+for and in connection with specific products or compilations that
+contain the covered work, unless you entered into that arrangement,
+or that patent license was granted, prior to 28 March 2007.
+
+  Nothing in this License shall be construed as excluding or limiting
+any implied license or other defenses to infringement that may
+otherwise be available to you under applicable patent law.
+
+  12. No Surrender of Others' Freedom.
+
+  If conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot convey a
+covered work so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you may
+not convey it at all.  For example, if you agree to terms that obligate you
+to collect a royalty for further conveying from those to whom you convey
+the Program, the only way you could satisfy both those terms and this
+License would be to refrain entirely from conveying the Program.
+
+  13. Use with the GNU Affero General Public License.
+
+  Notwithstanding any other provision of this License, you have
+permission to link or combine any covered work with a work licensed
+under version 3 of the GNU Affero General Public License into a single
+combined work, and to convey the resulting work.  The terms of this
+License will continue to apply to the part which is the covered work,
+but the special requirements of the GNU Affero General Public License,
+section 13, concerning interaction through a network will apply to the
+combination as such.
+
+  14. Revised Versions of this License.
+
+  The Free Software Foundation may publish revised and/or new versions of
+the GNU General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+  Each version is given a distinguishing version number.  If the
+Program specifies that a certain numbered version of the GNU General
+Public License "or any later version" applies to it, you have the
+option of following the terms and conditions either of that numbered
+version or of any later version published by the Free Software
+Foundation.  If the Program does not specify a version number of the
+GNU General Public License, you may choose any version ever published
+by the Free Software Foundation.
+
+  If the Program specifies that a proxy can decide which future
+versions of the GNU General Public License can be used, that proxy's
+public statement of acceptance of a version permanently authorizes you
+to choose that version for the Program.
+
+  Later license versions may give you additional or different
+permissions.  However, no additional obligations are imposed on any
+author or copyright holder as a result of your choosing to follow a
+later version.
+
+  15. Disclaimer of Warranty.
+
+  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
+APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
+HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
+OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
+IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
+ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. Limitation of Liability.
+
+  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
+THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
+GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
+USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
+DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
+PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
+EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGES.
+
+  17. Interpretation of Sections 15 and 16.
+
+  If the disclaimer of warranty and limitation of liability provided
+above cannot be given local legal effect according to their terms,
+reviewing courts shall apply local law that most closely approximates
+an absolute waiver of all civil liability in connection with the
+Program, unless a warranty or assumption of liability accompanies a
+copy of the Program in return for a fee.
+
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+state the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <https://www.gnu.org/licenses/>.
+
+Also add information on how to contact you by electronic and paper mail.
+
+  If the program does terminal interaction, make it output a short
+notice like this when it starts in an interactive mode:
+
+    <program>  Copyright (C) <year>  <name of author>
+    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, your program's commands
+might be different; for a GUI interface, you would use an "about box".
+
+  You should also get your employer (if you work as a programmer) or school,
+if any, to sign a "copyright disclaimer" for the program, if necessary.
+For more information on this, and how to apply and follow the GNU GPL, see
+<https://www.gnu.org/licenses/>.
+
+  The GNU General Public License does not permit incorporating your program
+into proprietary programs.  If your program is a subroutine library, you
+may consider it more useful to permit linking proprietary applications with
+the library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.  But first, please read
+<https://www.gnu.org/licenses/why-not-lgpl.html>.
diff --git a/app/src/main/java/libengine/RVVM/LICENSE-MPL b/app/src/main/java/libengine/RVVM/LICENSE-MPL
new file mode 100644
index 00000000..a612ad98
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/LICENSE-MPL
@@ -0,0 +1,373 @@
+Mozilla Public License Version 2.0
+==================================
+
+1. Definitions
+--------------
+
+1.1. "Contributor"
+    means each individual or legal entity that creates, contributes to
+    the creation of, or owns Covered Software.
+
+1.2. "Contributor Version"
+    means the combination of the Contributions of others (if any) used
+    by a Contributor and that particular Contributor's Contribution.
+
+1.3. "Contribution"
+    means Covered Software of a particular Contributor.
+
+1.4. "Covered Software"
+    means Source Code Form to which the initial Contributor has attached
+    the notice in Exhibit A, the Executable Form of such Source Code
+    Form, and Modifications of such Source Code Form, in each case
+    including portions thereof.
+
+1.5. "Incompatible With Secondary Licenses"
+    means
+
+    (a) that the initial Contributor has attached the notice described
+        in Exhibit B to the Covered Software; or
+
+    (b) that the Covered Software was made available under the terms of
+        version 1.1 or earlier of the License, but not also under the
+        terms of a Secondary License.
+
+1.6. "Executable Form"
+    means any form of the work other than Source Code Form.
+
+1.7. "Larger Work"
+    means a work that combines Covered Software with other material, in
+    a separate file or files, that is not Covered Software.
+
+1.8. "License"
+    means this document.
+
+1.9. "Licensable"
+    means having the right to grant, to the maximum extent possible,
+    whether at the time of the initial grant or subsequently, any and
+    all of the rights conveyed by this License.
+
+1.10. "Modifications"
+    means any of the following:
+
+    (a) any file in Source Code Form that results from an addition to,
+        deletion from, or modification of the contents of Covered
+        Software; or
+
+    (b) any new file in Source Code Form that contains any Covered
+        Software.
+
+1.11. "Patent Claims" of a Contributor
+    means any patent claim(s), including without limitation, method,
+    process, and apparatus claims, in any patent Licensable by such
+    Contributor that would be infringed, but for the grant of the
+    License, by the making, using, selling, offering for sale, having
+    made, import, or transfer of either its Contributions or its
+    Contributor Version.
+
+1.12. "Secondary License"
+    means either the GNU General Public License, Version 2.0, the GNU
+    Lesser General Public License, Version 2.1, the GNU Affero General
+    Public License, Version 3.0, or any later versions of those
+    licenses.
+
+1.13. "Source Code Form"
+    means the form of the work preferred for making modifications.
+
+1.14. "You" (or "Your")
+    means an individual or a legal entity exercising rights under this
+    License. For legal entities, "You" includes any entity that
+    controls, is controlled by, or is under common control with You. For
+    purposes of this definition, "control" means (a) the power, direct
+    or indirect, to cause the direction or management of such entity,
+    whether by contract or otherwise, or (b) ownership of more than
+    fifty percent (50%) of the outstanding shares or beneficial
+    ownership of such entity.
+
+2. License Grants and Conditions
+--------------------------------
+
+2.1. Grants
+
+Each Contributor hereby grants You a world-wide, royalty-free,
+non-exclusive license:
+
+(a) under intellectual property rights (other than patent or trademark)
+    Licensable by such Contributor to use, reproduce, make available,
+    modify, display, perform, distribute, and otherwise exploit its
+    Contributions, either on an unmodified basis, with Modifications, or
+    as part of a Larger Work; and
+
+(b) under Patent Claims of such Contributor to make, use, sell, offer
+    for sale, have made, import, and otherwise transfer either its
+    Contributions or its Contributor Version.
+
+2.2. Effective Date
+
+The licenses granted in Section 2.1 with respect to any Contribution
+become effective for each Contribution on the date the Contributor first
+distributes such Contribution.
+
+2.3. Limitations on Grant Scope
+
+The licenses granted in this Section 2 are the only rights granted under
+this License. No additional rights or licenses will be implied from the
+distribution or licensing of Covered Software under this License.
+Notwithstanding Section 2.1(b) above, no patent license is granted by a
+Contributor:
+
+(a) for any code that a Contributor has removed from Covered Software;
+    or
+
+(b) for infringements caused by: (i) Your and any other third party's
+    modifications of Covered Software, or (ii) the combination of its
+    Contributions with other software (except as part of its Contributor
+    Version); or
+
+(c) under Patent Claims infringed by Covered Software in the absence of
+    its Contributions.
+
+This License does not grant any rights in the trademarks, service marks,
+or logos of any Contributor (except as may be necessary to comply with
+the notice requirements in Section 3.4).
+
+2.4. Subsequent Licenses
+
+No Contributor makes additional grants as a result of Your choice to
+distribute the Covered Software under a subsequent version of this
+License (see Section 10.2) or under the terms of a Secondary License (if
+permitted under the terms of Section 3.3).
+
+2.5. Representation
+
+Each Contributor represents that the Contributor believes its
+Contributions are its original creation(s) or it has sufficient rights
+to grant the rights to its Contributions conveyed by this License.
+
+2.6. Fair Use
+
+This License is not intended to limit any rights You have under
+applicable copyright doctrines of fair use, fair dealing, or other
+equivalents.
+
+2.7. Conditions
+
+Sections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted
+in Section 2.1.
+
+3. Responsibilities
+-------------------
+
+3.1. Distribution of Source Form
+
+All distribution of Covered Software in Source Code Form, including any
+Modifications that You create or to which You contribute, must be under
+the terms of this License. You must inform recipients that the Source
+Code Form of the Covered Software is governed by the terms of this
+License, and how they can obtain a copy of this License. You may not
+attempt to alter or restrict the recipients' rights in the Source Code
+Form.
+
+3.2. Distribution of Executable Form
+
+If You distribute Covered Software in Executable Form then:
+
+(a) such Covered Software must also be made available in Source Code
+    Form, as described in Section 3.1, and You must inform recipients of
+    the Executable Form how they can obtain a copy of such Source Code
+    Form by reasonable means in a timely manner, at a charge no more
+    than the cost of distribution to the recipient; and
+
+(b) You may distribute such Executable Form under the terms of this
+    License, or sublicense it under different terms, provided that the
+    license for the Executable Form does not attempt to limit or alter
+    the recipients' rights in the Source Code Form under this License.
+
+3.3. Distribution of a Larger Work
+
+You may create and distribute a Larger Work under terms of Your choice,
+provided that You also comply with the requirements of this License for
+the Covered Software. If the Larger Work is a combination of Covered
+Software with a work governed by one or more Secondary Licenses, and the
+Covered Software is not Incompatible With Secondary Licenses, this
+License permits You to additionally distribute such Covered Software
+under the terms of such Secondary License(s), so that the recipient of
+the Larger Work may, at their option, further distribute the Covered
+Software under the terms of either this License or such Secondary
+License(s).
+
+3.4. Notices
+
+You may not remove or alter the substance of any license notices
+(including copyright notices, patent notices, disclaimers of warranty,
+or limitations of liability) contained within the Source Code Form of
+the Covered Software, except that You may alter any license notices to
+the extent required to remedy known factual inaccuracies.
+
+3.5. Application of Additional Terms
+
+You may choose to offer, and to charge a fee for, warranty, support,
+indemnity or liability obligations to one or more recipients of Covered
+Software. However, You may do so only on Your own behalf, and not on
+behalf of any Contributor. You must make it absolutely clear that any
+such warranty, support, indemnity, or liability obligation is offered by
+You alone, and You hereby agree to indemnify every Contributor for any
+liability incurred by such Contributor as a result of warranty, support,
+indemnity or liability terms You offer. You may include additional
+disclaimers of warranty and limitations of liability specific to any
+jurisdiction.
+
+4. Inability to Comply Due to Statute or Regulation
+---------------------------------------------------
+
+If it is impossible for You to comply with any of the terms of this
+License with respect to some or all of the Covered Software due to
+statute, judicial order, or regulation then You must: (a) comply with
+the terms of this License to the maximum extent possible; and (b)
+describe the limitations and the code they affect. Such description must
+be placed in a text file included with all distributions of the Covered
+Software under this License. Except to the extent prohibited by statute
+or regulation, such description must be sufficiently detailed for a
+recipient of ordinary skill to be able to understand it.
+
+5. Termination
+--------------
+
+5.1. The rights granted under this License will terminate automatically
+if You fail to comply with any of its terms. However, if You become
+compliant, then the rights granted under this License from a particular
+Contributor are reinstated (a) provisionally, unless and until such
+Contributor explicitly and finally terminates Your grants, and (b) on an
+ongoing basis, if such Contributor fails to notify You of the
+non-compliance by some reasonable means prior to 60 days after You have
+come back into compliance. Moreover, Your grants from a particular
+Contributor are reinstated on an ongoing basis if such Contributor
+notifies You of the non-compliance by some reasonable means, this is the
+first time You have received notice of non-compliance with this License
+from such Contributor, and You become compliant prior to 30 days after
+Your receipt of the notice.
+
+5.2. If You initiate litigation against any entity by asserting a patent
+infringement claim (excluding declaratory judgment actions,
+counter-claims, and cross-claims) alleging that a Contributor Version
+directly or indirectly infringes any patent, then the rights granted to
+You by any and all Contributors for the Covered Software under Section
+2.1 of this License shall terminate.
+
+5.3. In the event of termination under Sections 5.1 or 5.2 above, all
+end user license agreements (excluding distributors and resellers) which
+have been validly granted by You or Your distributors under this License
+prior to termination shall survive termination.
+
+************************************************************************
+*                                                                      *
+*  6. Disclaimer of Warranty                                           *
+*  -------------------------                                           *
+*                                                                      *
+*  Covered Software is provided under this License on an "as is"       *
+*  basis, without warranty of any kind, either expressed, implied, or  *
+*  statutory, including, without limitation, warranties that the       *
+*  Covered Software is free of defects, merchantable, fit for a        *
+*  particular purpose or non-infringing. The entire risk as to the     *
+*  quality and performance of the Covered Software is with You.        *
+*  Should any Covered Software prove defective in any respect, You     *
+*  (not any Contributor) assume the cost of any necessary servicing,   *
+*  repair, or correction. This disclaimer of warranty constitutes an   *
+*  essential part of this License. No use of any Covered Software is   *
+*  authorized under this License except under this disclaimer.         *
+*                                                                      *
+************************************************************************
+
+************************************************************************
+*                                                                      *
+*  7. Limitation of Liability                                          *
+*  --------------------------                                          *
+*                                                                      *
+*  Under no circumstances and under no legal theory, whether tort      *
+*  (including negligence), contract, or otherwise, shall any           *
+*  Contributor, or anyone who distributes Covered Software as          *
+*  permitted above, be liable to You for any direct, indirect,         *
+*  special, incidental, or consequential damages of any character      *
+*  including, without limitation, damages for lost profits, loss of    *
+*  goodwill, work stoppage, computer failure or malfunction, or any    *
+*  and all other commercial damages or losses, even if such party      *
+*  shall have been informed of the possibility of such damages. This   *
+*  limitation of liability shall not apply to liability for death or   *
+*  personal injury resulting from such party's negligence to the       *
+*  extent applicable law prohibits such limitation. Some               *
+*  jurisdictions do not allow the exclusion or limitation of           *
+*  incidental or consequential damages, so this exclusion and          *
+*  limitation may not apply to You.                                    *
+*                                                                      *
+************************************************************************
+
+8. Litigation
+-------------
+
+Any litigation relating to this License may be brought only in the
+courts of a jurisdiction where the defendant maintains its principal
+place of business and such litigation shall be governed by laws of that
+jurisdiction, without reference to its conflict-of-law provisions.
+Nothing in this Section shall prevent a party's ability to bring
+cross-claims or counter-claims.
+
+9. Miscellaneous
+----------------
+
+This License represents the complete agreement concerning the subject
+matter hereof. If any provision of this License is held to be
+unenforceable, such provision shall be reformed only to the extent
+necessary to make it enforceable. Any law or regulation which provides
+that the language of a contract shall be construed against the drafter
+shall not be used to construe this License against a Contributor.
+
+10. Versions of the License
+---------------------------
+
+10.1. New Versions
+
+Mozilla Foundation is the license steward. Except as provided in Section
+10.3, no one other than the license steward has the right to modify or
+publish new versions of this License. Each version will be given a
+distinguishing version number.
+
+10.2. Effect of New Versions
+
+You may distribute the Covered Software under the terms of the version
+of the License under which You originally received the Covered Software,
+or under the terms of any subsequent version published by the license
+steward.
+
+10.3. Modified Versions
+
+If you create software not governed by this License, and you want to
+create a new license for such software, you may create and use a
+modified version of this License if you rename the license and remove
+any references to the name of the license steward (except to note that
+such modified license differs from this License).
+
+10.4. Distributing Source Code Form that is Incompatible With Secondary
+Licenses
+
+If You choose to distribute Source Code Form that is Incompatible With
+Secondary Licenses under the terms of this version of the License, the
+notice described in Exhibit B of this License must be attached.
+
+Exhibit A - Source Code Form License Notice
+-------------------------------------------
+
+  This Source Code Form is subject to the terms of the Mozilla Public
+  License, v. 2.0. If a copy of the MPL was not distributed with this
+  file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+If it is not possible or desirable to put the notice in a particular
+file, then You may include the notice in a location (such as a LICENSE
+file in a relevant directory) where a recipient would be likely to look
+for such a notice.
+
+You may add additional accurate notices of copyright ownership.
+
+Exhibit B - "Incompatible With Secondary Licenses" Notice
+---------------------------------------------------------
+
+  This Source Code Form is "Incompatible With Secondary Licenses", as
+  defined by the Mozilla Public License, v. 2.0.
diff --git a/app/src/main/java/libengine/RVVM/Makefile b/app/src/main/java/libengine/RVVM/Makefile
new file mode 100644
index 00000000..4d1685ea
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/Makefile
@@ -0,0 +1,360 @@
+all: build_debug build_debug_asan build_release
+all_ninja: build_debug_ninja build_debug_ninja_asan build_release_ninja
+
+debug_build_dir = debug_BUILD
+debug_build_dir_target = $(debug_build_dir)-$(wildcard $(debug_build_dir))
+debug_build_dir_present = $(debug_build_dir)-$(debug_build_dir)
+debug_build_dir_absent = $(debug_build_dir)-
+debug_ninja_build_dir = debug_ninja_BUILD
+debug_ninja_build_dir_target = $(debug_ninja_build_dir)-$(wildcard $(debug_ninja_build_dir))
+debug_ninja_build_dir_present = $(debug_ninja_build_dir)-$(debug_ninja_build_dir)
+debug_ninja_build_dir_absent = $(debug_ninja_build_dir)-
+release_build_dir = release_BUILD
+release_build_dir_target = $(release_build_dir)-$(wildcard $(release_build_dir))
+release_build_dir_present = $(release_build_dir)-$(release_build_dir)
+release_build_dir_absent = $(release_build_dir)-
+release_ninja_build_dir = release_ninja_BUILD
+release_ninja_build_dir_target = $(release_ninja_build_dir)-$(wildcard $(release_ninja_build_dir))
+release_ninja_build_dir_present = $(release_ninja_build_dir)-$(release_ninja_build_dir)
+release_ninja_build_dir_absent = $(release_ninja_build_dir)-
+
+debug_executable_dir = debug_EXECUTABLE
+debug_executable_dir_target = $(debug_executable_dir)-$(wildcard $(debug_executable_dir))
+debug_executable_dir_present = $(debug_executable_dir)-$(debug_executable_dir)
+debug_executable_dir_absent = $(debug_executable_dir)-
+release_executable_dir = release_EXECUTABLE
+release_executable_dir_target = $(release_executable_dir)-$(wildcard $(release_executable_dir))
+release_executable_dir_present = $(release_executable_dir)-$(release_executable_dir)
+release_executable_dir_absent = $(release_executable_dir)-
+
+$(release_executable_dir_present):
+$(release_build_dir_present):
+$(release_ninja_build_dir_present):
+
+$(release_build_dir_absent):
+	mkdir $(release_build_dir)
+$(release_ninja_build_dir_absent):
+	mkdir $(release_ninja_build_dir)
+
+$(release_executable_dir_absent):
+	mkdir $(release_executable_dir)
+	mkdir $(release_executable_dir)_TMP
+
+$(debug_executable_dir_present):
+$(debug_build_dir_present):
+$(debug_ninja_build_dir_present):
+
+$(debug_build_dir_absent):
+	mkdir $(debug_build_dir)
+$(debug_ninja_build_dir_absent):
+	mkdir $(debug_ninja_build_dir)
+$(debug_executable_dir_absent):
+	mkdir $(debug_executable_dir)
+	mkdir $(debug_executable_dir)_TMP
+
+debug_asan_build_dir = debug_asan_BUILD
+debug_asan_build_dir_target = $(debug_asan_build_dir)-$(wildcard $(debug_asan_build_dir))
+debug_asan_build_dir_present = $(debug_asan_build_dir)-$(debug_asan_build_dir)
+debug_asan_build_dir_absent = $(debug_asan_build_dir)-
+debug_ninja_asan_build_dir = debug_ninja_asan_BUILD
+debug_ninja_asan_build_dir_target = $(debug_ninja_asan_build_dir)-$(wildcard $(debug_ninja_asan_build_dir))
+debug_ninja_asan_build_dir_present = $(debug_ninja_asan_build_dir)-$(debug_ninja_asan_build_dir)
+debug_ninja_asan_build_dir_absent = $(debug_ninja_asan_build_dir)-
+debug_asan_executable_dir = debug_asan_EXECUTABLE
+debug_asan_executable_dir_target = $(debug_asan_executable_dir)-$(wildcard $(debug_asan_executable_dir))
+debug_asan_executable_dir_present = $(debug_asan_executable_dir)-$(debug_asan_executable_dir)
+debug_asan_executable_dir_absent = $(debug_asan_executable_dir)-
+$(debug_asan_executable_dir_present):
+$(debug_asan_build_dir_present):
+$(debug_ninja_asan_build_dir_present):
+$(debug_asan_build_dir_absent):
+	mkdir $(debug_asan_build_dir)
+$(debug_ninja_asan_build_dir_absent):
+	mkdir $(debug_ninja_asan_build_dir)
+$(debug_asan_executable_dir_absent):
+	mkdir $(debug_asan_executable_dir)
+	mkdir $(debug_asan_executable_dir)_TMP
+
+debug_directories: | $(debug_build_dir_target) $(debug_executable_dir_target)
+debug_ninja_directories: | $(debug_ninja_build_dir_target) $(debug_executable_dir_target)
+
+release_directories: | $(release_build_dir_target) $(release_executable_dir_target)
+release_ninja_directories: | $(release_ninja_build_dir_target) $(release_executable_dir_target)
+
+debug_asan_directories: | $(debug_asan_build_dir_target) $(debug_asan_executable_dir_target)
+debug_ninja_asan_directories: | $(debug_ninja_asan_build_dir_target) $(debug_asan_executable_dir_target)
+
+ifneq ($(CC),)
+	C_COMPILER_flags = -DCMAKE_C_COMPILER="$(CC)"
+endif
+
+ifneq ($(CXX),)
+	CXX_COMPILER_flags = -DCMAKE_CXX_COMPILER="$(CXX)"
+endif
+
+ifneq ($(CCOMPILER),)
+	C_COMPILER_flags = -DCMAKE_CXX_COMPILER="$(CCOMPILER)"
+endif
+
+ifneq ($(CXXCOMPILER),)
+	CXX_COMPILER_flags = -DCMAKE_CXX_COMPILER="$(CXXCOMPILER)"
+endif
+
+cmake_run_flags += $(C_COMPILER_flags) $(CXX_COMPILER_flags) $(CMAKE_FLAGS)
+
+build_debug: debug_directories
+	cd ${debug_build_dir} ; mkdir EXECUTABLES; cmake -DCMAKE_BUILD_TYPE=Debug $(cmake_run_flags) -DCMAKE_C_FLAGS_DEBUG="$(CFLAGS) -g3 -O0" -DCMAKE_CXX_FLAGS_DEBUG="$(CXXFLAGS) -g3 -O0" .. ; make && if test -e EXECUTABLES ; then cd EXECUTABLES; for file in * ; do mv -v $$file ../../$(debug_executable_dir)/$$FILE ; done ; cd ..; rmdir EXECUTABLES; fi
+
+build_debug_ninja: debug_ninja_directories
+	cd ${debug_ninja_build_dir} ; mkdir EXECUTABLES; cmake -G Ninja -DCMAKE_BUILD_TYPE=Debug $(cmake_run_flags) -DCMAKE_C_FLAGS_DEBUG="$(CFLAGS) -g3 -O0" -DCMAKE_CXX_FLAGS_DEBUG="$(CXXFLAGS) -g3 -O0" .. ; ninja && if test -e EXECUTABLES ; then cd EXECUTABLES; for file in * ; do mv -v $$file ../../$(debug_executable_dir)/$$FILE ; done ; cd ..; rmdir EXECUTABLES; fi
+
+build_release: release_directories
+	cd ${release_build_dir} ; mkdir EXECUTABLES; cmake -DCMAKE_BUILD_TYPE=Release $(cmake_run_flags) -DCMAKE_C_FLAGS_RELEASE="$(CFLAGS) -g0 -O3" -DCMAKE_CXX_FLAGS_RELEASE="$(CXXFLAGS) -g0 -O3" .. ; make && if test -e EXECUTABLES ; then cd EXECUTABLES; for file in * ; do mv -v $$file ../../$(release_executable_dir)/$$FILE ; done ; cd ..; rmdir EXECUTABLES; fi
+
+build_release_ninja: release_ninja_directories
+	cd ${release_ninja_build_dir} ; mkdir EXECUTABLES; cmake -G Ninja -DCMAKE_BUILD_TYPE=Release $(cmake_run_flags) -DCMAKE_C_FLAGS_RELEASE="$(CFLAGS) -g0 -O3" -DCMAKE_CXX_FLAGS_RELEASE="$(CXXFLAGS) -g0 -O3" .. ; ninja && if test -e EXECUTABLES ; then cd EXECUTABLES; for file in * ; do mv -v $$file ../../$(release_executable_dir)/$$FILE ; done ; cd ..; rmdir EXECUTABLES; fi
+
+
+
+asan_build_flags = -fno-omit-frame-pointer -fsanitize=address -fsanitize-address-use-after-scope -fno-common
+asan_run_flags = LSAN_OPTIONS=verbosity=1:log_threads=1 ASAN_OPTIONS=verbosity=1:detect_leaks=1:detect_stack_use_after_return=1:check_initialization_order=true:strict_init_order=true
+
+build_debug_asan: debug_asan_directories
+	cd ${debug_asan_build_dir} ; mkdir EXECUTABLES; cmake -DCMAKE_BUILD_TYPE=Debug $(cmake_run_flags) -DCMAKE_C_FLAGS_DEBUG="$(CFLAGS) -g3 -O0 ${asan_build_flags}" -DCMAKE_CXX_FLAGS_DEBUG="$(CXXFLAGS) -g3 -O0 ${asan_build_flags}" .. ; make && if test -e EXECUTABLES ; then cd EXECUTABLES; for file in * ; do mv -v $$file ../../$(debug_asan_executable_dir)/$$FILE ; done ; cd ..; rmdir EXECUTABLES; fi
+
+build_debug_ninja_asan: debug_ninja_asan_directories
+	cd ${debug_ninja_asan_build_dir} ; mkdir EXECUTABLES; cmake -G Ninja -DCMAKE_BUILD_TYPE=Debug $(cmake_run_flags) -DCMAKE_C_FLAGS_DEBUG="$(CFLAGS) -g3 -O0 ${asan_build_flags}" -DCMAKE_CXX_FLAGS_DEBUG="$(CXXFLAGS) -g3 -O0 ${asan_build_flags}" .. ; ninja && if test -e EXECUTABLES ; then cd EXECUTABLES; for file in * ; do mv -v $$file ../../$(debug_asan_executable_dir)/$$FILE ; done ; cd ..; rmdir EXECUTABLES; fi
+
+.PHONY: all
+
+clean: clean_debug clean_release clean_debug_asan clean_ninja
+
+clean_ninja: clean_debug_ninja clean_release_ninja clean_debug_ninja_asan
+
+clean_debug:
+	rm -rf $(debug_build_dir) $(debug_executable_dir) $(debug_executable_dir)_TMP
+
+clean_debug_ninja:
+	rm -rf $(debug_ninja_build_dir) $(debug_executable_dir) $(debug_executable_dir)_TMP
+
+clean_release:
+	rm -rf $(release_build_dir) $(release_executable_dir) $(release_executable_dir)_TMP
+
+clean_release_ninja:
+	rm -rf $(release_ninja_build_dir) $(release_executable_dir) $(release_executable_dir)_TMP
+
+clean_debug_asan:
+	rm -rf $(debug_asan_build_dir) $(debug_asan_executable_dir) $(debug_asan_executable_dir)_TMP
+
+clean_debug_ninja_asan:
+	rm -rf $(debug_ninja_asan_build_dir) $(debug_asan_executable_dir) $(debug_asan_executable_dir)_TMP
+
+rebuild: rebuild_debug rebuild_debug_asan rebuild_release
+
+rebuild_ninja: rebuild_debug_ninja rebuild_debug_ninja_asan rebuild_release_ninja
+
+rebuild_debug:
+	make clean_debug
+	make build_debug
+
+rebuild_debug_ninja:
+	make clean_debug_ninja
+	make build_debug_ninja
+
+rebuild_debug_asan:
+	make clean_debug_asan
+	make build_debug_asan
+
+rebuild_debug_ninja_asan:
+	make clean_debug_ninja_asan
+	make build_debug_ninja_asan
+
+rebuild_release:
+	make clean_release
+	make build_release
+
+rebuild_release_ninja:
+	make clean_release_ninja
+	make build_release_ninja
+
+
+test: test_debug test_debug_asan test_release
+test_ninja: test_debug_ninja test_debug_ninja_asan test_release_ninja
+rebuild_test: rebuild_test_debug rebuild_test_debug_asan rebuild_test_release
+rebuild_test_ninja: rebuild_test_debug_ninja rebuild_test_debug_ninja_asan rebuild_test_release_ninja
+
+test_debug: build_debug
+	export TEST_TMPDIR=$(debug_executable_dir)_TMP; for file in $(debug_executable_dir)/* ; do echo "testing $$file..." ; $$file ; echo "$$file returned with code $$?" ; done
+
+test_debug_ninja: build_debug_ninja
+	export TEST_TMPDIR=$(debug_executable_dir)_TMP; for file in $(debug_executable_dir)/* ; do echo "testing $$file..." ; if [[ -d $$file ]] ; then if [[ -e $$file/Contents ]]; then echo "opening mac os application $$file" ; open $$file; else echo "$$file is a directory but $$file/Contents does not exist"; fi; else echo "opening windows/linux application $$file" ; $$file; fi ; echo "$$file returned with code $$?" ; done
+
+rebuild_test_debug:
+	make clean_debug
+	make test_debug
+
+rebuild_test_debug_ninja:
+	make clean_debug_ninja
+	make test_debug_ninja
+
+
+test_debug_asan: build_debug_asan
+	export TEST_TMPDIR=$(debug_asan_executable_dir)_TMP; for file in $(debug_asan_executable_dir)/* ; do echo "testing $$file..." ; ${asan_run_flags} $$file ; echo "$$file returned with code $$?" ; done
+
+test_debug_ninja_asan: build_debug_ninja_asan
+	export TEST_TMPDIR=$(debug_asan_executable_dir)_TMP; for file in $(debug_asan_executable_dir)/* ; do echo "testing $$file..." ; ${asan_run_flags} $$file ; echo "$$file returned with code $$?" ; done
+
+rebuild_test_debug_asan:
+	make clean_debug_asan
+	make test_debug_asan
+
+rebuild_test_debug_ninja_asan:
+	make clean_debug_ninja_asan
+	make test_debug_ninja_asan
+
+test_release: build_release
+	export TEST_TMPDIR=$(release_executable_dir)_TMP; for file in $(release_executable_dir)/* ; do echo "testing $$file..." ; $$file ; echo "$$file returned with code $$?" ; done
+
+test_release_ninja: build_release_ninja
+	export TEST_TMPDIR=$(release_executable_dir)_TMP; for file in $(release_executable_dir)/* ; do echo "testing $$file..." ; $$file ; echo "$$file returned with code $$?" ; done
+
+rebuild_test_release:
+	make clean_release
+	make test_release
+
+rebuild_test_release_ninja:
+	make clean_release_ninja
+	make test_release_ninja
+
+valgrind_flags = --leak-check=full --show-leak-kinds=all --track-origins=yes
+
+test_valgrind: test_debug_valgrind test_release_valgrind
+test_ninja_valgrind: test_debug_ninja_valgrind test_release_ninja_valgrind
+rebuild_test_valgrind: rebuild_test_debug_valgrind rebuild_test_release_valgrind
+rebuild_test_ninja_valgrind: rebuild_test_debug_ninja_valgrind rebuild_test_release_ninja_valgrind
+
+test_debug_valgrind: build_debug
+	export TEST_TMPDIR=$(debug_executable_dir)_TMP; for file in $(debug_executable_dir)/* ; do echo "testing $$file..." ; valgrind ${valgrind_flags} $$file ; echo "$$file returned with code $$?" ; done
+
+test_debug_ninja_valgrind: build_debug_ninja
+	export TEST_TMPDIR=$(debug_executable_dir)_TMP; for file in $(debug_executable_dir)/* ; do echo "testing $$file..." ; valgrind ${valgrind_flags} $$file ; echo "$$file returned with code $$?" ; done
+
+rebuild_test_debug_valgrind:
+	make clean_debug
+	make test_debug_valgrind
+
+rebuild_test_debug_ninja_valgrind:
+	make clean_debug_ninja
+	make test_debug_ninja_valgrind
+
+test_release_valgrind: build_release
+	export TEST_TMPDIR=$(release_executable_dir)_TMP; for file in $(release_executable_dir)/* ; do echo "testing $$file..." ; valgrind ${valgrind_flags} $$file ; echo "$$file returned with code $$?" ; done
+
+test_release_ninja_valgrind: build_release_ninja
+	export TEST_TMPDIR=$(release_executable_dir)_TMP; for file in $(release_executable_dir)/* ; do echo "testing $$file..." ; valgrind ${valgrind_flags} $$file ; echo "$$file returned with code $$?" ; done
+
+rebuild_test_release_valgrind:
+	make clean_release
+	make test_release_valgrind
+
+rebuild_test_release_ninja_valgrind:
+	make clean_release_ninja
+	make test_release_ninja_valgrind
+
+gdb_flags = -ex='set confirm on' --quiet
+
+test_gdb: test_debug_gdb test_debug_asan_gdb test_release_gdb
+test_ninja_gdb: test_debug_ninja_gdb test_debug_ninja_asan_gdb test_release_ninja_gdb
+rebuild_test_gdb: rebuild_test_debug_gdb rebuild_test_debug_asan_gdb rebuild_test_release_gdb
+rebuild_test_ninja_gdb: rebuild_test_debug_ninja_gdb rebuild_test_debug_ninja_asan_gdb rebuild_test_ninja_release_gdb
+
+test_debug_gdb: build_debug
+	export TEST_TMPDIR=$(debug_executable_dir)_TMP; for file in $(debug_executable_dir)/* ; do echo "testing $$file..." ; gdb ${gdb_flags} $$file ; echo "$$file returned with code $$?" ; done
+
+test_debug_ninja_gdb: build_debug_ninja
+	export TEST_TMPDIR=$(debug_executable_dir)_TMP; for file in $(debug_executable_dir)/* ; do echo "testing $$file..." ; gdb ${gdb_flags} $$file ; echo "$$file returned with code $$?" ; done
+
+rebuild_test_debug_gdb:
+	make clean_debug
+	make test_debug_gdb
+
+rebuild_test_debug_ninja_gdb:
+	make clean_debug_ninja
+	make test_debug_ninja_gdb
+
+test_debug_asan_gdb: build_debug_asan
+	export TEST_TMPDIR=$(debug_asan_executable_dir)_TMP; for file in $(debug_asan_executable_dir)/* ; do echo "testing $$file..." ; ${asan_run_flags} gdb ${gdb_flags} $$file ; echo "$$file returned with code $$?" ; done
+
+test_debug_ninja_asan_gdb: build_debug_ninja_asan
+	export TEST_TMPDIR=$(debug_asan_executable_dir)_TMP; for file in $(debug_asan_executable_dir)/* ; do echo "testing $$file..." ; ${asan_run_flags} gdb ${gdb_flags} $$file ; echo "$$file returned with code $$?" ; done
+
+rebuild_test_debug_asan_gdb:
+	make clean_debug_asan
+	make test_debug_asan_gdb
+
+rebuild_test_debug_ninja_asan_gdb:
+	make clean_debug_ninja_asan
+	make test_debug_ninja_asan_gdb
+
+test_release_gdb: build_release
+	export TEST_TMPDIR=$(release_executable_dir)_TMP; for file in $(release_executable_dir)/* ; do echo "testing $$file..." ; gdb ${gdb_flags} $$file ; echo "$$file returned with code $$?" ; done
+
+test_release_ninja_gdb: build_release_ninja
+	export TEST_TMPDIR=$(release_executable_dir)_TMP; for file in $(release_executable_dir)/* ; do echo "testing $$file..." ; gdb ${gdb_flags} $$file ; echo "$$file returned with code $$?" ; done
+
+rebuild_test_release_gdb:
+	make clean_release
+	make test_release_gdb
+
+rebuild_test_release_ninja_gdb:
+	make clean_release_ninja
+	make test_release_ninja_gdb
+
+lldb_flags =
+
+test_lldb: test_debug_lldb test_debug_asan_lldb test_release_lldb
+test_ninja_lldb: test_debug_ninja_lldb test_debug_ninja_asan_lldb test_release_ninja_lldb
+rebuild_test_lldb: rebuild_test_debug_lldb rebuild_test_debug_asan_lldb rebuild_test_release_lldb
+rebuild_test_ninja_lldb: rebuild_test_debug_ninja_lldb rebuild_test_debug_ninja_asan_lldb rebuild_test_ninja_release_lldb
+
+test_debug_lldb: build_debug
+	export TEST_TMPDIR=$(debug_executable_dir)_TMP; for file in $(debug_executable_dir)/* ; do echo "testing $$file..." ; lldb ${lldb_flags} $$file ; echo "$$file returned with code $$?" ; done
+
+test_debug_ninja_lldb: build_debug_ninja
+	export TEST_TMPDIR=$(debug_executable_dir)_TMP; for file in $(debug_executable_dir)/* ; do echo "testing $$file..." ; lldb ${lldb_flags} $$file ; echo "$$file returned with code $$?" ; done
+
+rebuild_test_debug_lldb:
+	make clean_debug
+	make test_debug_lldb
+
+rebuild_test_debug_ninja_lldb:
+	make clean_debug_ninja
+	make test_debug_ninja_lldb
+
+test_debug_asan_lldb: build_debug_asan
+	export TEST_TMPDIR=$(debug_asan_executable_dir)_TMP; for file in $(debug_asan_executable_dir)/* ; do echo "testing $$file..." ; ${asan_run_flags} lldb ${lldb_flags} $$file ; echo "$$file returned with code $$?" ; done
+
+test_debug_ninja_asan_lldb: build_debug_ninja_asan
+	export TEST_TMPDIR=$(debug_asan_executable_dir)_TMP; for file in $(debug_asan_executable_dir)/* ; do echo "testing $$file..." ; ${asan_run_flags} lldb ${lldb_flags} $$file ; echo "$$file returned with code $$?" ; done
+
+rebuild_test_debug_asan_lldb:
+	make clean_debug_asan
+	make test_debug_asan_lldb
+
+rebuild_test_debug_ninja_asan_lldb:
+	make clean_debug_ninja_asan
+	make test_debug_ninja_asan_lldb
+
+test_release_lldb: build_release
+	export TEST_TMPDIR=$(release_executable_dir)_TMP; for file in $(release_executable_dir)/* ; do echo "testing $$file..." ; lldb ${lldb_flags} $$file ; echo "$$file returned with code $$?" ; done
+
+test_release_ninja_lldb: build_release_ninja
+	export TEST_TMPDIR=$(release_executable_dir)_TMP; for file in $(release_executable_dir)/* ; do echo "testing $$file..." ; lldb ${lldb_flags} $$file ; echo "$$file returned with code $$?" ; done
+
+rebuild_test_release_lldb:
+	make clean_release
+	make test_release_lldb
+
+rebuild_test_release_ninja_lldb:
+	make clean_release_ninja
+	make test_release_ninja_lldb
diff --git a/app/src/main/java/libengine/RVVM/README.md b/app/src/main/java/libengine/RVVM/README.md
new file mode 100644
index 00000000..a504132e
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/README.md
@@ -0,0 +1,142 @@
+# RVVM - The RISC-V Virtual Machine
+[![version](https://img.shields.io/badge/version-0.7--git-brightgreen?style=for-the-badge)](#-installing) [![Build](https://img.shields.io/github/actions/workflow/status/LekKit/RVVM/build.yml?branch=staging&style=for-the-badge)](https://github.com/LekKit/RVVM/actions/workflows/build.yml) [![Codacy grade](https://img.shields.io/codacy/grade/c77cc7499a784cd293fde58641ce3e46?logo=codacy&style=for-the-badge)](https://app.codacy.com/gh/LekKit/RVVM/dashboard)
+![RISC-V Logo](https://riscv.org/wp-content/uploads/2018/09/riscv-logo-1.png "The “RISC-V” trade name is a registered trade mark of RISC-V International.")
+
+RISC-V CPU & System software implementation written in С
+
+## What's working
+[![Demo](https://img.shields.io/badge/Check%20it%20out-WASM%20Demo-red?style=for-the-badge)](https://lekkit.github.io/test/index.html)
+- Passes RISC-V compliance/torture tests for both RV64 & RV32
+- OpenSBI, U-Boot, custom firmwares boot and execute properly
+- Working Linux, FreeBSD, OpenBSD, Haiku & other cool OSes
+- Tracing JIT, multicore support
+- Framebuffer display, mouse & keyboard, UART shell
+- NVMe storage drives
+- Networking
+
+## 💡 Tell me more...
+- Feature-complete **rv64imafdcb** instruction set, Zkr/Zicbom/Zicboz/Sstc extensions
+- Multicore support (SMP), SV32/SV39/SV48/SV57 MMU
+- Tracing RVJIT with x86_64, ARM64, RISC-V, i386, ARM backends
+  (faster than QEMU, yay!)
+- Bootrom, Kernel Image loading, ELF support
+- Device Tree auto-generation, passing to firmware/kernel
+- RVVM Public API for VM integration
+- UART 16550a-compatible text console
+- PLIC/ACLINT, Timers, Poweroff/reset
+- Generic PCI Express Bus
+- NVMe storage, image TRIM support, fast IO
+- Framebuffer display, GUI for X11/WinAPI/Haiku/SDL
+- I2C HID keyboard & mouse, OpenCores I2C controller
+- Realtek RTL8169, OpenCores Ethernet NICs
+- Userspace networking
+- VFIO PCI Passthrough (For GPUs, etc)
+- SiFive GPIO
+- Deprecated: PS2 keyboard & mouse, ATA (IDE) drive, Linux TAP
+
+## 📦 Installing
+[![Release](https://img.shields.io/badge/BIN-Release-green?style=for-the-badge)](https://github.com/LekKit/RVVM/releases) 
+[![Artifacts](https://img.shields.io/badge/BIN-Artifacts-orange?style=for-the-badge)](https://nightly.link/LekKit/RVVM/workflows/build/staging) [![AUR](https://img.shields.io/badge/Arch%20Linux-AUR-blue?style=for-the-badge&logo=archlinux)](https://aur.archlinux.org/packages/rvvm-git) [![Build](https://img.shields.io/badge/Build-Make-red?style=for-the-badge)](#-building)
+
+## 🛠 Building
+Currently builds using GNU Make (recommended) or CMake and is extremely portable.
+```
+git clone https://github.com/LekKit/RVVM
+cd RVVM
+make
+cd release.linux.x86_64
+./rvvm_x86_64 -h
+```
+You can configure the build with USE flags. To cross-compile, pass CC=target-gcc to make. If it fails to detect features, pass ARCH/OS variables explicitly.
+
+Examples:
+```
+make lib CC=aarch64-linux-android21-clang USE_FB=0
+make lib all CC=x86_64-w64-mingw32-gcc USE_NET=1
+make CFLAGS=-m32 ARCH=i386 USE_RV64=0 BUILDDIR=build BINARY=rvvm
+make CC=mipseb-linux-gnu-gcc USE_JIT=0 USE_SDL=2
+```
+Alternatively, you can use CMake:
+```
+git clone https://github.com/LekKit/RVVM
+cd RVVM
+cmake -S. -Bbuild
+cmake --build build --target all
+cd build
+./rvvm -h
+```
+
+## 🚀 Running
+```
+rvvm fw_payload.bin -i drive.img -m 2G -smp 2 -res 1280x720
+```
+Recommended working firmware, distro images are found in [Release section](https://github.com/LekKit/RVVM/releases/tag/v0.6)
+
+Argument explanation:
+```
+[fw_payload.bin]       Initial M-mode firmware, OpenSBI + U-Boot in this case
+-k, -kernel u-boot.bin Optional S-mode kernel payload (Linux Image, U-Boot, etc)
+-i, -image drive.img   Attach storage image (Raw format, NVMe as of now)
+-m, -mem 2G            Memory amount (may be suffixed by k/M/G), default 256M
+-s, -smp 2             Amount of cores, single-core machine by default
+-res 1280x720          Changes framebuffer & VM window resolution
+-rv32                  Enable 32-bit RISC-V, 64-bit by default
+ . . .
+-cmdline, -append ...  Override/append default kernel command line
+-nogui, -nojit         Disable GUI (Use only UART), Disable JIT (for debugging)
+-v                     Verbose mode
+```
+Invoke `rvvm -h` to see extended help.
+
+## Tested environments (Likely works elsewhere as well)
+| OS         | JIT                        | GUI          |
+|------------|----------------------------|--------------|
+| Linux      | Works                      | X11, SDL     |
+| Windows    | Works                      | Win32, SDL   |
+| MacOS X    | Works, need signing for M1 | SDL, XQuartz |
+| FreeBSD    | Works                      | X11, SDL     |
+| Haiku      | Works                      | Haiku, SDL   |
+| Serenity   | Works                      | SDL          |
+| Windows CE | Broken (?)                 | Win32        |
+| Emscripten | -                          | SDL          |
+
+## ⚖️ License
+This work is dual-licensed under **GPL 3.0** and **MPL 2.0**. You can choose between one of them if you use this work.
+
+If you wish to use this work as a component of a larger, non-GPL compliant project, you are free to do so in any form
+(Static linkage, binary distribution, modules) as long as you comply with the MPL 2.0 license.
+
+For any form of software distribution, changes made precisely to this work should be made public to comply with either licenses.
+
+Source file headers should be gradually transitioned to reflect their reusability.
+
+## 🎉 Contributions
+[![PRs are welcome](https://img.shields.io/badge/Pull%20requests-welcome-8957e5?style=for-the-badge&logo=github)](https://github.com/LekKit/RVVM/pulls?q=is%3Apr+is%3Aclosed)
+|                      | Achievements | Working on |
+|----------------------|-------------|------------|
+| [**LekKit**](https://github.com/LekKit)                     | RVVM API & infrastructure <br> RV64IMAFDC interpreter, MMU/IRQs/Priv/etc <br> RVJIT Compiler, X86/RISC-V backends <br> NVMe, RTL8169, VFIO, many tiny devices <br> Userspace network <br> Rework of PCIe, PLIC, etc | Networking, Userspace emulation <br> COW blk-dedup image format <br> New CPU features & JIT optimizations |
+| [**cerg2010cerg2010**](https://github.com/cerg2010cerg2010) | Important fixes, RV64 groundwork, FPU <br> Initial PLIC & PCI, PS2 HID, ATA, OC Ethernet <br> ARM/ARM64 RVJIT backends | Testing, Assistance |
+| [**Mr0maks**](https://github.com/Mr0maks)                   | Initial C/M/Zicsr extensions, initial UART, VM debugger <br> ARM32 mul/div JIT intrinsics | - |
+| [**0xCatPKG**](https://github.com/0xCatPKG)                 | Userspace network & API improvements <br> Extended testing & portability fixes | HD Audio |
+| [**X547**](https://github.com/X547)                         | Haiku GUI, I2C HID, Userland API assistance | Guest Haiku support, UserlandVM |
+| [**iyzsong**](https://github.com/iyzsong)                   | OpenBSD & PLIC fixes, Chardev API | |
+| [**nebulka1**](https://github.com/nebulka1)                 | Relative input mode | |
+
+## 🔍 TODO
+- Implement Svpbmt, Svnapot extensions
+- Sparse block image format with compression/deduplication
+- Suspend/resume to file, VM migration
+- Linux userspace binary emulation (WIP)
+- USB3.0 XHCI, USB passthrough
+- Sound (HD Audio or else)
+- More RVJIT optimizations, shared caches
+- FPU JIT (Complicated AF to make a conformant one)
+- Vector extensions
+- Other peripherals from real boards (VisionFive 2: GPIO, SPI, flash...)
+- RISC-V APLIC, PCIe MSI Interrupts
+- *Maybe* virtio devices (For better QEMU interoperability, current devices are plenty fast)
+- Free page reporting via virtio-balloon
+- *A lot more...*
+- KVM hypervisor? Alternative CPU engines?
+
+The RISC-V trade name is a registered trade mark of RISC-V International.
diff --git a/app/src/main/java/libengine/RVVM/boot.sh b/app/src/main/java/libengine/RVVM/boot.sh
new file mode 100755
index 00000000..3c7360a4
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/boot.sh
@@ -0,0 +1,7 @@
+# to exit via terminal - CTRL-A + x
+#
+# to exit via kernel shell - busybox poweroff -f
+#
+#./make.sh
+#./debug_BUILD/rvvm ./uboot -v -k ./riscv-linux-prebuilt/kernel/vmlinux-rv64-5.4-rc7 -m 100m
+./debug_BUILD/rvvm ./uboot -v -k linux_6.8 -i ramdisk.img -m 100m
diff --git a/app/src/main/java/libengine/RVVM/make.sh b/app/src/main/java/libengine/RVVM/make.sh
new file mode 100755
index 00000000..b69e4c0a
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/make.sh
@@ -0,0 +1 @@
+make build_debug CC=clang CXX=clang++
diff --git a/app/src/main/java/libengine/RVVM/make_asan.sh b/app/src/main/java/libengine/RVVM/make_asan.sh
new file mode 100755
index 00000000..622886c5
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/make_asan.sh
@@ -0,0 +1 @@
+make test_debug_asan CC=clang CXX=clang++
diff --git a/app/src/main/java/libengine/RVVM/make_release.sh b/app/src/main/java/libengine/RVVM/make_release.sh
new file mode 100755
index 00000000..d97eedd2
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/make_release.sh
@@ -0,0 +1 @@
+make build_release CC=clang CXX=clang++
diff --git a/app/src/main/java/libengine/RVVM/make_valgrind.sh b/app/src/main/java/libengine/RVVM/make_valgrind.sh
new file mode 100755
index 00000000..c356d13d
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/make_valgrind.sh
@@ -0,0 +1 @@
+make test_debug_valgrind CC=clang CXX=clang++
diff --git a/app/src/main/java/libengine/RVVM/src/atomics.h b/app/src/main/java/libengine/RVVM/src/atomics.h
new file mode 100644
index 00000000..d336d408
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/atomics.h
@@ -0,0 +1,877 @@
+/*
+atomics.h - Atomic operations
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef ATOMICS_H
+#define ATOMICS_H
+
+#include <stdint.h>
+#include <stdbool.h>
+#include "compiler.h"
+
+#if __STDC_VERSION__ >= 201112LL && !defined(__STDC_NO_ATOMICS__) && !defined(__chibicc__)
+// Use C11 atomics on modern compilers
+// Those are broken on chibicc compiler, fallback if we detect it
+#include <stdatomic.h>
+#define C11_ATOMICS 1
+
+#define ATOMIC_RELAXED memory_order_relaxed
+#define ATOMIC_CONSUME memory_order_consume
+#define ATOMIC_ACQUIRE memory_order_acquire
+#define ATOMIC_RELEASE memory_order_release
+#define ATOMIC_ACQ_REL memory_order_acq_rel
+#define ATOMIC_SEQ_CST memory_order_seq_cst
+
+#elif GCC_CHECK_VER(4, 7) || CLANG_CHECK_VER(3, 1)
+// Use libatomic-compatible compiler intrinsics on GCC 4.7+ and Clang 3.1+
+#define GNU_ATOMICS 1
+#define GNU_ATOMIC_INTRINS 1
+
+#define ATOMIC_RELAXED __ATOMIC_RELAXED
+#define ATOMIC_CONSUME __ATOMIC_CONSUME
+#define ATOMIC_ACQUIRE __ATOMIC_ACQUIRE
+#define ATOMIC_RELEASE __ATOMIC_RELEASE
+#define ATOMIC_ACQ_REL __ATOMIC_ACQ_REL
+#define ATOMIC_SEQ_CST __ATOMIC_SEQ_CST
+
+#define __atomic_load_4             __atomic_load_n
+#define __atomic_store_4            __atomic_store_n
+#define __atomic_exchange_4         __atomic_exchange_n
+#define __atomic_compare_exchange_4 __atomic_compare_exchange_n
+#define __atomic_fetch_add_4        __atomic_fetch_add
+#define __atomic_fetch_sub_4        __atomic_fetch_sub
+#define __atomic_fetch_and_4        __atomic_fetch_and
+#define __atomic_fetch_xor_4        __atomic_fetch_xor
+#define __atomic_fetch_or_4         __atomic_fetch_or
+
+#define __atomic_load_8             __atomic_load_n
+#define __atomic_store_8            __atomic_store_n
+#define __atomic_exchange_8         __atomic_exchange_n
+#define __atomic_compare_exchange_8 __atomic_compare_exchange_n
+#define __atomic_fetch_add_8        __atomic_fetch_add
+#define __atomic_fetch_sub_8        __atomic_fetch_sub
+#define __atomic_fetch_and_8        __atomic_fetch_and
+#define __atomic_fetch_xor_8        __atomic_fetch_xor
+#define __atomic_fetch_or_8         __atomic_fetch_or
+
+#define atomic_thread_fence         __atomic_thread_fence
+
+#else
+
+#define ATOMIC_RELAXED 0
+#define ATOMIC_CONSUME 1
+#define ATOMIC_ACQUIRE 2
+#define ATOMIC_RELEASE 3
+#define ATOMIC_ACQ_REL 4
+#define ATOMIC_SEQ_CST 5
+
+#ifdef _WIN32
+// Use Interlocked Win32 functions
+#include <windows.h>
+
+#elif !defined(NO_LIBATOMIC)
+// Directly call libatomic functions
+#define GNU_ATOMICS 1
+
+uint32_t __atomic_load_4(const volatile void* ptr, int memorder);
+void     __atomic_store_4(volatile void* ptr, uint32_t val, int memorder);
+uint32_t __atomic_exchange_4(volatile void* ptr, uint32_t val, int memorder);
+bool     __atomic_compare_exchange_4(volatile void* ptr, void* expected, uint32_t desired,
+                                     bool weak, int success_memorder, int failure_memorder);
+uint32_t __atomic_fetch_add_4(volatile void* ptr, uint32_t val, int memorder);
+uint32_t __atomic_fetch_sub_4(volatile void* ptr, uint32_t val, int memorder);
+uint32_t __atomic_fetch_and_4(volatile void* ptr, uint32_t val, int memorder);
+uint32_t __atomic_fetch_xor_4(volatile void* ptr, uint32_t val, int memorder);
+uint32_t __atomic_fetch_or_4(volatile void* ptr, uint32_t val, int memorder);
+
+uint64_t __atomic_load_8(const volatile void* ptr, int memorder);
+void     __atomic_store_8(volatile void* ptr, uint64_t val, int memorder);
+uint64_t __atomic_exchange_8(volatile void* ptr, uint64_t val, int memorder);
+bool     __atomic_compare_exchange_8(volatile void* ptr, void* expected, uint64_t desired,
+                                     bool weak, int success_memorder, int failure_memorder);
+uint64_t __atomic_fetch_add_8(volatile void* ptr, uint64_t val, int memorder);
+uint64_t __atomic_fetch_sub_8(volatile void* ptr, uint64_t val, int memorder);
+uint64_t __atomic_fetch_and_8(volatile void* ptr, uint64_t val, int memorder);
+uint64_t __atomic_fetch_xor_8(volatile void* ptr, uint64_t val, int memorder);
+uint64_t __atomic_fetch_or_8(volatile void* ptr, uint64_t val, int memorder);
+
+void     atomic_thread_fence(int memorder);
+
+#else
+// This is really unstable, but at least it'll compile
+#warning No atomics support for current build target!
+#define HOST_NO_ATOMICS 1
+#endif
+
+#endif
+
+#ifndef HOST_LITTLE_ENDIAN
+// Use portable conversions instead of host atomics for explicit little endian
+#include "mem_ops.h"
+#endif
+
+static forceinline void atomic_fence_ex(int memorder)
+{
+#if defined(C11_ATOMICS) || defined(GNU_ATOMICS)
+    atomic_thread_fence(memorder);
+#elif _WIN32
+    UNUSED(memorder);
+    MemoryBarrier();
+#else
+    UNUSED(memorder);
+#endif
+}
+
+static forceinline void atomic_fence(void)
+{
+    atomic_fence_ex(ATOMIC_SEQ_CST);
+}
+
+/*
+ * Host-endian 32-bit operations
+ */
+
+static forceinline uint32_t atomic_load_uint32_ex(const void* addr, int memorder)
+{
+#ifdef C11_ATOMICS
+    return atomic_load_explicit((_Atomic uint32_t*)addr, memorder);
+#elif GNU_ATOMICS
+#if !defined(GNU_ATOMIC_INTRINS)
+    // Optimize relaxed atomic loads when libatomic is used directly
+    if (memorder == ATOMIC_RELAXED) return *(const uint32_t*)addr;
+#endif
+    return __atomic_load_4((const uint32_t*)addr, memorder);
+#elif _WIN32
+    UNUSED(memorder);
+    return InterlockedOr((LONG*)addr, 0);
+#else
+    UNUSED(memorder);
+    return *(const uint32_t*)addr;
+#endif
+}
+
+static forceinline void atomic_store_uint32_ex(void* addr, uint32_t val, int memorder)
+{
+#ifdef C11_ATOMICS
+    atomic_store_explicit((_Atomic uint32_t*)addr, val, memorder);
+#elif GNU_ATOMICS
+    __atomic_store_4((uint32_t*)addr, val, memorder);
+#elif _WIN32
+    UNUSED(memorder);
+    InterlockedExchange((LONG*)addr, val);
+#else
+    UNUSED(memorder);
+    *(uint32_t*)addr = val;
+#endif
+}
+
+static forceinline uint32_t atomic_swap_uint32_ex(void* addr, uint32_t val, int memorder)
+{
+#ifdef C11_ATOMICS
+    return atomic_exchange_explicit((_Atomic uint32_t*)addr, val, memorder);
+#elif GNU_ATOMICS
+    return __atomic_exchange_4((uint32_t*)addr, val, memorder);
+#elif _WIN32
+    UNUSED(memorder);
+    return InterlockedExchange((LONG*)addr, val);
+#else
+    UNUSED(memorder);
+    uint32_t tmp = *(uint32_t*)addr;
+    *(uint32_t*)addr = val;
+    return tmp;
+#endif
+}
+
+static forceinline bool atomic_cas_uint32_ex(void* addr, uint32_t exp, uint32_t val, bool weak, int succ, int fail)
+{
+#if defined(__riscv_a) && defined(GNU_EXTS)
+    // Workaround RISC-V atomic CAS miscompilation on GCC <14.1
+    UNUSED(weak); UNUSED(succ); UNUSED(fail);
+    uint32_t ret = 1, tmp = 0;
+    __asm__ __volatile__ (
+        "lrsc_cas_loop%=: \n\t"
+        "lr.w.aq %1, (%4) \n\t"
+        "bne %1, %2, lrsc_cas_exit%= \n\t"
+        "sc.w.rl %0, %3, (%4) \n\t"
+        "bnez %0, lrsc_cas_loop%= \n\t"
+        "lrsc_cas_exit%=: "
+        : "=&r" (ret), "=&r" (tmp) : "r" (exp), "r" (val), "p" (addr) : "memory");
+    return tmp == exp;
+#elif C11_ATOMICS
+    if (weak) {
+        return atomic_compare_exchange_weak_explicit((_Atomic uint32_t*)addr, &exp, val, succ, fail);
+    } else {
+        return atomic_compare_exchange_strong_explicit((_Atomic uint32_t*)addr, &exp, val, succ, fail);
+    }
+#elif GNU_ATOMICS
+    return __atomic_compare_exchange_4((uint32_t*)addr, &exp, val, weak, succ, fail);
+#elif _WIN32
+    UNUSED(weak); UNUSED(succ); UNUSED(fail);
+    return InterlockedCompareExchange((LONG*)addr, val, exp) == (LONG)exp;
+#else
+    UNUSED(weak); UNUSED(succ); UNUSED(fail);
+    if (*(uint32_t*)addr == exp) {
+        *(uint32_t*)addr = val;
+        return true;
+    } else return false;
+#endif
+}
+
+static forceinline uint32_t atomic_add_uint32_ex(void* addr, uint32_t val, int memorder)
+{
+#ifdef C11_ATOMICS
+    return atomic_fetch_add_explicit((_Atomic uint32_t*)addr, val, memorder);
+#elif GNU_ATOMICS
+    return __atomic_fetch_add_4((uint32_t*)addr, val, memorder);
+#elif _WIN32
+    UNUSED(memorder);
+    return InterlockedExchangeAdd((LONG*)addr, val);
+#else
+    UNUSED(memorder);
+    uint32_t tmp = *(uint32_t*)addr;
+    *(uint32_t*)addr += val;
+    return tmp;
+#endif
+}
+
+static forceinline uint32_t atomic_sub_uint32_ex(void* addr, uint32_t val, int memorder)
+{
+#ifdef C11_ATOMICS
+    return atomic_fetch_sub_explicit((_Atomic uint32_t*)addr, val, memorder);
+#elif GNU_ATOMICS
+    return __atomic_fetch_sub_4((uint32_t*)addr, val, memorder);
+#elif _WIN32
+    UNUSED(memorder);
+    return InterlockedExchangeAdd((LONG*)addr, -val);
+#else
+    UNUSED(memorder);
+    uint32_t tmp = *(uint32_t*)addr;
+    *(uint32_t*)addr -= val;
+    return tmp;
+#endif
+}
+
+static forceinline uint32_t atomic_and_uint32_ex(void* addr, uint32_t val, int memorder)
+{
+#ifdef C11_ATOMICS
+    return atomic_fetch_and_explicit((_Atomic uint32_t*)addr, val, memorder);
+#elif GNU_ATOMICS
+    return __atomic_fetch_and_4((uint32_t*)addr, val, memorder);
+#elif _WIN32
+    UNUSED(memorder);
+    return InterlockedAnd((LONG*)addr, val);
+#else
+    UNUSED(memorder);
+    uint32_t tmp = *(uint32_t*)addr;
+    *(uint32_t*)addr &= val;
+    return tmp;
+#endif
+}
+
+static forceinline uint32_t atomic_xor_uint32_ex(void* addr, uint32_t val, int memorder)
+{
+#ifdef C11_ATOMICS
+    return atomic_fetch_xor_explicit((_Atomic uint32_t*)addr, val, memorder);
+#elif GNU_ATOMICS
+    return __atomic_fetch_xor_4((uint32_t*)addr, val, memorder);
+#elif _WIN32
+    UNUSED(memorder);
+    return InterlockedXor((LONG*)addr, val);
+#else
+    UNUSED(memorder);
+    uint32_t tmp = *(uint32_t*)addr;
+    *(uint32_t*)addr ^= val;
+    return tmp;
+#endif
+}
+
+static forceinline uint32_t atomic_or_uint32_ex(void* addr, uint32_t val, int memorder)
+{
+#ifdef C11_ATOMICS
+    return atomic_fetch_or_explicit((_Atomic uint32_t*)addr, val, memorder);
+#elif GNU_ATOMICS
+    return __atomic_fetch_or_4((uint32_t*)addr, val, memorder);
+#elif _WIN32
+    UNUSED(memorder);
+    return InterlockedOr((LONG*)addr, val);
+#else
+    UNUSED(memorder);
+    uint32_t tmp = *(uint32_t*)addr;
+    *(uint32_t*)addr |= val;
+    return tmp;
+#endif
+}
+
+static forceinline uint32_t atomic_load_uint32(const void* addr)
+{
+    return atomic_load_uint32_ex(addr, ATOMIC_ACQUIRE);
+}
+
+static forceinline void atomic_store_uint32(void* addr, uint32_t val)
+{
+    atomic_store_uint32_ex(addr, val, ATOMIC_RELEASE);
+}
+
+static forceinline uint32_t atomic_swap_uint32(void* addr, uint32_t val)
+{
+    return atomic_swap_uint32_ex(addr, val, ATOMIC_ACQ_REL);
+}
+
+static forceinline bool atomic_cas_uint32(void* addr, uint32_t exp, uint32_t val)
+{
+    return atomic_cas_uint32_ex(addr, exp, val, false, ATOMIC_ACQ_REL, ATOMIC_ACQUIRE);
+}
+
+static forceinline bool atomic_cas_uint32_weak(void* addr, uint32_t exp, uint32_t val)
+{
+    return atomic_cas_uint32_ex(addr, exp, val, true, ATOMIC_ACQ_REL, ATOMIC_ACQUIRE);
+}
+
+static forceinline uint32_t atomic_add_uint32(void* addr, uint32_t val)
+{
+    return atomic_add_uint32_ex(addr, val, ATOMIC_ACQ_REL);
+}
+
+static forceinline uint32_t atomic_sub_uint32(void* addr, uint32_t val)
+{
+    return atomic_sub_uint32_ex(addr, val, ATOMIC_ACQ_REL);
+}
+
+static forceinline uint32_t atomic_and_uint32(void* addr, uint32_t val)
+{
+    return atomic_and_uint32_ex(addr, val, ATOMIC_ACQ_REL);
+}
+
+static forceinline uint32_t atomic_xor_uint32(void* addr, uint32_t val)
+{
+    return atomic_xor_uint32_ex(addr, val, ATOMIC_ACQ_REL);
+}
+
+static forceinline uint32_t atomic_or_uint32(void* addr, uint32_t val)
+{
+    return atomic_or_uint32_ex(addr, val, ATOMIC_ACQ_REL);
+}
+
+/*
+ * Host-endian 64-bit operations
+ */
+
+static forceinline uint64_t atomic_load_uint64_ex(const void* addr, int memorder)
+{
+#ifdef C11_ATOMICS
+    return atomic_load_explicit((_Atomic uint64_t*)addr, memorder);
+#elif GNU_ATOMICS
+#if !defined(GNU_ATOMIC_INTRINS) && defined(HOST_64BIT)
+    // Optimize relaxed atomic loads when libatomic is used directly
+    if (memorder == ATOMIC_RELAXED) return *(const uint64_t*)addr;
+#endif
+    return __atomic_load_8((const uint64_t*)addr, memorder);
+#elif _WIN32
+    UNUSED(memorder);
+    return InterlockedOr64((LONG64*)addr, 0);
+#else
+    UNUSED(memorder);
+    return *(const uint64_t*)addr;
+#endif
+}
+
+static forceinline void atomic_store_uint64_ex(void* addr, uint64_t val, int memorder)
+{
+#ifdef C11_ATOMICS
+    atomic_store_explicit((_Atomic uint64_t*)addr, val, memorder);
+#elif GNU_ATOMICS
+    __atomic_store_8((uint64_t*)addr, val, memorder);
+#elif _WIN32
+    UNUSED(memorder);
+    InterlockedExchange64((LONG64*)addr, val);
+#else
+    UNUSED(memorder);
+    *(uint64_t*)addr = val;
+#endif
+}
+
+static forceinline uint64_t atomic_swap_uint64_ex(void* addr, uint64_t val, int memorder)
+{
+#ifdef C11_ATOMICS
+    return atomic_exchange_explicit((_Atomic uint64_t*)addr, val, memorder);
+#elif GNU_ATOMICS
+    return __atomic_exchange_8((uint64_t*)addr, val, memorder);
+#elif _WIN32
+    UNUSED(memorder);
+    return InterlockedExchange64((LONG64*)addr, val);
+#else
+    UNUSED(memorder);
+    uint64_t tmp = *(uint64_t*)addr;
+    *(uint64_t*)addr = val;
+    return tmp;
+#endif
+}
+
+static forceinline bool atomic_cas_uint64_ex(void* addr, uint64_t exp, uint64_t val, bool weak, int succ, int fail)
+{
+#if defined(__riscv_a) && __riscv_xlen >= 64 && defined(GNU_EXTS)
+    // Workaround RISC-V atomic CAS miscompilation on GCC <14.1
+    UNUSED(weak); UNUSED(succ); UNUSED(fail);
+    uint64_t ret = 1, tmp = 0;
+    __asm__ __volatile__ (
+        "lrsc_cas_loop%=: \n\t"
+        "lr.d.aq %1, (%4) \n\t"
+        "bne %1, %2, lrsc_cas_exit%= \n\t"
+        "sc.d.rl %0, %3, (%4) \n\t"
+        "bnez %0, lrsc_cas_loop%= \n\t"
+        "lrsc_cas_exit%=: "
+        : "=&r" (ret), "=&r" (tmp) : "r" (exp), "r" (val), "p" (addr) : "memory");
+    return tmp == exp;
+#elif C11_ATOMICS
+    if (weak) {
+        return atomic_compare_exchange_weak_explicit((_Atomic uint64_t*)addr, &exp, val, succ, fail);
+    } else {
+        return atomic_compare_exchange_strong_explicit((_Atomic uint64_t*)addr, &exp, val, succ, fail);
+    }
+#elif GNU_ATOMICS
+    return __atomic_compare_exchange_8((uint64_t*)addr, &exp, val, weak, succ, fail);
+#elif _WIN32
+    UNUSED(weak); UNUSED(succ); UNUSED(fail);
+    return InterlockedCompareExchange64((LONG64*)addr, val, exp) == (LONG64)exp;
+#else
+    UNUSED(weak); UNUSED(succ); UNUSED(fail);
+    if (*(uint64_t*)addr == exp) {
+        *(uint64_t*)addr = val;
+        return true;
+    } else return false;
+#endif
+}
+
+static forceinline uint64_t atomic_add_uint64_ex(void* addr, uint64_t val, int memorder)
+{
+#ifdef C11_ATOMICS
+    return atomic_fetch_add_explicit((_Atomic uint64_t*)addr, val, memorder);
+#elif GNU_ATOMICS
+    return __atomic_fetch_add_8((uint64_t*)addr, val, memorder);
+#elif _WIN32
+    UNUSED(memorder);
+    return InterlockedExchangeAdd64((LONG64*)addr, val);
+#else
+    UNUSED(memorder);
+    uint64_t tmp = *(uint64_t*)addr;
+    *(uint64_t*)addr += val;
+    return tmp;
+#endif
+}
+
+static forceinline uint64_t atomic_sub_uint64_ex(void* addr, uint64_t val, int memorder)
+{
+#ifdef C11_ATOMICS
+    return atomic_fetch_sub_explicit((_Atomic uint64_t*)addr, val, memorder);
+#elif GNU_ATOMICS
+    return __atomic_fetch_sub_8((uint64_t*)addr, val, memorder);
+#elif _WIN32
+    UNUSED(memorder);
+    return InterlockedExchangeAdd64((LONG64*)addr, -val);
+#else
+    UNUSED(memorder);
+    uint64_t tmp = *(uint64_t*)addr;
+    *(uint64_t*)addr -= val;
+    return tmp;
+#endif
+}
+
+static forceinline uint64_t atomic_and_uint64_ex(void* addr, uint64_t val, int memorder)
+{
+#ifdef C11_ATOMICS
+    return atomic_fetch_and_explicit((_Atomic uint64_t*)addr, val, memorder);
+#elif GNU_ATOMICS
+    return __atomic_fetch_and_8((uint64_t*)addr, val, memorder);
+#elif _WIN32
+    UNUSED(memorder);
+    return InterlockedAnd64((LONG64*)addr, val);
+#else
+    UNUSED(memorder);
+    uint64_t tmp = *(uint64_t*)addr;
+    *(uint64_t*)addr &= val;
+    return tmp;
+#endif
+}
+
+static forceinline uint64_t atomic_xor_uint64_ex(void* addr, uint64_t val, int memorder)
+{
+#ifdef C11_ATOMICS
+    return atomic_fetch_xor_explicit((_Atomic uint64_t*)addr, val, memorder);
+#elif GNU_ATOMICS
+    return __atomic_fetch_xor_8((uint64_t*)addr, val, memorder);
+#elif _WIN32
+    UNUSED(memorder);
+    return InterlockedXor64((LONG64*)addr, val);
+#else
+    UNUSED(memorder);
+    uint64_t tmp = *(uint64_t*)addr;
+    *(uint64_t*)addr ^= val;
+    return tmp;
+#endif
+}
+
+static forceinline uint64_t atomic_or_uint64_ex(void* addr, uint64_t val, int memorder)
+{
+#ifdef C11_ATOMICS
+    return atomic_fetch_or_explicit((_Atomic uint64_t*)addr, val, memorder);
+#elif GNU_ATOMICS
+    return __atomic_fetch_or_8((uint64_t*)addr, val, memorder);
+#elif _WIN32
+    UNUSED(memorder);
+    return InterlockedOr64((LONG64*)addr, val);
+#else
+    UNUSED(memorder);
+    uint64_t tmp = *(uint64_t*)addr;
+    *(uint64_t*)addr |= val;
+    return tmp;
+#endif
+}
+
+static forceinline uint64_t atomic_load_uint64(const void* addr)
+{
+    return atomic_load_uint64_ex(addr, ATOMIC_ACQUIRE);
+}
+
+static forceinline void atomic_store_uint64(void* addr, uint64_t val)
+{
+    atomic_store_uint64_ex(addr, val, ATOMIC_RELEASE);
+}
+
+static forceinline uint64_t atomic_swap_uint64(void* addr, uint64_t val)
+{
+    return atomic_swap_uint64_ex(addr, val, ATOMIC_ACQ_REL);
+}
+
+static forceinline bool atomic_cas_uint64(void* addr, uint64_t exp, uint64_t val)
+{
+    return atomic_cas_uint64_ex(addr, exp, val, false, ATOMIC_ACQ_REL, ATOMIC_ACQUIRE);
+}
+
+static forceinline bool atomic_cas_uint64_weak(void* addr, uint64_t exp, uint64_t val)
+{
+    return atomic_cas_uint64_ex(addr, exp, val, true, ATOMIC_ACQ_REL, ATOMIC_ACQUIRE);
+}
+
+static forceinline uint64_t atomic_add_uint64(void* addr, uint64_t val)
+{
+    return atomic_add_uint64_ex(addr, val, ATOMIC_ACQ_REL);
+}
+
+static forceinline uint64_t atomic_sub_uint64(void* addr, uint64_t val)
+{
+    return atomic_sub_uint64_ex(addr, val, ATOMIC_ACQ_REL);
+}
+
+static forceinline uint64_t atomic_and_uint64(void* addr, uint64_t val)
+{
+    return atomic_and_uint64_ex(addr, val, ATOMIC_ACQ_REL);
+}
+
+static forceinline uint64_t atomic_xor_uint64(void* addr, uint64_t val)
+{
+    return atomic_xor_uint64_ex(addr, val, ATOMIC_ACQ_REL);
+}
+
+static forceinline uint64_t atomic_or_uint64(void* addr, uint64_t val)
+{
+    return atomic_or_uint64_ex(addr, val, ATOMIC_ACQ_REL);
+}
+
+/*
+ * Emulated little-endian atomics for big-endian hosts
+ */
+
+static inline void atomic_store_uint32_le(void* addr, uint32_t val)
+{
+#ifdef HOST_LITTLE_ENDIAN
+    atomic_store_uint32(addr, val);
+#else
+    write_uint32_le(&val, val);
+    atomic_store_uint32(addr, val);
+#endif
+}
+
+static inline uint32_t atomic_load_uint32_le(const void* addr)
+{
+#ifdef HOST_LITTLE_ENDIAN
+    return atomic_load_uint32(addr);
+#else
+    uint32_t val = atomic_load_uint32(addr);
+    return read_uint32_le(&val);
+#endif
+}
+
+static inline uint32_t atomic_swap_uint32_le(void* addr, uint32_t val)
+{
+#ifdef HOST_LITTLE_ENDIAN
+    return atomic_swap_uint32(addr, val);
+#else
+    write_uint32_le(&val, val);
+    val = atomic_swap_uint32(addr, val);
+    return read_uint32_le(&val);
+#endif
+}
+
+static inline bool atomic_cas_uint32_le(void* addr, uint32_t exp, uint32_t val)
+{
+#ifdef HOST_LITTLE_ENDIAN
+    return atomic_cas_uint32_ex(addr, exp, val, true, ATOMIC_ACQ_REL, ATOMIC_ACQUIRE);
+#else
+    write_uint32_le(&exp, exp);
+    write_uint32_le(&val, val);
+    return atomic_cas_uint32_ex(addr, exp, val, true, ATOMIC_ACQ_REL, ATOMIC_ACQUIRE);
+#endif
+}
+
+static inline uint32_t atomic_or_uint32_le(void* addr, uint32_t val)
+{
+#ifdef HOST_LITTLE_ENDIAN
+    return atomic_or_uint32(addr, val);
+#else
+    write_uint32_le(&val, val);
+    val = atomic_or_uint32(addr, val);
+    return read_uint32_le(&val);
+#endif
+}
+
+static inline uint32_t atomic_xor_uint32_le(void* addr, uint32_t val)
+{
+#ifdef HOST_LITTLE_ENDIAN
+    return atomic_xor_uint32(addr, val);
+#else
+    write_uint32_le(&val, val);
+    val = atomic_xor_uint32(addr, val);
+    return read_uint32_le(&val);
+#endif
+}
+
+static inline uint32_t atomic_and_uint32_le(void* addr, uint32_t val)
+{
+#ifdef HOST_LITTLE_ENDIAN
+    return atomic_and_uint32(addr, val);
+#else
+    write_uint32_le(&val, val);
+    val = atomic_and_uint32(addr, val);
+    return read_uint32_le(&val);
+#endif
+}
+
+static inline void atomic_store_uint64_le(void* addr, uint64_t val)
+{
+#ifdef HOST_LITTLE_ENDIAN
+    atomic_store_uint64(addr, val);
+#else
+    write_uint64_le(&val, val);
+    atomic_store_uint64(addr, val);
+#endif
+}
+
+static inline uint64_t atomic_load_uint64_le(const void* addr)
+{
+#ifdef HOST_LITTLE_ENDIAN
+    return atomic_load_uint64(addr);
+#else
+    uint64_t val = atomic_load_uint64(addr);
+    return read_uint64_le(&val);
+#endif
+}
+
+static inline uint64_t atomic_swap_uint64_le(void* addr, uint64_t val)
+{
+#ifdef HOST_LITTLE_ENDIAN
+    return atomic_swap_uint64(addr, val);
+#else
+    write_uint64_le(&val, val);
+    val = atomic_swap_uint64(addr, val);
+    return read_uint64_le(&val);
+#endif
+}
+
+static inline bool atomic_cas_uint64_le(void* addr, uint64_t exp, uint64_t val)
+{
+#ifdef HOST_LITTLE_ENDIAN
+    return atomic_cas_uint64_ex(addr, exp, val, true, ATOMIC_ACQ_REL, ATOMIC_ACQUIRE);
+#else
+    write_uint64_le(&exp, exp);
+    write_uint64_le(&val, val);
+    return atomic_cas_uint64_ex(addr, exp, val, true, ATOMIC_ACQ_REL, ATOMIC_ACQUIRE);
+#endif
+}
+
+static inline uint64_t atomic_or_uint64_le(void* addr, uint64_t val)
+{
+#ifdef HOST_LITTLE_ENDIAN
+    return atomic_or_uint64(addr, val);
+#else
+    write_uint64_le(&val, val);
+    val = atomic_or_uint64(addr, val);
+    return read_uint64_le(&val);
+#endif
+}
+
+static inline uint64_t atomic_xor_uint64_le(void* addr, uint64_t val)
+{
+#ifdef HOST_LITTLE_ENDIAN
+    return atomic_xor_uint64(addr, val);
+#else
+    write_uint64_le(&val, val);
+    val = atomic_xor_uint64(addr, val);
+    return read_uint64_le(&val);
+#endif
+}
+
+static inline uint64_t atomic_and_uint64_le(void* addr, uint64_t val)
+{
+#ifdef HOST_LITTLE_ENDIAN
+    return atomic_and_uint64(addr, val);
+#else
+    write_uint64_le(&val, val);
+    val = atomic_and_uint64(addr, val);
+    return read_uint64_le(&val);
+#endif
+}
+
+/*
+ * CAS-based arithmetic operations
+ * Store operation result if the value is unchanged
+ */
+
+static inline uint32_t atomic_add_uint32_le(void* addr, uint32_t val)
+{
+#ifdef HOST_LITTLE_ENDIAN
+    return atomic_add_uint32(addr, val);
+#else
+    uint32_t tmp;
+    do {
+        tmp = atomic_load_uint32_le(addr);
+    } while (!atomic_cas_uint32_le(addr, tmp, tmp + val));
+    return tmp;
+#endif
+}
+
+static inline uint32_t atomic_sub_uint32_le(void* addr, uint32_t val)
+{
+#ifdef HOST_LITTLE_ENDIAN
+    return atomic_sub_uint32(addr, val);
+#else
+    uint32_t tmp;
+    do {
+        tmp = atomic_load_uint32_le(addr);
+    } while (!atomic_cas_uint32_le(addr, tmp, tmp - val));
+    return tmp;
+#endif
+}
+
+static inline int32_t atomic_max_int32_le(void* addr, int32_t val)
+{
+    int32_t tmp;
+    do {
+        tmp = atomic_load_uint32_le(addr);
+    } while (!atomic_cas_uint32_le(addr, tmp, tmp > val ? tmp : val));
+    return tmp;
+}
+
+static inline int32_t atomic_min_int32_le(void* addr, int32_t val)
+{
+    int32_t tmp;
+    do {
+        tmp = atomic_load_uint32_le(addr);
+    } while (!atomic_cas_uint32_le(addr, tmp, tmp < val ? tmp : val));
+    return tmp;
+}
+
+static inline uint32_t atomic_maxu_uint32_le(void* addr, uint32_t val)
+{
+    uint32_t tmp;
+    do {
+        tmp = atomic_load_uint32_le(addr);
+    } while (!atomic_cas_uint32_le(addr, tmp, tmp > val ? tmp : val));
+    return tmp;
+}
+
+static inline uint32_t atomic_minu_uint32_le(void* addr, uint32_t val)
+{
+    uint32_t tmp;
+    do {
+        tmp = atomic_load_uint32_le(addr);
+    } while (!atomic_cas_uint32_le(addr, tmp, tmp < val ? tmp : val));
+    return tmp;
+}
+
+static inline uint64_t atomic_add_uint64_le(void* addr, uint64_t val)
+{
+#ifdef HOST_LITTLE_ENDIAN
+    return atomic_add_uint64(addr, val);
+#else
+    uint64_t tmp;
+    do {
+        tmp = atomic_load_uint64_le(addr);
+    } while (!atomic_cas_uint64_le(addr, tmp, tmp + val));
+    return tmp;
+#endif
+}
+
+static inline uint64_t atomic_sub_uint64_le(void* addr, uint64_t val)
+{
+#ifdef HOST_LITTLE_ENDIAN
+    return atomic_sub_uint64(addr, val);
+#else
+    uint64_t tmp;
+    do {
+        tmp = atomic_load_uint64_le(addr);
+    } while (!atomic_cas_uint64_le(addr, tmp, tmp - val));
+    return tmp;
+#endif
+}
+
+static inline int64_t atomic_max_int64_le(void* addr, int64_t val)
+{
+    int64_t tmp;
+    do {
+        tmp = atomic_load_uint64_le(addr);
+    } while (!atomic_cas_uint64_le(addr, tmp, tmp > val ? tmp : val));
+    return tmp;
+}
+
+static inline int64_t atomic_min_int64_le(void* addr, int64_t val)
+{
+    int64_t tmp;
+    do {
+        tmp = atomic_load_uint64_le(addr);
+    } while (!atomic_cas_uint64_le(addr, tmp, tmp < val ? tmp : val));
+    return tmp;
+}
+
+static inline uint64_t atomic_maxu_uint64_le(void* addr, uint64_t val)
+{
+    uint64_t tmp;
+    do {
+        tmp = atomic_load_uint64_le(addr);
+    } while (!atomic_cas_uint64_le(addr, tmp, tmp > val ? tmp : val));
+    return tmp;
+}
+
+static inline uint64_t atomic_minu_uint64_le(void* addr, uint64_t val)
+{
+    uint64_t tmp;
+    do {
+        tmp = atomic_load_uint64_le(addr);
+    } while (!atomic_cas_uint64_le(addr, tmp, tmp < val ? tmp : val));
+    return tmp;
+}
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/Framebuffer.java b/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/Framebuffer.java
new file mode 100644
index 00000000..48d645c0
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/Framebuffer.java
@@ -0,0 +1,48 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at https://mozilla.org/MPL/2.0/.
+ */
+
+package lekkit.rvvm;
+
+import java.nio.ByteBuffer;
+
+public class Framebuffer extends MMIODevice {
+    protected int width;
+    protected int height;
+    protected int bpp;
+    protected ByteBuffer buff;
+
+    public static final int BPP_R5G6B5 = 16;
+    public static final int BPP_R8G8B8 = 24;
+    public static final int BPP_A8R8G8B8 = 32;
+
+    public Framebuffer(RVVMMachine machine, int x, int y) {
+        this(machine, x, y, BPP_A8R8G8B8);
+    }
+
+    public Framebuffer(RVVMMachine machine, int x, int y, int bpp) {
+        super(machine);
+        this.width = x;
+        this.height = y;
+        this.bpp = bpp;
+        this.buff = ByteBuffer.allocateDirect(x * y * (bpp / 8));
+        if (machine.isValid()) {
+            setMMIOHandle(RVVMNative.framebuffer_init_auto(machine.getPtr(), this.buff, x, y, bpp));
+        }
+    }
+
+    public ByteBuffer getBuffer() {
+        return buff;
+    }
+    public int getWidth() {
+        return width;
+    }
+    public int getHeight() {
+        return height;
+    }
+    public int getBpp() {
+        return bpp;
+    }
+}
diff --git a/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/GoldfishRTC.java b/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/GoldfishRTC.java
new file mode 100644
index 00000000..6f3fac40
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/GoldfishRTC.java
@@ -0,0 +1,16 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at https://mozilla.org/MPL/2.0/.
+ */
+
+package lekkit.rvvm;
+
+public class GoldfishRTC extends MMIODevice {
+    public GoldfishRTC(RVVMMachine machine) {
+        super(machine);
+        if (machine.isValid()) {
+            setMMIOHandle(RVVMNative.rtc_goldfish_init_auto(machine.getPtr()));
+        }
+    }
+}
diff --git a/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/HIDKeyboard.java b/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/HIDKeyboard.java
new file mode 100644
index 00000000..220382f1
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/HIDKeyboard.java
@@ -0,0 +1,242 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at https://mozilla.org/MPL/2.0/.
+ */
+
+package lekkit.rvvm;
+
+public class HIDKeyboard {
+    private final RVVMMachine machine;
+    private final long hid_keyboard;
+
+    // Keyboard keycode definitions
+    public static final byte HID_KEY_NONE = 0x00;
+
+    // Keyboard errors (Non-physical keys)
+    public static final byte HID_KEY_ERR_ROLLOVER  = 0x01;
+    public static final byte HID_KEY_ERR_POSTFAIL  = 0x02;
+    public static final byte HID_KEY_ERR_UNDEFINED = 0x03;
+
+    // Typing keys
+    public static final byte HID_KEY_A = 0x04;
+    public static final byte HID_KEY_B = 0x05;
+    public static final byte HID_KEY_C = 0x06;
+    public static final byte HID_KEY_D = 0x07;
+    public static final byte HID_KEY_E = 0x08;
+    public static final byte HID_KEY_F = 0x09;
+    public static final byte HID_KEY_G = 0x0a;
+    public static final byte HID_KEY_H = 0x0b;
+    public static final byte HID_KEY_I = 0x0c;
+    public static final byte HID_KEY_J = 0x0d;
+    public static final byte HID_KEY_K = 0x0e;
+    public static final byte HID_KEY_L = 0x0f;
+    public static final byte HID_KEY_M = 0x10;
+    public static final byte HID_KEY_N = 0x11;
+    public static final byte HID_KEY_O = 0x12;
+    public static final byte HID_KEY_P = 0x13;
+    public static final byte HID_KEY_Q = 0x14;
+    public static final byte HID_KEY_R = 0x15;
+    public static final byte HID_KEY_S = 0x16;
+    public static final byte HID_KEY_T = 0x17;
+    public static final byte HID_KEY_U = 0x18;
+    public static final byte HID_KEY_V = 0x19;
+    public static final byte HID_KEY_W = 0x1a;
+    public static final byte HID_KEY_X = 0x1b;
+    public static final byte HID_KEY_Y = 0x1c;
+    public static final byte HID_KEY_Z = 0x1d;
+
+    // Number keys
+    public static final byte HID_KEY_1 = 0x1e;
+    public static final byte HID_KEY_2 = 0x1f;
+    public static final byte HID_KEY_3 = 0x20;
+    public static final byte HID_KEY_4 = 0x21;
+    public static final byte HID_KEY_5 = 0x22;
+    public static final byte HID_KEY_6 = 0x23;
+    public static final byte HID_KEY_7 = 0x24;
+    public static final byte HID_KEY_8 = 0x25;
+    public static final byte HID_KEY_9 = 0x26;
+    public static final byte HID_KEY_0 = 0x27;
+
+    // Control keys
+    public static final byte HID_KEY_ENTER      = 0x28;
+    public static final byte HID_KEY_ESC        = 0x29;
+    public static final byte HID_KEY_BACKSPACE  = 0x2a;
+    public static final byte HID_KEY_TAB        = 0x2b;
+    public static final byte HID_KEY_SPACE      = 0x2c;
+    public static final byte HID_KEY_MINUS      = 0x2d;
+    public static final byte HID_KEY_EQUAL      = 0x2e;
+    public static final byte HID_KEY_LEFTBRACE  = 0x2f; // Button [ {
+    public static final byte HID_KEY_RIGHTBRACE = 0x30; // Button ] }
+    public static final byte HID_KEY_BACKSLASH  = 0x31;
+    public static final byte HID_KEY_HASHTILDE  = 0x32; // Button # ~ (Huh? Never seen one.)
+    public static final byte HID_KEY_SEMICOLON  = 0x33; // Button ; :
+    public static final byte HID_KEY_APOSTROPHE = 0x34; // Button ' "
+    public static final byte HID_KEY_GRAVE      = 0x35; // Button ` ~ (For dummies: Quake console button)
+    public static final byte HID_KEY_COMMA      = 0x36; // Button , <
+    public static final byte HID_KEY_DOT        = 0x37; // Button . >
+    public static final byte HID_KEY_SLASH      = 0x38;
+    public static final byte HID_KEY_CAPSLOCK   = 0x39;
+
+    // Function keys
+    public static final byte HID_KEY_F1  = 0x3a;
+    public static final byte HID_KEY_F2  = 0x3b;
+    public static final byte HID_KEY_F3  = 0x3c;
+    public static final byte HID_KEY_F4  = 0x3d;
+    public static final byte HID_KEY_F5  = 0x3e;
+    public static final byte HID_KEY_F6  = 0x3f;
+    public static final byte HID_KEY_F7  = 0x40;
+    public static final byte HID_KEY_F8  = 0x41;
+    public static final byte HID_KEY_F9  = 0x42;
+    public static final byte HID_KEY_F10 = 0x43;
+    public static final byte HID_KEY_F11 = 0x44;
+    public static final byte HID_KEY_F12 = 0x45;
+
+    // Editing keys
+    public static final byte HID_KEY_SYSRQ      = 0x46; // Print Screen (REISUB, anyone?)
+    public static final byte HID_KEY_SCROLLLOCK = 0x47;
+    public static final byte HID_KEY_PAUSE      = 0x48;
+    public static final byte HID_KEY_INSERT     = 0x49;
+    public static final byte HID_KEY_HOME       = 0x4a;
+    public static final byte HID_KEY_PAGEUP     = 0x4b;
+    public static final byte HID_KEY_DELETE     = 0x4c;
+    public static final byte HID_KEY_END        = 0x4d;
+    public static final byte HID_KEY_PAGEDOWN   = 0x4e;
+    public static final byte HID_KEY_RIGHT      = 0x4f; // Right Arrow
+    public static final byte HID_KEY_LEFT       = 0x50; // Left Arrow
+    public static final byte HID_KEY_DOWN       = 0x51; // Down Arrow
+    public static final byte HID_KEY_UP         = 0x52; // Up Arrow
+
+    // Numpad keys
+    public static final byte HID_KEY_NUMLOCK    = 0x53;
+    public static final byte HID_KEY_KPSLASH    = 0x54;
+    public static final byte HID_KEY_KPASTERISK = 0x55; // Button *
+    public static final byte HID_KEY_KPMINUS    = 0x56;
+    public static final byte HID_KEY_KPPLUS     = 0x57;
+    public static final byte HID_KEY_KPENTER    = 0x58;
+    public static final byte HID_KEY_KP1        = 0x59;
+    public static final byte HID_KEY_KP2        = 0x5a;
+    public static final byte HID_KEY_KP3        = 0x5b;
+    public static final byte HID_KEY_KP4        = 0x5c;
+    public static final byte HID_KEY_KP5        = 0x5d;
+    public static final byte HID_KEY_KP6        = 0x5e;
+    public static final byte HID_KEY_KP7        = 0x5f;
+    public static final byte HID_KEY_KP8        = 0x60;
+    public static final byte HID_KEY_KP9        = 0x61;
+    public static final byte HID_KEY_KP0        = 0x62;
+    public static final byte HID_KEY_KPDOT      = 0x63;
+
+    // Non-US keyboard keys
+    public static final byte HID_KEY_102ND      = 0x64; // Non-US \ and |, also <> key on German-like keyboards
+    public static final byte HID_KEY_COMPOSE    = 0x65; // Compose key
+    public static final byte HID_KEY_POWER      = 0x66; // Poweroff key
+    public static final byte HID_KEY_KPEQUAL    = 0x67; // Keypad =
+
+    // Function keys (F13 - F24)
+    public static final byte HID_KEY_F13 = 0x68;
+    public static final byte HID_KEY_F14 = 0x69;
+    public static final byte HID_KEY_F15 = 0x6a;
+    public static final byte HID_KEY_F16 = 0x6b;
+    public static final byte HID_KEY_F17 = 0x6c;
+    public static final byte HID_KEY_F18 = 0x6d;
+    public static final byte HID_KEY_F19 = 0x6e;
+    public static final byte HID_KEY_F20 = 0x6f;
+    public static final byte HID_KEY_F21 = 0x70;
+    public static final byte HID_KEY_F22 = 0x71;
+    public static final byte HID_KEY_F23 = 0x72;
+    public static final byte HID_KEY_F24 = 0x73;
+
+    // Non-US Media/special keys
+    public static final byte HID_KEY_OPEN       = 0x74; // Execute
+    public static final byte HID_KEY_HELP       = 0x75;
+    public static final byte HID_KEY_PROPS      = 0x76; // Context menu key (Near right Alt) - Linux evdev naming
+    public static final byte HID_KEY_MENU       = 0x76; // ^ Context menu key too, different naming
+    public static final byte HID_KEY_FRONT      = 0x77; // Select key
+    public static final byte HID_KEY_STOP       = 0x78;
+    public static final byte HID_KEY_AGAIN      = 0x79;
+    public static final byte HID_KEY_UNDO       = 0x7a;
+    public static final byte HID_KEY_CUT        = 0x7b;
+    public static final byte HID_KEY_COPY       = 0x7c;
+    public static final byte HID_KEY_PASTE      = 0x7d;
+    public static final byte HID_KEY_FIND       = 0x7e;
+    public static final byte HID_KEY_MUTE       = 0x7f;
+    public static final byte HID_KEY_VOLUMEUP   = (byte)0x80;
+    public static final byte HID_KEY_VOLUMEDOWN = (byte)0x81;
+    public static final byte HID_KEY_KPCOMMA    = (byte)0x85; // Keypad Comma (Brazilian keypad period key?)
+
+    // International keys
+    public static final byte HID_KEY_RO               = (byte)0x87; // International1 (Japanese Ro, \\ key)
+    public static final byte HID_KEY_KATAKANAHIRAGANA = (byte)0x88; // International2 (Japanese Katakana/Hiragana, second key right to spacebar)
+    public static final byte HID_KEY_YEN              = (byte)0x89; // International3 (Japanese Yen)
+    public static final byte HID_KEY_HENKAN           = (byte)0x8a; // International4 (Japanese Henkan, key right to spacebar)
+    public static final byte HID_KEY_MUHENKAN         = (byte)0x8b; // International5 (Japanese Muhenkan, key left to spacebar)
+    public static final byte HID_KEY_KPJPCOMMA        = (byte)0x8c; // International6 (Japanese Comma? See HID spec...)
+
+    // LANG keys
+    public static final byte HID_KEY_HANGEUL        = (byte)0x90; // LANG1 (Korean Hangul/English toggle key)
+    public static final byte HID_KEY_HANJA          = (byte)0x91; // LANG2 (Korean Hanja control key)
+    public static final byte HID_KEY_KATAKANA       = (byte)0x92; // LANG3 (Japanese Katakana key)
+    public static final byte HID_KEY_HIRAGANA       = (byte)0x93; // LANG4 (Japanese Hiragana key)
+    public static final byte HID_KEY_ZENKAKUHANKAKU = (byte)0x94; // LANG5 (Japanese Zenkaku/Hankaku key)
+
+    // Additional keypad keys
+    public static final byte HID_KEY_KPLEFTPAREN  = (byte)0xb6; // Keypad (
+    public static final byte HID_KEY_KPRIGHTPAREN = (byte)0xb7; // Keypad )
+
+    // Modifier keys
+    public static final byte HID_KEY_LEFTCTRL   = (byte)0xe0;
+    public static final byte HID_KEY_LEFTSHIFT  = (byte)0xe1;
+    public static final byte HID_KEY_LEFTALT    = (byte)0xe2;
+    public static final byte HID_KEY_LEFTMETA   = (byte)0xe3; // The one with the ugly Windows icon
+    public static final byte HID_KEY_RIGHTCTRL  = (byte)0xe4;
+    public static final byte HID_KEY_RIGHTSHIFT = (byte)0xe5;
+    public static final byte HID_KEY_RIGHTALT   = (byte)0xe6;
+    public static final byte HID_KEY_RIGHTMETA  = (byte)0xe7;
+
+    // Media keys
+    public static final byte HID_KEY_MEDIA_PLAYPAUSE    = (byte)0xe8;
+    public static final byte HID_KEY_MEDIA_STOPCD       = (byte)0xe9;
+    public static final byte HID_KEY_MEDIA_PREVIOUSSONG = (byte)0xea;
+    public static final byte HID_KEY_MEDIA_NEXTSONG     = (byte)0xeb;
+    public static final byte HID_KEY_MEDIA_EJECTCD      = (byte)0xec;
+    public static final byte HID_KEY_MEDIA_VOLUMEUP     = (byte)0xed;
+    public static final byte HID_KEY_MEDIA_VOLUMEDOWN   = (byte)0xee;
+    public static final byte HID_KEY_MEDIA_MUTE         = (byte)0xef;
+    public static final byte HID_KEY_MEDIA_WWW          = (byte)0xf0;
+    public static final byte HID_KEY_MEDIA_BACK         = (byte)0xf1;
+    public static final byte HID_KEY_MEDIA_FORWARD      = (byte)0xf2;
+    public static final byte HID_KEY_MEDIA_STOP         = (byte)0xf3;
+    public static final byte HID_KEY_MEDIA_FIND         = (byte)0xf4;
+    public static final byte HID_KEY_MEDIA_SCROLLUP     = (byte)0xf5;
+    public static final byte HID_KEY_MEDIA_SCROLLDOWN   = (byte)0xf6;
+    public static final byte HID_KEY_MEDIA_EDIT         = (byte)0xf7;
+    public static final byte HID_KEY_MEDIA_SLEEP        = (byte)0xf8;
+    public static final byte HID_KEY_MEDIA_COFFEE       = (byte)0xf9;
+    public static final byte HID_KEY_MEDIA_REFRESH      = (byte)0xfa;
+    public static final byte HID_KEY_MEDIA_CALC         = (byte)0xfb;
+
+    public HIDKeyboard(RVVMMachine machine) {
+        if (machine.isValid()) {
+            this.machine = machine;
+            this.hid_keyboard = RVVMNative.hid_keyboard_init_auto(machine.getPtr());
+        } else {
+            this.machine = null;
+            this.hid_keyboard = 0;
+        }
+    }
+
+    public boolean isValid() {
+        return hid_keyboard != 0;
+    }
+
+    public void press(byte key) {
+        if (isValid()) {
+            RVVMNative.hid_keyboard_press(hid_keyboard, key);
+        }
+    }
+    public void release(byte key) {
+        if (isValid()) {
+            RVVMNative.hid_keyboard_release(hid_keyboard, key);
+        }
+    }
+}
diff --git a/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/HIDMouse.java b/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/HIDMouse.java
new file mode 100644
index 00000000..df4f1b98
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/HIDMouse.java
@@ -0,0 +1,65 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at https://mozilla.org/MPL/2.0/.
+ */
+
+package lekkit.rvvm;
+
+public class HIDMouse {
+    private final RVVMMachine machine;
+    private final long hid_mouse;
+
+    public static final byte HID_BTN_NONE = 0;
+    public static final byte HID_BTN_LEFT = 1;
+    public static final byte HID_BTN_RIGHT = 2;
+    public static final byte HID_BTN_MIDDLE = 4;
+
+    public static final int HID_SCROLL_UP = -1;
+    public static final int HID_SCROLL_DOWN = 1;
+
+    public HIDMouse(RVVMMachine machine) {
+        if (machine.isValid()) {
+            this.machine = machine;
+            this.hid_mouse = RVVMNative.hid_mouse_init_auto(machine.getPtr());
+        } else {
+            this.machine = null;
+            this.hid_mouse = 0;
+        }
+    }
+
+    public boolean isValid() {
+        return hid_mouse != 0;
+    }
+
+    public void move(int x, int y) {
+        if (isValid()) {
+            RVVMNative.hid_mouse_move(hid_mouse, x, y);
+        }
+    }
+    public void place(int x, int y) {
+        if (isValid()) {
+            RVVMNative.hid_mouse_place(hid_mouse, x, y);
+        }
+    }
+    public void resolution(int x, int y) {
+        if (isValid()) {
+            RVVMNative.hid_mouse_resolution(hid_mouse, x, y);
+        }
+    }
+    public void press(byte btns) {
+        if (isValid()) {
+            RVVMNative.hid_mouse_press(hid_mouse, btns);
+        }
+    }
+    public void release(byte btns) {
+        if (isValid()) {
+            RVVMNative.hid_mouse_release(hid_mouse, btns);
+        }
+    }
+    public void scroll(int offset) {
+        if (isValid()) {
+            RVVMNative.hid_mouse_scroll(hid_mouse, offset);
+        }
+    }
+}
diff --git a/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/I2CBus.java b/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/I2CBus.java
new file mode 100644
index 00000000..bae68e63
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/I2CBus.java
@@ -0,0 +1,22 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at https://mozilla.org/MPL/2.0/.
+ */
+
+package lekkit.rvvm;
+
+public class I2CBus {
+    protected final RVVMMachine machine;
+    protected final long i2c_bus;
+
+    public I2CBus(RVVMMachine machine) {
+        if (machine.isValid()) {
+            this.machine = machine;
+            i2c_bus = RVVMNative.i2c_bus_init_auto(machine.getPtr());
+        } else {
+            this.machine = null;
+            i2c_bus = 0;
+        }
+    }
+}
diff --git a/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/IGPIODevice.java b/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/IGPIODevice.java
new file mode 100644
index 00000000..6875097b
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/IGPIODevice.java
@@ -0,0 +1,18 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at https://mozilla.org/MPL/2.0/.
+ */
+
+package lekkit.rvvm;
+
+public interface IGPIODevice {
+
+    public boolean write_pins(int offset, int pins);
+
+    public int read_pins(int offset);
+
+    public boolean write_pins(int pins);
+
+    public int read_pins();
+}
diff --git a/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/IRemovableDevice.java b/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/IRemovableDevice.java
new file mode 100644
index 00000000..be3f20e7
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/IRemovableDevice.java
@@ -0,0 +1,14 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at https://mozilla.org/MPL/2.0/.
+ */
+
+package lekkit.rvvm;
+
+public interface IRemovableDevice {
+
+    public boolean isValid();
+
+    public void remove();
+}
diff --git a/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/MMIOBase.java b/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/MMIOBase.java
new file mode 100644
index 00000000..97d49b6a
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/MMIOBase.java
@@ -0,0 +1,27 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at https://mozilla.org/MPL/2.0/.
+ */
+
+package lekkit.rvvm;
+
+import java.nio.ByteBuffer;
+
+// TODO MMIO, PCI, I2C devices implementable in Java
+
+public class MMIOBase {
+    public long region_addr = 0;
+    public long region_size = 0;
+    public long min_op_size = 1;
+    public long max_op_size = 8;
+
+    ByteBuffer mapping;
+
+    public void remove() {}
+    public void update() {}
+    public void reset() {}
+
+    public boolean read(ByteBuffer data, long offset, byte size) { return true; }
+    public boolean write(ByteBuffer data, long offset, byte size) { return true;}
+}
diff --git a/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/MMIODevice.java b/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/MMIODevice.java
new file mode 100644
index 00000000..586475ee
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/MMIODevice.java
@@ -0,0 +1,35 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at https://mozilla.org/MPL/2.0/.
+ */
+
+package lekkit.rvvm;
+
+public abstract class MMIODevice implements IRemovableDevice {
+    private final RVVMMachine machine;
+    private long mmio_dev = 0;
+
+    public MMIODevice(RVVMMachine machine) {
+        this.machine = machine;
+    }
+
+    public RVVMMachine getMachine() {
+        return machine;
+    }
+
+    protected void setMMIOHandle(long mmio_dev) {
+        this.mmio_dev = mmio_dev;
+    }
+
+    public boolean isValid() {
+        return machine.isValid() && this.mmio_dev != 0;
+    }
+
+    public synchronized void remove() {
+        if (isValid()) {
+            RVVMNative.remove_mmio(this.mmio_dev);
+            mmio_dev = 0;
+        }
+    }
+}
diff --git a/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/MTDFlash.java b/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/MTDFlash.java
new file mode 100644
index 00000000..5c647c4c
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/MTDFlash.java
@@ -0,0 +1,16 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at https://mozilla.org/MPL/2.0/.
+ */
+
+package lekkit.rvvm;
+
+public class MTDFlash extends MMIODevice {
+    public MTDFlash(RVVMMachine machine, String imagePath, boolean rw) {
+        super(machine);
+        if (machine.isValid()) {
+            setMMIOHandle(RVVMNative.mtd_physmap_init_auto(machine.getPtr(), imagePath, rw));
+        }
+    }
+}
diff --git a/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/NS16550A.java b/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/NS16550A.java
new file mode 100644
index 00000000..886e21ec
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/NS16550A.java
@@ -0,0 +1,16 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at https://mozilla.org/MPL/2.0/.
+ */
+
+package lekkit.rvvm;
+
+public class NS16550A extends MMIODevice {
+    public NS16550A(RVVMMachine machine) {
+        super(machine);
+        if (machine.isValid()) {
+            setMMIOHandle(RVVMNative.ns16550a_init_auto(machine.getPtr()));
+        }
+    }
+}
diff --git a/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/NVMeDrive.java b/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/NVMeDrive.java
new file mode 100644
index 00000000..f2b9541b
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/NVMeDrive.java
@@ -0,0 +1,16 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at https://mozilla.org/MPL/2.0/.
+ */
+
+package lekkit.rvvm;
+
+public class NVMeDrive extends PCIDevice {
+    public NVMeDrive(RVVMMachine machine, String imagePath, boolean rw) {
+        super(machine);
+        if (machine.isValid()) {
+            setPCIHandle(RVVMNative.nvme_init_auto(machine.getPtr(), imagePath, rw));
+        }
+    }
+}
diff --git a/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/PCIBus.java b/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/PCIBus.java
new file mode 100644
index 00000000..cc180cb1
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/PCIBus.java
@@ -0,0 +1,22 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at https://mozilla.org/MPL/2.0/.
+ */
+
+package lekkit.rvvm;
+
+public class PCIBus {
+    protected final RVVMMachine machine;
+    protected final long pci_bus;
+
+    public PCIBus(RVVMMachine machine) {
+        if (machine.isValid()) {
+            this.machine = machine;
+            pci_bus = RVVMNative.pci_bus_init_auto(machine.getPtr());
+        } else {
+            this.machine = null;
+            pci_bus = 0;
+        }
+    }
+}
diff --git a/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/PCIDevice.java b/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/PCIDevice.java
new file mode 100644
index 00000000..f607bd41
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/PCIDevice.java
@@ -0,0 +1,35 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at https://mozilla.org/MPL/2.0/.
+ */
+
+package lekkit.rvvm;
+
+public abstract class PCIDevice implements IRemovableDevice {
+    private final RVVMMachine machine;
+    private long pci_dev;
+
+    public PCIDevice(RVVMMachine machine) {
+        this.machine = machine;
+    }
+
+    public RVVMMachine getMachine() {
+        return machine;
+    }
+
+    protected void setPCIHandle(long pci_dev) {
+        this.pci_dev = pci_dev;
+    }
+
+    public boolean isValid() {
+        return machine.isValid() && pci_dev != 0;
+    }
+
+    public synchronized void remove() {
+        if (isValid()) {
+            RVVMNative.pci_remove_device(pci_dev);
+            pci_dev = 0;
+        }
+    }
+}
diff --git a/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/PLIC.java b/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/PLIC.java
new file mode 100644
index 00000000..fffcd03a
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/PLIC.java
@@ -0,0 +1,22 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at https://mozilla.org/MPL/2.0/.
+ */
+
+package lekkit.rvvm;
+
+public class PLIC {
+    protected final RVVMMachine machine;
+    protected final long plic_ctx;
+
+    public PLIC(RVVMMachine machine) {
+        if (machine.isValid()) {
+            this.machine = machine;
+            plic_ctx = RVVMNative.plic_init_auto(machine.getPtr());
+        } else {
+            this.machine = null;
+            plic_ctx = 0;
+        }
+    }
+}
diff --git a/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/RTL8169.java b/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/RTL8169.java
new file mode 100644
index 00000000..84d22760
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/RTL8169.java
@@ -0,0 +1,16 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at https://mozilla.org/MPL/2.0/.
+ */
+
+package lekkit.rvvm;
+
+public class RTL8169 extends PCIDevice {
+    public RTL8169(RVVMMachine machine) {
+        super(machine);
+        if (machine.isValid()) {
+            setPCIHandle(RVVMNative.rtl8169_init_auto(machine.getPtr()));
+        }
+    }
+}
diff --git a/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/RVVMMachine.java b/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/RVVMMachine.java
new file mode 100644
index 00000000..dd00f159
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/RVVMMachine.java
@@ -0,0 +1,155 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at https://mozilla.org/MPL/2.0/.
+ */
+
+package lekkit.rvvm;
+
+import java.nio.ByteBuffer;
+
+public class RVVMMachine {
+    private long machine = 0;
+
+    public static final int RVVM_OPT_NONE = 0;
+    public static final int RVVM_OPT_JIT = 1;          // Enable JIT
+    public static final int RVVM_OPT_JIT_CACHE = 2;    // Amount of per-core JIT cache (In bytes)
+    public static final int RVVM_OPT_JIT_HARVARD = 3;  // No dirty code tracking, explicit ifence, slower
+    public static final int RVVM_OPT_VERBOSITY = 4;    // Verbosity level of internal logic
+    public static final int RVVM_OPT_HW_IMITATE = 5;   // Imitate traits or identity of physical hardware
+    public static final int RVVM_OPT_MAX_CPU_CENT = 6; // Max CPU load % per guest/host CPUs
+    public static final int RVVM_OPT_RESET_PC = 7;     // Physical jump address at reset, defaults to mem_base
+    public static final int RVVM_OPT_DTB_ADDR = 8;     // Pass DTB address if non-zero, omits FDT generation
+    public static final int RVVM_MAX_OPTS = 9;
+
+    public static final int RVVM_OPT_MEM_BASE = 0x80000001;   // Physical RAM base address
+    public static final int RVVM_OPT_MEM_SIZE = 0x80000002;   // Physical RAM size
+    public static final int RVVM_OPT_HART_COUNT = 0x80000003; // Amount of harts
+
+    public RVVMMachine(long mem_mb, int smp, boolean rv64) {
+        if (RVVMNative.isLoaded()) {
+            this.machine = RVVMNative.create_machine(RVVMNative.DEFAULT_MEMBASE, mem_mb << 20, smp, rv64);
+        }
+
+        if (isValid()) {
+            RVVMNative.clint_init_auto(machine);
+        }
+    }
+
+    public boolean isValid() {
+        return machine != 0;
+    }
+
+    public long getPtr() {
+        return machine;
+    }
+
+    public ByteBuffer getDmaBuffer(long addr, long size) {
+        if (isValid()) {
+            return RVVMNative.get_dma_buf(machine, addr, size);
+        }
+        return null;
+    }
+
+    public void setCmdline(String cmdline) {
+        if (isValid()) {
+            RVVMNative.set_cmdline(machine, cmdline);
+        }
+    }
+
+    public void appendCmdline(String cmdline) {
+        if (isValid()) {
+            RVVMNative.append_cmdline(machine, cmdline);
+        }
+    }
+
+    public long getOption(int opt) {
+        if (isValid()) {
+            return RVVMNative.get_opt(machine, opt);
+        }
+        return 0;
+    }
+
+    public void setOption(int opt, long val) {
+        if (isValid()) {
+            RVVMNative.set_opt(machine, opt, val);
+        }
+    }
+
+    public boolean loadBootrom(String path) {
+        if (isValid()) {
+            return RVVMNative.load_bootrom(machine, path);
+        }
+        return false;
+    }
+
+    public boolean loadKernel(String path) {
+        if (isValid()) {
+            return RVVMNative.load_kernel(machine, path);
+        }
+        return false;
+    }
+
+    public boolean loadDeviceTree(String path) {
+        if (isValid()) {
+            return RVVMNative.load_dtb(machine, path);
+        }
+        return false;
+    }
+
+    public boolean dumpDeviceTree(String path) {
+        if (isValid()) {
+            return RVVMNative.dump_dtb(machine, path);
+        }
+        return false;
+    }
+
+    public boolean start() {
+        if (isValid()) {
+            return RVVMNative.start_machine(machine);
+        }
+        return false;
+    }
+
+    public boolean reset() {
+        if (isValid()) {
+            return RVVMNative.reset_machine(machine, true);
+        }
+        return false;
+    }
+
+    public boolean poweroff() {
+        if (isValid()) {
+            return RVVMNative.reset_machine(machine, false);
+        }
+        return false;
+    }
+
+    public boolean pause() {
+        if (isValid()) {
+            return RVVMNative.pause_machine(machine);
+        }
+        return false;
+    }
+
+    public boolean isPowered() {
+        if (isValid()) {
+            return RVVMNative.machine_powered(machine);
+        }
+        return false;
+    }
+
+    // Beware to drop all references beforehand
+    public synchronized void free() {
+        if (isValid()) {
+            RVVMNative.free_machine(machine);
+            machine = 0;
+        }
+    }
+
+    // Should not be relied upon
+    @Override
+    protected synchronized void finalize() {
+        free();
+    }
+}
diff --git a/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/RVVMNative.java b/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/RVVMNative.java
new file mode 100644
index 00000000..0637e332
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/RVVMNative.java
@@ -0,0 +1,117 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at https://mozilla.org/MPL/2.0/.
+ */
+
+package lekkit.rvvm;
+
+import java.nio.ByteBuffer;
+
+// Regenerate C prototypes: $ javac -h . RVVMNative.java
+
+public class RVVMNative {
+    // Do not crash the JVM if we failed to load native lib
+    public static boolean loaded = false;
+
+    private static void checkABI() {
+        int abi = get_abi_version();
+        if (abi == 7) {
+            loaded = true;
+        } else {
+            System.out.println("ERROR: Invalid librvvm ABI version: " + Integer.toString(abi));
+        }
+    }
+
+    // Manually load librvvm
+    public static boolean loadLib(String path) {
+        if (loaded) return true;
+        try {
+            System.load(path);
+            checkABI();
+        } catch (Throwable e) {
+            System.out.println("ERROR: Failed to load librvvm: " + e.toString());
+        }
+        return loaded;
+    }
+
+    static {
+        try {
+            System.loadLibrary("rvvm");
+            checkABI();
+        } catch (Throwable e) {
+            System.out.println("INFO: Failed to load system-wide librvvm: " + e.toString());
+        }
+    }
+
+    public static boolean isLoaded() {
+        return loaded;
+    }
+
+    public static final long DEFAULT_MEMBASE = 0x80000000L;
+
+    public static native int get_abi_version();
+
+    // Common RVVM API functions
+    public static native long       create_machine(long mem_base, long mem_size, int smp, boolean rv64);
+    public static native ByteBuffer get_dma_buf(long machine, long addr, long size);
+    public static native long       get_plic(long machine);
+    public static native void       set_plic(long machine, long plic);
+    public static native long       get_pci_bus(long machine);
+    public static native void       set_pci_bus(long machine, long pci_bus);
+    public static native long       get_i2c_bus(long machine);
+    public static native void       set_i2c_bus(long machine, long i2c_bus);
+    public static native void       set_cmdline(long machine, String cmdline);
+    public static native void       append_cmdline(long machine, String cmdline);
+    public static native long       get_opt(long machine, int opt);
+    public static native void       set_opt(long machine, int opt, long val);
+    public static native boolean    load_bootrom(long machine, String path);
+    public static native boolean    load_kernel(long machine, String path);
+    public static native boolean    load_dtb(long machine, String path);
+    public static native boolean    dump_dtb(long machine, String path);
+    public static native boolean    start_machine(long machine);
+    public static native boolean    pause_machine(long machine);
+    public static native boolean    reset_machine(long machine, boolean reset);
+    public static native boolean    machine_powered(long machine);
+    public static native void       free_machine(long machine);
+    public static native long       mmio_zone_auto(long machine, long addr, long size);
+    public static native void       remove_mmio(long mmio_dev);
+    public static native void       run_eventloop();
+
+    // TODO: MMIO API
+    //public static native int        attach_mmio(long machine, MMIOBase mmio);
+
+    // Devices
+    public static native void clint_init_auto(long machine);
+    public static native long plic_init_auto(long machine);
+    public static native long pci_bus_init_auto(long machine);
+    public static native long i2c_bus_init_auto(long machine);
+    public static native long ns16550a_init_auto(long machine);
+    public static native long rtc_goldfish_init_auto(long machine);
+    public static native long syscon_init_auto(long machine);
+    public static native long rtl8169_init_auto(long machine);
+    public static native long nvme_init_auto(long machine, String image_path, boolean rw);
+    public static native long mtd_physmap_init_auto(long machine, String image_path, boolean rw);
+    public static native long framebuffer_init_auto(long machine, ByteBuffer fb, int x, int y, int bpp);
+    public static native long hid_mouse_init_auto(long machine);
+    public static native long hid_keyboard_init_auto(long machine);
+
+    public static native long    gpio_dev_create();
+    public static native void    gpio_dev_free(long gpio);
+    public static native int     gpio_read_pins(long gpio, int off);
+    public static native boolean gpio_write_pins(long gpio, int off, int pins);
+
+    public static native long    gpio_sifive_init_auto(long machine, long gpio);
+
+    public static native void pci_remove_device(long dev);
+
+    public static native void hid_mouse_resolution(long mouse, int x, int y);
+    public static native void hid_mouse_place(long mouse, int x, int y);
+    public static native void hid_mouse_move(long mouse, int x, int y);
+    public static native void hid_mouse_press(long mouse, byte btns);
+    public static native void hid_mouse_release(long mouse, byte btns);
+    public static native void hid_mouse_scroll(long mouse, int offset);
+
+    public static native void hid_keyboard_press(long kb, byte key);
+    public static native void hid_keyboard_release(long kb, byte key);
+}
diff --git a/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/SiFiveGPIO.java b/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/SiFiveGPIO.java
new file mode 100644
index 00000000..fb61f084
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/SiFiveGPIO.java
@@ -0,0 +1,47 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at https://mozilla.org/MPL/2.0/.
+ */
+
+package lekkit.rvvm;
+
+public class SiFiveGPIO extends MMIODevice implements IGPIODevice {
+    private long gpio_dev = 0;
+
+    public SiFiveGPIO(RVVMMachine machine) {
+        super(machine);
+        if (machine.isValid()) {
+            this.gpio_dev = RVVMNative.gpio_dev_create();
+
+            setMMIOHandle(RVVMNative.gpio_sifive_init_auto(getMachine().getPtr(), this.gpio_dev));
+
+            if (!this.isValid() && this.gpio_dev != 0) {
+                RVVMNative.gpio_dev_free(gpio_dev);
+                this.gpio_dev = 0;
+            }
+        }
+    }
+
+    public boolean write_pins(int offset, int pins) {
+        if (isValid()) {
+            return RVVMNative.gpio_write_pins(gpio_dev, offset, pins);
+        }
+        return false;
+    }
+
+    public int read_pins(int offset) {
+        if (isValid()) {
+            return RVVMNative.gpio_read_pins(gpio_dev, offset);
+        }
+        return 0;
+    }
+
+    public boolean write_pins(int pins) {
+        return write_pins(0, pins);
+    }
+
+    public int read_pins() {
+        return read_pins(0);
+    }
+}
diff --git a/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/Syscon.java b/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/Syscon.java
new file mode 100644
index 00000000..d913a35b
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/bindings/jni/lekkit/rvvm/Syscon.java
@@ -0,0 +1,16 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at https://mozilla.org/MPL/2.0/.
+ */
+
+package lekkit.rvvm;
+
+public class Syscon extends MMIODevice {
+    public Syscon(RVVMMachine machine) {
+        super(machine);
+        if (machine.isValid()) {
+            setMMIOHandle(RVVMNative.syscon_init_auto(machine.getPtr()));
+        }
+    }
+}
diff --git a/app/src/main/java/libengine/RVVM/src/bindings/jni/rvvm_jni.c b/app/src/main/java/libengine/RVVM/src/bindings/jni/rvvm_jni.c
new file mode 100644
index 00000000..2dad9f1c
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/bindings/jni/rvvm_jni.c
@@ -0,0 +1,487 @@
+#include "tiny-jni.h"
+#include "../../compiler.h"
+#include "../../utils.h"
+#include "../../spinlock.h"
+
+#include "../../rvvmlib.h"
+
+#include "../../devices/clint.h"
+#include "../../devices/plic.h"
+#include "../../devices/pci-bus.h"
+#include "../../devices/i2c-oc.h"
+#include "../../devices/ns16550a.h"
+#include "../../devices/rtc-goldfish.h"
+#include "../../devices/syscon.h"
+#include "../../devices/rtl8169.h"
+#include "../../devices/nvme.h"
+#include "../../devices/mtd-physmap.h"
+#include "../../devices/framebuffer.h"
+#include "../../devices/hid_api.h"
+#include "../../devices/gpio-sifive.h"
+
+PUSH_OPTIMIZATION_SIZE
+
+JNIEXPORT jint JNICALL Java_lekkit_rvvm_RVVMNative_get_1abi_1version(JNIEnv* env, jclass class)
+{
+    UNUSED(env); UNUSED(class);
+    return RVVM_ABI_VERSION;
+}
+
+JNIEXPORT jlong JNICALL Java_lekkit_rvvm_RVVMNative_create_1machine(JNIEnv* env, jclass class, jlong mem_base, jlong mem_size, jint smp, jboolean rv64)
+{
+    UNUSED(env); UNUSED(class);
+    return (size_t)rvvm_create_machine(mem_base, mem_size, smp, rv64);
+}
+
+JNIEXPORT jobject JNICALL Java_lekkit_rvvm_RVVMNative_get_1dma_1buf(JNIEnv* env, jclass class, jlong machine, jlong addr, jlong size)
+{
+    void* ptr = rvvm_get_dma_ptr((rvvm_machine_t*)(size_t)machine, addr, size);
+    UNUSED(class);
+    if (ptr == NULL) return NULL;
+    return (*env)->NewDirectByteBuffer(env, ptr, size);
+}
+
+JNIEXPORT jlong JNICALL Java_lekkit_rvvm_RVVMNative_get_1plic(JNIEnv* env, jclass class, jlong machine)
+{
+    UNUSED(env); UNUSED(class);
+    return (size_t)rvvm_get_plic((rvvm_machine_t*)(size_t)machine);
+}
+
+JNIEXPORT void JNICALL Java_lekkit_rvvm_RVVMNative_set_1plic(JNIEnv* env, jclass class, jlong machine, jlong plic)
+{
+    UNUSED(env); UNUSED(class);
+    rvvm_set_plic((rvvm_machine_t*)(size_t)machine, (plic_ctx_t*)(size_t)plic);
+}
+
+JNIEXPORT jlong JNICALL Java_lekkit_rvvm_RVVMNative_get_1pci_1bus(JNIEnv* env, jclass class, jlong machine)
+{
+    UNUSED(env); UNUSED(class);
+    return (size_t)rvvm_get_pci_bus((rvvm_machine_t*)(size_t)machine);
+}
+
+JNIEXPORT void JNICALL Java_lekkit_rvvm_RVVMNative_set_1pci_1bus(JNIEnv* env, jclass class, jlong machine, jlong pci_bus)
+{
+    UNUSED(env); UNUSED(class);
+    rvvm_set_pci_bus((rvvm_machine_t*)(size_t)machine, (pci_bus_t*)(size_t)pci_bus);
+}
+
+JNIEXPORT jlong JNICALL Java_lekkit_rvvm_RVVMNative_get_1i2c_1bus(JNIEnv* env, jclass class, jlong machine)
+{
+    UNUSED(env); UNUSED(class);
+    return (size_t)rvvm_get_i2c_bus((rvvm_machine_t*)(size_t)machine);
+}
+
+JNIEXPORT void JNICALL Java_lekkit_rvvm_RVVMNative_set_1i2c_1bus(JNIEnv* env, jclass class, jlong machine, jlong i2c_bus)
+{
+    UNUSED(env); UNUSED(class);
+    rvvm_set_i2c_bus((rvvm_machine_t*)(size_t)machine, (i2c_bus_t*)(size_t)i2c_bus);
+}
+
+JNIEXPORT void JNICALL Java_lekkit_rvvm_RVVMNative_set_1cmdline(JNIEnv* env, jclass class, jlong machine, jstring cmdline)
+{
+    const char* u8_cmdline = (*env)->GetStringUTFChars(env, cmdline, NULL);
+    UNUSED(class);
+    rvvm_set_cmdline((rvvm_machine_t*)(size_t)machine, u8_cmdline);
+    (*env)->ReleaseStringUTFChars(env, cmdline, u8_cmdline);
+}
+
+JNIEXPORT void JNICALL Java_lekkit_rvvm_RVVMNative_append_1cmdline(JNIEnv* env, jclass class, jlong machine, jstring cmdline)
+{
+    const char* u8_cmdline = (*env)->GetStringUTFChars(env, cmdline, NULL);
+    UNUSED(class);
+    rvvm_append_cmdline((rvvm_machine_t*)(size_t)machine, u8_cmdline);
+    (*env)->ReleaseStringUTFChars(env, cmdline, u8_cmdline);
+}
+
+JNIEXPORT jlong JNICALL Java_lekkit_rvvm_RVVMNative_get_1opt(JNIEnv* env, jclass class, jlong machine, jint opt)
+{
+    UNUSED(env); UNUSED(class);
+    return rvvm_get_opt((rvvm_machine_t*)(size_t)machine, (uint32_t)opt);
+}
+
+JNIEXPORT void JNICALL Java_lekkit_rvvm_RVVMNative_set_1opt(JNIEnv* env, jclass class, jlong machine, jint opt, jlong val)
+{
+    UNUSED(env); UNUSED(class);
+    rvvm_set_opt((rvvm_machine_t*)(size_t)machine, (uint32_t)opt, val);
+}
+
+JNIEXPORT jboolean JNICALL Java_lekkit_rvvm_RVVMNative_load_1bootrom(JNIEnv* env, jclass class, jlong machine, jstring path)
+{
+    const char* u8_path = (*env)->GetStringUTFChars(env, path, NULL);
+    bool ret = rvvm_load_bootrom((rvvm_machine_t*)(size_t)machine, u8_path);
+    UNUSED(class);
+    (*env)->ReleaseStringUTFChars(env, path, u8_path);
+    return ret;
+}
+
+JNIEXPORT jboolean JNICALL Java_lekkit_rvvm_RVVMNative_load_1kernel(JNIEnv* env, jclass class, jlong machine, jstring path)
+{
+    const char* u8_path = (*env)->GetStringUTFChars(env, path, NULL);
+    bool ret = rvvm_load_kernel((rvvm_machine_t*)(size_t)machine, u8_path);
+    UNUSED(class);
+    (*env)->ReleaseStringUTFChars(env, path, u8_path);
+    return ret;
+}
+
+JNIEXPORT jboolean JNICALL Java_lekkit_rvvm_RVVMNative_load_1dtb(JNIEnv* env, jclass class, jlong machine, jstring path)
+{
+    const char* u8_path = (*env)->GetStringUTFChars(env, path, NULL);
+    bool ret = rvvm_load_dtb((rvvm_machine_t*)(size_t)machine, u8_path);
+    UNUSED(class);
+    (*env)->ReleaseStringUTFChars(env, path, u8_path);
+    return ret;
+}
+
+JNIEXPORT jboolean JNICALL Java_lekkit_rvvm_RVVMNative_dump_1dtb(JNIEnv* env, jclass class, jlong machine, jstring path)
+{
+    const char* u8_path = (*env)->GetStringUTFChars(env, path, NULL);
+    bool ret = rvvm_dump_dtb((rvvm_machine_t*)(size_t)machine, u8_path);
+    UNUSED(class);
+    (*env)->ReleaseStringUTFChars(env, path, u8_path);
+    return ret;
+}
+
+JNIEXPORT jboolean JNICALL Java_lekkit_rvvm_RVVMNative_start_1machine(JNIEnv* env, jclass class, jlong machine)
+{
+    UNUSED(env); UNUSED(class);
+    return rvvm_start_machine((rvvm_machine_t*)(size_t)machine);
+}
+
+JNIEXPORT jboolean JNICALL Java_lekkit_rvvm_RVVMNative_pause_1machine(JNIEnv* env, jclass class, jlong machine)
+{
+    UNUSED(env); UNUSED(class);
+    return rvvm_pause_machine((rvvm_machine_t*)(size_t)machine);
+}
+
+JNIEXPORT jboolean JNICALL Java_lekkit_rvvm_RVVMNative_reset_1machine(JNIEnv* env, jclass class, jlong machine, jboolean reset)
+{
+    UNUSED(env); UNUSED(class);
+    rvvm_reset_machine((rvvm_machine_t*)(size_t)machine, reset);
+    return true;
+}
+
+JNIEXPORT jboolean JNICALL Java_lekkit_rvvm_RVVMNative_machine_1powered(JNIEnv* env, jclass class, jlong machine)
+{
+    UNUSED(env); UNUSED(class);
+    return rvvm_machine_powered((rvvm_machine_t*)(size_t)machine);
+}
+
+JNIEXPORT void JNICALL Java_lekkit_rvvm_RVVMNative_free_1machine(JNIEnv* env, jclass class, jlong machine)
+{
+    UNUSED(env); UNUSED(class);
+    rvvm_free_machine((rvvm_machine_t*)(size_t)machine);
+}
+
+JNIEXPORT jlong JNICALL Java_lekkit_rvvm_RVVMNative_mmio_1zone_1auto(JNIEnv* env, jclass class, jlong machine, jlong addr, jlong size)
+{
+    UNUSED(env); UNUSED(class);
+    return rvvm_mmio_zone_auto((rvvm_machine_t*)(size_t)machine, addr, size);
+}
+
+#if 0
+typedef struct {
+    JNIEnv* env;
+    jobject obj;
+    jmethodID read;
+    jmethodID write;
+    jmethodID update;
+    jmethodID reset;
+    jmethodID remove;
+} jni_mmio_data_t;
+
+static bool jni_mmio_read(rvvm_mmio_dev_t* dev, void* dest, size_t offset, uint8_t size)
+{
+    jni_mmio_data_t* jni_data = dev->data;
+    memset(dest, 0, size);
+    bool ret = (*env)->CallBoolMethod(env, jni_data->obj, );
+}
+
+static rvvm_mmio_desc_t jni_mmio_desc = {
+    .name = "jni_mmio",
+    //.update =
+};
+
+JNIEXPORT jint JNICALL Java_lekkit_rvvm_RVVMNative_attach_1mmio(JNIEnv* env, jclass class, jlong machine, jobject mmio_obj)
+{
+    rvvm_mmio_dev_t* mmio = safe_new_obj(rvvm_mmio_dev_t);
+    jni_mmio_data_t jni_data = safe_new_obj(jni_mmio_data_t);
+    mmio->data = jni_data;
+    class = (*env)->GetObjectClass(env, mmio_obj);
+    jni_data->env = env;
+    jni_data->obj = (*env)->NewGlobalRef(mmio_obj);
+    jni_data->read = (*env)->GetMethodID(env, class, "read", "(Ljava/nio/ByteBuffer;JB)Z");
+    jni_data->write = (*env)->GetMethodID(env, class, "write", "(Ljava/nio/ByteBuffer;JB)Z");
+    jni_data->update = (*env)->GetMethodID(env, class, "update", "()V");
+    jni_data->remove = (*env)->GetMethodID(env, class, "remove", "()V");
+    jni_data->reset = (*env)->GetMethodID(env, class, "reset", "()V");
+
+
+    rvvm_detach_mmio((rvvm_machine_t*)(size_t)machine, handle, cleanup);
+}
+#endif
+
+JNIEXPORT void JNICALL Java_lekkit_rvvm_RVVMNative_remove_1mmio(JNIEnv* env, jclass class, jlong mmio_dev)
+{
+    UNUSED(env); UNUSED(class);
+    rvvm_remove_mmio((rvvm_mmio_dev_t*)(size_t)mmio_dev);
+}
+
+JNIEXPORT void JNICALL Java_lekkit_rvvm_RVVMNative_run_1eventloop(JNIEnv* env, jclass class)
+{
+    UNUSED(env); UNUSED(class);
+    rvvm_run_eventloop();
+}
+
+JNIEXPORT void JNICALL Java_lekkit_rvvm_RVVMNative_clint_1init_1auto(JNIEnv* env, jclass class, jlong machine)
+{
+    UNUSED(env); UNUSED(class);
+    clint_init_auto((rvvm_machine_t*)(size_t)machine);
+}
+
+JNIEXPORT jlong JNICALL Java_lekkit_rvvm_RVVMNative_plic_1init_1auto(JNIEnv* env, jclass class, jlong machine)
+{
+    UNUSED(env); UNUSED(class);
+    return (size_t)plic_init_auto((rvvm_machine_t*)(size_t)machine);
+}
+
+JNIEXPORT jlong JNICALL Java_lekkit_rvvm_RVVMNative_pci_1bus_1init_1auto(JNIEnv* env, jclass class, jlong machine)
+{
+    UNUSED(env); UNUSED(class);
+    return (size_t)pci_bus_init_auto((rvvm_machine_t*)(size_t)machine);
+}
+
+JNIEXPORT jlong JNICALL Java_lekkit_rvvm_RVVMNative_i2c_1bus_1init_1auto(JNIEnv* env, jclass class, jlong machine)
+{
+    UNUSED(env); UNUSED(class);
+    return (size_t)i2c_oc_init_auto((rvvm_machine_t*)(size_t)machine);
+}
+
+JNIEXPORT jlong JNICALL Java_lekkit_rvvm_RVVMNative_ns16550a_1init_1auto(JNIEnv* env, jclass class, jlong machine)
+{
+    UNUSED(env); UNUSED(class);
+    return (size_t)ns16550a_init_term_auto((rvvm_machine_t*)(size_t)machine);
+}
+
+JNIEXPORT jlong JNICALL Java_lekkit_rvvm_RVVMNative_rtc_1goldfish_1init_1auto(JNIEnv* env, jclass class, jlong machine)
+{
+    UNUSED(env); UNUSED(class);
+    return (size_t)rtc_goldfish_init_auto((rvvm_machine_t*)(size_t)machine);
+}
+
+JNIEXPORT jlong JNICALL Java_lekkit_rvvm_RVVMNative_syscon_1init_1auto(JNIEnv* env, jclass class, jlong machine)
+{
+    UNUSED(env); UNUSED(class);
+    return (size_t)syscon_init_auto((rvvm_machine_t*)(size_t)machine);
+}
+
+JNIEXPORT jlong JNICALL Java_lekkit_rvvm_RVVMNative_rtl8169_1init_1auto(JNIEnv* env, jclass class, jlong machine)
+{
+    UNUSED(env); UNUSED(class);
+    return (size_t)rtl8169_init_auto((rvvm_machine_t*)(size_t)machine);
+}
+
+JNIEXPORT jlong JNICALL Java_lekkit_rvvm_RVVMNative_nvme_1init_1auto(JNIEnv* env, jclass class, jlong machine, jstring path, jboolean rw)
+{
+    const char* u8_path = (*env)->GetStringUTFChars(env, path, NULL);
+    pci_dev_t* ret = nvme_init_auto((rvvm_machine_t*)(size_t)machine, u8_path, rw);
+    UNUSED(class);
+    (*env)->ReleaseStringUTFChars(env, path, u8_path);
+    return (size_t)ret;
+}
+
+JNIEXPORT jlong JNICALL Java_lekkit_rvvm_RVVMNative_mtd_1physmap_1init_1auto(JNIEnv* env, jclass class, jlong machine, jstring path, jboolean rw)
+{
+    const char* u8_path = (*env)->GetStringUTFChars(env, path, NULL);
+    rvvm_mmio_dev_t* mmio = mtd_physmap_init_auto((rvvm_machine_t*)(size_t)machine, u8_path, rw);
+    UNUSED(class);
+    (*env)->ReleaseStringUTFChars(env, path, u8_path);
+    return (size_t)mmio;
+}
+
+// Share an object reference across threads safely
+typedef struct {
+    JavaVM* jvm;
+    jobject glob_ref;
+    spinlock_t lock;
+    bool attached;
+} jni_glob_objref_t;
+
+static jni_glob_objref_t* jni_create_glob_ref(JNIEnv* env, jobject local_obj)
+{
+    jni_glob_objref_t* ref = safe_new_obj(jni_glob_objref_t);
+    (*env)->GetJavaVM(env, &ref->jvm);
+    ref->glob_ref = (*env)->NewGlobalRef(env, local_obj);
+    return ref;
+}
+
+static JNIEnv* jni_attach_thread(jni_glob_objref_t* ref)
+{
+    JNIEnv* env = NULL;
+    JavaVMAttachArgs args = { .version = JNI_VERSION_1_6, .name = "librvvm JNI Thread", };
+    spin_lock(&ref->lock);
+    if ((*ref->jvm)->GetEnv(ref->jvm, (void**)&env, JNI_VERSION_1_6) == JNI_OK) return env;
+    if ((*ref->jvm)->AttachCurrentThread(ref->jvm, (void**)&env, &args)) {
+        rvvm_warn("JNI AttachCurrentThread failed!");
+        return NULL;
+    }
+    ref->attached = true;
+    return env;
+}
+
+static void jni_dettach_thread(jni_glob_objref_t* ref)
+{
+    if (ref->attached) {
+        (*ref->jvm)->DetachCurrentThread(ref->jvm);
+        ref->attached = false;
+    }
+    spin_unlock(&ref->lock);
+}
+
+static void jni_free_glob_ref(jni_glob_objref_t* ref)
+{
+    JNIEnv* env = jni_attach_thread(ref);
+    if (env) (*env)->DeleteGlobalRef(env, ref->glob_ref);
+    jni_dettach_thread(ref);
+    free(ref);
+}
+
+// Clean up the ByteBuffer reference
+static void jni_framebuffer_remove(rvvm_mmio_dev_t* dev)
+{
+    jni_glob_objref_t* ref = dev->data;
+    jni_free_glob_ref(ref);
+}
+
+static rvvm_mmio_type_t jni_fb_cleanup_desc = {
+    .remove = jni_framebuffer_remove,
+};
+
+JNIEXPORT jlong JNICALL Java_lekkit_rvvm_RVVMNative_framebuffer_1init_1auto(JNIEnv* env, jclass class, jlong machine, jobject fb, jint x, jint y, jint bpp)
+{
+    size_t buf_size = (*env)->GetDirectBufferCapacity(env, fb);
+    fb_ctx_t fb_ctx = {
+        .buffer = (*env)->GetDirectBufferAddress(env, fb),
+        .format = rgb_format_from_bpp(bpp),
+        .width = x,
+        .height = y,
+    };
+    rvvm_mmio_dev_t jni_fb_cleaup = {
+        .type = &jni_fb_cleanup_desc,
+        .data = jni_create_glob_ref(env, fb),
+    };
+    UNUSED(class);
+    if (fb_ctx.buffer && framebuffer_size(&fb_ctx) == buf_size) {
+        rvvm_mmio_dev_t* mmio = framebuffer_init_auto((rvvm_machine_t*)(size_t)machine, &fb_ctx);
+        if (mmio != NULL) rvvm_attach_mmio((rvvm_machine_t*)(size_t)machine, &jni_fb_cleaup);
+        return (size_t)mmio;
+    } else {
+        rvvm_warn("Invalid ByteBuffer passed to JNI framebuffer_init_auto()");
+        return 0;
+    }
+}
+
+JNIEXPORT jlong JNICALL Java_lekkit_rvvm_RVVMNative_hid_1mouse_1init_1auto(JNIEnv* env, jclass class, jlong machine)
+{
+    UNUSED(env); UNUSED(class);
+    return (size_t)hid_mouse_init_auto((rvvm_machine_t*)(size_t)machine);
+}
+
+JNIEXPORT jlong JNICALL Java_lekkit_rvvm_RVVMNative_hid_1keyboard_1init_1auto(JNIEnv* env, jclass class, jlong machine)
+{
+    UNUSED(env); UNUSED(class);
+    return (size_t)hid_keyboard_init_auto((rvvm_machine_t*)(size_t)machine);
+}
+
+JNIEXPORT void JNICALL Java_lekkit_rvvm_RVVMNative_pci_1remove_1device(JNIEnv* env, jclass class, jlong pci_dev)
+{
+    UNUSED(env); UNUSED(class);
+    pci_remove_device((pci_dev_t*)(size_t)pci_dev);
+}
+
+static void jni_gpio_remove(rvvm_gpio_dev_t* gpio)
+{
+    free(gpio);
+}
+
+JNIEXPORT jlong JNICALL Java_lekkit_rvvm_RVVMNative_gpio_1dev_1create(JNIEnv* env, jclass class)
+{
+    rvvm_gpio_dev_t* gpio = safe_new_obj(rvvm_gpio_dev_t);
+    gpio->remove = jni_gpio_remove;
+    UNUSED(env); UNUSED(class);
+    return (size_t)gpio;
+}
+
+JNIEXPORT void JNICALL Java_lekkit_rvvm_RVVMNative_gpio_1dev_1free(JNIEnv* env, jclass class, jlong gpio)
+{
+    void* ptr = (void*)(size_t)gpio;
+    UNUSED(env); UNUSED(class);
+    free(ptr);
+}
+
+JNIEXPORT jint JNICALL Java_lekkit_rvvm_RVVMNative_gpio_1read_1pins(JNIEnv* env, jclass class, jlong gpio, jint off)
+{
+    UNUSED(env); UNUSED(class);
+    return gpio_read_pins((rvvm_gpio_dev_t*)(size_t)gpio, off);
+}
+
+JNIEXPORT jboolean JNICALL Java_lekkit_rvvm_RVVMNative_gpio_1write_1pins(JNIEnv* env, jclass class, jlong gpio, jint off, jint pins)
+{
+    UNUSED(env); UNUSED(class);
+    return gpio_write_pins((rvvm_gpio_dev_t*)(size_t)gpio, off, pins);
+}
+
+JNIEXPORT jlong JNICALL Java_lekkit_rvvm_RVVMNative_gpio_1sifive_1init_1auto(JNIEnv* env, jclass class, jlong machine, jlong gpio)
+{
+    UNUSED(env); UNUSED(class);
+    return (size_t)gpio_sifive_init_auto((rvvm_machine_t*)(size_t)machine, (rvvm_gpio_dev_t*)(size_t)gpio);
+}
+
+JNIEXPORT void JNICALL Java_lekkit_rvvm_RVVMNative_hid_1mouse_1resolution(JNIEnv* env, jclass class, jlong mice, jint x, jint y)
+{
+    UNUSED(env); UNUSED(class);
+    hid_mouse_resolution((hid_mouse_t*)(size_t)mice, x, y);
+}
+
+JNIEXPORT void JNICALL Java_lekkit_rvvm_RVVMNative_hid_1mouse_1place(JNIEnv* env, jclass class, jlong mice, jint x, jint y)
+{
+    UNUSED(env); UNUSED(class);
+    hid_mouse_place((hid_mouse_t*)(size_t)mice, x, y);
+}
+
+JNIEXPORT void JNICALL Java_lekkit_rvvm_RVVMNative_hid_1mouse_1move(JNIEnv* env, jclass class, jlong mice, jint x, jint y)
+{
+    UNUSED(env); UNUSED(class);
+    hid_mouse_move((hid_mouse_t*)(size_t)mice, x, y);
+}
+
+JNIEXPORT void JNICALL Java_lekkit_rvvm_RVVMNative_hid_1mouse_1press(JNIEnv* env, jclass class, jlong mice, jbyte btns)
+{
+    UNUSED(env); UNUSED(class);
+    hid_mouse_press((hid_mouse_t*)(size_t)mice, btns);
+}
+
+JNIEXPORT void JNICALL Java_lekkit_rvvm_RVVMNative_hid_1mouse_1release(JNIEnv* env, jclass class, jlong mice, jbyte btns)
+{
+    UNUSED(env); UNUSED(class);
+    hid_mouse_release((hid_mouse_t*)(size_t)mice, btns);
+}
+
+JNIEXPORT void JNICALL Java_lekkit_rvvm_RVVMNative_hid_1mouse_1scroll(JNIEnv* env, jclass class, jlong mice, jint offset)
+{
+    UNUSED(env); UNUSED(class);
+    hid_mouse_scroll((hid_mouse_t*)(size_t)mice, offset);
+}
+
+JNIEXPORT void JNICALL Java_lekkit_rvvm_RVVMNative_hid_1keyboard_1press(JNIEnv* env, jclass class, jlong kb, jbyte key)
+{
+    UNUSED(env); UNUSED(class);
+    hid_keyboard_press((hid_keyboard_t*)(size_t)kb, key);
+}
+
+JNIEXPORT void JNICALL Java_lekkit_rvvm_RVVMNative_hid_1keyboard_1release(JNIEnv* env, jclass class, jlong kb, jbyte key)
+{
+    UNUSED(env); UNUSED(class);
+    hid_keyboard_release((hid_keyboard_t*)(size_t)kb, key);
+}
+
+POP_OPTIMIZATION_SIZE
diff --git a/app/src/main/java/libengine/RVVM/src/bindings/jni/tiny-jni.h b/app/src/main/java/libengine/RVVM/src/bindings/jni/tiny-jni.h
new file mode 100644
index 00000000..ada30a54
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/bindings/jni/tiny-jni.h
@@ -0,0 +1,717 @@
+/*
+ * Copyright (c) 1996, 2022, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * We used part of Netscape's Java Runtime Interface (JRI) as the starting
+ * point of our design and implementation.
+ */
+
+/******************************************************************************
+ * Java Runtime Interface
+ * Copyright (c) 1996 Netscape Communications Corporation. All rights reserved.
+ *****************************************************************************/
+
+/*
+ * tiny-jni by https://github.com/LekKit
+ * This is a tiny & portable self-contained JNI API header,
+ * allows to build JNI bridges in-tree without supplying JDK headers.
+ * Just drop this in your sources & you're good to go.
+ *
+ * Original source from is from Oracle OpenJDK distribution.
+ * The classpath exception allows to include this into non-GPL works.
+ */
+
+#ifndef _JAVASOFT_JNI_H_
+#define _JAVASOFT_JNI_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdint.h> /* Use modern standard type definitions */
+#include <stddef.h>
+#include <stdarg.h>
+
+#if defined(_WIN32)
+#define JNIEXPORT __declspec(dllexport)
+#define JNIIMPORT __declspec(dllimport)
+#define JNICALL   __stdcall
+#elif defined(__GNUC__)
+#define JNIEXPORT __attribute__((visibility("default")))
+#define JNIIMPORT __attribute__((visibility("default")))
+#define JNICALL
+#else
+/*
+ * Build the project anyways under unsupported target for JNI.
+ * Here you might add your own attributes for porting
+ */
+#define JNIEXPORT
+#define JNIIMPORT
+#define JNICALL
+#endif
+
+#define JNI_FALSE 0
+#define JNI_TRUE  1
+
+#define JNI_OK        0    /* Success */
+#define JNI_ERR       (-1) /* Unknown error */
+#define JNI_EDETACHED (-2) /* Thread detached from the VM */
+#define JNI_EVERSION  (-3) /* JNI version error */
+#define JNI_ENOMEM    (-4) /* Not enough memory */
+#define JNI_EEXIST    (-5) /* VM already created */
+#define JNI_EINVAL    (-6) /* Invalid arguments */
+
+#define JNI_COMMIT 1
+#define JNI_ABORT  2
+
+#define JDK1_2
+#define JDK1_4
+
+#define JNI_VERSION_1_1 0x00010001
+#define JNI_VERSION_1_2 0x00010002
+#define JNI_VERSION_1_4 0x00010004
+#define JNI_VERSION_1_6 0x00010006
+#define JNI_VERSION_1_8 0x00010008
+#define JNI_VERSION_9   0x00090000
+#define JNI_VERSION_10  0x000a0000
+#define JNI_VERSION_19  0x00130000
+#define JNI_VERSION_20  0x00140000
+
+typedef uint8_t  jboolean;
+typedef int8_t   jbyte;
+typedef uint16_t jchar;
+typedef int16_t  jshort;
+typedef int32_t  jint;
+typedef int32_t  jsize;
+typedef int64_t  jlong;
+typedef float    jfloat;
+typedef double   jdouble;
+
+#ifdef __cplusplus
+class _jobject {};
+class _jclass : public _jobject {};
+class _jarray : public _jobject {};
+class _jstring : public _jobject {};
+class _jthrowable : public _jobject {};
+class _jbooleanArray : public _jarray {};
+class _jbyteArray : public _jarray {};
+class _jcharArray : public _jarray {};
+class _jshortArray : public _jarray {};
+class _jintArray : public _jarray {};
+class _jlongArray : public _jarray {};
+class _jfloatArray : public _jarray {};
+class _jdoubleArray : public _jarray {};
+class _jobjectArray : public _jarray {};
+typedef _jobject *jobject;
+typedef _jclass *jclass;
+typedef _jthrowable *jthrowable;
+typedef _jstring *jstring;
+typedef _jarray *jarray;
+typedef _jbooleanArray *jbooleanArray;
+typedef _jbyteArray *jbyteArray;
+typedef _jcharArray *jcharArray;
+typedef _jshortArray *jshortArray;
+typedef _jintArray *jintArray;
+typedef _jlongArray *jlongArray;
+typedef _jfloatArray *jfloatArray;
+typedef _jdoubleArray *jdoubleArray;
+typedef _jobjectArray *jobjectArray;
+#else
+struct _jobject;
+typedef struct _jobject *jobject;
+typedef jobject jclass;
+typedef jobject jthrowable;
+typedef jobject jstring;
+typedef jobject jarray;
+typedef jarray jbooleanArray;
+typedef jarray jbyteArray;
+typedef jarray jcharArray;
+typedef jarray jshortArray;
+typedef jarray jintArray;
+typedef jarray jlongArray;
+typedef jarray jfloatArray;
+typedef jarray jdoubleArray;
+typedef jarray jobjectArray;
+#endif
+
+struct _jfieldID;
+typedef struct _jfieldID *jfieldID;
+struct _jmethodID;
+typedef struct _jmethodID *jmethodID;
+
+typedef jobject jweak;
+typedef enum _jobjectType {
+     JNIInvalidRefType    = 0,
+     JNILocalRefType      = 1,
+     JNIGlobalRefType     = 2,
+     JNIWeakGlobalRefType = 3
+} jobjectRefType;
+
+typedef union jvalue {
+    jboolean z;
+    jbyte    b;
+    jchar    c;
+    jshort   s;
+    jint     i;
+    jlong    j;
+    jfloat   f;
+    jdouble  d;
+    jobject  l;
+} jvalue;
+
+typedef struct {
+    char *name;
+    char *signature;
+    void *fnPtr;
+} JNINativeMethod;
+
+struct JNINativeInterface_;
+struct JNIEnv_;
+struct JNIInvokeInterface_;
+struct JavaVM_;
+
+#ifdef __cplusplus
+typedef JNIEnv_ JNIEnv;
+typedef JavaVM_ JavaVM;
+#else
+typedef const struct JNINativeInterface_ *JNIEnv;
+typedef const struct JNIInvokeInterface_ *JavaVM;
+#endif
+
+struct JNINativeInterface_ {
+    void *reserved0;
+    void *reserved1;
+    void *reserved2;
+    void *reserved3;
+    jint (JNICALL *GetVersion)(JNIEnv *env);
+    jclass (JNICALL *DefineClass) (JNIEnv *env, const char *name, jobject loader, const jbyte *buf, jsize len);
+    jclass (JNICALL *FindClass) (JNIEnv *env, const char *name);
+    jmethodID (JNICALL *FromReflectedMethod) (JNIEnv *env, jobject method);
+    jfieldID (JNICALL *FromReflectedField) (JNIEnv *env, jobject field);
+    jobject (JNICALL *ToReflectedMethod) (JNIEnv *env, jclass cls, jmethodID methodID, jboolean isStatic);
+    jclass (JNICALL *GetSuperclass) (JNIEnv *env, jclass sub);
+    jboolean (JNICALL *IsAssignableFrom) (JNIEnv *env, jclass sub, jclass sup);
+    jobject (JNICALL *ToReflectedField) (JNIEnv *env, jclass cls, jfieldID fieldID, jboolean isStatic);
+    jint (JNICALL *Throw) (JNIEnv *env, jthrowable obj);
+    jint (JNICALL *ThrowNew) (JNIEnv *env, jclass clazz, const char *msg);
+    jthrowable (JNICALL *ExceptionOccurred) (JNIEnv *env);
+    void (JNICALL *ExceptionDescribe) (JNIEnv *env);
+    void (JNICALL *ExceptionClear) (JNIEnv *env);
+    void (JNICALL *FatalError) (JNIEnv *env, const char *msg);
+    jint (JNICALL *PushLocalFrame) (JNIEnv *env, jint capacity);
+    jobject (JNICALL *PopLocalFrame) (JNIEnv *env, jobject result);
+    jobject (JNICALL *NewGlobalRef) (JNIEnv *env, jobject lobj);
+    void (JNICALL *DeleteGlobalRef) (JNIEnv *env, jobject gref);
+    void (JNICALL *DeleteLocalRef) (JNIEnv *env, jobject obj);
+    jboolean (JNICALL *IsSameObject) (JNIEnv *env, jobject obj1, jobject obj2);
+    jobject (JNICALL *NewLocalRef) (JNIEnv *env, jobject ref);
+    jint (JNICALL *EnsureLocalCapacity) (JNIEnv *env, jint capacity);
+    jobject (JNICALL *AllocObject) (JNIEnv *env, jclass clazz);
+    jobject (JNICALL *NewObject) (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
+    jobject (JNICALL *NewObjectV) (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
+    jobject (JNICALL *NewObjectA) (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);
+    jclass (JNICALL *GetObjectClass) (JNIEnv *env, jobject obj);
+    jboolean (JNICALL *IsInstanceOf) (JNIEnv *env, jobject obj, jclass clazz);
+    jmethodID (JNICALL *GetMethodID) (JNIEnv *env, jclass clazz, const char *name, const char *sig);
+#define JNI_C_GEN_CALL(C_TYPE, JAVA_TYPE) \
+    C_TYPE (JNICALL *Call##JAVA_TYPE##Method) (JNIEnv *env, jobject obj, jmethodID methodID, ...); \
+    C_TYPE (JNICALL *Call##JAVA_TYPE##MethodV) (JNIEnv *env, jobject obj, jmethodID methodID, va_list args); \
+    C_TYPE (JNICALL *Call##JAVA_TYPE##MethodA) (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue * args);
+    JNI_C_GEN_CALL(jobject, Object)
+    JNI_C_GEN_CALL(jboolean, Boolean)
+    JNI_C_GEN_CALL(jbyte, Byte)
+    JNI_C_GEN_CALL(jchar, Char)
+    JNI_C_GEN_CALL(jshort, Short)
+    JNI_C_GEN_CALL(jint, Int)
+    JNI_C_GEN_CALL(jlong, Long)
+    JNI_C_GEN_CALL(jfloat, Float)
+    JNI_C_GEN_CALL(jdouble, Double)
+    JNI_C_GEN_CALL(void, Void)
+#define JNI_C_GEN_NONVIRT_CALL(C_TYPE, JAVA_TYPE) \
+    C_TYPE (JNICALL *CallNonvirtual##JAVA_TYPE##Method) (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...); \
+    C_TYPE (JNICALL *CallNonvirtual##JAVA_TYPE##MethodV) (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, va_list args); \
+    C_TYPE (JNICALL *CallNonvirtual##JAVA_TYPE##MethodA) (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, const jvalue * args);
+    JNI_C_GEN_NONVIRT_CALL(jobject, Object)
+    JNI_C_GEN_NONVIRT_CALL(jboolean, Boolean)
+    JNI_C_GEN_NONVIRT_CALL(jbyte, Byte)
+    JNI_C_GEN_NONVIRT_CALL(jchar, Char)
+    JNI_C_GEN_NONVIRT_CALL(jshort, Short)
+    JNI_C_GEN_NONVIRT_CALL(jint, Int)
+    JNI_C_GEN_NONVIRT_CALL(jlong, Long)
+    JNI_C_GEN_NONVIRT_CALL(jfloat, Float)
+    JNI_C_GEN_NONVIRT_CALL(jdouble, Double)
+    JNI_C_GEN_NONVIRT_CALL(void, Void)
+    jfieldID (JNICALL *GetFieldID) (JNIEnv *env, jclass clazz, const char *name, const char *sig);
+    jobject (JNICALL *GetObjectField) (JNIEnv *env, jobject obj, jfieldID fieldID);
+    jboolean (JNICALL *GetBooleanField) (JNIEnv *env, jobject obj, jfieldID fieldID);
+    jbyte (JNICALL *GetByteField) (JNIEnv *env, jobject obj, jfieldID fieldID);
+    jchar (JNICALL *GetCharField) (JNIEnv *env, jobject obj, jfieldID fieldID);
+    jshort (JNICALL *GetShortField) (JNIEnv *env, jobject obj, jfieldID fieldID);
+    jint (JNICALL *GetIntField) (JNIEnv *env, jobject obj, jfieldID fieldID);
+    jlong (JNICALL *GetLongField) (JNIEnv *env, jobject obj, jfieldID fieldID);
+    jfloat (JNICALL *GetFloatField) (JNIEnv *env, jobject obj, jfieldID fieldID);
+    jdouble (JNICALL *GetDoubleField) (JNIEnv *env, jobject obj, jfieldID fieldID);
+    void (JNICALL *SetObjectField) (JNIEnv *env, jobject obj, jfieldID fieldID, jobject val);
+    void (JNICALL *SetBooleanField) (JNIEnv *env, jobject obj, jfieldID fieldID, jboolean val);
+    void (JNICALL *SetByteField) (JNIEnv *env, jobject obj, jfieldID fieldID, jbyte val);
+    void (JNICALL *SetCharField) (JNIEnv *env, jobject obj, jfieldID fieldID, jchar val);
+    void (JNICALL *SetShortField) (JNIEnv *env, jobject obj, jfieldID fieldID, jshort val);
+    void (JNICALL *SetIntField) (JNIEnv *env, jobject obj, jfieldID fieldID, jint val);
+    void (JNICALL *SetLongField) (JNIEnv *env, jobject obj, jfieldID fieldID, jlong val);
+    void (JNICALL *SetFloatField) (JNIEnv *env, jobject obj, jfieldID fieldID, jfloat val);
+    void (JNICALL *SetDoubleField) (JNIEnv *env, jobject obj, jfieldID fieldID, jdouble val);
+    jmethodID (JNICALL *GetStaticMethodID) (JNIEnv *env, jclass clazz, const char *name, const char *sig);
+#define JNI_C_GEN_STATIC_CALL(C_TYPE, JAVA_TYPE) \
+    C_TYPE (JNICALL *CallStatic##JAVA_TYPE##Method) (JNIEnv *env, jclass clazz, jmethodID methodID, ...); \
+    C_TYPE (JNICALL *CallStatic##JAVA_TYPE##MethodV) (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args); \
+    C_TYPE (JNICALL *CallStatic##JAVA_TYPE##MethodA) (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);
+    JNI_C_GEN_STATIC_CALL(jobject, Object)
+    JNI_C_GEN_STATIC_CALL(jboolean, Boolean)
+    JNI_C_GEN_STATIC_CALL(jbyte, Byte)
+    JNI_C_GEN_STATIC_CALL(jchar, Char)
+    JNI_C_GEN_STATIC_CALL(jshort, Short)
+    JNI_C_GEN_STATIC_CALL(jint, Int)
+    JNI_C_GEN_STATIC_CALL(jlong, Long)
+    JNI_C_GEN_STATIC_CALL(jfloat, Float)
+    JNI_C_GEN_STATIC_CALL(jdouble, Double)
+    JNI_C_GEN_STATIC_CALL(void, Void)
+    jfieldID (JNICALL *GetStaticFieldID) (JNIEnv *env, jclass clazz, const char *name, const char *sig);
+    jobject (JNICALL *GetStaticObjectField) (JNIEnv *env, jclass clazz, jfieldID fieldID);
+    jboolean (JNICALL *GetStaticBooleanField) (JNIEnv *env, jclass clazz, jfieldID fieldID);
+    jbyte (JNICALL *GetStaticByteField) (JNIEnv *env, jclass clazz, jfieldID fieldID);
+    jchar (JNICALL *GetStaticCharField) (JNIEnv *env, jclass clazz, jfieldID fieldID);
+    jshort (JNICALL *GetStaticShortField) (JNIEnv *env, jclass clazz, jfieldID fieldID);
+    jint (JNICALL *GetStaticIntField) (JNIEnv *env, jclass clazz, jfieldID fieldID);
+    jlong (JNICALL *GetStaticLongField) (JNIEnv *env, jclass clazz, jfieldID fieldID);
+    jfloat (JNICALL *GetStaticFloatField) (JNIEnv *env, jclass clazz, jfieldID fieldID);
+    jdouble (JNICALL *GetStaticDoubleField) (JNIEnv *env, jclass clazz, jfieldID fieldID);
+    void (JNICALL *SetStaticObjectField) (JNIEnv *env, jclass clazz, jfieldID fieldID, jobject value);
+    void (JNICALL *SetStaticBooleanField) (JNIEnv *env, jclass clazz, jfieldID fieldID, jboolean value);
+    void (JNICALL *SetStaticByteField) (JNIEnv *env, jclass clazz, jfieldID fieldID, jbyte value);
+    void (JNICALL *SetStaticCharField) (JNIEnv *env, jclass clazz, jfieldID fieldID, jchar value);
+    void (JNICALL *SetStaticShortField) (JNIEnv *env, jclass clazz, jfieldID fieldID, jshort value);
+    void (JNICALL *SetStaticIntField) (JNIEnv *env, jclass clazz, jfieldID fieldID, jint value);
+    void (JNICALL *SetStaticLongField) (JNIEnv *env, jclass clazz, jfieldID fieldID, jlong value);
+    void (JNICALL *SetStaticFloatField) (JNIEnv *env, jclass clazz, jfieldID fieldID, jfloat value);
+    void (JNICALL *SetStaticDoubleField) (JNIEnv *env, jclass clazz, jfieldID fieldID, jdouble value);
+    jstring (JNICALL *NewString) (JNIEnv *env, const jchar *unicode, jsize len);
+    jsize (JNICALL *GetStringLength) (JNIEnv *env, jstring str);
+    const jchar *(JNICALL *GetStringChars) (JNIEnv *env, jstring str, jboolean *isCopy);
+    void (JNICALL *ReleaseStringChars) (JNIEnv *env, jstring str, const jchar *chars);
+    jstring (JNICALL *NewStringUTF) (JNIEnv *env, const char *utf);
+    jsize (JNICALL *GetStringUTFLength) (JNIEnv *env, jstring str);
+    const char* (JNICALL *GetStringUTFChars) (JNIEnv *env, jstring str, jboolean *isCopy);
+    void (JNICALL *ReleaseStringUTFChars) (JNIEnv *env, jstring str, const char* chars);
+    jsize (JNICALL *GetArrayLength) (JNIEnv *env, jarray array);
+    jobjectArray (JNICALL *NewObjectArray) (JNIEnv *env, jsize len, jclass clazz, jobject init);
+    jobject (JNICALL *GetObjectArrayElement) (JNIEnv *env, jobjectArray array, jsize index);
+    void (JNICALL *SetObjectArrayElement) (JNIEnv *env, jobjectArray array, jsize index, jobject val);
+    jbooleanArray (JNICALL *NewBooleanArray) (JNIEnv *env, jsize len);
+    jbyteArray (JNICALL *NewByteArray) (JNIEnv *env, jsize len);
+    jcharArray (JNICALL *NewCharArray) (JNIEnv *env, jsize len);
+    jshortArray (JNICALL *NewShortArray) (JNIEnv *env, jsize len);
+    jintArray (JNICALL *NewIntArray) (JNIEnv *env, jsize len);
+    jlongArray (JNICALL *NewLongArray) (JNIEnv *env, jsize len);
+    jfloatArray (JNICALL *NewFloatArray) (JNIEnv *env, jsize len);
+    jdoubleArray (JNICALL *NewDoubleArray) (JNIEnv *env, jsize len);
+    jboolean * (JNICALL *GetBooleanArrayElements) (JNIEnv *env, jbooleanArray array, jboolean *isCopy);
+    jbyte * (JNICALL *GetByteArrayElements) (JNIEnv *env, jbyteArray array, jboolean *isCopy);
+    jchar * (JNICALL *GetCharArrayElements) (JNIEnv *env, jcharArray array, jboolean *isCopy);
+    jshort * (JNICALL *GetShortArrayElements) (JNIEnv *env, jshortArray array, jboolean *isCopy);
+    jint * (JNICALL *GetIntArrayElements) (JNIEnv *env, jintArray array, jboolean *isCopy);
+    jlong * (JNICALL *GetLongArrayElements) (JNIEnv *env, jlongArray array, jboolean *isCopy);
+    jfloat * (JNICALL *GetFloatArrayElements) (JNIEnv *env, jfloatArray array, jboolean *isCopy);
+    jdouble * (JNICALL *GetDoubleArrayElements) (JNIEnv *env, jdoubleArray array, jboolean *isCopy);
+    void (JNICALL *ReleaseBooleanArrayElements) (JNIEnv *env, jbooleanArray array, jboolean *elems, jint mode);
+    void (JNICALL *ReleaseByteArrayElements) (JNIEnv *env, jbyteArray array, jbyte *elems, jint mode);
+    void (JNICALL *ReleaseCharArrayElements) (JNIEnv *env, jcharArray array, jchar *elems, jint mode);
+    void (JNICALL *ReleaseShortArrayElements) (JNIEnv *env, jshortArray array, jshort *elems, jint mode);
+    void (JNICALL *ReleaseIntArrayElements) (JNIEnv *env, jintArray array, jint *elems, jint mode);
+    void (JNICALL *ReleaseLongArrayElements) (JNIEnv *env, jlongArray array, jlong *elems, jint mode);
+    void (JNICALL *ReleaseFloatArrayElements) (JNIEnv *env, jfloatArray array, jfloat *elems, jint mode);
+    void (JNICALL *ReleaseDoubleArrayElements) (JNIEnv *env, jdoubleArray array, jdouble *elems, jint mode);
+    void (JNICALL *GetBooleanArrayRegion) (JNIEnv *env, jbooleanArray array, jsize start, jsize l, jboolean *buf);
+    void (JNICALL *GetByteArrayRegion) (JNIEnv *env, jbyteArray array, jsize start, jsize len, jbyte *buf);
+    void (JNICALL *GetCharArrayRegion) (JNIEnv *env, jcharArray array, jsize start, jsize len, jchar *buf);
+    void (JNICALL *GetShortArrayRegion) (JNIEnv *env, jshortArray array, jsize start, jsize len, jshort *buf);
+    void (JNICALL *GetIntArrayRegion) (JNIEnv *env, jintArray array, jsize start, jsize len, jint *buf);
+    void (JNICALL *GetLongArrayRegion) (JNIEnv *env, jlongArray array, jsize start, jsize len, jlong *buf);
+    void (JNICALL *GetFloatArrayRegion) (JNIEnv *env, jfloatArray array, jsize start, jsize len, jfloat *buf);
+    void (JNICALL *GetDoubleArrayRegion) (JNIEnv *env, jdoubleArray array, jsize start, jsize len, jdouble *buf);
+    void (JNICALL *SetBooleanArrayRegion) (JNIEnv *env, jbooleanArray array, jsize start, jsize l, const jboolean *buf);
+    void (JNICALL *SetByteArrayRegion) (JNIEnv *env, jbyteArray array, jsize start, jsize len, const jbyte *buf);
+    void (JNICALL *SetCharArrayRegion) (JNIEnv *env, jcharArray array, jsize start, jsize len, const jchar *buf);
+    void (JNICALL *SetShortArrayRegion) (JNIEnv *env, jshortArray array, jsize start, jsize len, const jshort *buf);
+    void (JNICALL *SetIntArrayRegion) (JNIEnv *env, jintArray array, jsize start, jsize len, const jint *buf);
+    void (JNICALL *SetLongArrayRegion) (JNIEnv *env, jlongArray array, jsize start, jsize len, const jlong *buf);
+    void (JNICALL *SetFloatArrayRegion) (JNIEnv *env, jfloatArray array, jsize start, jsize len, const jfloat *buf);
+    void (JNICALL *SetDoubleArrayRegion) (JNIEnv *env, jdoubleArray array, jsize start, jsize len, const jdouble *buf);
+    jint (JNICALL *RegisterNatives) (JNIEnv *env, jclass clazz, const JNINativeMethod *methods, jint nMethods);
+    jint (JNICALL *UnregisterNatives) (JNIEnv *env, jclass clazz);
+    jint (JNICALL *MonitorEnter) (JNIEnv *env, jobject obj);
+    jint (JNICALL *MonitorExit) (JNIEnv *env, jobject obj);
+    jint (JNICALL *GetJavaVM) (JNIEnv *env, JavaVM **vm);
+    void (JNICALL *GetStringRegion) (JNIEnv *env, jstring str, jsize start, jsize len, jchar *buf);
+    void (JNICALL *GetStringUTFRegion) (JNIEnv *env, jstring str, jsize start, jsize len, char *buf);
+    void * (JNICALL *GetPrimitiveArrayCritical) (JNIEnv *env, jarray array, jboolean *isCopy);
+    void (JNICALL *ReleasePrimitiveArrayCritical) (JNIEnv *env, jarray array, void *carray, jint mode);
+    const jchar * (JNICALL *GetStringCritical) (JNIEnv *env, jstring string, jboolean *isCopy);
+    void (JNICALL *ReleaseStringCritical) (JNIEnv *env, jstring string, const jchar *cstring);
+    jweak (JNICALL *NewWeakGlobalRef) (JNIEnv *env, jobject obj);
+    void (JNICALL *DeleteWeakGlobalRef) (JNIEnv *env, jweak ref);
+    jboolean (JNICALL *ExceptionCheck) (JNIEnv *env);
+    jobject (JNICALL *NewDirectByteBuffer) (JNIEnv* env, void* address, jlong capacity);
+    void* (JNICALL *GetDirectBufferAddress) (JNIEnv* env, jobject buf);
+    jlong (JNICALL *GetDirectBufferCapacity) (JNIEnv* env, jobject buf);
+    jobjectRefType (JNICALL *GetObjectRefType) (JNIEnv* env, jobject obj);
+    jobject (JNICALL *GetModule) (JNIEnv* env, jclass clazz);
+    jboolean (JNICALL *IsVirtualThread) (JNIEnv* env, jobject obj);
+};
+
+struct JNIEnv_ {
+    const struct JNINativeInterface_ *functions;
+#ifdef __cplusplus
+    jint GetVersion() { return functions->GetVersion(this); }
+    jclass DefineClass(const char *name, jobject loader, const jbyte *buf, jsize len)
+    { return functions->DefineClass(this, name, loader, buf, len); }
+    jclass FindClass(const char *name)
+    { return functions->FindClass(this, name); }
+    jmethodID FromReflectedMethod(jobject method)
+    { return functions->FromReflectedMethod(this, method); }
+    jfieldID FromReflectedField(jobject field)
+    { return functions->FromReflectedField(this,field); }
+    jobject ToReflectedMethod(jclass cls, jmethodID methodID, jboolean isStatic)
+    { return functions->ToReflectedMethod(this, cls, methodID, isStatic); }
+    jclass GetSuperclass(jclass sub)
+    { return functions->GetSuperclass(this, sub); }
+    jboolean IsAssignableFrom(jclass sub, jclass sup)
+    { return functions->IsAssignableFrom(this, sub, sup); }
+    jobject ToReflectedField(jclass cls, jfieldID fieldID, jboolean isStatic)
+    { return functions->ToReflectedField(this,cls,fieldID,isStatic); }
+    jint Throw(jthrowable obj)
+    { return functions->Throw(this, obj); }
+    jint ThrowNew(jclass clazz, const char *msg)
+    { return functions->ThrowNew(this, clazz, msg); }
+    jthrowable ExceptionOccurred()
+    { return functions->ExceptionOccurred(this); }
+    void ExceptionDescribe()
+    { functions->ExceptionDescribe(this); }
+    void ExceptionClear()
+    { functions->ExceptionClear(this); }
+    void FatalError(const char *msg)
+    { functions->FatalError(this, msg); }
+    jint PushLocalFrame(jint capacity)
+    { return functions->PushLocalFrame(this,capacity); }
+    jobject PopLocalFrame(jobject result)
+    { return functions->PopLocalFrame(this, result); }
+    jobject NewGlobalRef(jobject lobj)
+    { return functions->NewGlobalRef(this, lobj); }
+    void DeleteGlobalRef(jobject gref)
+    { functions->DeleteGlobalRef(this, gref); }
+    void DeleteLocalRef(jobject obj)
+    { functions->DeleteLocalRef(this, obj); }
+    jboolean IsSameObject(jobject obj1, jobject obj2)
+    { return functions->IsSameObject(this, obj1, obj2); }
+    jobject NewLocalRef(jobject ref)
+    { return functions->NewLocalRef(this, ref); }
+    jint EnsureLocalCapacity(jint capacity)
+    { return functions->EnsureLocalCapacity(this,capacity); }
+    jobject AllocObject(jclass clazz)
+    { return functions->AllocObject(this, clazz); }
+    jobject NewObject(jclass clazz, jmethodID methodID, ...) {
+        va_list args;
+        va_start(args, methodID);
+        jobject ret = functions->NewObjectV(this, clazz, methodID, args);
+        va_end(args);
+        return ret;
+    }
+    jobject NewObjectV(jclass clazz, jmethodID methodID, va_list args)
+    { return functions->NewObjectV(this, clazz, methodID, args); }
+    jobject NewObjectA(jclass clazz, jmethodID methodID, const jvalue *args)
+    { return functions->NewObjectA(this, clazz, methodID, args); }
+    jclass GetObjectClass(jobject obj)
+    { return functions->GetObjectClass(this,obj); }
+    jboolean IsInstanceOf(jobject obj, jclass clazz)
+    { return functions->IsInstanceOf(this, obj, clazz); }
+    jmethodID GetMethodID(jclass clazz, const char *name, const char *sig)
+    { return functions->GetMethodID(this,clazz,name,sig); }
+    void CallVoidMethod(jobject obj, jmethodID methodID, ...) {
+        va_list args;
+        va_start(args,methodID);
+        functions->CallVoidMethodV(this,obj,methodID,args);
+        va_end(args);
+    }
+    void CallVoidMethodV(jobject obj, jmethodID methodID, va_list args)
+    { functions->CallVoidMethodV(this, obj, methodID, args); }
+    void CallVoidMethodA(jobject obj, jmethodID methodID, const jvalue * args)
+    { functions->CallVoidMethodA(this, obj, methodID, args); }
+    void CallNonvirtualVoidMethod(jobject obj, jclass clazz, jmethodID methodID, ...) {
+        va_list args;
+        va_start(args,methodID);
+        functions->CallNonvirtualVoidMethodV(this, obj, clazz, methodID, args);
+        va_end(args);
+    }
+    void CallNonvirtualVoidMethodV(jobject obj, jclass clazz, jmethodID methodID, va_list args)
+    { functions->CallNonvirtualVoidMethodV(this, obj, clazz, methodID, args); }
+    void CallNonvirtualVoidMethodA(jobject obj, jclass clazz, jmethodID methodID, const jvalue * args)
+    { functions->CallNonvirtualVoidMethodA(this, obj, clazz, methodID, args); }
+    jfieldID GetFieldID(jclass clazz, const char *name, const char *sig)
+    { return functions->GetFieldID(this, clazz, name, sig); }
+    jmethodID GetStaticMethodID(jclass clazz, const char *name, const char *sig)
+    { return functions->GetStaticMethodID(this,clazz,name,sig); }
+    void CallStaticVoidMethod(jclass cls, jmethodID methodID, ...) {
+        va_list args;
+        va_start(args,methodID);
+        functions->CallStaticVoidMethodV(this,cls,methodID,args);
+        va_end(args);
+    }
+    void CallStaticVoidMethodV(jclass cls, jmethodID methodID, va_list args)
+    { functions->CallStaticVoidMethodV(this, cls, methodID, args); }
+    void CallStaticVoidMethodA(jclass cls, jmethodID methodID, const jvalue * args)
+    { functions->CallStaticVoidMethodA(this, cls, methodID, args); }
+    jfieldID GetStaticFieldID(jclass clazz, const char *name, const char *sig)
+    { return functions->GetStaticFieldID(this, clazz, name, sig); }
+    jstring NewString(const jchar *unicode, jsize len)
+    { return functions->NewString(this, unicode, len); }
+    jsize GetStringLength(jstring str)
+    { return functions->GetStringLength(this,str); }
+    const jchar *GetStringChars(jstring str, jboolean *isCopy)
+    { return functions->GetStringChars(this, str, isCopy); }
+    void ReleaseStringChars(jstring str, const jchar *chars)
+    { functions->ReleaseStringChars(this, str, chars); }
+    jstring NewStringUTF(const char *utf)
+    { return functions->NewStringUTF(this, utf); }
+    jsize GetStringUTFLength(jstring str)
+    { return functions->GetStringUTFLength(this,str); }
+    const char* GetStringUTFChars(jstring str, jboolean *isCopy)
+    { return functions->GetStringUTFChars(this, str, isCopy); }
+    void ReleaseStringUTFChars(jstring str, const char* chars)
+    { functions->ReleaseStringUTFChars(this, str, chars); }
+    jsize GetArrayLength(jarray array)
+    { return functions->GetArrayLength(this, array); }
+    jobjectArray NewObjectArray(jsize len, jclass clazz, jobject init)
+    { return functions->NewObjectArray(this, len, clazz, init); }
+    jobject GetObjectArrayElement(jobjectArray array, jsize index)
+    { return functions->GetObjectArrayElement(this, array, index); }
+    void SetObjectArrayElement(jobjectArray array, jsize index, jobject val)
+    { functions->SetObjectArrayElement(this,array,index,val); }
+    jint RegisterNatives(jclass clazz, const JNINativeMethod *methods, jint nMethods)
+    { return functions->RegisterNatives(this, clazz, methods, nMethods); }
+    jint UnregisterNatives(jclass clazz)
+    { return functions->UnregisterNatives(this, clazz); }
+    jint MonitorEnter(jobject obj)
+    { return functions->MonitorEnter(this, obj); }
+    jint MonitorExit(jobject obj)
+    { return functions->MonitorExit(this, obj); }
+    jint GetJavaVM(JavaVM **vm)
+    { return functions->GetJavaVM(this, vm); }
+    void GetStringRegion(jstring str, jsize start, jsize len, jchar *buf)
+    { functions->GetStringRegion(this, str, start, len, buf); }
+    void GetStringUTFRegion(jstring str, jsize start, jsize len, char *buf)
+    { functions->GetStringUTFRegion(this, str, start, len, buf); }
+    void * GetPrimitiveArrayCritical(jarray array, jboolean *isCopy)
+    { return functions->GetPrimitiveArrayCritical(this, array, isCopy); }
+    void ReleasePrimitiveArrayCritical(jarray array, void *carray, jint mode)
+    { functions->ReleasePrimitiveArrayCritical(this, array, carray, mode); }
+    const jchar * GetStringCritical(jstring string, jboolean *isCopy)
+    { return functions->GetStringCritical(this, string, isCopy); }
+    void ReleaseStringCritical(jstring string, const jchar *cstring)
+    { functions->ReleaseStringCritical(this, string, cstring); }
+    jweak NewWeakGlobalRef(jobject obj)
+    { return functions->NewWeakGlobalRef(this, obj); }
+    void DeleteWeakGlobalRef(jweak ref)
+    { functions->DeleteWeakGlobalRef(this, ref); }
+    jboolean ExceptionCheck()
+    { return functions->ExceptionCheck(this); }
+    jobject NewDirectByteBuffer(void* address, jlong capacity)
+    { return functions->NewDirectByteBuffer(this, address, capacity); }
+    void* GetDirectBufferAddress(jobject buf)
+    { return functions->GetDirectBufferAddress(this, buf); }
+    jlong GetDirectBufferCapacity(jobject buf)
+    { return functions->GetDirectBufferCapacity(this, buf); }
+    jobjectRefType GetObjectRefType(jobject obj)
+    { return functions->GetObjectRefType(this, obj); }
+    jobject GetModule(jclass clazz)
+    { return functions->GetModule(this, clazz); }
+    jboolean IsVirtualThread(jobject obj)
+    { return functions->IsVirtualThread(this, obj); }
+#define JNI_CPP_GEN_CALL(CPP_TYPE, JAVA_TYPE) \
+    CPP_TYPE Call##JAVA_TYPE##Method(jobject obj, jmethodID methodID, ...) \
+    { \
+        va_list args; \
+        va_start(args, methodID); \
+        CPP_TYPE ret = functions->Call##JAVA_TYPE##MethodV(this, obj, methodID, args); \
+        va_end(args); \
+        return ret; \
+    } \
+    CPP_TYPE Call##JAVA_TYPE##MethodV(jobject obj, jmethodID methodID, va_list args) \
+    { return functions->Call##JAVA_TYPE##MethodV(this, obj, methodID, args); } \
+    CPP_TYPE Call##JAVA_TYPE##MethodA(jobject obj, jmethodID methodID, const jvalue* args) \
+    { return functions->Call##JAVA_TYPE##MethodA(this, obj, methodID, args); }
+#define JNI_CPP_GEN_NONVIRT_CALL(CPP_TYPE, JAVA_TYPE) \
+    CPP_TYPE CallNonvirtual##JAVA_TYPE##Method(jobject obj, jclass clazz, jmethodID methodID, ...) \
+    { \
+        va_list args; \
+        va_start(args, methodID); \
+        CPP_TYPE ret = functions->CallNonvirtual##JAVA_TYPE##MethodV(this, obj, clazz, methodID, args); \
+        va_end(args); \
+        return ret; \
+    } \
+    CPP_TYPE CallNonvirtual##JAVA_TYPE##MethodV(jobject obj, jclass clazz, jmethodID methodID, va_list args) \
+    { return functions->CallNonvirtual##JAVA_TYPE##MethodV(this, obj, clazz, methodID, args); } \
+    CPP_TYPE CallNonvirtual##JAVA_TYPE##MethodA(jobject obj, jclass clazz, jmethodID methodID, const jvalue* args) \
+    { return functions->CallNonvirtual##JAVA_TYPE##MethodA(this, obj, clazz, methodID, args); }
+#define JNI_CPP_GEN_GETFIELD(CPP_TYPE, JAVA_TYPE) \
+    CPP_TYPE Get##JAVA_TYPE##Field(jobject obj, jfieldID fieldID) \
+    { return functions->Get##JAVA_TYPE##Field(this, obj, fieldID); }
+#define JNI_CPP_GEN_SETFIELD(CPP_TYPE, JAVA_TYPE) \
+    void Set##JAVA_TYPE##Field(jobject obj, jfieldID fieldID, CPP_TYPE val) \
+    { functions->Set##JAVA_TYPE##Field(this, obj, fieldID, val); }
+#define JNI_CPP_GEN_STATIC_CALL(CPP_TYPE, JAVA_TYPE) \
+    CPP_TYPE CallStatic##JAVA_TYPE##Method(jclass clazz, jmethodID methodID, ...) \
+    { \
+        va_list args; \
+        va_start(args, methodID); \
+        CPP_TYPE ret = functions->CallStatic##JAVA_TYPE##MethodV(this, clazz, methodID, args); \
+        va_end(args); \
+        return ret; \
+    } \
+    CPP_TYPE CallStatic##JAVA_TYPE##MethodV(jclass clazz, jmethodID methodID, va_list args) \
+    { return functions->CallStatic##JAVA_TYPE##MethodV(this, clazz, methodID, args); } \
+    CPP_TYPE CallStatic##JAVA_TYPE##MethodA(jclass clazz, jmethodID methodID, const jvalue* args) \
+    { return functions->CallStatic##JAVA_TYPE##MethodA(this, clazz, methodID, args); }
+#define JNI_CPP_GEN_GETSTATICFIELD(CPP_TYPE, JAVA_TYPE) \
+    CPP_TYPE GetStatic##JAVA_TYPE##Field(jclass clazz, jfieldID fieldID) \
+    { return functions->GetStatic##JAVA_TYPE##Field(this, clazz, fieldID); }
+#define JNI_CPP_GEN_SETSTATICFIELD(CPP_TYPE, JAVA_TYPE) \
+    void SetStatic##JAVA_TYPE##Field(jclass clazz, jfieldID fieldID, CPP_TYPE val) \
+    { functions->SetStatic##JAVA_TYPE##Field(this, clazz, fieldID, val); }
+#define JNI_CPP_GEN_NEWARRAY(CPP_ARR_TYPE, JAVA_TYPE) \
+    CPP_ARR_TYPE New##JAVA_TYPE##Array(jsize len) \
+    { return functions->New##JAVA_TYPE##Array(this, len); }
+#define JNI_CPP_GEN_GETARRAYELEMENTS(CPP_TYPE, CPP_ARR_TYPE, JAVA_TYPE) \
+    CPP_TYPE* Get##JAVA_TYPE##ArrayElements(CPP_ARR_TYPE array, jboolean *isCopy) \
+    { return functions->Get##JAVA_TYPE##ArrayElements(this, array, isCopy); }
+#define JNI_CPP_GEN_RELEASEARRAYELEMENTS(CPP_TYPE, CPP_ARR_TYPE, JAVA_TYPE) \
+    void Release##JAVA_TYPE##ArrayElements(CPP_ARR_TYPE array, CPP_TYPE* elems, jint mode) \
+    { functions->Release##JAVA_TYPE##ArrayElements(this, array, elems, mode); }
+#define JNI_CPP_GEN_GETARRAYREGION(CPP_TYPE, CPP_ARR_TYPE, JAVA_TYPE) \
+    void Get##JAVA_TYPE##ArrayRegion(CPP_ARR_TYPE array, jsize start, jsize len, CPP_TYPE* buf) \
+    { functions->Get##JAVA_TYPE##ArrayRegion(this, array, start, len, buf); }
+#define JNI_CPP_GEN_SETARRAYREGION(CPP_TYPE, CPP_ARR_TYPE, JAVA_TYPE) \
+    void Set##JAVA_TYPE##ArrayRegion(CPP_ARR_TYPE array, jsize start, jsize len, const CPP_TYPE* buf) \
+    { functions->Set##JAVA_TYPE##ArrayRegion(this, array, start, len, buf); }
+#define JNI_CPP_GEN_CALLS_FIELDS(CPP_TYPE, JAVA_TYPE) \
+    JNI_CPP_GEN_CALL(CPP_TYPE, JAVA_TYPE) \
+    JNI_CPP_GEN_NONVIRT_CALL(CPP_TYPE, JAVA_TYPE) \
+    JNI_CPP_GEN_GETFIELD(CPP_TYPE, JAVA_TYPE) \
+    JNI_CPP_GEN_SETFIELD(CPP_TYPE, JAVA_TYPE) \
+    JNI_CPP_GEN_STATIC_CALL(CPP_TYPE, JAVA_TYPE) \
+    JNI_CPP_GEN_GETSTATICFIELD(CPP_TYPE, JAVA_TYPE) \
+    JNI_CPP_GEN_SETSTATICFIELD(CPP_TYPE, JAVA_TYPE)
+#define JNI_CPP_GEN_ARRAYS(CPP_TYPE, CPP_ARR_TYPE, JAVA_TYPE) \
+    JNI_CPP_GEN_NEWARRAY(CPP_ARR_TYPE, JAVA_TYPE) \
+    JNI_CPP_GEN_GETARRAYELEMENTS(CPP_TYPE, CPP_ARR_TYPE, JAVA_TYPE) \
+    JNI_CPP_GEN_RELEASEARRAYELEMENTS(CPP_TYPE, CPP_ARR_TYPE, JAVA_TYPE) \
+    JNI_CPP_GEN_GETARRAYREGION(CPP_TYPE, CPP_ARR_TYPE, JAVA_TYPE) \
+    JNI_CPP_GEN_SETARRAYREGION(CPP_TYPE, CPP_ARR_TYPE, JAVA_TYPE)
+    JNI_CPP_GEN_CALLS_FIELDS(jobject, Object)
+    JNI_CPP_GEN_CALLS_FIELDS(jboolean, Boolean)
+    JNI_CPP_GEN_CALLS_FIELDS(jbyte, Byte)
+    JNI_CPP_GEN_CALLS_FIELDS(jchar, Char)
+    JNI_CPP_GEN_CALLS_FIELDS(jshort, Short)
+    JNI_CPP_GEN_CALLS_FIELDS(jint, Int)
+    JNI_CPP_GEN_CALLS_FIELDS(jlong, Long)
+    JNI_CPP_GEN_CALLS_FIELDS(jfloat, Float)
+    JNI_CPP_GEN_CALLS_FIELDS(jdouble, Double)
+    JNI_CPP_GEN_ARRAYS(jboolean, jbooleanArray, Boolean)
+    JNI_CPP_GEN_ARRAYS(jbyte, jbyteArray, Byte)
+    JNI_CPP_GEN_ARRAYS(jchar, jcharArray, Char)
+    JNI_CPP_GEN_ARRAYS(jshort, jshortArray, Short)
+    JNI_CPP_GEN_ARRAYS(jint, jintArray, Int)
+    JNI_CPP_GEN_ARRAYS(jlong, jlongArray, Long)
+    JNI_CPP_GEN_ARRAYS(jfloat, jfloatArray, Float)
+    JNI_CPP_GEN_ARRAYS(jdouble, jdoubleArray, Double)
+#endif /* __cplusplus */
+};
+
+typedef struct JavaVMOption {
+    char *optionString;
+    void *extraInfo;
+} JavaVMOption;
+
+typedef struct JavaVMInitArgs {
+    jint version;
+    jint nOptions;
+    JavaVMOption *options;
+    jboolean ignoreUnrecognized;
+} JavaVMInitArgs;
+
+typedef struct JavaVMAttachArgs {
+    jint version;
+    char *name;
+    jobject group;
+} JavaVMAttachArgs;
+
+struct JNIInvokeInterface_ {
+    void *reserved0;
+    void *reserved1;
+    void *reserved2;
+    jint (JNICALL *DestroyJavaVM)(JavaVM *vm);
+    jint (JNICALL *AttachCurrentThread)(JavaVM *vm, void **penv, void *args);
+    jint (JNICALL *DetachCurrentThread)(JavaVM *vm);
+    jint (JNICALL *GetEnv)(JavaVM *vm, void **penv, jint version);
+    jint (JNICALL *AttachCurrentThreadAsDaemon)(JavaVM *vm, void **penv, void *args);
+};
+
+struct JavaVM_ {
+    const struct JNIInvokeInterface_ *functions;
+#ifdef __cplusplus
+    jint DestroyJavaVM()
+    { return functions->DestroyJavaVM(this); }
+    jint AttachCurrentThread(void **penv, void *args)
+    { return functions->AttachCurrentThread(this, penv, args); }
+    jint DetachCurrentThread()
+    { return functions->DetachCurrentThread(this); }
+    jint GetEnv(void **penv, jint version)
+    { return functions->GetEnv(this, penv, version); }
+    jint AttachCurrentThreadAsDaemon(void **penv, void *args)
+    { return functions->AttachCurrentThreadAsDaemon(this, penv, args); }
+#endif
+};
+
+JNIIMPORT jint JNICALL JNI_GetDefaultJavaVMInitArgs(void *args);
+JNIIMPORT jint JNICALL JNI_CreateJavaVM(JavaVM **pvm, void **penv, void *args);
+JNIIMPORT jint JNICALL JNI_GetCreatedJavaVMs(JavaVM **, jsize, jsize *);
+
+/* Defined by native libraries. */
+JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *vm, void *reserved);
+JNIEXPORT void JNICALL JNI_OnUnload(JavaVM *vm, void *reserved);
+
+#ifdef __cplusplus
+} /* extern "C" */
+#endif /* __cplusplus */
+
+#endif /* !_JAVASOFT_JNI_H_ */
diff --git a/app/src/main/java/libengine/RVVM/src/bindings/libretro/libretro.c b/app/src/main/java/libengine/RVVM/src/bindings/libretro/libretro.c
new file mode 100644
index 00000000..69d86a36
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/bindings/libretro/libretro.c
@@ -0,0 +1,539 @@
+/*
+libretro.c - RVVM libretro core
+Copyright (C) 2023  宋文武 <iyzsong@envs.net>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include <stdarg.h>
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <libgen.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include "libretro.h"
+
+// RVVM headers
+#include "../../rvvmlib.h"
+#include "../../utils.h"
+#include "../../devices/clint.h"
+#include "../../devices/plic.h"
+#include "../../devices/syscon.h"
+#include "../../devices/rtc-goldfish.h"
+#include "../../devices/pci-bus.h"
+#include "../../devices/nvme.h"
+#include "../../devices/framebuffer.h"
+#include "../../devices/i2c-oc.h"
+#include "../../devices/hid_api.h"
+#include "../../devices/ns16550a.h"
+#include "../../devices/chardev.h"
+#include "../../devices/rtl8169.h"
+
+static void fallback_log(enum retro_log_level level, const char *fmt, ...);
+static retro_log_printf_t log_cb = fallback_log;
+static retro_video_refresh_t video_cb;
+static retro_input_poll_t input_poll_cb;
+static retro_input_state_t input_state_cb;
+static retro_environment_t environ_cb;
+static rvvm_machine_t *machine;
+static fb_ctx_t vm_fb;
+static hid_keyboard_t *vm_keyboard;
+static hid_mouse_t *vm_mouse;
+#define NVME_MAX 4
+static struct {
+    size_t smp;
+    size_t mem;
+    bool rv64;
+    char bootrom[PATH_MAX];
+    char kernel[PATH_MAX];
+    char nvme[NVME_MAX][PATH_MAX];
+    char cmdline[1024];
+    uint32_t fb_width;
+    uint32_t fb_height;
+} machine_opts = {
+    .smp = 1,
+    .mem = 256,
+    .rv64 = true,
+    .bootrom = {0},
+    .kernel = {0},
+    .nvme = {{0}},
+    .cmdline = "root=/dev/nvme0n1 rootflags=discard rw console=tty0",
+    .fb_width = 640,
+    .fb_height = 480,
+};
+
+static void fallback_log(enum retro_log_level level, const char *fmt, ...)
+{
+  (void)level;
+  va_list va;
+  va_start(va, fmt);
+  vfprintf(stderr, fmt, va);
+  va_end(va);
+}
+
+static void error_msg(const char *msg)
+{
+    struct retro_message x = {
+        .msg = msg,
+        .frames = 180,
+    };
+    environ_cb(RETRO_ENVIRONMENT_SET_MESSAGE, &x);
+}
+
+unsigned retro_api_version(void)
+{
+    return RETRO_API_VERSION;
+}
+
+static hid_key_t retrok_to_hid(unsigned keycode)
+{
+    static const hid_key_t kbmap[] = {
+        [RETROK_a] = HID_KEY_A,
+        [RETROK_b] = HID_KEY_B,
+        [RETROK_c] = HID_KEY_C,
+        [RETROK_d] = HID_KEY_D,
+        [RETROK_e] = HID_KEY_E,
+        [RETROK_f] = HID_KEY_F,
+        [RETROK_g] = HID_KEY_G,
+        [RETROK_h] = HID_KEY_H,
+        [RETROK_i] = HID_KEY_I,
+        [RETROK_j] = HID_KEY_J,
+        [RETROK_k] = HID_KEY_K,
+        [RETROK_l] = HID_KEY_L,
+        [RETROK_m] = HID_KEY_M,
+        [RETROK_n] = HID_KEY_N,
+        [RETROK_o] = HID_KEY_O,
+        [RETROK_p] = HID_KEY_P,
+        [RETROK_q] = HID_KEY_Q,
+        [RETROK_r] = HID_KEY_R,
+        [RETROK_s] = HID_KEY_S,
+        [RETROK_t] = HID_KEY_T,
+        [RETROK_u] = HID_KEY_U,
+        [RETROK_v] = HID_KEY_V,
+        [RETROK_w] = HID_KEY_W,
+        [RETROK_x] = HID_KEY_X,
+        [RETROK_y] = HID_KEY_Y,
+        [RETROK_z] = HID_KEY_Z,
+        [RETROK_0] = HID_KEY_0,
+        [RETROK_1] = HID_KEY_1,
+        [RETROK_2] = HID_KEY_2,
+        [RETROK_3] = HID_KEY_3,
+        [RETROK_4] = HID_KEY_4,
+        [RETROK_5] = HID_KEY_5,
+        [RETROK_6] = HID_KEY_6,
+        [RETROK_7] = HID_KEY_7,
+        [RETROK_8] = HID_KEY_8,
+        [RETROK_9] = HID_KEY_9,
+        [RETROK_RETURN] = HID_KEY_ENTER,
+        [RETROK_ESCAPE] = HID_KEY_ESC,
+        [RETROK_BACKSPACE] = HID_KEY_BACKSPACE,
+        [RETROK_TAB] = HID_KEY_TAB,
+        [RETROK_SPACE] = HID_KEY_SPACE,
+        [RETROK_MINUS] = HID_KEY_MINUS,
+        [RETROK_EQUALS] = HID_KEY_EQUAL,
+        [RETROK_LEFTBRACKET] = HID_KEY_LEFTBRACE,
+        [RETROK_RIGHTBRACKET] = HID_KEY_RIGHTBRACE,
+        [RETROK_BACKSLASH] = HID_KEY_BACKSLASH,
+        [RETROK_SEMICOLON] = HID_KEY_SEMICOLON,
+        [RETROK_QUOTE] = HID_KEY_APOSTROPHE,
+        [RETROK_BACKQUOTE] = HID_KEY_GRAVE,
+        [RETROK_COMMA] = HID_KEY_COMMA,
+        [RETROK_PERIOD] = HID_KEY_DOT,
+        [RETROK_SLASH] = HID_KEY_SLASH,
+        [RETROK_CAPSLOCK] = HID_KEY_CAPSLOCK,
+        [RETROK_LCTRL] = HID_KEY_LEFTCTRL,
+        [RETROK_LSHIFT] = HID_KEY_LEFTSHIFT,
+        [RETROK_LALT] = HID_KEY_LEFTALT,
+        [RETROK_LMETA] = HID_KEY_LEFTMETA,
+        [RETROK_RCTRL] = HID_KEY_RIGHTCTRL,
+        [RETROK_RSHIFT] = HID_KEY_RIGHTSHIFT,
+        [RETROK_RALT] = HID_KEY_RIGHTALT,
+        [RETROK_RMETA] = HID_KEY_RIGHTMETA,
+        [RETROK_F1] = HID_KEY_F1,
+        [RETROK_F2] = HID_KEY_F2,
+        [RETROK_F3] = HID_KEY_F3,
+        [RETROK_F4] = HID_KEY_F4,
+        [RETROK_F5] = HID_KEY_F5,
+        [RETROK_F6] = HID_KEY_F6,
+        [RETROK_F7] = HID_KEY_F7,
+        [RETROK_F8] = HID_KEY_F8,
+        [RETROK_F9] = HID_KEY_F9,
+        [RETROK_F10] = HID_KEY_F10,
+        [RETROK_F11] = HID_KEY_F11,
+        [RETROK_F12] = HID_KEY_F12,
+        [RETROK_SYSREQ] = HID_KEY_SYSRQ,
+        [RETROK_SCROLLOCK] = HID_KEY_SCROLLLOCK,
+        [RETROK_PAUSE] = HID_KEY_PAUSE,
+        [RETROK_INSERT] = HID_KEY_INSERT,
+        [RETROK_HOME] = HID_KEY_HOME,
+        [RETROK_PAGEUP] = HID_KEY_PAGEUP,
+        [RETROK_DELETE] = HID_KEY_DELETE,
+        [RETROK_END] = HID_KEY_END,
+        [RETROK_PAGEDOWN] = HID_KEY_PAGEDOWN,
+        [RETROK_RIGHT] = HID_KEY_RIGHT,
+        [RETROK_LEFT] = HID_KEY_LEFT,
+        [RETROK_DOWN] = HID_KEY_DOWN,
+        [RETROK_UP] = HID_KEY_UP,
+        [RETROK_NUMLOCK] = HID_KEY_NUMLOCK,
+        [RETROK_KP_DIVIDE] = HID_KEY_KPSLASH,
+        [RETROK_KP_MULTIPLY] = HID_KEY_KPASTERISK,
+        [RETROK_KP_MINUS] = HID_KEY_KPMINUS,
+        [RETROK_KP_PLUS] = HID_KEY_KPPLUS,
+        [RETROK_KP_ENTER] = HID_KEY_KPENTER,
+        [RETROK_KP1] = HID_KEY_KP1,
+        [RETROK_KP2] = HID_KEY_KP2,
+        [RETROK_KP3] = HID_KEY_KP3,
+        [RETROK_KP4] = HID_KEY_KP4,
+        [RETROK_KP5] = HID_KEY_KP5,
+        [RETROK_KP6] = HID_KEY_KP6,
+        [RETROK_KP7] = HID_KEY_KP7,
+        [RETROK_KP8] = HID_KEY_KP8,
+        [RETROK_KP9] = HID_KEY_KP9,
+        [RETROK_KP0] = HID_KEY_KP0,
+        [RETROK_KP_PERIOD] = HID_KEY_KPDOT,
+        [RETROK_MENU] = HID_KEY_MENU,
+    };
+    return (keycode < sizeof(kbmap)) ? kbmap[keycode] : HID_KEY_NONE;
+}
+
+static void keyboard_cb(bool down, unsigned keycode,
+                        uint32_t character, uint16_t key_modifiers)
+{
+    UNUSED(character);
+    UNUSED(key_modifiers);
+    hid_key_t key = retrok_to_hid(keycode);
+    if (down)
+        hid_keyboard_press(vm_keyboard, key);
+    else
+        hid_keyboard_release(vm_keyboard, key);
+}
+
+void retro_set_environment(retro_environment_t cb)
+{
+    static struct retro_log_callback log;
+    static struct retro_keyboard_callback kbd = {
+        .callback = keyboard_cb,
+    };
+    environ_cb = cb;
+    if (environ_cb(RETRO_ENVIRONMENT_GET_LOG_INTERFACE, &log))
+        log_cb = log.log;
+
+    environ_cb(RETRO_ENVIRONMENT_SET_KEYBOARD_CALLBACK, &kbd);
+}
+
+void retro_set_video_refresh(retro_video_refresh_t cb)
+{
+    video_cb = cb;
+}
+
+void retro_set_audio_sample(retro_audio_sample_t cb)
+{
+    UNUSED(cb);
+}
+
+void retro_set_audio_sample_batch(retro_audio_sample_batch_t cb)
+{
+    UNUSED(cb);
+}
+
+void retro_set_input_poll(retro_input_poll_t cb)
+{
+    input_poll_cb = cb;
+}
+
+void retro_set_input_state(retro_input_state_t cb)
+{
+    input_state_cb = cb;
+}
+
+void retro_get_system_info(struct retro_system_info *info)
+{
+    info->need_fullpath = true;
+    info->valid_extensions = "rvvm";
+    info->library_version = "0.6-git";
+    info->library_name = "RVVM";
+    info->block_extract = false;
+}
+
+void retro_get_system_av_info(struct retro_system_av_info *info)
+{
+    info->geometry.base_width = machine_opts.fb_width;
+    info->geometry.base_height = machine_opts.fb_height;
+    info->geometry.max_width = machine_opts.fb_width;
+    info->geometry.max_height = machine_opts.fb_height;
+    info->geometry.aspect_ratio = (machine_opts.fb_width * 1.0) / machine_opts.fb_height;
+    info->timing.fps = 60.0;
+    info->timing.sample_rate = 44100.0;
+}
+
+void retro_init(void)
+{
+    enum retro_pixel_format pixfmt = RETRO_PIXEL_FORMAT_XRGB8888;
+    environ_cb(RETRO_ENVIRONMENT_SET_PIXEL_FORMAT, &pixfmt);
+}
+
+static void vm_init(void)
+{
+    machine = rvvm_create_machine(RVVM_DEFAULT_MEMBASE, machine_opts.mem << 20, machine_opts.smp, machine_opts.rv64);
+    vm_fb.width = machine_opts.fb_width;
+    vm_fb.height = machine_opts.fb_height;
+    vm_fb.format = RGB_FMT_A8R8G8B8;
+    vm_fb.buffer = safe_malloc(framebuffer_size(&vm_fb));
+    clint_init_auto(machine);
+    plic_init_auto(machine);
+    pci_bus_init_auto(machine);
+    rtc_goldfish_init_auto(machine);
+    i2c_oc_init_auto(machine);
+    syscon_init_auto(machine);
+    framebuffer_init_auto(machine, &vm_fb);
+    ns16550a_init_auto(machine, NULL);
+#ifdef USE_NET
+    rtl8169_init_auto(machine);
+#endif
+    vm_keyboard = hid_keyboard_init_auto(machine);
+    vm_mouse = hid_mouse_init_auto(machine);
+    hid_mouse_resolution(vm_mouse, vm_fb.width, vm_fb.height);
+    if (rvvm_strlen(machine_opts.bootrom)) {
+        if (!rvvm_load_bootrom(machine, machine_opts.bootrom)) {
+            error_msg("RVVM: failed to load bootrom");
+        }
+    } else {
+        error_msg("RVVM: No bootrom");
+    }
+    if (rvvm_strlen(machine_opts.kernel) && !rvvm_load_kernel(machine, machine_opts.kernel)) {
+        error_msg("RVVM: failed to load kernel");
+    }
+    rvvm_set_cmdline(machine, machine_opts.cmdline);
+    for (int i = 0; i < NVME_MAX; ++i) {
+        if (rvvm_strlen(machine_opts.nvme[i])) {
+            log_cb(RETRO_LOG_INFO, "Mount nvme%d: %s\n", i, machine_opts.nvme[i]);
+            if (!nvme_init_auto(machine, machine_opts.nvme[i], true)) {
+                error_msg("RVVM: failed to mount nvme");
+            }
+        } else {
+            break;
+        }
+    }
+}
+
+bool retro_load_game(const struct retro_game_info *game)
+{
+    if (!game)
+        return false;
+
+    FILE *fp = fopen(game->path, "r");
+    if (fp == NULL) {
+        log_cb(RETRO_LOG_ERROR, "Failed to open %s: %s\n",
+               game->path, strerror(errno));
+        return false;
+    }
+
+    int nvme_idx = 0;
+    char *line = NULL;
+    size_t linesize = 0;
+    ssize_t linelen;
+    while ((linelen = getline(&line, &linesize, fp)) != -1) {
+        if (rvvm_strcmp(line, "rv64\n")) {
+            machine_opts.rv64 = true;
+            continue;
+        }
+        if (rvvm_strcmp(line, "rv32\n")) {
+            machine_opts.rv64 = false;
+            continue;
+        }
+        if (rvvm_strcmp(line, "\n")) {
+            continue;
+        }
+        char *k = strtok(line, "=");
+        if (k == NULL) {
+            log_cb(RETRO_LOG_ERROR, "Invalid option: %s\n", line);
+            continue;
+        }
+        char *v = strtok(NULL, "\n");
+        if (v == NULL) {
+            log_cb(RETRO_LOG_ERROR, "Invalid option: %s\n", line);
+            continue;
+        }
+        if (rvvm_strcmp(k, "mem")) {
+            machine_opts.mem = str_to_int_dec(v);
+            continue;
+        }
+        if (rvvm_strcmp(k, "smp")) {
+            machine_opts.smp = str_to_int_dec(v);
+            continue;
+        }
+        if (rvvm_strcmp(k, "bootrom")) {
+            size_t len = sizeof(machine_opts.bootrom);
+            memset(machine_opts.bootrom, 0, len);
+            memcpy(machine_opts.bootrom, v, strnlen(v, len-1));
+            continue;
+        }
+        if (rvvm_strcmp(k, "kernel")) {
+            size_t len = sizeof(machine_opts.kernel);
+            memset(machine_opts.kernel, 0, len);
+            memcpy(machine_opts.kernel, v, strnlen(v, len-1));
+            continue;
+        }
+        if (rvvm_strcmp(k, "nvme")) {
+            size_t len = sizeof(machine_opts.nvme[0]);
+            if (nvme_idx == NVME_MAX) {
+                log_cb(RETRO_LOG_ERROR, "Failed to mount %s as nvme, only %d devices are allowed\n", v, NVME_MAX);
+                continue;
+            }
+            char *nvme = machine_opts.nvme[nvme_idx++];
+            memset(nvme, 0, len);
+            memcpy(nvme, v, strnlen(v, len-1));
+            continue;
+        }
+        if (rvvm_strcmp(k, "cmdline")) {
+            size_t len = sizeof(machine_opts.cmdline);
+            memset(machine_opts.cmdline, 0, len);
+            memcpy(machine_opts.cmdline, v, strnlen(v, len-1));
+            continue;
+        }
+        log_cb(RETRO_LOG_ERROR, "Invalid option: %s\n", line);
+    }
+    free(line);
+    if (ferror(fp)) {
+        log_cb(RETRO_LOG_ERROR, "Failed to read %s\n", game->path);
+        return false;
+    }
+    fclose(fp);
+
+    char cwd[1024];
+    rvvm_strlcpy(cwd, game->path, sizeof(cwd));
+    chdir(dirname(cwd));
+    vm_init();
+    return rvvm_start_machine(machine);
+}
+
+void retro_set_controller_port_device(unsigned port, unsigned device)
+{
+    UNUSED(port);
+    UNUSED(device);
+}
+
+void retro_deinit(void)
+{
+}
+
+void retro_reset(void)
+{
+    rvvm_reset_machine(machine, true);
+}
+
+static void mouse_update()
+{
+    static bool left_pressed = false;
+    static bool right_pressed = false;
+    static bool middle_pressed = false;
+    int16_t x = input_state_cb(0, RETRO_DEVICE_MOUSE, 0, RETRO_DEVICE_ID_MOUSE_X);
+    int16_t y = input_state_cb(0, RETRO_DEVICE_MOUSE, 0, RETRO_DEVICE_ID_MOUSE_Y);
+    int16_t left = input_state_cb(0, RETRO_DEVICE_MOUSE, 0, RETRO_DEVICE_ID_MOUSE_LEFT);
+    int16_t right = input_state_cb(0, RETRO_DEVICE_MOUSE, 0, RETRO_DEVICE_ID_MOUSE_RIGHT);
+    int16_t middle = input_state_cb(0, RETRO_DEVICE_MOUSE, 0, RETRO_DEVICE_ID_MOUSE_MIDDLE);
+    if (x || y)
+        hid_mouse_move(vm_mouse, x, y);
+    if (left && !left_pressed) {
+        hid_mouse_press(vm_mouse, HID_BTN_LEFT);
+        left_pressed = true;
+    }
+    if (right && !right_pressed) {
+        hid_mouse_press(vm_mouse, HID_BTN_RIGHT);
+        right_pressed = true;
+    }
+    if (middle && !middle_pressed) {
+        hid_mouse_press(vm_mouse, HID_BTN_MIDDLE);
+        middle_pressed = true;
+    }
+    if (!left && left_pressed) {
+        hid_mouse_release(vm_mouse, HID_BTN_LEFT);
+        left_pressed = false;
+    }
+    if (!right && right_pressed) {
+        hid_mouse_release(vm_mouse, HID_BTN_RIGHT);
+        right_pressed = false;
+    }
+    if (!middle && middle_pressed) {
+        hid_mouse_release(vm_mouse, HID_BTN_MIDDLE);
+        middle_pressed = false;
+    }
+}
+
+void retro_run(void)
+{
+    input_poll_cb();
+    mouse_update();
+    video_cb(vm_fb.buffer, vm_fb.width, vm_fb.height, vm_fb.width * 4);
+}
+
+size_t retro_serialize_size(void)
+{
+    return 0;
+}
+
+bool retro_serialize(void *data, size_t size)
+{
+    UNUSED(data);
+    UNUSED(size);
+    return false;
+}
+
+bool retro_unserialize(const void *data, size_t size)
+{
+    UNUSED(data);
+    UNUSED(size);
+    return false;
+}
+
+void retro_cheat_reset(void) {}
+void retro_cheat_set(unsigned index, bool enabled, const char *code)
+{
+    UNUSED(index);
+    UNUSED(enabled);
+    UNUSED(code);
+}
+
+bool retro_load_game_special(unsigned game_type, const struct retro_game_info *info, size_t num_info)
+{
+    UNUSED(game_type);
+    UNUSED(info);
+    UNUSED(num_info);
+    return false;
+}
+
+void retro_unload_game(void)
+{
+    rvvm_reset_machine(machine, false);
+    rvvm_free_machine(machine);
+    free(vm_fb.buffer);
+}
+
+unsigned retro_get_region(void)
+{
+    return RETRO_REGION_NTSC;
+}
+
+void *retro_get_memory_data(unsigned id)
+{
+    UNUSED(id);
+    return 0;
+}
+
+size_t retro_get_memory_size(unsigned id)
+{
+    UNUSED(id);
+    return 0;
+}
diff --git a/app/src/main/java/libengine/RVVM/src/bindings/libretro/libretro.h b/app/src/main/java/libengine/RVVM/src/bindings/libretro/libretro.h
new file mode 100644
index 00000000..3d6df6f9
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/bindings/libretro/libretro.h
@@ -0,0 +1,3964 @@
+/* Copyright (C) 2010-2020 The RetroArch team
+ *
+ * ---------------------------------------------------------------------------------------
+ * The following license statement only applies to this libretro API header (libretro.h).
+ * ---------------------------------------------------------------------------------------
+ *
+ * Permission is hereby granted, free of charge,
+ * to any person obtaining a copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef LIBRETRO_H__
+#define LIBRETRO_H__
+
+#include <stdint.h>
+#include <stddef.h>
+#include <limits.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef __cplusplus
+#if defined(_MSC_VER) && _MSC_VER < 1800 && !defined(SN_TARGET_PS3)
+/* Hack applied for MSVC when compiling in C89 mode
+ * as it isn't C99-compliant. */
+#define bool unsigned char
+#define true 1
+#define false 0
+#else
+#include <stdbool.h>
+#endif
+#endif
+
+#ifndef RETRO_CALLCONV
+#  if defined(__GNUC__) && defined(__i386__) && !defined(__x86_64__)
+#    define RETRO_CALLCONV __attribute__((cdecl))
+#  elif defined(_MSC_VER) && defined(_M_X86) && !defined(_M_X64)
+#    define RETRO_CALLCONV __cdecl
+#  else
+#    define RETRO_CALLCONV /* all other platforms only have one calling convention each */
+#  endif
+#endif
+
+#ifndef RETRO_API
+#  if defined(_WIN32) || defined(__CYGWIN__) || defined(__MINGW32__)
+#    ifdef RETRO_IMPORT_SYMBOLS
+#      ifdef __GNUC__
+#        define RETRO_API RETRO_CALLCONV __attribute__((__dllimport__))
+#      else
+#        define RETRO_API RETRO_CALLCONV __declspec(dllimport)
+#      endif
+#    else
+#      ifdef __GNUC__
+#        define RETRO_API RETRO_CALLCONV __attribute__((__dllexport__))
+#      else
+#        define RETRO_API RETRO_CALLCONV __declspec(dllexport)
+#      endif
+#    endif
+#  else
+#      if defined(__GNUC__) && __GNUC__ >= 4
+#        define RETRO_API RETRO_CALLCONV __attribute__((__visibility__("default")))
+#      else
+#        define RETRO_API RETRO_CALLCONV
+#      endif
+#  endif
+#endif
+
+/* Used for checking API/ABI mismatches that can break libretro
+ * implementations.
+ * It is not incremented for compatible changes to the API.
+ */
+#define RETRO_API_VERSION         1
+
+/*
+ * Libretro's fundamental device abstractions.
+ *
+ * Libretro's input system consists of some standardized device types,
+ * such as a joypad (with/without analog), mouse, keyboard, lightgun
+ * and a pointer.
+ *
+ * The functionality of these devices are fixed, and individual cores
+ * map their own concept of a controller to libretro's abstractions.
+ * This makes it possible for frontends to map the abstract types to a
+ * real input device, and not having to worry about binding input
+ * correctly to arbitrary controller layouts.
+ */
+
+#define RETRO_DEVICE_TYPE_SHIFT         8
+#define RETRO_DEVICE_MASK               ((1 << RETRO_DEVICE_TYPE_SHIFT) - 1)
+#define RETRO_DEVICE_SUBCLASS(base, id) (((id + 1) << RETRO_DEVICE_TYPE_SHIFT) | base)
+
+/* Input disabled. */
+#define RETRO_DEVICE_NONE         0
+
+/* The JOYPAD is called RetroPad. It is essentially a Super Nintendo
+ * controller, but with additional L2/R2/L3/R3 buttons, similar to a
+ * PS1 DualShock. */
+#define RETRO_DEVICE_JOYPAD       1
+
+/* The mouse is a simple mouse, similar to Super Nintendo's mouse.
+ * X and Y coordinates are reported relatively to last poll (poll callback).
+ * It is up to the libretro implementation to keep track of where the mouse
+ * pointer is supposed to be on the screen.
+ * The frontend must make sure not to interfere with its own hardware
+ * mouse pointer.
+ */
+#define RETRO_DEVICE_MOUSE        2
+
+/* KEYBOARD device lets one poll for raw key pressed.
+ * It is poll based, so input callback will return with the current
+ * pressed state.
+ * For event/text based keyboard input, see
+ * RETRO_ENVIRONMENT_SET_KEYBOARD_CALLBACK.
+ */
+#define RETRO_DEVICE_KEYBOARD     3
+
+/* LIGHTGUN device is similar to Guncon-2 for PlayStation 2.
+ * It reports X/Y coordinates in screen space (similar to the pointer)
+ * in the range [-0x8000, 0x7fff] in both axes, with zero being center and
+ * -0x8000 being out of bounds.
+ * As well as reporting on/off screen state. It features a trigger,
+ * start/select buttons, auxiliary action buttons and a
+ * directional pad. A forced off-screen shot can be requested for
+ * auto-reloading function in some games.
+ */
+#define RETRO_DEVICE_LIGHTGUN     4
+
+/* The ANALOG device is an extension to JOYPAD (RetroPad).
+ * Similar to DualShock2 it adds two analog sticks and all buttons can
+ * be analog. This is treated as a separate device type as it returns
+ * axis values in the full analog range of [-0x7fff, 0x7fff],
+ * although some devices may return -0x8000.
+ * Positive X axis is right. Positive Y axis is down.
+ * Buttons are returned in the range [0, 0x7fff].
+ * Only use ANALOG type when polling for analog values.
+ */
+#define RETRO_DEVICE_ANALOG       5
+
+/* Abstracts the concept of a pointing mechanism, e.g. touch.
+ * This allows libretro to query in absolute coordinates where on the
+ * screen a mouse (or something similar) is being placed.
+ * For a touch centric device, coordinates reported are the coordinates
+ * of the press.
+ *
+ * Coordinates in X and Y are reported as:
+ * [-0x7fff, 0x7fff]: -0x7fff corresponds to the far left/top of the screen,
+ * and 0x7fff corresponds to the far right/bottom of the screen.
+ * The "screen" is here defined as area that is passed to the frontend and
+ * later displayed on the monitor.
+ *
+ * The frontend is free to scale/resize this screen as it sees fit, however,
+ * (X, Y) = (-0x7fff, -0x7fff) will correspond to the top-left pixel of the
+ * game image, etc.
+ *
+ * To check if the pointer coordinates are valid (e.g. a touch display
+ * actually being touched), PRESSED returns 1 or 0.
+ *
+ * If using a mouse on a desktop, PRESSED will usually correspond to the
+ * left mouse button, but this is a frontend decision.
+ * PRESSED will only return 1 if the pointer is inside the game screen.
+ *
+ * For multi-touch, the index variable can be used to successively query
+ * more presses.
+ * If index = 0 returns true for _PRESSED, coordinates can be extracted
+ * with _X, _Y for index = 0. One can then query _PRESSED, _X, _Y with
+ * index = 1, and so on.
+ * Eventually _PRESSED will return false for an index. No further presses
+ * are registered at this point. */
+#define RETRO_DEVICE_POINTER      6
+
+/* Buttons for the RetroPad (JOYPAD).
+ * The placement of these is equivalent to placements on the
+ * Super Nintendo controller.
+ * L2/R2/L3/R3 buttons correspond to the PS1 DualShock.
+ * Also used as id values for RETRO_DEVICE_INDEX_ANALOG_BUTTON */
+#define RETRO_DEVICE_ID_JOYPAD_B        0
+#define RETRO_DEVICE_ID_JOYPAD_Y        1
+#define RETRO_DEVICE_ID_JOYPAD_SELECT   2
+#define RETRO_DEVICE_ID_JOYPAD_START    3
+#define RETRO_DEVICE_ID_JOYPAD_UP       4
+#define RETRO_DEVICE_ID_JOYPAD_DOWN     5
+#define RETRO_DEVICE_ID_JOYPAD_LEFT     6
+#define RETRO_DEVICE_ID_JOYPAD_RIGHT    7
+#define RETRO_DEVICE_ID_JOYPAD_A        8
+#define RETRO_DEVICE_ID_JOYPAD_X        9
+#define RETRO_DEVICE_ID_JOYPAD_L       10
+#define RETRO_DEVICE_ID_JOYPAD_R       11
+#define RETRO_DEVICE_ID_JOYPAD_L2      12
+#define RETRO_DEVICE_ID_JOYPAD_R2      13
+#define RETRO_DEVICE_ID_JOYPAD_L3      14
+#define RETRO_DEVICE_ID_JOYPAD_R3      15
+
+#define RETRO_DEVICE_ID_JOYPAD_MASK    256
+
+/* Index / Id values for ANALOG device. */
+#define RETRO_DEVICE_INDEX_ANALOG_LEFT       0
+#define RETRO_DEVICE_INDEX_ANALOG_RIGHT      1
+#define RETRO_DEVICE_INDEX_ANALOG_BUTTON     2
+#define RETRO_DEVICE_ID_ANALOG_X             0
+#define RETRO_DEVICE_ID_ANALOG_Y             1
+
+/* Id values for MOUSE. */
+#define RETRO_DEVICE_ID_MOUSE_X                0
+#define RETRO_DEVICE_ID_MOUSE_Y                1
+#define RETRO_DEVICE_ID_MOUSE_LEFT             2
+#define RETRO_DEVICE_ID_MOUSE_RIGHT            3
+#define RETRO_DEVICE_ID_MOUSE_WHEELUP          4
+#define RETRO_DEVICE_ID_MOUSE_WHEELDOWN        5
+#define RETRO_DEVICE_ID_MOUSE_MIDDLE           6
+#define RETRO_DEVICE_ID_MOUSE_HORIZ_WHEELUP    7
+#define RETRO_DEVICE_ID_MOUSE_HORIZ_WHEELDOWN  8
+#define RETRO_DEVICE_ID_MOUSE_BUTTON_4         9
+#define RETRO_DEVICE_ID_MOUSE_BUTTON_5         10
+
+/* Id values for LIGHTGUN. */
+#define RETRO_DEVICE_ID_LIGHTGUN_SCREEN_X        13 /*Absolute Position*/
+#define RETRO_DEVICE_ID_LIGHTGUN_SCREEN_Y        14 /*Absolute*/
+#define RETRO_DEVICE_ID_LIGHTGUN_IS_OFFSCREEN    15 /*Status Check*/
+#define RETRO_DEVICE_ID_LIGHTGUN_TRIGGER          2
+#define RETRO_DEVICE_ID_LIGHTGUN_RELOAD          16 /*Forced off-screen shot*/
+#define RETRO_DEVICE_ID_LIGHTGUN_AUX_A            3
+#define RETRO_DEVICE_ID_LIGHTGUN_AUX_B            4
+#define RETRO_DEVICE_ID_LIGHTGUN_START            6
+#define RETRO_DEVICE_ID_LIGHTGUN_SELECT           7
+#define RETRO_DEVICE_ID_LIGHTGUN_AUX_C            8
+#define RETRO_DEVICE_ID_LIGHTGUN_DPAD_UP          9
+#define RETRO_DEVICE_ID_LIGHTGUN_DPAD_DOWN       10
+#define RETRO_DEVICE_ID_LIGHTGUN_DPAD_LEFT       11
+#define RETRO_DEVICE_ID_LIGHTGUN_DPAD_RIGHT      12
+/* deprecated */
+#define RETRO_DEVICE_ID_LIGHTGUN_X                0 /*Relative Position*/
+#define RETRO_DEVICE_ID_LIGHTGUN_Y                1 /*Relative*/
+#define RETRO_DEVICE_ID_LIGHTGUN_CURSOR           3 /*Use Aux:A*/
+#define RETRO_DEVICE_ID_LIGHTGUN_TURBO            4 /*Use Aux:B*/
+#define RETRO_DEVICE_ID_LIGHTGUN_PAUSE            5 /*Use Start*/
+
+/* Id values for POINTER. */
+#define RETRO_DEVICE_ID_POINTER_X         0
+#define RETRO_DEVICE_ID_POINTER_Y         1
+#define RETRO_DEVICE_ID_POINTER_PRESSED   2
+#define RETRO_DEVICE_ID_POINTER_COUNT     3
+
+/* Returned from retro_get_region(). */
+#define RETRO_REGION_NTSC  0
+#define RETRO_REGION_PAL   1
+
+/* Id values for LANGUAGE */
+enum retro_language
+{
+   RETRO_LANGUAGE_ENGLISH             = 0,
+   RETRO_LANGUAGE_JAPANESE            = 1,
+   RETRO_LANGUAGE_FRENCH              = 2,
+   RETRO_LANGUAGE_SPANISH             = 3,
+   RETRO_LANGUAGE_GERMAN              = 4,
+   RETRO_LANGUAGE_ITALIAN             = 5,
+   RETRO_LANGUAGE_DUTCH               = 6,
+   RETRO_LANGUAGE_PORTUGUESE_BRAZIL   = 7,
+   RETRO_LANGUAGE_PORTUGUESE_PORTUGAL = 8,
+   RETRO_LANGUAGE_RUSSIAN             = 9,
+   RETRO_LANGUAGE_KOREAN              = 10,
+   RETRO_LANGUAGE_CHINESE_TRADITIONAL = 11,
+   RETRO_LANGUAGE_CHINESE_SIMPLIFIED  = 12,
+   RETRO_LANGUAGE_ESPERANTO           = 13,
+   RETRO_LANGUAGE_POLISH              = 14,
+   RETRO_LANGUAGE_VIETNAMESE          = 15,
+   RETRO_LANGUAGE_ARABIC              = 16,
+   RETRO_LANGUAGE_GREEK               = 17,
+   RETRO_LANGUAGE_TURKISH             = 18,
+   RETRO_LANGUAGE_SLOVAK              = 19,
+   RETRO_LANGUAGE_PERSIAN             = 20,
+   RETRO_LANGUAGE_HEBREW              = 21,
+   RETRO_LANGUAGE_ASTURIAN            = 22,
+   RETRO_LANGUAGE_FINNISH             = 23,
+   RETRO_LANGUAGE_INDONESIAN          = 24,
+   RETRO_LANGUAGE_SWEDISH             = 25,
+   RETRO_LANGUAGE_UKRAINIAN           = 26,
+   RETRO_LANGUAGE_CZECH               = 27,
+   RETRO_LANGUAGE_CATALAN_VALENCIA    = 28,
+   RETRO_LANGUAGE_CATALAN             = 29,
+   RETRO_LANGUAGE_BRITISH_ENGLISH     = 30,
+   RETRO_LANGUAGE_HUNGARIAN           = 31,
+   RETRO_LANGUAGE_LAST,
+
+   /* Ensure sizeof(enum) == sizeof(int) */
+   RETRO_LANGUAGE_DUMMY          = INT_MAX
+};
+
+/* Passed to retro_get_memory_data/size().
+ * If the memory type doesn't apply to the
+ * implementation NULL/0 can be returned.
+ */
+#define RETRO_MEMORY_MASK        0xff
+
+/* Regular save RAM. This RAM is usually found on a game cartridge,
+ * backed up by a battery.
+ * If save game data is too complex for a single memory buffer,
+ * the SAVE_DIRECTORY (preferably) or SYSTEM_DIRECTORY environment
+ * callback can be used. */
+#define RETRO_MEMORY_SAVE_RAM    0
+
+/* Some games have a built-in clock to keep track of time.
+ * This memory is usually just a couple of bytes to keep track of time.
+ */
+#define RETRO_MEMORY_RTC         1
+
+/* System ram lets a frontend peek into a game systems main RAM. */
+#define RETRO_MEMORY_SYSTEM_RAM  2
+
+/* Video ram lets a frontend peek into a game systems video RAM (VRAM). */
+#define RETRO_MEMORY_VIDEO_RAM   3
+
+/* Keysyms used for ID in input state callback when polling RETRO_KEYBOARD. */
+enum retro_key
+{
+   RETROK_UNKNOWN        = 0,
+   RETROK_FIRST          = 0,
+   RETROK_BACKSPACE      = 8,
+   RETROK_TAB            = 9,
+   RETROK_CLEAR          = 12,
+   RETROK_RETURN         = 13,
+   RETROK_PAUSE          = 19,
+   RETROK_ESCAPE         = 27,
+   RETROK_SPACE          = 32,
+   RETROK_EXCLAIM        = 33,
+   RETROK_QUOTEDBL       = 34,
+   RETROK_HASH           = 35,
+   RETROK_DOLLAR         = 36,
+   RETROK_AMPERSAND      = 38,
+   RETROK_QUOTE          = 39,
+   RETROK_LEFTPAREN      = 40,
+   RETROK_RIGHTPAREN     = 41,
+   RETROK_ASTERISK       = 42,
+   RETROK_PLUS           = 43,
+   RETROK_COMMA          = 44,
+   RETROK_MINUS          = 45,
+   RETROK_PERIOD         = 46,
+   RETROK_SLASH          = 47,
+   RETROK_0              = 48,
+   RETROK_1              = 49,
+   RETROK_2              = 50,
+   RETROK_3              = 51,
+   RETROK_4              = 52,
+   RETROK_5              = 53,
+   RETROK_6              = 54,
+   RETROK_7              = 55,
+   RETROK_8              = 56,
+   RETROK_9              = 57,
+   RETROK_COLON          = 58,
+   RETROK_SEMICOLON      = 59,
+   RETROK_LESS           = 60,
+   RETROK_EQUALS         = 61,
+   RETROK_GREATER        = 62,
+   RETROK_QUESTION       = 63,
+   RETROK_AT             = 64,
+   RETROK_LEFTBRACKET    = 91,
+   RETROK_BACKSLASH      = 92,
+   RETROK_RIGHTBRACKET   = 93,
+   RETROK_CARET          = 94,
+   RETROK_UNDERSCORE     = 95,
+   RETROK_BACKQUOTE      = 96,
+   RETROK_a              = 97,
+   RETROK_b              = 98,
+   RETROK_c              = 99,
+   RETROK_d              = 100,
+   RETROK_e              = 101,
+   RETROK_f              = 102,
+   RETROK_g              = 103,
+   RETROK_h              = 104,
+   RETROK_i              = 105,
+   RETROK_j              = 106,
+   RETROK_k              = 107,
+   RETROK_l              = 108,
+   RETROK_m              = 109,
+   RETROK_n              = 110,
+   RETROK_o              = 111,
+   RETROK_p              = 112,
+   RETROK_q              = 113,
+   RETROK_r              = 114,
+   RETROK_s              = 115,
+   RETROK_t              = 116,
+   RETROK_u              = 117,
+   RETROK_v              = 118,
+   RETROK_w              = 119,
+   RETROK_x              = 120,
+   RETROK_y              = 121,
+   RETROK_z              = 122,
+   RETROK_LEFTBRACE      = 123,
+   RETROK_BAR            = 124,
+   RETROK_RIGHTBRACE     = 125,
+   RETROK_TILDE          = 126,
+   RETROK_DELETE         = 127,
+
+   RETROK_KP0            = 256,
+   RETROK_KP1            = 257,
+   RETROK_KP2            = 258,
+   RETROK_KP3            = 259,
+   RETROK_KP4            = 260,
+   RETROK_KP5            = 261,
+   RETROK_KP6            = 262,
+   RETROK_KP7            = 263,
+   RETROK_KP8            = 264,
+   RETROK_KP9            = 265,
+   RETROK_KP_PERIOD      = 266,
+   RETROK_KP_DIVIDE      = 267,
+   RETROK_KP_MULTIPLY    = 268,
+   RETROK_KP_MINUS       = 269,
+   RETROK_KP_PLUS        = 270,
+   RETROK_KP_ENTER       = 271,
+   RETROK_KP_EQUALS      = 272,
+
+   RETROK_UP             = 273,
+   RETROK_DOWN           = 274,
+   RETROK_RIGHT          = 275,
+   RETROK_LEFT           = 276,
+   RETROK_INSERT         = 277,
+   RETROK_HOME           = 278,
+   RETROK_END            = 279,
+   RETROK_PAGEUP         = 280,
+   RETROK_PAGEDOWN       = 281,
+
+   RETROK_F1             = 282,
+   RETROK_F2             = 283,
+   RETROK_F3             = 284,
+   RETROK_F4             = 285,
+   RETROK_F5             = 286,
+   RETROK_F6             = 287,
+   RETROK_F7             = 288,
+   RETROK_F8             = 289,
+   RETROK_F9             = 290,
+   RETROK_F10            = 291,
+   RETROK_F11            = 292,
+   RETROK_F12            = 293,
+   RETROK_F13            = 294,
+   RETROK_F14            = 295,
+   RETROK_F15            = 296,
+
+   RETROK_NUMLOCK        = 300,
+   RETROK_CAPSLOCK       = 301,
+   RETROK_SCROLLOCK      = 302,
+   RETROK_RSHIFT         = 303,
+   RETROK_LSHIFT         = 304,
+   RETROK_RCTRL          = 305,
+   RETROK_LCTRL          = 306,
+   RETROK_RALT           = 307,
+   RETROK_LALT           = 308,
+   RETROK_RMETA          = 309,
+   RETROK_LMETA          = 310,
+   RETROK_LSUPER         = 311,
+   RETROK_RSUPER         = 312,
+   RETROK_MODE           = 313,
+   RETROK_COMPOSE        = 314,
+
+   RETROK_HELP           = 315,
+   RETROK_PRINT          = 316,
+   RETROK_SYSREQ         = 317,
+   RETROK_BREAK          = 318,
+   RETROK_MENU           = 319,
+   RETROK_POWER          = 320,
+   RETROK_EURO           = 321,
+   RETROK_UNDO           = 322,
+   RETROK_OEM_102        = 323,
+
+   RETROK_LAST,
+
+   RETROK_DUMMY          = INT_MAX /* Ensure sizeof(enum) == sizeof(int) */
+};
+
+enum retro_mod
+{
+   RETROKMOD_NONE       = 0x0000,
+
+   RETROKMOD_SHIFT      = 0x01,
+   RETROKMOD_CTRL       = 0x02,
+   RETROKMOD_ALT        = 0x04,
+   RETROKMOD_META       = 0x08,
+
+   RETROKMOD_NUMLOCK    = 0x10,
+   RETROKMOD_CAPSLOCK   = 0x20,
+   RETROKMOD_SCROLLOCK  = 0x40,
+
+   RETROKMOD_DUMMY = INT_MAX /* Ensure sizeof(enum) == sizeof(int) */
+};
+
+/* If set, this call is not part of the public libretro API yet. It can
+ * change or be removed at any time. */
+#define RETRO_ENVIRONMENT_EXPERIMENTAL 0x10000
+/* Environment callback to be used internally in frontend. */
+#define RETRO_ENVIRONMENT_PRIVATE 0x20000
+
+/* Environment commands. */
+#define RETRO_ENVIRONMENT_SET_ROTATION  1  /* const unsigned * --
+                                            * Sets screen rotation of graphics.
+                                            * Valid values are 0, 1, 2, 3, which rotates screen by 0, 90, 180,
+                                            * 270 degrees counter-clockwise respectively.
+                                            */
+#define RETRO_ENVIRONMENT_GET_OVERSCAN  2  /* bool * --
+                                            * NOTE: As of 2019 this callback is considered deprecated in favor of
+                                            * using core options to manage overscan in a more nuanced, core-specific way.
+                                            *
+                                            * Boolean value whether or not the implementation should use overscan,
+                                            * or crop away overscan.
+                                            */
+#define RETRO_ENVIRONMENT_GET_CAN_DUPE  3  /* bool * --
+                                            * Boolean value whether or not frontend supports frame duping,
+                                            * passing NULL to video frame callback.
+                                            */
+
+                                           /* Environ 4, 5 are no longer supported (GET_VARIABLE / SET_VARIABLES),
+                                            * and reserved to avoid possible ABI clash.
+                                            */
+
+#define RETRO_ENVIRONMENT_SET_MESSAGE   6  /* const struct retro_message * --
+                                            * Sets a message to be displayed in implementation-specific manner
+                                            * for a certain amount of 'frames'.
+                                            * Should not be used for trivial messages, which should simply be
+                                            * logged via RETRO_ENVIRONMENT_GET_LOG_INTERFACE (or as a
+                                            * fallback, stderr).
+                                            */
+#define RETRO_ENVIRONMENT_SHUTDOWN      7  /* N/A (NULL) --
+                                            * Requests the frontend to shutdown.
+                                            * Should only be used if game has a specific
+                                            * way to shutdown the game from a menu item or similar.
+                                            */
+#define RETRO_ENVIRONMENT_SET_PERFORMANCE_LEVEL 8
+                                           /* const unsigned * --
+                                            * Gives a hint to the frontend how demanding this implementation
+                                            * is on a system. E.g. reporting a level of 2 means
+                                            * this implementation should run decently on all frontends
+                                            * of level 2 and up.
+                                            *
+                                            * It can be used by the frontend to potentially warn
+                                            * about too demanding implementations.
+                                            *
+                                            * The levels are "floating".
+                                            *
+                                            * This function can be called on a per-game basis,
+                                            * as certain games an implementation can play might be
+                                            * particularly demanding.
+                                            * If called, it should be called in retro_load_game().
+                                            */
+#define RETRO_ENVIRONMENT_GET_SYSTEM_DIRECTORY 9
+                                           /* const char ** --
+                                            * Returns the "system" directory of the frontend.
+                                            * This directory can be used to store system specific
+                                            * content such as BIOSes, configuration data, etc.
+                                            * The returned value can be NULL.
+                                            * If so, no such directory is defined,
+                                            * and it's up to the implementation to find a suitable directory.
+                                            *
+                                            * NOTE: Some cores used this folder also for "save" data such as
+                                            * memory cards, etc, for lack of a better place to put it.
+                                            * This is now discouraged, and if possible, cores should try to
+                                            * use the new GET_SAVE_DIRECTORY.
+                                            */
+#define RETRO_ENVIRONMENT_SET_PIXEL_FORMAT 10
+                                           /* const enum retro_pixel_format * --
+                                            * Sets the internal pixel format used by the implementation.
+                                            * The default pixel format is RETRO_PIXEL_FORMAT_0RGB1555.
+                                            * This pixel format however, is deprecated (see enum retro_pixel_format).
+                                            * If the call returns false, the frontend does not support this pixel
+                                            * format.
+                                            *
+                                            * This function should be called inside retro_load_game() or
+                                            * retro_get_system_av_info().
+                                            */
+#define RETRO_ENVIRONMENT_SET_INPUT_DESCRIPTORS 11
+                                           /* const struct retro_input_descriptor * --
+                                            * Sets an array of retro_input_descriptors.
+                                            * It is up to the frontend to present this in a usable way.
+                                            * The array is terminated by retro_input_descriptor::description
+                                            * being set to NULL.
+                                            * This function can be called at any time, but it is recommended
+                                            * to call it as early as possible.
+                                            */
+#define RETRO_ENVIRONMENT_SET_KEYBOARD_CALLBACK 12
+                                           /* const struct retro_keyboard_callback * --
+                                            * Sets a callback function used to notify core about keyboard events.
+                                            */
+#define RETRO_ENVIRONMENT_SET_DISK_CONTROL_INTERFACE 13
+                                           /* const struct retro_disk_control_callback * --
+                                            * Sets an interface which frontend can use to eject and insert
+                                            * disk images.
+                                            * This is used for games which consist of multiple images and
+                                            * must be manually swapped out by the user (e.g. PSX).
+                                            */
+#define RETRO_ENVIRONMENT_SET_HW_RENDER 14
+                                           /* struct retro_hw_render_callback * --
+                                            * Sets an interface to let a libretro core render with
+                                            * hardware acceleration.
+                                            * Should be called in retro_load_game().
+                                            * If successful, libretro cores will be able to render to a
+                                            * frontend-provided framebuffer.
+                                            * The size of this framebuffer will be at least as large as
+                                            * max_width/max_height provided in get_av_info().
+                                            * If HW rendering is used, pass only RETRO_HW_FRAME_BUFFER_VALID or
+                                            * NULL to retro_video_refresh_t.
+                                            */
+#define RETRO_ENVIRONMENT_GET_VARIABLE 15
+                                           /* struct retro_variable * --
+                                            * Interface to acquire user-defined information from environment
+                                            * that cannot feasibly be supported in a multi-system way.
+                                            * 'key' should be set to a key which has already been set by
+                                            * SET_VARIABLES.
+                                            * 'data' will be set to a value or NULL.
+                                            */
+#define RETRO_ENVIRONMENT_SET_VARIABLES 16
+                                           /* const struct retro_variable * --
+                                            * Allows an implementation to signal the environment
+                                            * which variables it might want to check for later using
+                                            * GET_VARIABLE.
+                                            * This allows the frontend to present these variables to
+                                            * a user dynamically.
+                                            * This should be called the first time as early as
+                                            * possible (ideally in retro_set_environment).
+                                            * Afterward it may be called again for the core to communicate
+                                            * updated options to the frontend, but the number of core
+                                            * options must not change from the number in the initial call.
+                                            *
+                                            * 'data' points to an array of retro_variable structs
+                                            * terminated by a { NULL, NULL } element.
+                                            * retro_variable::key should be namespaced to not collide
+                                            * with other implementations' keys. E.g. A core called
+                                            * 'foo' should use keys named as 'foo_option'.
+                                            * retro_variable::value should contain a human readable
+                                            * description of the key as well as a '|' delimited list
+                                            * of expected values.
+                                            *
+                                            * The number of possible options should be very limited,
+                                            * i.e. it should be feasible to cycle through options
+                                            * without a keyboard.
+                                            *
+                                            * First entry should be treated as a default.
+                                            *
+                                            * Example entry:
+                                            * { "foo_option", "Speed hack coprocessor X; false|true" }
+                                            *
+                                            * Text before first ';' is description. This ';' must be
+                                            * followed by a space, and followed by a list of possible
+                                            * values split up with '|'.
+                                            *
+                                            * Only strings are operated on. The possible values will
+                                            * generally be displayed and stored as-is by the frontend.
+                                            */
+#define RETRO_ENVIRONMENT_GET_VARIABLE_UPDATE 17
+                                           /* bool * --
+                                            * Result is set to true if some variables are updated by
+                                            * frontend since last call to RETRO_ENVIRONMENT_GET_VARIABLE.
+                                            * Variables should be queried with GET_VARIABLE.
+                                            */
+#define RETRO_ENVIRONMENT_SET_SUPPORT_NO_GAME 18
+                                           /* const bool * --
+                                            * If true, the libretro implementation supports calls to
+                                            * retro_load_game() with NULL as argument.
+                                            * Used by cores which can run without particular game data.
+                                            * This should be called within retro_set_environment() only.
+                                            */
+#define RETRO_ENVIRONMENT_GET_LIBRETRO_PATH 19
+                                           /* const char ** --
+                                            * Retrieves the absolute path from where this libretro
+                                            * implementation was loaded.
+                                            * NULL is returned if the libretro was loaded statically
+                                            * (i.e. linked statically to frontend), or if the path cannot be
+                                            * determined.
+                                            * Mostly useful in cooperation with SET_SUPPORT_NO_GAME as assets can
+                                            * be loaded without ugly hacks.
+                                            */
+
+                                           /* Environment 20 was an obsolete version of SET_AUDIO_CALLBACK.
+                                            * It was not used by any known core at the time,
+                                            * and was removed from the API. */
+#define RETRO_ENVIRONMENT_SET_FRAME_TIME_CALLBACK 21
+                                           /* const struct retro_frame_time_callback * --
+                                            * Lets the core know how much time has passed since last
+                                            * invocation of retro_run().
+                                            * The frontend can tamper with the timing to fake fast-forward,
+                                            * slow-motion, frame stepping, etc.
+                                            * In this case the delta time will use the reference value
+                                            * in frame_time_callback..
+                                            */
+#define RETRO_ENVIRONMENT_SET_AUDIO_CALLBACK 22
+                                           /* const struct retro_audio_callback * --
+                                            * Sets an interface which is used to notify a libretro core about audio
+                                            * being available for writing.
+                                            * The callback can be called from any thread, so a core using this must
+                                            * have a thread safe audio implementation.
+                                            * It is intended for games where audio and video are completely
+                                            * asynchronous and audio can be generated on the fly.
+                                            * This interface is not recommended for use with emulators which have
+                                            * highly synchronous audio.
+                                            *
+                                            * The callback only notifies about writability; the libretro core still
+                                            * has to call the normal audio callbacks
+                                            * to write audio. The audio callbacks must be called from within the
+                                            * notification callback.
+                                            * The amount of audio data to write is up to the implementation.
+                                            * Generally, the audio callback will be called continously in a loop.
+                                            *
+                                            * Due to thread safety guarantees and lack of sync between audio and
+                                            * video, a frontend  can selectively disallow this interface based on
+                                            * internal configuration. A core using this interface must also
+                                            * implement the "normal" audio interface.
+                                            *
+                                            * A libretro core using SET_AUDIO_CALLBACK should also make use of
+                                            * SET_FRAME_TIME_CALLBACK.
+                                            */
+#define RETRO_ENVIRONMENT_GET_RUMBLE_INTERFACE 23
+                                           /* struct retro_rumble_interface * --
+                                            * Gets an interface which is used by a libretro core to set
+                                            * state of rumble motors in controllers.
+                                            * A strong and weak motor is supported, and they can be
+                                            * controlled indepedently.
+                                            * Should be called from either retro_init() or retro_load_game().
+                                            * Should not be called from retro_set_environment().
+                                            * Returns false if rumble functionality is unavailable.
+                                            */
+#define RETRO_ENVIRONMENT_GET_INPUT_DEVICE_CAPABILITIES 24
+                                           /* uint64_t * --
+                                            * Gets a bitmask telling which device type are expected to be
+                                            * handled properly in a call to retro_input_state_t.
+                                            * Devices which are not handled or recognized always return
+                                            * 0 in retro_input_state_t.
+                                            * Example bitmask: caps = (1 << RETRO_DEVICE_JOYPAD) | (1 << RETRO_DEVICE_ANALOG).
+                                            * Should only be called in retro_run().
+                                            */
+#define RETRO_ENVIRONMENT_GET_SENSOR_INTERFACE (25 | RETRO_ENVIRONMENT_EXPERIMENTAL)
+                                           /* struct retro_sensor_interface * --
+                                            * Gets access to the sensor interface.
+                                            * The purpose of this interface is to allow
+                                            * setting state related to sensors such as polling rate,
+                                            * enabling/disable it entirely, etc.
+                                            * Reading sensor state is done via the normal
+                                            * input_state_callback API.
+                                            */
+#define RETRO_ENVIRONMENT_GET_CAMERA_INTERFACE (26 | RETRO_ENVIRONMENT_EXPERIMENTAL)
+                                           /* struct retro_camera_callback * --
+                                            * Gets an interface to a video camera driver.
+                                            * A libretro core can use this interface to get access to a
+                                            * video camera.
+                                            * New video frames are delivered in a callback in same
+                                            * thread as retro_run().
+                                            *
+                                            * GET_CAMERA_INTERFACE should be called in retro_load_game().
+                                            *
+                                            * Depending on the camera implementation used, camera frames
+                                            * will be delivered as a raw framebuffer,
+                                            * or as an OpenGL texture directly.
+                                            *
+                                            * The core has to tell the frontend here which types of
+                                            * buffers can be handled properly.
+                                            * An OpenGL texture can only be handled when using a
+                                            * libretro GL core (SET_HW_RENDER).
+                                            * It is recommended to use a libretro GL core when
+                                            * using camera interface.
+                                            *
+                                            * The camera is not started automatically. The retrieved start/stop
+                                            * functions must be used to explicitly
+                                            * start and stop the camera driver.
+                                            */
+#define RETRO_ENVIRONMENT_GET_LOG_INTERFACE 27
+                                           /* struct retro_log_callback * --
+                                            * Gets an interface for logging. This is useful for
+                                            * logging in a cross-platform way
+                                            * as certain platforms cannot use stderr for logging.
+                                            * It also allows the frontend to
+                                            * show logging information in a more suitable way.
+                                            * If this interface is not used, libretro cores should
+                                            * log to stderr as desired.
+                                            */
+#define RETRO_ENVIRONMENT_GET_PERF_INTERFACE 28
+                                           /* struct retro_perf_callback * --
+                                            * Gets an interface for performance counters. This is useful
+                                            * for performance logging in a cross-platform way and for detecting
+                                            * architecture-specific features, such as SIMD support.
+                                            */
+#define RETRO_ENVIRONMENT_GET_LOCATION_INTERFACE 29
+                                           /* struct retro_location_callback * --
+                                            * Gets access to the location interface.
+                                            * The purpose of this interface is to be able to retrieve
+                                            * location-based information from the host device,
+                                            * such as current latitude / longitude.
+                                            */
+#define RETRO_ENVIRONMENT_GET_CONTENT_DIRECTORY 30 /* Old name, kept for compatibility. */
+#define RETRO_ENVIRONMENT_GET_CORE_ASSETS_DIRECTORY 30
+                                           /* const char ** --
+                                            * Returns the "core assets" directory of the frontend.
+                                            * This directory can be used to store specific assets that the
+                                            * core relies upon, such as art assets,
+                                            * input data, etc etc.
+                                            * The returned value can be NULL.
+                                            * If so, no such directory is defined,
+                                            * and it's up to the implementation to find a suitable directory.
+                                            */
+#define RETRO_ENVIRONMENT_GET_SAVE_DIRECTORY 31
+                                           /* const char ** --
+                                            * Returns the "save" directory of the frontend, unless there is no
+                                            * save directory available. The save directory should be used to
+                                            * store SRAM, memory cards, high scores, etc, if the libretro core
+                                            * cannot use the regular memory interface (retro_get_memory_data()).
+                                            *
+                                            * If the frontend cannot designate a save directory, it will return
+                                            * NULL to indicate that the core should attempt to operate without a
+                                            * save directory set.
+                                            *
+                                            * NOTE: early libretro cores used the system directory for save
+                                            * files. Cores that need to be backwards-compatible can still check
+                                            * GET_SYSTEM_DIRECTORY.
+                                            */
+#define RETRO_ENVIRONMENT_SET_SYSTEM_AV_INFO 32
+                                           /* const struct retro_system_av_info * --
+                                            * Sets a new av_info structure. This can only be called from
+                                            * within retro_run().
+                                            * This should *only* be used if the core is completely altering the
+                                            * internal resolutions, aspect ratios, timings, sampling rate, etc.
+                                            * Calling this can require a full reinitialization of video/audio
+                                            * drivers in the frontend,
+                                            *
+                                            * so it is important to call it very sparingly, and usually only with
+                                            * the users explicit consent.
+                                            * An eventual driver reinitialize will happen so that video and
+                                            * audio callbacks
+                                            * happening after this call within the same retro_run() call will
+                                            * target the newly initialized driver.
+                                            *
+                                            * This callback makes it possible to support configurable resolutions
+                                            * in games, which can be useful to
+                                            * avoid setting the "worst case" in max_width/max_height.
+                                            *
+                                            * ***HIGHLY RECOMMENDED*** Do not call this callback every time
+                                            * resolution changes in an emulator core if it's
+                                            * expected to be a temporary change, for the reasons of possible
+                                            * driver reinitialization.
+                                            * This call is not a free pass for not trying to provide
+                                            * correct values in retro_get_system_av_info(). If you need to change
+                                            * things like aspect ratio or nominal width/height,
+                                            * use RETRO_ENVIRONMENT_SET_GEOMETRY, which is a softer variant
+                                            * of SET_SYSTEM_AV_INFO.
+                                            *
+                                            * If this returns false, the frontend does not acknowledge a
+                                            * changed av_info struct.
+                                            */
+#define RETRO_ENVIRONMENT_SET_PROC_ADDRESS_CALLBACK 33
+                                           /* const struct retro_get_proc_address_interface * --
+                                            * Allows a libretro core to announce support for the
+                                            * get_proc_address() interface.
+                                            * This interface allows for a standard way to extend libretro where
+                                            * use of environment calls are too indirect,
+                                            * e.g. for cases where the frontend wants to call directly into the core.
+                                            *
+                                            * If a core wants to expose this interface, SET_PROC_ADDRESS_CALLBACK
+                                            * **MUST** be called from within retro_set_environment().
+                                            */
+#define RETRO_ENVIRONMENT_SET_SUBSYSTEM_INFO 34
+                                           /* const struct retro_subsystem_info * --
+                                            * This environment call introduces the concept of libretro "subsystems".
+                                            * A subsystem is a variant of a libretro core which supports
+                                            * different kinds of games.
+                                            * The purpose of this is to support e.g. emulators which might
+                                            * have special needs, e.g. Super Nintendo's Super GameBoy, Sufami Turbo.
+                                            * It can also be used to pick among subsystems in an explicit way
+                                            * if the libretro implementation is a multi-system emulator itself.
+                                            *
+                                            * Loading a game via a subsystem is done with retro_load_game_special(),
+                                            * and this environment call allows a libretro core to expose which
+                                            * subsystems are supported for use with retro_load_game_special().
+                                            * A core passes an array of retro_game_special_info which is terminated
+                                            * with a zeroed out retro_game_special_info struct.
+                                            *
+                                            * If a core wants to use this functionality, SET_SUBSYSTEM_INFO
+                                            * **MUST** be called from within retro_set_environment().
+                                            */
+#define RETRO_ENVIRONMENT_SET_CONTROLLER_INFO 35
+                                           /* const struct retro_controller_info * --
+                                            * This environment call lets a libretro core tell the frontend
+                                            * which controller subclasses are recognized in calls to
+                                            * retro_set_controller_port_device().
+                                            *
+                                            * Some emulators such as Super Nintendo support multiple lightgun
+                                            * types which must be specifically selected from. It is therefore
+                                            * sometimes necessary for a frontend to be able to tell the core
+                                            * about a special kind of input device which is not specifcally
+                                            * provided by the Libretro API.
+                                            *
+                                            * In order for a frontend to understand the workings of those devices,
+                                            * they must be defined as a specialized subclass of the generic device
+                                            * types already defined in the libretro API.
+                                            *
+                                            * The core must pass an array of const struct retro_controller_info which
+                                            * is terminated with a blanked out struct. Each element of the
+                                            * retro_controller_info struct corresponds to the ascending port index
+                                            * that is passed to retro_set_controller_port_device() when that function
+                                            * is called to indicate to the core that the frontend has changed the
+                                            * active device subclass. SEE ALSO: retro_set_controller_port_device()
+                                            *
+                                            * The ascending input port indexes provided by the core in the struct
+                                            * are generally presented by frontends as ascending User # or Player #,
+                                            * such as Player 1, Player 2, Player 3, etc. Which device subclasses are
+                                            * supported can vary per input port.
+                                            *
+                                            * The first inner element of each entry in the retro_controller_info array
+                                            * is a retro_controller_description struct that specifies the names and
+                                            * codes of all device subclasses that are available for the corresponding
+                                            * User or Player, beginning with the generic Libretro device that the
+                                            * subclasses are derived from. The second inner element of each entry is the
+                                            * total number of subclasses that are listed in the retro_controller_description.
+                                            *
+                                            * NOTE: Even if special device types are set in the libretro core,
+                                            * libretro should only poll input based on the base input device types.
+                                            */
+#define RETRO_ENVIRONMENT_SET_MEMORY_MAPS (36 | RETRO_ENVIRONMENT_EXPERIMENTAL)
+                                           /* const struct retro_memory_map * --
+                                            * This environment call lets a libretro core tell the frontend
+                                            * about the memory maps this core emulates.
+                                            * This can be used to implement, for example, cheats in a core-agnostic way.
+                                            *
+                                            * Should only be used by emulators; it doesn't make much sense for
+                                            * anything else.
+                                            * It is recommended to expose all relevant pointers through
+                                            * retro_get_memory_* as well.
+                                            *
+                                            * Can be called from retro_init and retro_load_game.
+                                            */
+#define RETRO_ENVIRONMENT_SET_GEOMETRY 37
+                                           /* const struct retro_game_geometry * --
+                                            * This environment call is similar to SET_SYSTEM_AV_INFO for changing
+                                            * video parameters, but provides a guarantee that drivers will not be
+                                            * reinitialized.
+                                            * This can only be called from within retro_run().
+                                            *
+                                            * The purpose of this call is to allow a core to alter nominal
+                                            * width/heights as well as aspect ratios on-the-fly, which can be
+                                            * useful for some emulators to change in run-time.
+                                            *
+                                            * max_width/max_height arguments are ignored and cannot be changed
+                                            * with this call as this could potentially require a reinitialization or a
+                                            * non-constant time operation.
+                                            * If max_width/max_height are to be changed, SET_SYSTEM_AV_INFO is required.
+                                            *
+                                            * A frontend must guarantee that this environment call completes in
+                                            * constant time.
+                                            */
+#define RETRO_ENVIRONMENT_GET_USERNAME 38
+                                           /* const char **
+                                            * Returns the specified username of the frontend, if specified by the user.
+                                            * This username can be used as a nickname for a core that has online facilities
+                                            * or any other mode where personalization of the user is desirable.
+                                            * The returned value can be NULL.
+                                            * If this environ callback is used by a core that requires a valid username,
+                                            * a default username should be specified by the core.
+                                            */
+#define RETRO_ENVIRONMENT_GET_LANGUAGE 39
+                                           /* unsigned * --
+                                            * Returns the specified language of the frontend, if specified by the user.
+                                            * It can be used by the core for localization purposes.
+                                            */
+#define RETRO_ENVIRONMENT_GET_CURRENT_SOFTWARE_FRAMEBUFFER (40 | RETRO_ENVIRONMENT_EXPERIMENTAL)
+                                           /* struct retro_framebuffer * --
+                                            * Returns a preallocated framebuffer which the core can use for rendering
+                                            * the frame into when not using SET_HW_RENDER.
+                                            * The framebuffer returned from this call must not be used
+                                            * after the current call to retro_run() returns.
+                                            *
+                                            * The goal of this call is to allow zero-copy behavior where a core
+                                            * can render directly into video memory, avoiding extra bandwidth cost by copying
+                                            * memory from core to video memory.
+                                            *
+                                            * If this call succeeds and the core renders into it,
+                                            * the framebuffer pointer and pitch can be passed to retro_video_refresh_t.
+                                            * If the buffer from GET_CURRENT_SOFTWARE_FRAMEBUFFER is to be used,
+                                            * the core must pass the exact
+                                            * same pointer as returned by GET_CURRENT_SOFTWARE_FRAMEBUFFER;
+                                            * i.e. passing a pointer which is offset from the
+                                            * buffer is undefined. The width, height and pitch parameters
+                                            * must also match exactly to the values obtained from GET_CURRENT_SOFTWARE_FRAMEBUFFER.
+                                            *
+                                            * It is possible for a frontend to return a different pixel format
+                                            * than the one used in SET_PIXEL_FORMAT. This can happen if the frontend
+                                            * needs to perform conversion.
+                                            *
+                                            * It is still valid for a core to render to a different buffer
+                                            * even if GET_CURRENT_SOFTWARE_FRAMEBUFFER succeeds.
+                                            *
+                                            * A frontend must make sure that the pointer obtained from this function is
+                                            * writeable (and readable).
+                                            */
+#define RETRO_ENVIRONMENT_GET_HW_RENDER_INTERFACE (41 | RETRO_ENVIRONMENT_EXPERIMENTAL)
+                                           /* const struct retro_hw_render_interface ** --
+                                            * Returns an API specific rendering interface for accessing API specific data.
+                                            * Not all HW rendering APIs support or need this.
+                                            * The contents of the returned pointer is specific to the rendering API
+                                            * being used. See the various headers like libretro_vulkan.h, etc.
+                                            *
+                                            * GET_HW_RENDER_INTERFACE cannot be called before context_reset has been called.
+                                            * Similarly, after context_destroyed callback returns,
+                                            * the contents of the HW_RENDER_INTERFACE are invalidated.
+                                            */
+#define RETRO_ENVIRONMENT_SET_SUPPORT_ACHIEVEMENTS (42 | RETRO_ENVIRONMENT_EXPERIMENTAL)
+                                           /* const bool * --
+                                            * If true, the libretro implementation supports achievements
+                                            * either via memory descriptors set with RETRO_ENVIRONMENT_SET_MEMORY_MAPS
+                                            * or via retro_get_memory_data/retro_get_memory_size.
+                                            *
+                                            * This must be called before the first call to retro_run.
+                                            */
+#define RETRO_ENVIRONMENT_SET_HW_RENDER_CONTEXT_NEGOTIATION_INTERFACE (43 | RETRO_ENVIRONMENT_EXPERIMENTAL)
+                                           /* const struct retro_hw_render_context_negotiation_interface * --
+                                            * Sets an interface which lets the libretro core negotiate with frontend how a context is created.
+                                            * The semantics of this interface depends on which API is used in SET_HW_RENDER earlier.
+                                            * This interface will be used when the frontend is trying to create a HW rendering context,
+                                            * so it will be used after SET_HW_RENDER, but before the context_reset callback.
+                                            */
+#define RETRO_ENVIRONMENT_SET_SERIALIZATION_QUIRKS 44
+                                           /* uint64_t * --
+                                            * Sets quirk flags associated with serialization. The frontend will zero any flags it doesn't
+                                            * recognize or support. Should be set in either retro_init or retro_load_game, but not both.
+                                            */
+#define RETRO_ENVIRONMENT_SET_HW_SHARED_CONTEXT (44 | RETRO_ENVIRONMENT_EXPERIMENTAL)
+                                           /* N/A (null) * --
+                                            * The frontend will try to use a 'shared' hardware context (mostly applicable
+                                            * to OpenGL) when a hardware context is being set up.
+                                            *
+                                            * Returns true if the frontend supports shared hardware contexts and false
+                                            * if the frontend does not support shared hardware contexts.
+                                            *
+                                            * This will do nothing on its own until SET_HW_RENDER env callbacks are
+                                            * being used.
+                                            */
+#define RETRO_ENVIRONMENT_GET_VFS_INTERFACE (45 | RETRO_ENVIRONMENT_EXPERIMENTAL)
+                                           /* struct retro_vfs_interface_info * --
+                                            * Gets access to the VFS interface.
+                                            * VFS presence needs to be queried prior to load_game or any
+                                            * get_system/save/other_directory being called to let front end know
+                                            * core supports VFS before it starts handing out paths.
+                                            * It is recomended to do so in retro_set_environment
+                                            */
+#define RETRO_ENVIRONMENT_GET_LED_INTERFACE (46 | RETRO_ENVIRONMENT_EXPERIMENTAL)
+                                           /* struct retro_led_interface * --
+                                            * Gets an interface which is used by a libretro core to set
+                                            * state of LEDs.
+                                            */
+#define RETRO_ENVIRONMENT_GET_AUDIO_VIDEO_ENABLE (47 | RETRO_ENVIRONMENT_EXPERIMENTAL)
+                                           /* int * --
+                                            * Tells the core if the frontend wants audio or video.
+                                            * If disabled, the frontend will discard the audio or video,
+                                            * so the core may decide to skip generating a frame or generating audio.
+                                            * This is mainly used for increasing performance.
+                                            * Bit 0 (value 1): Enable Video
+                                            * Bit 1 (value 2): Enable Audio
+                                            * Bit 2 (value 4): Use Fast Savestates.
+                                            * Bit 3 (value 8): Hard Disable Audio
+                                            * Other bits are reserved for future use and will default to zero.
+                                            * If video is disabled:
+                                            * * The frontend wants the core to not generate any video,
+                                            *   including presenting frames via hardware acceleration.
+                                            * * The frontend's video frame callback will do nothing.
+                                            * * After running the frame, the video output of the next frame should be
+                                            *   no different than if video was enabled, and saving and loading state
+                                            *   should have no issues.
+                                            * If audio is disabled:
+                                            * * The frontend wants the core to not generate any audio.
+                                            * * The frontend's audio callbacks will do nothing.
+                                            * * After running the frame, the audio output of the next frame should be
+                                            *   no different than if audio was enabled, and saving and loading state
+                                            *   should have no issues.
+                                            * Fast Savestates:
+                                            * * Guaranteed to be created by the same binary that will load them.
+                                            * * Will not be written to or read from the disk.
+                                            * * Suggest that the core assumes loading state will succeed.
+                                            * * Suggest that the core updates its memory buffers in-place if possible.
+                                            * * Suggest that the core skips clearing memory.
+                                            * * Suggest that the core skips resetting the system.
+                                            * * Suggest that the core may skip validation steps.
+                                            * Hard Disable Audio:
+                                            * * Used for a secondary core when running ahead.
+                                            * * Indicates that the frontend will never need audio from the core.
+                                            * * Suggests that the core may stop synthesizing audio, but this should not
+                                            *   compromise emulation accuracy.
+                                            * * Audio output for the next frame does not matter, and the frontend will
+                                            *   never need an accurate audio state in the future.
+                                            * * State will never be saved when using Hard Disable Audio.
+                                            */
+#define RETRO_ENVIRONMENT_GET_MIDI_INTERFACE (48 | RETRO_ENVIRONMENT_EXPERIMENTAL)
+                                           /* struct retro_midi_interface ** --
+                                            * Returns a MIDI interface that can be used for raw data I/O.
+                                            */
+
+#define RETRO_ENVIRONMENT_GET_FASTFORWARDING (49 | RETRO_ENVIRONMENT_EXPERIMENTAL)
+                                            /* bool * --
+                                            * Boolean value that indicates whether or not the frontend is in
+                                            * fastforwarding mode.
+                                            */
+
+#define RETRO_ENVIRONMENT_GET_TARGET_REFRESH_RATE (50 | RETRO_ENVIRONMENT_EXPERIMENTAL)
+                                            /* float * --
+                                            * Float value that lets us know what target refresh rate
+                                            * is curently in use by the frontend.
+                                            *
+                                            * The core can use the returned value to set an ideal
+                                            * refresh rate/framerate.
+                                            */
+
+#define RETRO_ENVIRONMENT_GET_INPUT_BITMASKS (51 | RETRO_ENVIRONMENT_EXPERIMENTAL)
+                                            /* bool * --
+                                            * Boolean value that indicates whether or not the frontend supports
+                                            * input bitmasks being returned by retro_input_state_t. The advantage
+                                            * of this is that retro_input_state_t has to be only called once to
+                                            * grab all button states instead of multiple times.
+                                            *
+                                            * If it returns true, you can pass RETRO_DEVICE_ID_JOYPAD_MASK as 'id'
+                                            * to retro_input_state_t (make sure 'device' is set to RETRO_DEVICE_JOYPAD).
+                                            * It will return a bitmask of all the digital buttons.
+                                            */
+
+#define RETRO_ENVIRONMENT_GET_CORE_OPTIONS_VERSION 52
+                                           /* unsigned * --
+                                            * Unsigned value is the API version number of the core options
+                                            * interface supported by the frontend. If callback return false,
+                                            * API version is assumed to be 0.
+                                            *
+                                            * In legacy code, core options are set by passing an array of
+                                            * retro_variable structs to RETRO_ENVIRONMENT_SET_VARIABLES.
+                                            * This may be still be done regardless of the core options
+                                            * interface version.
+                                            *
+                                            * If version is >= 1 however, core options may instead be set by
+                                            * passing an array of retro_core_option_definition structs to
+                                            * RETRO_ENVIRONMENT_SET_CORE_OPTIONS, or a 2D array of
+                                            * retro_core_option_definition structs to RETRO_ENVIRONMENT_SET_CORE_OPTIONS_INTL.
+                                            * This allows the core to additionally set option sublabel information
+                                            * and/or provide localisation support.
+                                            *
+                                            * If version is >= 2, core options may instead be set by passing
+                                            * a retro_core_options_v2 struct to RETRO_ENVIRONMENT_SET_CORE_OPTIONS_V2,
+                                            * or an array of retro_core_options_v2 structs to
+                                            * RETRO_ENVIRONMENT_SET_CORE_OPTIONS_V2_INTL. This allows the core
+                                            * to additionally set optional core option category information
+                                            * for frontends with core option category support.
+                                            */
+
+#define RETRO_ENVIRONMENT_SET_CORE_OPTIONS 53
+                                           /* const struct retro_core_option_definition ** --
+                                            * Allows an implementation to signal the environment
+                                            * which variables it might want to check for later using
+                                            * GET_VARIABLE.
+                                            * This allows the frontend to present these variables to
+                                            * a user dynamically.
+                                            * This should only be called if RETRO_ENVIRONMENT_GET_CORE_OPTIONS_VERSION
+                                            * returns an API version of >= 1.
+                                            * This should be called instead of RETRO_ENVIRONMENT_SET_VARIABLES.
+                                            * This should be called the first time as early as
+                                            * possible (ideally in retro_set_environment).
+                                            * Afterwards it may be called again for the core to communicate
+                                            * updated options to the frontend, but the number of core
+                                            * options must not change from the number in the initial call.
+                                            *
+                                            * 'data' points to an array of retro_core_option_definition structs
+                                            * terminated by a { NULL, NULL, NULL, {{0}}, NULL } element.
+                                            * retro_core_option_definition::key should be namespaced to not collide
+                                            * with other implementations' keys. e.g. A core called
+                                            * 'foo' should use keys named as 'foo_option'.
+                                            * retro_core_option_definition::desc should contain a human readable
+                                            * description of the key.
+                                            * retro_core_option_definition::info should contain any additional human
+                                            * readable information text that a typical user may need to
+                                            * understand the functionality of the option.
+                                            * retro_core_option_definition::values is an array of retro_core_option_value
+                                            * structs terminated by a { NULL, NULL } element.
+                                            * > retro_core_option_definition::values[index].value is an expected option
+                                            *   value.
+                                            * > retro_core_option_definition::values[index].label is a human readable
+                                            *   label used when displaying the value on screen. If NULL,
+                                            *   the value itself is used.
+                                            * retro_core_option_definition::default_value is the default core option
+                                            * setting. It must match one of the expected option values in the
+                                            * retro_core_option_definition::values array. If it does not, or the
+                                            * default value is NULL, the first entry in the
+                                            * retro_core_option_definition::values array is treated as the default.
+                                            *
+                                            * The number of possible option values should be very limited,
+                                            * and must be less than RETRO_NUM_CORE_OPTION_VALUES_MAX.
+                                            * i.e. it should be feasible to cycle through options
+                                            * without a keyboard.
+                                            *
+                                            * Example entry:
+                                            * {
+                                            *     "foo_option",
+                                            *     "Speed hack coprocessor X",
+                                            *     "Provides increased performance at the expense of reduced accuracy",
+                                            * 	  {
+                                            *         { "false",    NULL },
+                                            *         { "true",     NULL },
+                                            *         { "unstable", "Turbo (Unstable)" },
+                                            *         { NULL, NULL },
+                                            *     },
+                                            *     "false"
+                                            * }
+                                            *
+                                            * Only strings are operated on. The possible values will
+                                            * generally be displayed and stored as-is by the frontend.
+                                            */
+
+#define RETRO_ENVIRONMENT_SET_CORE_OPTIONS_INTL 54
+                                           /* const struct retro_core_options_intl * --
+                                            * Allows an implementation to signal the environment
+                                            * which variables it might want to check for later using
+                                            * GET_VARIABLE.
+                                            * This allows the frontend to present these variables to
+                                            * a user dynamically.
+                                            * This should only be called if RETRO_ENVIRONMENT_GET_CORE_OPTIONS_VERSION
+                                            * returns an API version of >= 1.
+                                            * This should be called instead of RETRO_ENVIRONMENT_SET_VARIABLES.
+                                            * This should be called instead of RETRO_ENVIRONMENT_SET_CORE_OPTIONS.
+                                            * This should be called the first time as early as
+                                            * possible (ideally in retro_set_environment).
+                                            * Afterwards it may be called again for the core to communicate
+                                            * updated options to the frontend, but the number of core
+                                            * options must not change from the number in the initial call.
+                                            *
+                                            * This is fundamentally the same as RETRO_ENVIRONMENT_SET_CORE_OPTIONS,
+                                            * with the addition of localisation support. The description of the
+                                            * RETRO_ENVIRONMENT_SET_CORE_OPTIONS callback should be consulted
+                                            * for further details.
+                                            *
+                                            * 'data' points to a retro_core_options_intl struct.
+                                            *
+                                            * retro_core_options_intl::us is a pointer to an array of
+                                            * retro_core_option_definition structs defining the US English
+                                            * core options implementation. It must point to a valid array.
+                                            *
+                                            * retro_core_options_intl::local is a pointer to an array of
+                                            * retro_core_option_definition structs defining core options for
+                                            * the current frontend language. It may be NULL (in which case
+                                            * retro_core_options_intl::us is used by the frontend). Any items
+                                            * missing from this array will be read from retro_core_options_intl::us
+                                            * instead.
+                                            *
+                                            * NOTE: Default core option values are always taken from the
+                                            * retro_core_options_intl::us array. Any default values in
+                                            * retro_core_options_intl::local array will be ignored.
+                                            */
+
+#define RETRO_ENVIRONMENT_SET_CORE_OPTIONS_DISPLAY 55
+                                           /* struct retro_core_option_display * --
+                                            *
+                                            * Allows an implementation to signal the environment to show
+                                            * or hide a variable when displaying core options. This is
+                                            * considered a *suggestion*. The frontend is free to ignore
+                                            * this callback, and its implementation not considered mandatory.
+                                            *
+                                            * 'data' points to a retro_core_option_display struct
+                                            *
+                                            * retro_core_option_display::key is a variable identifier
+                                            * which has already been set by SET_VARIABLES/SET_CORE_OPTIONS.
+                                            *
+                                            * retro_core_option_display::visible is a boolean, specifying
+                                            * whether variable should be displayed
+                                            *
+                                            * Note that all core option variables will be set visible by
+                                            * default when calling SET_VARIABLES/SET_CORE_OPTIONS.
+                                            */
+
+#define RETRO_ENVIRONMENT_GET_PREFERRED_HW_RENDER 56
+                                           /* unsigned * --
+                                            *
+                                            * Allows an implementation to ask frontend preferred hardware
+                                            * context to use. Core should use this information to deal
+                                            * with what specific context to request with SET_HW_RENDER.
+                                            *
+                                            * 'data' points to an unsigned variable
+                                            */
+
+#define RETRO_ENVIRONMENT_GET_DISK_CONTROL_INTERFACE_VERSION 57
+                                           /* unsigned * --
+                                            * Unsigned value is the API version number of the disk control
+                                            * interface supported by the frontend. If callback return false,
+                                            * API version is assumed to be 0.
+                                            *
+                                            * In legacy code, the disk control interface is defined by passing
+                                            * a struct of type retro_disk_control_callback to
+                                            * RETRO_ENVIRONMENT_SET_DISK_CONTROL_INTERFACE.
+                                            * This may be still be done regardless of the disk control
+                                            * interface version.
+                                            *
+                                            * If version is >= 1 however, the disk control interface may
+                                            * instead be defined by passing a struct of type
+                                            * retro_disk_control_ext_callback to
+                                            * RETRO_ENVIRONMENT_SET_DISK_CONTROL_EXT_INTERFACE.
+                                            * This allows the core to provide additional information about
+                                            * disk images to the frontend and/or enables extra
+                                            * disk control functionality by the frontend.
+                                            */
+
+#define RETRO_ENVIRONMENT_SET_DISK_CONTROL_EXT_INTERFACE 58
+                                           /* const struct retro_disk_control_ext_callback * --
+                                            * Sets an interface which frontend can use to eject and insert
+                                            * disk images, and also obtain information about individual
+                                            * disk image files registered by the core.
+                                            * This is used for games which consist of multiple images and
+                                            * must be manually swapped out by the user (e.g. PSX, floppy disk
+                                            * based systems).
+                                            */
+
+#define RETRO_ENVIRONMENT_GET_MESSAGE_INTERFACE_VERSION 59
+                                           /* unsigned * --
+                                            * Unsigned value is the API version number of the message
+                                            * interface supported by the frontend. If callback returns
+                                            * false, API version is assumed to be 0.
+                                            *
+                                            * In legacy code, messages may be displayed in an
+                                            * implementation-specific manner by passing a struct
+                                            * of type retro_message to RETRO_ENVIRONMENT_SET_MESSAGE.
+                                            * This may be still be done regardless of the message
+                                            * interface version.
+                                            *
+                                            * If version is >= 1 however, messages may instead be
+                                            * displayed by passing a struct of type retro_message_ext
+                                            * to RETRO_ENVIRONMENT_SET_MESSAGE_EXT. This allows the
+                                            * core to specify message logging level, priority and
+                                            * destination (OSD, logging interface or both).
+                                            */
+
+#define RETRO_ENVIRONMENT_SET_MESSAGE_EXT 60
+                                           /* const struct retro_message_ext * --
+                                            * Sets a message to be displayed in an implementation-specific
+                                            * manner for a certain amount of 'frames'. Additionally allows
+                                            * the core to specify message logging level, priority and
+                                            * destination (OSD, logging interface or both).
+                                            * Should not be used for trivial messages, which should simply be
+                                            * logged via RETRO_ENVIRONMENT_GET_LOG_INTERFACE (or as a
+                                            * fallback, stderr).
+                                            */
+
+#define RETRO_ENVIRONMENT_GET_INPUT_MAX_USERS 61
+                                           /* unsigned * --
+                                            * Unsigned value is the number of active input devices
+                                            * provided by the frontend. This may change between
+                                            * frames, but will remain constant for the duration
+                                            * of each frame.
+                                            * If callback returns true, a core need not poll any
+                                            * input device with an index greater than or equal to
+                                            * the number of active devices.
+                                            * If callback returns false, the number of active input
+                                            * devices is unknown. In this case, all input devices
+                                            * should be considered active.
+                                            */
+
+#define RETRO_ENVIRONMENT_SET_AUDIO_BUFFER_STATUS_CALLBACK 62
+                                           /* const struct retro_audio_buffer_status_callback * --
+                                            * Lets the core know the occupancy level of the frontend
+                                            * audio buffer. Can be used by a core to attempt frame
+                                            * skipping in order to avoid buffer under-runs.
+                                            * A core may pass NULL to disable buffer status reporting
+                                            * in the frontend.
+                                            */
+
+#define RETRO_ENVIRONMENT_SET_MINIMUM_AUDIO_LATENCY 63
+                                           /* const unsigned * --
+                                            * Sets minimum frontend audio latency in milliseconds.
+                                            * Resultant audio latency may be larger than set value,
+                                            * or smaller if a hardware limit is encountered. A frontend
+                                            * is expected to honour requests up to 512 ms.
+                                            *
+                                            * - If value is less than current frontend
+                                            *   audio latency, callback has no effect
+                                            * - If value is zero, default frontend audio
+                                            *   latency is set
+                                            *
+                                            * May be used by a core to increase audio latency and
+                                            * therefore decrease the probability of buffer under-runs
+                                            * (crackling) when performing 'intensive' operations.
+                                            * A core utilising RETRO_ENVIRONMENT_SET_AUDIO_BUFFER_STATUS_CALLBACK
+                                            * to implement audio-buffer-based frame skipping may achieve
+                                            * optimal results by setting the audio latency to a 'high'
+                                            * (typically 6x or 8x) integer multiple of the expected
+                                            * frame time.
+                                            *
+                                            * WARNING: This can only be called from within retro_run().
+                                            * Calling this can require a full reinitialization of audio
+                                            * drivers in the frontend, so it is important to call it very
+                                            * sparingly, and usually only with the users explicit consent.
+                                            * An eventual driver reinitialize will happen so that audio
+                                            * callbacks happening after this call within the same retro_run()
+                                            * call will target the newly initialized driver.
+                                            */
+
+#define RETRO_ENVIRONMENT_SET_FASTFORWARDING_OVERRIDE 64
+                                           /* const struct retro_fastforwarding_override * --
+                                            * Used by a libretro core to override the current
+                                            * fastforwarding mode of the frontend.
+                                            * If NULL is passed to this function, the frontend
+                                            * will return true if fastforwarding override
+                                            * functionality is supported (no change in
+                                            * fastforwarding state will occur in this case).
+                                            */
+
+#define RETRO_ENVIRONMENT_SET_CONTENT_INFO_OVERRIDE 65
+                                           /* const struct retro_system_content_info_override * --
+                                            * Allows an implementation to override 'global' content
+                                            * info parameters reported by retro_get_system_info().
+                                            * Overrides also affect subsystem content info parameters
+                                            * set via RETRO_ENVIRONMENT_SET_SUBSYSTEM_INFO.
+                                            * This function must be called inside retro_set_environment().
+                                            * If callback returns false, content info overrides
+                                            * are unsupported by the frontend, and will be ignored.
+                                            * If callback returns true, extended game info may be
+                                            * retrieved by calling RETRO_ENVIRONMENT_GET_GAME_INFO_EXT
+                                            * in retro_load_game() or retro_load_game_special().
+                                            *
+                                            * 'data' points to an array of retro_system_content_info_override
+                                            * structs terminated by a { NULL, false, false } element.
+                                            * If 'data' is NULL, no changes will be made to the frontend;
+                                            * a core may therefore pass NULL in order to test whether
+                                            * the RETRO_ENVIRONMENT_SET_CONTENT_INFO_OVERRIDE and
+                                            * RETRO_ENVIRONMENT_GET_GAME_INFO_EXT callbacks are supported
+                                            * by the frontend.
+                                            *
+                                            * For struct member descriptions, see the definition of
+                                            * struct retro_system_content_info_override.
+                                            *
+                                            * Example:
+                                            *
+                                            * - struct retro_system_info:
+                                            * {
+                                            *    "My Core",                      // library_name
+                                            *    "v1.0",                         // library_version
+                                            *    "m3u|md|cue|iso|chd|sms|gg|sg", // valid_extensions
+                                            *    true,                           // need_fullpath
+                                            *    false                           // block_extract
+                                            * }
+                                            *
+                                            * - Array of struct retro_system_content_info_override:
+                                            * {
+                                            *    {
+                                            *       "md|sms|gg", // extensions
+                                            *       false,       // need_fullpath
+                                            *       true         // persistent_data
+                                            *    },
+                                            *    {
+                                            *       "sg",        // extensions
+                                            *       false,       // need_fullpath
+                                            *       false        // persistent_data
+                                            *    },
+                                            *    { NULL, false, false }
+                                            * }
+                                            *
+                                            * Result:
+                                            * - Files of type m3u, cue, iso, chd will not be
+                                            *   loaded by the frontend. Frontend will pass a
+                                            *   valid path to the core, and core will handle
+                                            *   loading internally
+                                            * - Files of type md, sms, gg will be loaded by
+                                            *   the frontend. A valid memory buffer will be
+                                            *   passed to the core. This memory buffer will
+                                            *   remain valid until retro_deinit() returns
+                                            * - Files of type sg will be loaded by the frontend.
+                                            *   A valid memory buffer will be passed to the core.
+                                            *   This memory buffer will remain valid until
+                                            *   retro_load_game() (or retro_load_game_special())
+                                            *   returns
+                                            *
+                                            * NOTE: If an extension is listed multiple times in
+                                            * an array of retro_system_content_info_override
+                                            * structs, only the first instance will be registered
+                                            */
+
+#define RETRO_ENVIRONMENT_GET_GAME_INFO_EXT 66
+                                           /* const struct retro_game_info_ext ** --
+                                            * Allows an implementation to fetch extended game
+                                            * information, providing additional content path
+                                            * and memory buffer status details.
+                                            * This function may only be called inside
+                                            * retro_load_game() or retro_load_game_special().
+                                            * If callback returns false, extended game information
+                                            * is unsupported by the frontend. In this case, only
+                                            * regular retro_game_info will be available.
+                                            * RETRO_ENVIRONMENT_GET_GAME_INFO_EXT is guaranteed
+                                            * to return true if RETRO_ENVIRONMENT_SET_CONTENT_INFO_OVERRIDE
+                                            * returns true.
+                                            *
+                                            * 'data' points to an array of retro_game_info_ext structs.
+                                            *
+                                            * For struct member descriptions, see the definition of
+                                            * struct retro_game_info_ext.
+                                            *
+                                            * - If function is called inside retro_load_game(),
+                                            *   the retro_game_info_ext array is guaranteed to
+                                            *   have a size of 1 - i.e. the returned pointer may
+                                            *   be used to access directly the members of the
+                                            *   first retro_game_info_ext struct, for example:
+                                            *
+                                            *      struct retro_game_info_ext *game_info_ext;
+                                            *      if (environ_cb(RETRO_ENVIRONMENT_GET_GAME_INFO_EXT, &game_info_ext))
+                                            *         printf("Content Directory: %s\n", game_info_ext->dir);
+                                            *
+                                            * - If the function is called inside retro_load_game_special(),
+                                            *   the retro_game_info_ext array is guaranteed to have a
+                                            *   size equal to the num_info argument passed to
+                                            *   retro_load_game_special()
+                                            */
+
+#define RETRO_ENVIRONMENT_SET_CORE_OPTIONS_V2 67
+                                           /* const struct retro_core_options_v2 * --
+                                            * Allows an implementation to signal the environment
+                                            * which variables it might want to check for later using
+                                            * GET_VARIABLE.
+                                            * This allows the frontend to present these variables to
+                                            * a user dynamically.
+                                            * This should only be called if RETRO_ENVIRONMENT_GET_CORE_OPTIONS_VERSION
+                                            * returns an API version of >= 2.
+                                            * This should be called instead of RETRO_ENVIRONMENT_SET_VARIABLES.
+                                            * This should be called instead of RETRO_ENVIRONMENT_SET_CORE_OPTIONS.
+                                            * This should be called the first time as early as
+                                            * possible (ideally in retro_set_environment).
+                                            * Afterwards it may be called again for the core to communicate
+                                            * updated options to the frontend, but the number of core
+                                            * options must not change from the number in the initial call.
+                                            * If RETRO_ENVIRONMENT_GET_CORE_OPTIONS_VERSION returns an API
+                                            * version of >= 2, this callback is guaranteed to succeed
+                                            * (i.e. callback return value does not indicate success)
+                                            * If callback returns true, frontend has core option category
+                                            * support.
+                                            * If callback returns false, frontend does not have core option
+                                            * category support.
+                                            *
+                                            * 'data' points to a retro_core_options_v2 struct, containing
+                                            * of two pointers:
+                                            * - retro_core_options_v2::categories is an array of
+                                            *   retro_core_option_v2_category structs terminated by a
+                                            *   { NULL, NULL, NULL } element. If retro_core_options_v2::categories
+                                            *   is NULL, all core options will have no category and will be shown
+                                            *   at the top level of the frontend core option interface. If frontend
+                                            *   does not have core option category support, categories array will
+                                            *   be ignored.
+                                            * - retro_core_options_v2::definitions is an array of
+                                            *   retro_core_option_v2_definition structs terminated by a
+                                            *   { NULL, NULL, NULL, NULL, NULL, NULL, {{0}}, NULL }
+                                            *   element.
+                                            *
+                                            * >> retro_core_option_v2_category notes:
+                                            *
+                                            * - retro_core_option_v2_category::key should contain string
+                                            *   that uniquely identifies the core option category. Valid
+                                            *   key characters are [a-z, A-Z, 0-9, _, -]
+                                            *   Namespace collisions with other implementations' category
+                                            *   keys are permitted.
+                                            * - retro_core_option_v2_category::desc should contain a human
+                                            *   readable description of the category key.
+                                            * - retro_core_option_v2_category::info should contain any
+                                            *   additional human readable information text that a typical
+                                            *   user may need to understand the nature of the core option
+                                            *   category.
+                                            *
+                                            * Example entry:
+                                            * {
+                                            *     "advanced_settings",
+                                            *     "Advanced",
+                                            *     "Options affecting low-level emulation performance and accuracy."
+                                            * }
+                                            *
+                                            * >> retro_core_option_v2_definition notes:
+                                            *
+                                            * - retro_core_option_v2_definition::key should be namespaced to not
+                                            *   collide with other implementations' keys. e.g. A core called
+                                            *   'foo' should use keys named as 'foo_option'. Valid key characters
+                                            *   are [a-z, A-Z, 0-9, _, -].
+                                            * - retro_core_option_v2_definition::desc should contain a human readable
+                                            *   description of the key. Will be used when the frontend does not
+                                            *   have core option category support. Examples: "Aspect Ratio" or
+                                            *   "Video > Aspect Ratio".
+                                            * - retro_core_option_v2_definition::desc_categorized should contain a
+                                            *   human readable description of the key, which will be used when
+                                            *   frontend has core option category support. Example: "Aspect Ratio",
+                                            *   where associated retro_core_option_v2_category::desc is "Video".
+                                            *   If empty or NULL, the string specified by
+                                            *   retro_core_option_v2_definition::desc will be used instead.
+                                            *   retro_core_option_v2_definition::desc_categorized will be ignored
+                                            *   if retro_core_option_v2_definition::category_key is empty or NULL.
+                                            * - retro_core_option_v2_definition::info should contain any additional
+                                            *   human readable information text that a typical user may need to
+                                            *   understand the functionality of the option.
+                                            * - retro_core_option_v2_definition::info_categorized should contain
+                                            *   any additional human readable information text that a typical user
+                                            *   may need to understand the functionality of the option, and will be
+                                            *   used when frontend has core option category support. This is provided
+                                            *   to accommodate the case where info text references an option by
+                                            *   name/desc, and the desc/desc_categorized text for that option differ.
+                                            *   If empty or NULL, the string specified by
+                                            *   retro_core_option_v2_definition::info will be used instead.
+                                            *   retro_core_option_v2_definition::info_categorized will be ignored
+                                            *   if retro_core_option_v2_definition::category_key is empty or NULL.
+                                            * - retro_core_option_v2_definition::category_key should contain a
+                                            *   category identifier (e.g. "video" or "audio") that will be
+                                            *   assigned to the core option if frontend has core option category
+                                            *   support. A categorized option will be shown in a subsection/
+                                            *   submenu of the frontend core option interface. If key is empty
+                                            *   or NULL, or if key does not match one of the
+                                            *   retro_core_option_v2_category::key values in the associated
+                                            *   retro_core_option_v2_category array, option will have no category
+                                            *   and will be shown at the top level of the frontend core option
+                                            *   interface.
+                                            * - retro_core_option_v2_definition::values is an array of
+                                            *   retro_core_option_value structs terminated by a { NULL, NULL }
+                                            *   element.
+                                            * --> retro_core_option_v2_definition::values[index].value is an
+                                            *     expected option value.
+                                            * --> retro_core_option_v2_definition::values[index].label is a
+                                            *     human readable label used when displaying the value on screen.
+                                            *     If NULL, the value itself is used.
+                                            * - retro_core_option_v2_definition::default_value is the default
+                                            *   core option setting. It must match one of the expected option
+                                            *   values in the retro_core_option_v2_definition::values array. If
+                                            *   it does not, or the default value is NULL, the first entry in the
+                                            *   retro_core_option_v2_definition::values array is treated as the
+                                            *   default.
+                                            *
+                                            * The number of possible option values should be very limited,
+                                            * and must be less than RETRO_NUM_CORE_OPTION_VALUES_MAX.
+                                            * i.e. it should be feasible to cycle through options
+                                            * without a keyboard.
+                                            *
+                                            * Example entries:
+                                            *
+                                            * - Uncategorized:
+                                            *
+                                            * {
+                                            *     "foo_option",
+                                            *     "Speed hack coprocessor X",
+                                            *     NULL,
+                                            *     "Provides increased performance at the expense of reduced accuracy.",
+                                            *     NULL,
+                                            *     NULL,
+                                            * 	  {
+                                            *         { "false",    NULL },
+                                            *         { "true",     NULL },
+                                            *         { "unstable", "Turbo (Unstable)" },
+                                            *         { NULL, NULL },
+                                            *     },
+                                            *     "false"
+                                            * }
+                                            *
+                                            * - Categorized:
+                                            *
+                                            * {
+                                            *     "foo_option",
+                                            *     "Advanced > Speed hack coprocessor X",
+                                            *     "Speed hack coprocessor X",
+                                            *     "Setting 'Advanced > Speed hack coprocessor X' to 'true' or 'Turbo' provides increased performance at the expense of reduced accuracy",
+                                            *     "Setting 'Speed hack coprocessor X' to 'true' or 'Turbo' provides increased performance at the expense of reduced accuracy",
+                                            *     "advanced_settings",
+                                            * 	  {
+                                            *         { "false",    NULL },
+                                            *         { "true",     NULL },
+                                            *         { "unstable", "Turbo (Unstable)" },
+                                            *         { NULL, NULL },
+                                            *     },
+                                            *     "false"
+                                            * }
+                                            *
+                                            * Only strings are operated on. The possible values will
+                                            * generally be displayed and stored as-is by the frontend.
+                                            */
+
+#define RETRO_ENVIRONMENT_SET_CORE_OPTIONS_V2_INTL 68
+                                           /* const struct retro_core_options_v2_intl * --
+                                            * Allows an implementation to signal the environment
+                                            * which variables it might want to check for later using
+                                            * GET_VARIABLE.
+                                            * This allows the frontend to present these variables to
+                                            * a user dynamically.
+                                            * This should only be called if RETRO_ENVIRONMENT_GET_CORE_OPTIONS_VERSION
+                                            * returns an API version of >= 2.
+                                            * This should be called instead of RETRO_ENVIRONMENT_SET_VARIABLES.
+                                            * This should be called instead of RETRO_ENVIRONMENT_SET_CORE_OPTIONS.
+                                            * This should be called instead of RETRO_ENVIRONMENT_SET_CORE_OPTIONS_INTL.
+                                            * This should be called instead of RETRO_ENVIRONMENT_SET_CORE_OPTIONS_V2.
+                                            * This should be called the first time as early as
+                                            * possible (ideally in retro_set_environment).
+                                            * Afterwards it may be called again for the core to communicate
+                                            * updated options to the frontend, but the number of core
+                                            * options must not change from the number in the initial call.
+                                            * If RETRO_ENVIRONMENT_GET_CORE_OPTIONS_VERSION returns an API
+                                            * version of >= 2, this callback is guaranteed to succeed
+                                            * (i.e. callback return value does not indicate success)
+                                            * If callback returns true, frontend has core option category
+                                            * support.
+                                            * If callback returns false, frontend does not have core option
+                                            * category support.
+                                            *
+                                            * This is fundamentally the same as RETRO_ENVIRONMENT_SET_CORE_OPTIONS_V2,
+                                            * with the addition of localisation support. The description of the
+                                            * RETRO_ENVIRONMENT_SET_CORE_OPTIONS_V2 callback should be consulted
+                                            * for further details.
+                                            *
+                                            * 'data' points to a retro_core_options_v2_intl struct.
+                                            *
+                                            * - retro_core_options_v2_intl::us is a pointer to a
+                                            *   retro_core_options_v2 struct defining the US English
+                                            *   core options implementation. It must point to a valid struct.
+                                            *
+                                            * - retro_core_options_v2_intl::local is a pointer to a
+                                            *   retro_core_options_v2 struct defining core options for
+                                            *   the current frontend language. It may be NULL (in which case
+                                            *   retro_core_options_v2_intl::us is used by the frontend). Any items
+                                            *   missing from this struct will be read from
+                                            *   retro_core_options_v2_intl::us instead.
+                                            *
+                                            * NOTE: Default core option values are always taken from the
+                                            * retro_core_options_v2_intl::us struct. Any default values in
+                                            * the retro_core_options_v2_intl::local struct will be ignored.
+                                            */
+
+#define RETRO_ENVIRONMENT_SET_CORE_OPTIONS_UPDATE_DISPLAY_CALLBACK 69
+                                           /* const struct retro_core_options_update_display_callback * --
+                                            * Allows a frontend to signal that a core must update
+                                            * the visibility of any dynamically hidden core options,
+                                            * and enables the frontend to detect visibility changes.
+                                            * Used by the frontend to update the menu display status
+                                            * of core options without requiring a call of retro_run().
+                                            * Must be called in retro_set_environment().
+                                            */
+
+#define RETRO_ENVIRONMENT_SET_VARIABLE 70
+                                           /* const struct retro_variable * --
+                                            * Allows an implementation to notify the frontend
+                                            * that a core option value has changed.
+                                            *
+                                            * retro_variable::key and retro_variable::value
+                                            * must match strings that have been set previously
+                                            * via one of the following:
+                                            *
+                                            * - RETRO_ENVIRONMENT_SET_VARIABLES
+                                            * - RETRO_ENVIRONMENT_SET_CORE_OPTIONS
+                                            * - RETRO_ENVIRONMENT_SET_CORE_OPTIONS_INTL
+                                            * - RETRO_ENVIRONMENT_SET_CORE_OPTIONS_V2
+                                            * - RETRO_ENVIRONMENT_SET_CORE_OPTIONS_V2_INTL
+                                            *
+                                            * After changing a core option value via this
+                                            * callback, RETRO_ENVIRONMENT_GET_VARIABLE_UPDATE
+                                            * will return true.
+                                            *
+                                            * If data is NULL, no changes will be registered
+                                            * and the callback will return true; an
+                                            * implementation may therefore pass NULL in order
+                                            * to test whether the callback is supported.
+                                            */
+
+#define RETRO_ENVIRONMENT_GET_THROTTLE_STATE (71 | RETRO_ENVIRONMENT_EXPERIMENTAL)
+                                           /* struct retro_throttle_state * --
+                                            * Allows an implementation to get details on the actual rate
+                                            * the frontend is attempting to call retro_run().
+                                            */
+
+#define RETRO_ENVIRONMENT_GET_SAVESTATE_CONTEXT (72 | RETRO_ENVIRONMENT_EXPERIMENTAL)
+                                           /* int * --
+                                            * Tells the core about the context the frontend is asking for savestate.
+                                            * (see enum retro_savestate_context)
+                                            */
+
+#define RETRO_ENVIRONMENT_GET_HW_RENDER_CONTEXT_NEGOTIATION_INTERFACE_SUPPORT (73 | RETRO_ENVIRONMENT_EXPERIMENTAL)
+                                            /* struct retro_hw_render_context_negotiation_interface * --
+                                             * Before calling SET_HW_RNEDER_CONTEXT_NEGOTIATION_INTERFACE, a core can query
+                                             * which version of the interface is supported.
+                                             *
+                                             * Frontend looks at interface_type and returns the maximum supported
+                                             * context negotiation interface version.
+                                             * If the interface_type is not supported or recognized by the frontend, a version of 0
+                                             * must be returned in interface_version and true is returned by frontend.
+                                             *
+                                             * If this environment call returns true with interface_version greater than 0,
+                                             * a core can always use a negotiation interface version larger than what the frontend returns, but only
+                                             * earlier versions of the interface will be used by the frontend.
+                                             * A frontend must not reject a negotiation interface version that is larger than
+                                             * what the frontend supports. Instead, the frontend will use the older entry points that it recognizes.
+                                             * If this is incompatible with a particular core's requirements, it can error out early.
+                                             *
+                                             * Backwards compatibility note:
+                                             * This environment call was introduced after Vulkan v1 context negotiation.
+                                             * If this environment call is not supported by frontend - i.e. the environment call returns false -
+                                             * only Vulkan v1 context negotiation is supported (if Vulkan HW rendering is supported at all).
+                                             * If a core uses Vulkan negotiation interface with version > 1, negotiation may fail unexpectedly.
+                                             * All future updates to the context negotiation interface implies that frontend must support
+                                             * this environment call to query support.
+                                             */
+
+
+/* VFS functionality */
+
+/* File paths:
+ * File paths passed as parameters when using this API shall be well formed UNIX-style,
+ * using "/" (unquoted forward slash) as directory separator regardless of the platform's native separator.
+ * Paths shall also include at least one forward slash ("game.bin" is an invalid path, use "./game.bin" instead).
+ * Other than the directory separator, cores shall not make assumptions about path format:
+ * "C:/path/game.bin", "http://example.com/game.bin", "#game/game.bin", "./game.bin" (without quotes) are all valid paths.
+ * Cores may replace the basename or remove path components from the end, and/or add new components;
+ * however, cores shall not append "./", "../" or multiple consecutive forward slashes ("//") to paths they request to front end.
+ * The frontend is encouraged to make such paths work as well as it can, but is allowed to give up if the core alters paths too much.
+ * Frontends are encouraged, but not required, to support native file system paths (modulo replacing the directory separator, if applicable).
+ * Cores are allowed to try using them, but must remain functional if the front rejects such requests.
+ * Cores are encouraged to use the libretro-common filestream functions for file I/O,
+ * as they seamlessly integrate with VFS, deal with directory separator replacement as appropriate
+ * and provide platform-specific fallbacks in cases where front ends do not support VFS. */
+
+/* Opaque file handle
+ * Introduced in VFS API v1 */
+struct retro_vfs_file_handle;
+
+/* Opaque directory handle
+ * Introduced in VFS API v3 */
+struct retro_vfs_dir_handle;
+
+/* File open flags
+ * Introduced in VFS API v1 */
+#define RETRO_VFS_FILE_ACCESS_READ            (1 << 0) /* Read only mode */
+#define RETRO_VFS_FILE_ACCESS_WRITE           (1 << 1) /* Write only mode, discard contents and overwrites existing file unless RETRO_VFS_FILE_ACCESS_UPDATE is also specified */
+#define RETRO_VFS_FILE_ACCESS_READ_WRITE      (RETRO_VFS_FILE_ACCESS_READ | RETRO_VFS_FILE_ACCESS_WRITE) /* Read-write mode, discard contents and overwrites existing file unless RETRO_VFS_FILE_ACCESS_UPDATE is also specified*/
+#define RETRO_VFS_FILE_ACCESS_UPDATE_EXISTING (1 << 2) /* Prevents discarding content of existing files opened for writing */
+
+/* These are only hints. The frontend may choose to ignore them. Other than RAM/CPU/etc use,
+   and how they react to unlikely external interference (for example someone else writing to that file,
+   or the file's server going down), behavior will not change. */
+#define RETRO_VFS_FILE_ACCESS_HINT_NONE              (0)
+/* Indicate that the file will be accessed many times. The frontend should aggressively cache everything. */
+#define RETRO_VFS_FILE_ACCESS_HINT_FREQUENT_ACCESS   (1 << 0)
+
+/* Seek positions */
+#define RETRO_VFS_SEEK_POSITION_START    0
+#define RETRO_VFS_SEEK_POSITION_CURRENT  1
+#define RETRO_VFS_SEEK_POSITION_END      2
+
+/* stat() result flags
+ * Introduced in VFS API v3 */
+#define RETRO_VFS_STAT_IS_VALID               (1 << 0)
+#define RETRO_VFS_STAT_IS_DIRECTORY           (1 << 1)
+#define RETRO_VFS_STAT_IS_CHARACTER_SPECIAL   (1 << 2)
+
+/* Get path from opaque handle. Returns the exact same path passed to file_open when getting the handle
+ * Introduced in VFS API v1 */
+typedef const char *(RETRO_CALLCONV *retro_vfs_get_path_t)(struct retro_vfs_file_handle *stream);
+
+/* Open a file for reading or writing. If path points to a directory, this will
+ * fail. Returns the opaque file handle, or NULL for error.
+ * Introduced in VFS API v1 */
+typedef struct retro_vfs_file_handle *(RETRO_CALLCONV *retro_vfs_open_t)(const char *path, unsigned mode, unsigned hints);
+
+/* Close the file and release its resources. Must be called if open_file returns non-NULL. Returns 0 on success, -1 on failure.
+ * Whether the call succeeds ot not, the handle passed as parameter becomes invalid and should no longer be used.
+ * Introduced in VFS API v1 */
+typedef int (RETRO_CALLCONV *retro_vfs_close_t)(struct retro_vfs_file_handle *stream);
+
+/* Return the size of the file in bytes, or -1 for error.
+ * Introduced in VFS API v1 */
+typedef int64_t (RETRO_CALLCONV *retro_vfs_size_t)(struct retro_vfs_file_handle *stream);
+
+/* Truncate file to specified size. Returns 0 on success or -1 on error
+ * Introduced in VFS API v2 */
+typedef int64_t (RETRO_CALLCONV *retro_vfs_truncate_t)(struct retro_vfs_file_handle *stream, int64_t length);
+
+/* Get the current read / write position for the file. Returns -1 for error.
+ * Introduced in VFS API v1 */
+typedef int64_t (RETRO_CALLCONV *retro_vfs_tell_t)(struct retro_vfs_file_handle *stream);
+
+/* Set the current read/write position for the file. Returns the new position, -1 for error.
+ * Introduced in VFS API v1 */
+typedef int64_t (RETRO_CALLCONV *retro_vfs_seek_t)(struct retro_vfs_file_handle *stream, int64_t offset, int seek_position);
+
+/* Read data from a file. Returns the number of bytes read, or -1 for error.
+ * Introduced in VFS API v1 */
+typedef int64_t (RETRO_CALLCONV *retro_vfs_read_t)(struct retro_vfs_file_handle *stream, void *s, uint64_t len);
+
+/* Write data to a file. Returns the number of bytes written, or -1 for error.
+ * Introduced in VFS API v1 */
+typedef int64_t (RETRO_CALLCONV *retro_vfs_write_t)(struct retro_vfs_file_handle *stream, const void *s, uint64_t len);
+
+/* Flush pending writes to file, if using buffered IO. Returns 0 on sucess, or -1 on failure.
+ * Introduced in VFS API v1 */
+typedef int (RETRO_CALLCONV *retro_vfs_flush_t)(struct retro_vfs_file_handle *stream);
+
+/* Delete the specified file. Returns 0 on success, -1 on failure
+ * Introduced in VFS API v1 */
+typedef int (RETRO_CALLCONV *retro_vfs_remove_t)(const char *path);
+
+/* Rename the specified file. Returns 0 on success, -1 on failure
+ * Introduced in VFS API v1 */
+typedef int (RETRO_CALLCONV *retro_vfs_rename_t)(const char *old_path, const char *new_path);
+
+/* Stat the specified file. Retruns a bitmask of RETRO_VFS_STAT_* flags, none are set if path was not valid.
+ * Additionally stores file size in given variable, unless NULL is given.
+ * Introduced in VFS API v3 */
+typedef int (RETRO_CALLCONV *retro_vfs_stat_t)(const char *path, int32_t *size);
+
+/* Create the specified directory. Returns 0 on success, -1 on unknown failure, -2 if already exists.
+ * Introduced in VFS API v3 */
+typedef int (RETRO_CALLCONV *retro_vfs_mkdir_t)(const char *dir);
+
+/* Open the specified directory for listing. Returns the opaque dir handle, or NULL for error.
+ * Support for the include_hidden argument may vary depending on the platform.
+ * Introduced in VFS API v3 */
+typedef struct retro_vfs_dir_handle *(RETRO_CALLCONV *retro_vfs_opendir_t)(const char *dir, bool include_hidden);
+
+/* Read the directory entry at the current position, and move the read pointer to the next position.
+ * Returns true on success, false if already on the last entry.
+ * Introduced in VFS API v3 */
+typedef bool (RETRO_CALLCONV *retro_vfs_readdir_t)(struct retro_vfs_dir_handle *dirstream);
+
+/* Get the name of the last entry read. Returns a string on success, or NULL for error.
+ * The returned string pointer is valid until the next call to readdir or closedir.
+ * Introduced in VFS API v3 */
+typedef const char *(RETRO_CALLCONV *retro_vfs_dirent_get_name_t)(struct retro_vfs_dir_handle *dirstream);
+
+/* Check if the last entry read was a directory. Returns true if it was, false otherwise (or on error).
+ * Introduced in VFS API v3 */
+typedef bool (RETRO_CALLCONV *retro_vfs_dirent_is_dir_t)(struct retro_vfs_dir_handle *dirstream);
+
+/* Close the directory and release its resources. Must be called if opendir returns non-NULL. Returns 0 on success, -1 on failure.
+ * Whether the call succeeds ot not, the handle passed as parameter becomes invalid and should no longer be used.
+ * Introduced in VFS API v3 */
+typedef int (RETRO_CALLCONV *retro_vfs_closedir_t)(struct retro_vfs_dir_handle *dirstream);
+
+struct retro_vfs_interface
+{
+   /* VFS API v1 */
+	retro_vfs_get_path_t get_path;
+	retro_vfs_open_t open;
+	retro_vfs_close_t close;
+	retro_vfs_size_t size;
+	retro_vfs_tell_t tell;
+	retro_vfs_seek_t seek;
+	retro_vfs_read_t read;
+	retro_vfs_write_t write;
+	retro_vfs_flush_t flush;
+	retro_vfs_remove_t remove;
+	retro_vfs_rename_t rename;
+   /* VFS API v2 */
+   retro_vfs_truncate_t truncate;
+   /* VFS API v3 */
+   retro_vfs_stat_t stat;
+   retro_vfs_mkdir_t mkdir;
+   retro_vfs_opendir_t opendir;
+   retro_vfs_readdir_t readdir;
+   retro_vfs_dirent_get_name_t dirent_get_name;
+   retro_vfs_dirent_is_dir_t dirent_is_dir;
+   retro_vfs_closedir_t closedir;
+};
+
+struct retro_vfs_interface_info
+{
+   /* Set by core: should this be higher than the version the front end supports,
+    * front end will return false in the RETRO_ENVIRONMENT_GET_VFS_INTERFACE call
+    * Introduced in VFS API v1 */
+   uint32_t required_interface_version;
+
+   /* Frontend writes interface pointer here. The frontend also sets the actual
+    * version, must be at least required_interface_version.
+    * Introduced in VFS API v1 */
+   struct retro_vfs_interface *iface;
+};
+
+enum retro_hw_render_interface_type
+{
+	RETRO_HW_RENDER_INTERFACE_VULKAN = 0,
+	RETRO_HW_RENDER_INTERFACE_D3D9   = 1,
+	RETRO_HW_RENDER_INTERFACE_D3D10  = 2,
+	RETRO_HW_RENDER_INTERFACE_D3D11  = 3,
+	RETRO_HW_RENDER_INTERFACE_D3D12  = 4,
+   RETRO_HW_RENDER_INTERFACE_GSKIT_PS2  = 5,
+   RETRO_HW_RENDER_INTERFACE_DUMMY  = INT_MAX
+};
+
+/* Base struct. All retro_hw_render_interface_* types
+ * contain at least these fields. */
+struct retro_hw_render_interface
+{
+   enum retro_hw_render_interface_type interface_type;
+   unsigned interface_version;
+};
+
+typedef void (RETRO_CALLCONV *retro_set_led_state_t)(int led, int state);
+struct retro_led_interface
+{
+    retro_set_led_state_t set_led_state;
+};
+
+/* Retrieves the current state of the MIDI input.
+ * Returns true if it's enabled, false otherwise. */
+typedef bool (RETRO_CALLCONV *retro_midi_input_enabled_t)(void);
+
+/* Retrieves the current state of the MIDI output.
+ * Returns true if it's enabled, false otherwise */
+typedef bool (RETRO_CALLCONV *retro_midi_output_enabled_t)(void);
+
+/* Reads next byte from the input stream.
+ * Returns true if byte is read, false otherwise. */
+typedef bool (RETRO_CALLCONV *retro_midi_read_t)(uint8_t *byte);
+
+/* Writes byte to the output stream.
+ * 'delta_time' is in microseconds and represent time elapsed since previous write.
+ * Returns true if byte is written, false otherwise. */
+typedef bool (RETRO_CALLCONV *retro_midi_write_t)(uint8_t byte, uint32_t delta_time);
+
+/* Flushes previously written data.
+ * Returns true if successful, false otherwise. */
+typedef bool (RETRO_CALLCONV *retro_midi_flush_t)(void);
+
+struct retro_midi_interface
+{
+   retro_midi_input_enabled_t input_enabled;
+   retro_midi_output_enabled_t output_enabled;
+   retro_midi_read_t read;
+   retro_midi_write_t write;
+   retro_midi_flush_t flush;
+};
+
+enum retro_hw_render_context_negotiation_interface_type
+{
+   RETRO_HW_RENDER_CONTEXT_NEGOTIATION_INTERFACE_VULKAN = 0,
+   RETRO_HW_RENDER_CONTEXT_NEGOTIATION_INTERFACE_DUMMY = INT_MAX
+};
+
+/* Base struct. All retro_hw_render_context_negotiation_interface_* types
+ * contain at least these fields. */
+struct retro_hw_render_context_negotiation_interface
+{
+   enum retro_hw_render_context_negotiation_interface_type interface_type;
+   unsigned interface_version;
+};
+
+/* Serialized state is incomplete in some way. Set if serialization is
+ * usable in typical end-user cases but should not be relied upon to
+ * implement frame-sensitive frontend features such as netplay or
+ * rerecording. */
+#define RETRO_SERIALIZATION_QUIRK_INCOMPLETE (1 << 0)
+/* The core must spend some time initializing before serialization is
+ * supported. retro_serialize() will initially fail; retro_unserialize()
+ * and retro_serialize_size() may or may not work correctly either. */
+#define RETRO_SERIALIZATION_QUIRK_MUST_INITIALIZE (1 << 1)
+/* Serialization size may change within a session. */
+#define RETRO_SERIALIZATION_QUIRK_CORE_VARIABLE_SIZE (1 << 2)
+/* Set by the frontend to acknowledge that it supports variable-sized
+ * states. */
+#define RETRO_SERIALIZATION_QUIRK_FRONT_VARIABLE_SIZE (1 << 3)
+/* Serialized state can only be loaded during the same session. */
+#define RETRO_SERIALIZATION_QUIRK_SINGLE_SESSION (1 << 4)
+/* Serialized state cannot be loaded on an architecture with a different
+ * endianness from the one it was saved on. */
+#define RETRO_SERIALIZATION_QUIRK_ENDIAN_DEPENDENT (1 << 5)
+/* Serialized state cannot be loaded on a different platform from the one it
+ * was saved on for reasons other than endianness, such as word size
+ * dependence */
+#define RETRO_SERIALIZATION_QUIRK_PLATFORM_DEPENDENT (1 << 6)
+
+#define RETRO_MEMDESC_CONST      (1 << 0)   /* The frontend will never change this memory area once retro_load_game has returned. */
+#define RETRO_MEMDESC_BIGENDIAN  (1 << 1)   /* The memory area contains big endian data. Default is little endian. */
+#define RETRO_MEMDESC_SYSTEM_RAM (1 << 2)   /* The memory area is system RAM.  This is main RAM of the gaming system. */
+#define RETRO_MEMDESC_SAVE_RAM   (1 << 3)   /* The memory area is save RAM. This RAM is usually found on a game cartridge, backed up by a battery. */
+#define RETRO_MEMDESC_VIDEO_RAM  (1 << 4)   /* The memory area is video RAM (VRAM) */
+#define RETRO_MEMDESC_ALIGN_2    (1 << 16)  /* All memory access in this area is aligned to their own size, or 2, whichever is smaller. */
+#define RETRO_MEMDESC_ALIGN_4    (2 << 16)
+#define RETRO_MEMDESC_ALIGN_8    (3 << 16)
+#define RETRO_MEMDESC_MINSIZE_2  (1 << 24)  /* All memory in this region is accessed at least 2 bytes at the time. */
+#define RETRO_MEMDESC_MINSIZE_4  (2 << 24)
+#define RETRO_MEMDESC_MINSIZE_8  (3 << 24)
+struct retro_memory_descriptor
+{
+   uint64_t flags;
+
+   /* Pointer to the start of the relevant ROM or RAM chip.
+    * It's strongly recommended to use 'offset' if possible, rather than
+    * doing math on the pointer.
+    *
+    * If the same byte is mapped my multiple descriptors, their descriptors
+    * must have the same pointer.
+    * If 'start' does not point to the first byte in the pointer, put the
+    * difference in 'offset' instead.
+    *
+    * May be NULL if there's nothing usable here (e.g. hardware registers and
+    * open bus). No flags should be set if the pointer is NULL.
+    * It's recommended to minimize the number of descriptors if possible,
+    * but not mandatory. */
+   void *ptr;
+   size_t offset;
+
+   /* This is the location in the emulated address space
+    * where the mapping starts. */
+   size_t start;
+
+   /* Which bits must be same as in 'start' for this mapping to apply.
+    * The first memory descriptor to claim a certain byte is the one
+    * that applies.
+    * A bit which is set in 'start' must also be set in this.
+    * Can be zero, in which case each byte is assumed mapped exactly once.
+    * In this case, 'len' must be a power of two. */
+   size_t select;
+
+   /* If this is nonzero, the set bits are assumed not connected to the
+    * memory chip's address pins. */
+   size_t disconnect;
+
+   /* This one tells the size of the current memory area.
+    * If, after start+disconnect are applied, the address is higher than
+    * this, the highest bit of the address is cleared.
+    *
+    * If the address is still too high, the next highest bit is cleared.
+    * Can be zero, in which case it's assumed to be infinite (as limited
+    * by 'select' and 'disconnect'). */
+   size_t len;
+
+   /* To go from emulated address to physical address, the following
+    * order applies:
+    * Subtract 'start', pick off 'disconnect', apply 'len', add 'offset'. */
+
+   /* The address space name must consist of only a-zA-Z0-9_-,
+    * should be as short as feasible (maximum length is 8 plus the NUL),
+    * and may not be any other address space plus one or more 0-9A-F
+    * at the end.
+    * However, multiple memory descriptors for the same address space is
+    * allowed, and the address space name can be empty. NULL is treated
+    * as empty.
+    *
+    * Address space names are case sensitive, but avoid lowercase if possible.
+    * The same pointer may exist in multiple address spaces.
+    *
+    * Examples:
+    * blank+blank - valid (multiple things may be mapped in the same namespace)
+    * 'Sp'+'Sp' - valid (multiple things may be mapped in the same namespace)
+    * 'A'+'B' - valid (neither is a prefix of each other)
+    * 'S'+blank - valid ('S' is not in 0-9A-F)
+    * 'a'+blank - valid ('a' is not in 0-9A-F)
+    * 'a'+'A' - valid (neither is a prefix of each other)
+    * 'AR'+blank - valid ('R' is not in 0-9A-F)
+    * 'ARB'+blank - valid (the B can't be part of the address either, because
+    *                      there is no namespace 'AR')
+    * blank+'B' - not valid, because it's ambigous which address space B1234
+    *             would refer to.
+    * The length can't be used for that purpose; the frontend may want
+    * to append arbitrary data to an address, without a separator. */
+   const char *addrspace;
+
+   /* TODO: When finalizing this one, add a description field, which should be
+    * "WRAM" or something roughly equally long. */
+
+   /* TODO: When finalizing this one, replace 'select' with 'limit', which tells
+    * which bits can vary and still refer to the same address (limit = ~select).
+    * TODO: limit? range? vary? something else? */
+
+   /* TODO: When finalizing this one, if 'len' is above what 'select' (or
+    * 'limit') allows, it's bankswitched. Bankswitched data must have both 'len'
+    * and 'select' != 0, and the mappings don't tell how the system switches the
+    * banks. */
+
+   /* TODO: When finalizing this one, fix the 'len' bit removal order.
+    * For len=0x1800, pointer 0x1C00 should go to 0x1400, not 0x0C00.
+    * Algorithm: Take bits highest to lowest, but if it goes above len, clear
+    * the most recent addition and continue on the next bit.
+    * TODO: Can the above be optimized? Is "remove the lowest bit set in both
+    * pointer and 'len'" equivalent? */
+
+   /* TODO: Some emulators (MAME?) emulate big endian systems by only accessing
+    * the emulated memory in 32-bit chunks, native endian. But that's nothing
+    * compared to Darek Mihocka <http://www.emulators.com/docs/nx07_vm101.htm>
+    * (section Emulation 103 - Nearly Free Byte Reversal) - he flips the ENTIRE
+    * RAM backwards! I'll want to represent both of those, via some flags.
+    *
+    * I suspect MAME either didn't think of that idea, or don't want the #ifdef.
+    * Not sure which, nor do I really care. */
+
+   /* TODO: Some of those flags are unused and/or don't really make sense. Clean
+    * them up. */
+};
+
+/* The frontend may use the largest value of 'start'+'select' in a
+ * certain namespace to infer the size of the address space.
+ *
+ * If the address space is larger than that, a mapping with .ptr=NULL
+ * should be at the end of the array, with .select set to all ones for
+ * as long as the address space is big.
+ *
+ * Sample descriptors (minus .ptr, and RETRO_MEMFLAG_ on the flags):
+ * SNES WRAM:
+ * .start=0x7E0000, .len=0x20000
+ * (Note that this must be mapped before the ROM in most cases; some of the
+ * ROM mappers
+ * try to claim $7E0000, or at least $7E8000.)
+ * SNES SPC700 RAM:
+ * .addrspace="S", .len=0x10000
+ * SNES WRAM mirrors:
+ * .flags=MIRROR, .start=0x000000, .select=0xC0E000, .len=0x2000
+ * .flags=MIRROR, .start=0x800000, .select=0xC0E000, .len=0x2000
+ * SNES WRAM mirrors, alternate equivalent descriptor:
+ * .flags=MIRROR, .select=0x40E000, .disconnect=~0x1FFF
+ * (Various similar constructions can be created by combining parts of
+ * the above two.)
+ * SNES LoROM (512KB, mirrored a couple of times):
+ * .flags=CONST, .start=0x008000, .select=0x408000, .disconnect=0x8000, .len=512*1024
+ * .flags=CONST, .start=0x400000, .select=0x400000, .disconnect=0x8000, .len=512*1024
+ * SNES HiROM (4MB):
+ * .flags=CONST,                 .start=0x400000, .select=0x400000, .len=4*1024*1024
+ * .flags=CONST, .offset=0x8000, .start=0x008000, .select=0x408000, .len=4*1024*1024
+ * SNES ExHiROM (8MB):
+ * .flags=CONST, .offset=0,                  .start=0xC00000, .select=0xC00000, .len=4*1024*1024
+ * .flags=CONST, .offset=4*1024*1024,        .start=0x400000, .select=0xC00000, .len=4*1024*1024
+ * .flags=CONST, .offset=0x8000,             .start=0x808000, .select=0xC08000, .len=4*1024*1024
+ * .flags=CONST, .offset=4*1024*1024+0x8000, .start=0x008000, .select=0xC08000, .len=4*1024*1024
+ * Clarify the size of the address space:
+ * .ptr=NULL, .select=0xFFFFFF
+ * .len can be implied by .select in many of them, but was included for clarity.
+ */
+
+struct retro_memory_map
+{
+   const struct retro_memory_descriptor *descriptors;
+   unsigned num_descriptors;
+};
+
+struct retro_controller_description
+{
+   /* Human-readable description of the controller. Even if using a generic
+    * input device type, this can be set to the particular device type the
+    * core uses. */
+   const char *desc;
+
+   /* Device type passed to retro_set_controller_port_device(). If the device
+    * type is a sub-class of a generic input device type, use the
+    * RETRO_DEVICE_SUBCLASS macro to create an ID.
+    *
+    * E.g. RETRO_DEVICE_SUBCLASS(RETRO_DEVICE_JOYPAD, 1). */
+   unsigned id;
+};
+
+struct retro_controller_info
+{
+   const struct retro_controller_description *types;
+   unsigned num_types;
+};
+
+struct retro_subsystem_memory_info
+{
+   /* The extension associated with a memory type, e.g. "psram". */
+   const char *extension;
+
+   /* The memory type for retro_get_memory(). This should be at
+    * least 0x100 to avoid conflict with standardized
+    * libretro memory types. */
+   unsigned type;
+};
+
+struct retro_subsystem_rom_info
+{
+   /* Describes what the content is (SGB BIOS, GB ROM, etc). */
+   const char *desc;
+
+   /* Same definition as retro_get_system_info(). */
+   const char *valid_extensions;
+
+   /* Same definition as retro_get_system_info(). */
+   bool need_fullpath;
+
+   /* Same definition as retro_get_system_info(). */
+   bool block_extract;
+
+   /* This is set if the content is required to load a game.
+    * If this is set to false, a zeroed-out retro_game_info can be passed. */
+   bool required;
+
+   /* Content can have multiple associated persistent
+    * memory types (retro_get_memory()). */
+   const struct retro_subsystem_memory_info *memory;
+   unsigned num_memory;
+};
+
+struct retro_subsystem_info
+{
+   /* Human-readable string of the subsystem type, e.g. "Super GameBoy" */
+   const char *desc;
+
+   /* A computer friendly short string identifier for the subsystem type.
+    * This name must be [a-z].
+    * E.g. if desc is "Super GameBoy", this can be "sgb".
+    * This identifier can be used for command-line interfaces, etc.
+    */
+   const char *ident;
+
+   /* Infos for each content file. The first entry is assumed to be the
+    * "most significant" content for frontend purposes.
+    * E.g. with Super GameBoy, the first content should be the GameBoy ROM,
+    * as it is the most "significant" content to a user.
+    * If a frontend creates new file paths based on the content used
+    * (e.g. savestates), it should use the path for the first ROM to do so. */
+   const struct retro_subsystem_rom_info *roms;
+
+   /* Number of content files associated with a subsystem. */
+   unsigned num_roms;
+
+   /* The type passed to retro_load_game_special(). */
+   unsigned id;
+};
+
+typedef void (RETRO_CALLCONV *retro_proc_address_t)(void);
+
+/* libretro API extension functions:
+ * (None here so far).
+ *
+ * Get a symbol from a libretro core.
+ * Cores should only return symbols which are actual
+ * extensions to the libretro API.
+ *
+ * Frontends should not use this to obtain symbols to standard
+ * libretro entry points (static linking or dlsym).
+ *
+ * The symbol name must be equal to the function name,
+ * e.g. if void retro_foo(void); exists, the symbol must be called "retro_foo".
+ * The returned function pointer must be cast to the corresponding type.
+ */
+typedef retro_proc_address_t (RETRO_CALLCONV *retro_get_proc_address_t)(const char *sym);
+
+struct retro_get_proc_address_interface
+{
+   retro_get_proc_address_t get_proc_address;
+};
+
+enum retro_log_level
+{
+   RETRO_LOG_DEBUG = 0,
+   RETRO_LOG_INFO,
+   RETRO_LOG_WARN,
+   RETRO_LOG_ERROR,
+
+   RETRO_LOG_DUMMY = INT_MAX
+};
+
+/* Logging function. Takes log level argument as well. */
+typedef void (RETRO_CALLCONV *retro_log_printf_t)(enum retro_log_level level,
+      const char *fmt, ...);
+
+struct retro_log_callback
+{
+   retro_log_printf_t log;
+};
+
+/* Performance related functions */
+
+/* ID values for SIMD CPU features */
+#define RETRO_SIMD_SSE      (1 << 0)
+#define RETRO_SIMD_SSE2     (1 << 1)
+#define RETRO_SIMD_VMX      (1 << 2)
+#define RETRO_SIMD_VMX128   (1 << 3)
+#define RETRO_SIMD_AVX      (1 << 4)
+#define RETRO_SIMD_NEON     (1 << 5)
+#define RETRO_SIMD_SSE3     (1 << 6)
+#define RETRO_SIMD_SSSE3    (1 << 7)
+#define RETRO_SIMD_MMX      (1 << 8)
+#define RETRO_SIMD_MMXEXT   (1 << 9)
+#define RETRO_SIMD_SSE4     (1 << 10)
+#define RETRO_SIMD_SSE42    (1 << 11)
+#define RETRO_SIMD_AVX2     (1 << 12)
+#define RETRO_SIMD_VFPU     (1 << 13)
+#define RETRO_SIMD_PS       (1 << 14)
+#define RETRO_SIMD_AES      (1 << 15)
+#define RETRO_SIMD_VFPV3    (1 << 16)
+#define RETRO_SIMD_VFPV4    (1 << 17)
+#define RETRO_SIMD_POPCNT   (1 << 18)
+#define RETRO_SIMD_MOVBE    (1 << 19)
+#define RETRO_SIMD_CMOV     (1 << 20)
+#define RETRO_SIMD_ASIMD    (1 << 21)
+
+typedef uint64_t retro_perf_tick_t;
+typedef int64_t retro_time_t;
+
+struct retro_perf_counter
+{
+   const char *ident;
+   retro_perf_tick_t start;
+   retro_perf_tick_t total;
+   retro_perf_tick_t call_cnt;
+
+   bool registered;
+};
+
+/* Returns current time in microseconds.
+ * Tries to use the most accurate timer available.
+ */
+typedef retro_time_t (RETRO_CALLCONV *retro_perf_get_time_usec_t)(void);
+
+/* A simple counter. Usually nanoseconds, but can also be CPU cycles.
+ * Can be used directly if desired (when creating a more sophisticated
+ * performance counter system).
+ * */
+typedef retro_perf_tick_t (RETRO_CALLCONV *retro_perf_get_counter_t)(void);
+
+/* Returns a bit-mask of detected CPU features (RETRO_SIMD_*). */
+typedef uint64_t (RETRO_CALLCONV *retro_get_cpu_features_t)(void);
+
+/* Asks frontend to log and/or display the state of performance counters.
+ * Performance counters can always be poked into manually as well.
+ */
+typedef void (RETRO_CALLCONV *retro_perf_log_t)(void);
+
+/* Register a performance counter.
+ * ident field must be set with a discrete value and other values in
+ * retro_perf_counter must be 0.
+ * Registering can be called multiple times. To avoid calling to
+ * frontend redundantly, you can check registered field first. */
+typedef void (RETRO_CALLCONV *retro_perf_register_t)(struct retro_perf_counter *counter);
+
+/* Starts a registered counter. */
+typedef void (RETRO_CALLCONV *retro_perf_start_t)(struct retro_perf_counter *counter);
+
+/* Stops a registered counter. */
+typedef void (RETRO_CALLCONV *retro_perf_stop_t)(struct retro_perf_counter *counter);
+
+/* For convenience it can be useful to wrap register, start and stop in macros.
+ * E.g.:
+ * #ifdef LOG_PERFORMANCE
+ * #define RETRO_PERFORMANCE_INIT(perf_cb, name) static struct retro_perf_counter name = {#name}; if (!name.registered) perf_cb.perf_register(&(name))
+ * #define RETRO_PERFORMANCE_START(perf_cb, name) perf_cb.perf_start(&(name))
+ * #define RETRO_PERFORMANCE_STOP(perf_cb, name) perf_cb.perf_stop(&(name))
+ * #else
+ * ... Blank macros ...
+ * #endif
+ *
+ * These can then be used mid-functions around code snippets.
+ *
+ * extern struct retro_perf_callback perf_cb;  * Somewhere in the core.
+ *
+ * void do_some_heavy_work(void)
+ * {
+ *    RETRO_PERFORMANCE_INIT(cb, work_1;
+ *    RETRO_PERFORMANCE_START(cb, work_1);
+ *    heavy_work_1();
+ *    RETRO_PERFORMANCE_STOP(cb, work_1);
+ *
+ *    RETRO_PERFORMANCE_INIT(cb, work_2);
+ *    RETRO_PERFORMANCE_START(cb, work_2);
+ *    heavy_work_2();
+ *    RETRO_PERFORMANCE_STOP(cb, work_2);
+ * }
+ *
+ * void retro_deinit(void)
+ * {
+ *    perf_cb.perf_log();  * Log all perf counters here for example.
+ * }
+ */
+
+struct retro_perf_callback
+{
+   retro_perf_get_time_usec_t    get_time_usec;
+   retro_get_cpu_features_t      get_cpu_features;
+
+   retro_perf_get_counter_t      get_perf_counter;
+   retro_perf_register_t         perf_register;
+   retro_perf_start_t            perf_start;
+   retro_perf_stop_t             perf_stop;
+   retro_perf_log_t              perf_log;
+};
+
+/* FIXME: Document the sensor API and work out behavior.
+ * It will be marked as experimental until then.
+ */
+enum retro_sensor_action
+{
+   RETRO_SENSOR_ACCELEROMETER_ENABLE = 0,
+   RETRO_SENSOR_ACCELEROMETER_DISABLE,
+   RETRO_SENSOR_GYROSCOPE_ENABLE,
+   RETRO_SENSOR_GYROSCOPE_DISABLE,
+   RETRO_SENSOR_ILLUMINANCE_ENABLE,
+   RETRO_SENSOR_ILLUMINANCE_DISABLE,
+
+   RETRO_SENSOR_DUMMY = INT_MAX
+};
+
+/* Id values for SENSOR types. */
+#define RETRO_SENSOR_ACCELEROMETER_X 0
+#define RETRO_SENSOR_ACCELEROMETER_Y 1
+#define RETRO_SENSOR_ACCELEROMETER_Z 2
+#define RETRO_SENSOR_GYROSCOPE_X 3
+#define RETRO_SENSOR_GYROSCOPE_Y 4
+#define RETRO_SENSOR_GYROSCOPE_Z 5
+#define RETRO_SENSOR_ILLUMINANCE 6
+
+typedef bool (RETRO_CALLCONV *retro_set_sensor_state_t)(unsigned port,
+      enum retro_sensor_action action, unsigned rate);
+
+typedef float (RETRO_CALLCONV *retro_sensor_get_input_t)(unsigned port, unsigned id);
+
+struct retro_sensor_interface
+{
+   retro_set_sensor_state_t set_sensor_state;
+   retro_sensor_get_input_t get_sensor_input;
+};
+
+enum retro_camera_buffer
+{
+   RETRO_CAMERA_BUFFER_OPENGL_TEXTURE = 0,
+   RETRO_CAMERA_BUFFER_RAW_FRAMEBUFFER,
+
+   RETRO_CAMERA_BUFFER_DUMMY = INT_MAX
+};
+
+/* Starts the camera driver. Can only be called in retro_run(). */
+typedef bool (RETRO_CALLCONV *retro_camera_start_t)(void);
+
+/* Stops the camera driver. Can only be called in retro_run(). */
+typedef void (RETRO_CALLCONV *retro_camera_stop_t)(void);
+
+/* Callback which signals when the camera driver is initialized
+ * and/or deinitialized.
+ * retro_camera_start_t can be called in initialized callback.
+ */
+typedef void (RETRO_CALLCONV *retro_camera_lifetime_status_t)(void);
+
+/* A callback for raw framebuffer data. buffer points to an XRGB8888 buffer.
+ * Width, height and pitch are similar to retro_video_refresh_t.
+ * First pixel is top-left origin.
+ */
+typedef void (RETRO_CALLCONV *retro_camera_frame_raw_framebuffer_t)(const uint32_t *buffer,
+      unsigned width, unsigned height, size_t pitch);
+
+/* A callback for when OpenGL textures are used.
+ *
+ * texture_id is a texture owned by camera driver.
+ * Its state or content should be considered immutable, except for things like
+ * texture filtering and clamping.
+ *
+ * texture_target is the texture target for the GL texture.
+ * These can include e.g. GL_TEXTURE_2D, GL_TEXTURE_RECTANGLE, and possibly
+ * more depending on extensions.
+ *
+ * affine points to a packed 3x3 column-major matrix used to apply an affine
+ * transform to texture coordinates. (affine_matrix * vec3(coord_x, coord_y, 1.0))
+ * After transform, normalized texture coord (0, 0) should be bottom-left
+ * and (1, 1) should be top-right (or (width, height) for RECTANGLE).
+ *
+ * GL-specific typedefs are avoided here to avoid relying on gl.h in
+ * the API definition.
+ */
+typedef void (RETRO_CALLCONV *retro_camera_frame_opengl_texture_t)(unsigned texture_id,
+      unsigned texture_target, const float *affine);
+
+struct retro_camera_callback
+{
+   /* Set by libretro core.
+    * Example bitmask: caps = (1 << RETRO_CAMERA_BUFFER_OPENGL_TEXTURE) | (1 << RETRO_CAMERA_BUFFER_RAW_FRAMEBUFFER).
+    */
+   uint64_t caps;
+
+   /* Desired resolution for camera. Is only used as a hint. */
+   unsigned width;
+   unsigned height;
+
+   /* Set by frontend. */
+   retro_camera_start_t start;
+   retro_camera_stop_t stop;
+
+   /* Set by libretro core if raw framebuffer callbacks will be used. */
+   retro_camera_frame_raw_framebuffer_t frame_raw_framebuffer;
+
+   /* Set by libretro core if OpenGL texture callbacks will be used. */
+   retro_camera_frame_opengl_texture_t frame_opengl_texture;
+
+   /* Set by libretro core. Called after camera driver is initialized and
+    * ready to be started.
+    * Can be NULL, in which this callback is not called.
+    */
+   retro_camera_lifetime_status_t initialized;
+
+   /* Set by libretro core. Called right before camera driver is
+    * deinitialized.
+    * Can be NULL, in which this callback is not called.
+    */
+   retro_camera_lifetime_status_t deinitialized;
+};
+
+/* Sets the interval of time and/or distance at which to update/poll
+ * location-based data.
+ *
+ * To ensure compatibility with all location-based implementations,
+ * values for both interval_ms and interval_distance should be provided.
+ *
+ * interval_ms is the interval expressed in milliseconds.
+ * interval_distance is the distance interval expressed in meters.
+ */
+typedef void (RETRO_CALLCONV *retro_location_set_interval_t)(unsigned interval_ms,
+      unsigned interval_distance);
+
+/* Start location services. The device will start listening for changes to the
+ * current location at regular intervals (which are defined with
+ * retro_location_set_interval_t). */
+typedef bool (RETRO_CALLCONV *retro_location_start_t)(void);
+
+/* Stop location services. The device will stop listening for changes
+ * to the current location. */
+typedef void (RETRO_CALLCONV *retro_location_stop_t)(void);
+
+/* Get the position of the current location. Will set parameters to
+ * 0 if no new  location update has happened since the last time. */
+typedef bool (RETRO_CALLCONV *retro_location_get_position_t)(double *lat, double *lon,
+      double *horiz_accuracy, double *vert_accuracy);
+
+/* Callback which signals when the location driver is initialized
+ * and/or deinitialized.
+ * retro_location_start_t can be called in initialized callback.
+ */
+typedef void (RETRO_CALLCONV *retro_location_lifetime_status_t)(void);
+
+struct retro_location_callback
+{
+   retro_location_start_t         start;
+   retro_location_stop_t          stop;
+   retro_location_get_position_t  get_position;
+   retro_location_set_interval_t  set_interval;
+
+   retro_location_lifetime_status_t initialized;
+   retro_location_lifetime_status_t deinitialized;
+};
+
+enum retro_rumble_effect
+{
+   RETRO_RUMBLE_STRONG = 0,
+   RETRO_RUMBLE_WEAK = 1,
+
+   RETRO_RUMBLE_DUMMY = INT_MAX
+};
+
+/* Sets rumble state for joypad plugged in port 'port'.
+ * Rumble effects are controlled independently,
+ * and setting e.g. strong rumble does not override weak rumble.
+ * Strength has a range of [0, 0xffff].
+ *
+ * Returns true if rumble state request was honored.
+ * Calling this before first retro_run() is likely to return false. */
+typedef bool (RETRO_CALLCONV *retro_set_rumble_state_t)(unsigned port,
+      enum retro_rumble_effect effect, uint16_t strength);
+
+struct retro_rumble_interface
+{
+   retro_set_rumble_state_t set_rumble_state;
+};
+
+/* Notifies libretro that audio data should be written. */
+typedef void (RETRO_CALLCONV *retro_audio_callback_t)(void);
+
+/* True: Audio driver in frontend is active, and callback is
+ * expected to be called regularily.
+ * False: Audio driver in frontend is paused or inactive.
+ * Audio callback will not be called until set_state has been
+ * called with true.
+ * Initial state is false (inactive).
+ */
+typedef void (RETRO_CALLCONV *retro_audio_set_state_callback_t)(bool enabled);
+
+struct retro_audio_callback
+{
+   retro_audio_callback_t callback;
+   retro_audio_set_state_callback_t set_state;
+};
+
+/* Notifies a libretro core of time spent since last invocation
+ * of retro_run() in microseconds.
+ *
+ * It will be called right before retro_run() every frame.
+ * The frontend can tamper with timing to support cases like
+ * fast-forward, slow-motion and framestepping.
+ *
+ * In those scenarios the reference frame time value will be used. */
+typedef int64_t retro_usec_t;
+typedef void (RETRO_CALLCONV *retro_frame_time_callback_t)(retro_usec_t usec);
+struct retro_frame_time_callback
+{
+   retro_frame_time_callback_t callback;
+   /* Represents the time of one frame. It is computed as
+    * 1000000 / fps, but the implementation will resolve the
+    * rounding to ensure that framestepping, etc is exact. */
+   retro_usec_t reference;
+};
+
+/* Notifies a libretro core of the current occupancy
+ * level of the frontend audio buffer.
+ *
+ * - active: 'true' if audio buffer is currently
+ *           in use. Will be 'false' if audio is
+ *           disabled in the frontend
+ *
+ * - occupancy: Given as a value in the range [0,100],
+ *              corresponding to the occupancy percentage
+ *              of the audio buffer
+ *
+ * - underrun_likely: 'true' if the frontend expects an
+ *                    audio buffer underrun during the
+ *                    next frame (indicates that a core
+ *                    should attempt frame skipping)
+ *
+ * It will be called right before retro_run() every frame. */
+typedef void (RETRO_CALLCONV *retro_audio_buffer_status_callback_t)(
+      bool active, unsigned occupancy, bool underrun_likely);
+struct retro_audio_buffer_status_callback
+{
+   retro_audio_buffer_status_callback_t callback;
+};
+
+/* Pass this to retro_video_refresh_t if rendering to hardware.
+ * Passing NULL to retro_video_refresh_t is still a frame dupe as normal.
+ * */
+#define RETRO_HW_FRAME_BUFFER_VALID ((void*)-1)
+
+/* Invalidates the current HW context.
+ * Any GL state is lost, and must not be deinitialized explicitly.
+ * If explicit deinitialization is desired by the libretro core,
+ * it should implement context_destroy callback.
+ * If called, all GPU resources must be reinitialized.
+ * Usually called when frontend reinits video driver.
+ * Also called first time video driver is initialized,
+ * allowing libretro core to initialize resources.
+ */
+typedef void (RETRO_CALLCONV *retro_hw_context_reset_t)(void);
+
+/* Gets current framebuffer which is to be rendered to.
+ * Could change every frame potentially.
+ */
+typedef uintptr_t (RETRO_CALLCONV *retro_hw_get_current_framebuffer_t)(void);
+
+/* Get a symbol from HW context. */
+typedef retro_proc_address_t (RETRO_CALLCONV *retro_hw_get_proc_address_t)(const char *sym);
+
+enum retro_hw_context_type
+{
+   RETRO_HW_CONTEXT_NONE             = 0,
+   /* OpenGL 2.x. Driver can choose to use latest compatibility context. */
+   RETRO_HW_CONTEXT_OPENGL           = 1,
+   /* OpenGL ES 2.0. */
+   RETRO_HW_CONTEXT_OPENGLES2        = 2,
+   /* Modern desktop core GL context. Use version_major/
+    * version_minor fields to set GL version. */
+   RETRO_HW_CONTEXT_OPENGL_CORE      = 3,
+   /* OpenGL ES 3.0 */
+   RETRO_HW_CONTEXT_OPENGLES3        = 4,
+   /* OpenGL ES 3.1+. Set version_major/version_minor. For GLES2 and GLES3,
+    * use the corresponding enums directly. */
+   RETRO_HW_CONTEXT_OPENGLES_VERSION = 5,
+
+   /* Vulkan, see RETRO_ENVIRONMENT_GET_HW_RENDER_INTERFACE. */
+   RETRO_HW_CONTEXT_VULKAN           = 6,
+
+   /* Direct3D, set version_major to select the type of interface
+    * returned by RETRO_ENVIRONMENT_GET_HW_RENDER_INTERFACE */
+   RETRO_HW_CONTEXT_DIRECT3D         = 7,
+
+   RETRO_HW_CONTEXT_DUMMY = INT_MAX
+};
+
+struct retro_hw_render_callback
+{
+   /* Which API to use. Set by libretro core. */
+   enum retro_hw_context_type context_type;
+
+   /* Called when a context has been created or when it has been reset.
+    * An OpenGL context is only valid after context_reset() has been called.
+    *
+    * When context_reset is called, OpenGL resources in the libretro
+    * implementation are guaranteed to be invalid.
+    *
+    * It is possible that context_reset is called multiple times during an
+    * application lifecycle.
+    * If context_reset is called without any notification (context_destroy),
+    * the OpenGL context was lost and resources should just be recreated
+    * without any attempt to "free" old resources.
+    */
+   retro_hw_context_reset_t context_reset;
+
+   /* Set by frontend.
+    * TODO: This is rather obsolete. The frontend should not
+    * be providing preallocated framebuffers. */
+   retro_hw_get_current_framebuffer_t get_current_framebuffer;
+
+   /* Set by frontend.
+    * Can return all relevant functions, including glClear on Windows. */
+   retro_hw_get_proc_address_t get_proc_address;
+
+   /* Set if render buffers should have depth component attached.
+    * TODO: Obsolete. */
+   bool depth;
+
+   /* Set if stencil buffers should be attached.
+    * TODO: Obsolete. */
+   bool stencil;
+
+   /* If depth and stencil are true, a packed 24/8 buffer will be added.
+    * Only attaching stencil is invalid and will be ignored. */
+
+   /* Use conventional bottom-left origin convention. If false,
+    * standard libretro top-left origin semantics are used.
+    * TODO: Move to GL specific interface. */
+   bool bottom_left_origin;
+
+   /* Major version number for core GL context or GLES 3.1+. */
+   unsigned version_major;
+
+   /* Minor version number for core GL context or GLES 3.1+. */
+   unsigned version_minor;
+
+   /* If this is true, the frontend will go very far to avoid
+    * resetting context in scenarios like toggling fullscreen, etc.
+    * TODO: Obsolete? Maybe frontend should just always assume this ...
+    */
+   bool cache_context;
+
+   /* The reset callback might still be called in extreme situations
+    * such as if the context is lost beyond recovery.
+    *
+    * For optimal stability, set this to false, and allow context to be
+    * reset at any time.
+    */
+
+   /* A callback to be called before the context is destroyed in a
+    * controlled way by the frontend. */
+   retro_hw_context_reset_t context_destroy;
+
+   /* OpenGL resources can be deinitialized cleanly at this step.
+    * context_destroy can be set to NULL, in which resources will
+    * just be destroyed without any notification.
+    *
+    * Even when context_destroy is non-NULL, it is possible that
+    * context_reset is called without any destroy notification.
+    * This happens if context is lost by external factors (such as
+    * notified by GL_ARB_robustness).
+    *
+    * In this case, the context is assumed to be already dead,
+    * and the libretro implementation must not try to free any OpenGL
+    * resources in the subsequent context_reset.
+    */
+
+   /* Creates a debug context. */
+   bool debug_context;
+};
+
+/* Callback type passed in RETRO_ENVIRONMENT_SET_KEYBOARD_CALLBACK.
+ * Called by the frontend in response to keyboard events.
+ * down is set if the key is being pressed, or false if it is being released.
+ * keycode is the RETROK value of the char.
+ * character is the text character of the pressed key. (UTF-32).
+ * key_modifiers is a set of RETROKMOD values or'ed together.
+ *
+ * The pressed/keycode state can be indepedent of the character.
+ * It is also possible that multiple characters are generated from a
+ * single keypress.
+ * Keycode events should be treated separately from character events.
+ * However, when possible, the frontend should try to synchronize these.
+ * If only a character is posted, keycode should be RETROK_UNKNOWN.
+ *
+ * Similarily if only a keycode event is generated with no corresponding
+ * character, character should be 0.
+ */
+typedef void (RETRO_CALLCONV *retro_keyboard_event_t)(bool down, unsigned keycode,
+      uint32_t character, uint16_t key_modifiers);
+
+struct retro_keyboard_callback
+{
+   retro_keyboard_event_t callback;
+};
+
+/* Callbacks for RETRO_ENVIRONMENT_SET_DISK_CONTROL_INTERFACE &
+ * RETRO_ENVIRONMENT_SET_DISK_CONTROL_EXT_INTERFACE.
+ * Should be set for implementations which can swap out multiple disk
+ * images in runtime.
+ *
+ * If the implementation can do this automatically, it should strive to do so.
+ * However, there are cases where the user must manually do so.
+ *
+ * Overview: To swap a disk image, eject the disk image with
+ * set_eject_state(true).
+ * Set the disk index with set_image_index(index). Insert the disk again
+ * with set_eject_state(false).
+ */
+
+/* If ejected is true, "ejects" the virtual disk tray.
+ * When ejected, the disk image index can be set.
+ */
+typedef bool (RETRO_CALLCONV *retro_set_eject_state_t)(bool ejected);
+
+/* Gets current eject state. The initial state is 'not ejected'. */
+typedef bool (RETRO_CALLCONV *retro_get_eject_state_t)(void);
+
+/* Gets current disk index. First disk is index 0.
+ * If return value is >= get_num_images(), no disk is currently inserted.
+ */
+typedef unsigned (RETRO_CALLCONV *retro_get_image_index_t)(void);
+
+/* Sets image index. Can only be called when disk is ejected.
+ * The implementation supports setting "no disk" by using an
+ * index >= get_num_images().
+ */
+typedef bool (RETRO_CALLCONV *retro_set_image_index_t)(unsigned index);
+
+/* Gets total number of images which are available to use. */
+typedef unsigned (RETRO_CALLCONV *retro_get_num_images_t)(void);
+
+struct retro_game_info;
+
+/* Replaces the disk image associated with index.
+ * Arguments to pass in info have same requirements as retro_load_game().
+ * Virtual disk tray must be ejected when calling this.
+ *
+ * Replacing a disk image with info = NULL will remove the disk image
+ * from the internal list.
+ * As a result, calls to get_image_index() can change.
+ *
+ * E.g. replace_image_index(1, NULL), and previous get_image_index()
+ * returned 4 before.
+ * Index 1 will be removed, and the new index is 3.
+ */
+typedef bool (RETRO_CALLCONV *retro_replace_image_index_t)(unsigned index,
+      const struct retro_game_info *info);
+
+/* Adds a new valid index (get_num_images()) to the internal disk list.
+ * This will increment subsequent return values from get_num_images() by 1.
+ * This image index cannot be used until a disk image has been set
+ * with replace_image_index. */
+typedef bool (RETRO_CALLCONV *retro_add_image_index_t)(void);
+
+/* Sets initial image to insert in drive when calling
+ * core_load_game().
+ * Since we cannot pass the initial index when loading
+ * content (this would require a major API change), this
+ * is set by the frontend *before* calling the core's
+ * retro_load_game()/retro_load_game_special() implementation.
+ * A core should therefore cache the index/path values and handle
+ * them inside retro_load_game()/retro_load_game_special().
+ * - If 'index' is invalid (index >= get_num_images()), the
+ *   core should ignore the set value and instead use 0
+ * - 'path' is used purely for error checking - i.e. when
+ *   content is loaded, the core should verify that the
+ *   disk specified by 'index' has the specified file path.
+ *   This is to guard against auto selecting the wrong image
+ *   if (for example) the user should modify an existing M3U
+ *   playlist. We have to let the core handle this because
+ *   set_initial_image() must be called before loading content,
+ *   i.e. the frontend cannot access image paths in advance
+ *   and thus cannot perform the error check itself.
+ *   If set path and content path do not match, the core should
+ *   ignore the set 'index' value and instead use 0
+ * Returns 'false' if index or 'path' are invalid, or core
+ * does not support this functionality
+ */
+typedef bool (RETRO_CALLCONV *retro_set_initial_image_t)(unsigned index, const char *path);
+
+/* Fetches the path of the specified disk image file.
+ * Returns 'false' if index is invalid (index >= get_num_images())
+ * or path is otherwise unavailable.
+ */
+typedef bool (RETRO_CALLCONV *retro_get_image_path_t)(unsigned index, char *path, size_t len);
+
+/* Fetches a core-provided 'label' for the specified disk
+ * image file. In the simplest case this may be a file name
+ * (without extension), but for cores with more complex
+ * content requirements information may be provided to
+ * facilitate user disk swapping - for example, a core
+ * running floppy-disk-based content may uniquely label
+ * save disks, data disks, level disks, etc. with names
+ * corresponding to in-game disk change prompts (so the
+ * frontend can provide better user guidance than a 'dumb'
+ * disk index value).
+ * Returns 'false' if index is invalid (index >= get_num_images())
+ * or label is otherwise unavailable.
+ */
+typedef bool (RETRO_CALLCONV *retro_get_image_label_t)(unsigned index, char *label, size_t len);
+
+struct retro_disk_control_callback
+{
+   retro_set_eject_state_t set_eject_state;
+   retro_get_eject_state_t get_eject_state;
+
+   retro_get_image_index_t get_image_index;
+   retro_set_image_index_t set_image_index;
+   retro_get_num_images_t  get_num_images;
+
+   retro_replace_image_index_t replace_image_index;
+   retro_add_image_index_t add_image_index;
+};
+
+struct retro_disk_control_ext_callback
+{
+   retro_set_eject_state_t set_eject_state;
+   retro_get_eject_state_t get_eject_state;
+
+   retro_get_image_index_t get_image_index;
+   retro_set_image_index_t set_image_index;
+   retro_get_num_images_t  get_num_images;
+
+   retro_replace_image_index_t replace_image_index;
+   retro_add_image_index_t add_image_index;
+
+   /* NOTE: Frontend will only attempt to record/restore
+    * last used disk index if both set_initial_image()
+    * and get_image_path() are implemented */
+   retro_set_initial_image_t set_initial_image; /* Optional - may be NULL */
+
+   retro_get_image_path_t get_image_path;       /* Optional - may be NULL */
+   retro_get_image_label_t get_image_label;     /* Optional - may be NULL */
+};
+
+enum retro_pixel_format
+{
+   /* 0RGB1555, native endian.
+    * 0 bit must be set to 0.
+    * This pixel format is default for compatibility concerns only.
+    * If a 15/16-bit pixel format is desired, consider using RGB565. */
+   RETRO_PIXEL_FORMAT_0RGB1555 = 0,
+
+   /* XRGB8888, native endian.
+    * X bits are ignored. */
+   RETRO_PIXEL_FORMAT_XRGB8888 = 1,
+
+   /* RGB565, native endian.
+    * This pixel format is the recommended format to use if a 15/16-bit
+    * format is desired as it is the pixel format that is typically
+    * available on a wide range of low-power devices.
+    *
+    * It is also natively supported in APIs like OpenGL ES. */
+   RETRO_PIXEL_FORMAT_RGB565   = 2,
+
+   /* Ensure sizeof() == sizeof(int). */
+   RETRO_PIXEL_FORMAT_UNKNOWN  = INT_MAX
+};
+
+enum retro_savestate_context
+{
+   /* Standard savestate written to disk. */
+   RETRO_SAVESTATE_CONTEXT_NORMAL                 = 0,
+
+   /* Savestate where you are guaranteed that the same instance will load the save state.
+    * You can store internal pointers to code or data.
+    * It's still a full serialization and deserialization, and could be loaded or saved at any time. 
+    * It won't be written to disk or sent over the network.
+    */
+   RETRO_SAVESTATE_CONTEXT_RUNAHEAD_SAME_INSTANCE = 1,
+
+   /* Savestate where you are guaranteed that the same emulator binary will load that savestate.
+    * You can skip anything that would slow down saving or loading state but you can not store internal pointers. 
+    * It won't be written to disk or sent over the network.
+    * Example: "Second Instance" runahead
+    */
+   RETRO_SAVESTATE_CONTEXT_RUNAHEAD_SAME_BINARY   = 2,
+
+   /* Savestate used within a rollback netplay feature.
+    * You should skip anything that would unnecessarily increase bandwidth usage.
+    * It won't be written to disk but it will be sent over the network.
+    */
+   RETRO_SAVESTATE_CONTEXT_ROLLBACK_NETPLAY       = 3,
+
+   /* Ensure sizeof() == sizeof(int). */
+   RETRO_SAVESTATE_CONTEXT_UNKNOWN                = INT_MAX
+};
+
+struct retro_message
+{
+   const char *msg;        /* Message to be displayed. */
+   unsigned    frames;     /* Duration in frames of message. */
+};
+
+enum retro_message_target
+{
+   RETRO_MESSAGE_TARGET_ALL = 0,
+   RETRO_MESSAGE_TARGET_OSD,
+   RETRO_MESSAGE_TARGET_LOG
+};
+
+enum retro_message_type
+{
+   RETRO_MESSAGE_TYPE_NOTIFICATION = 0,
+   RETRO_MESSAGE_TYPE_NOTIFICATION_ALT,
+   RETRO_MESSAGE_TYPE_STATUS,
+   RETRO_MESSAGE_TYPE_PROGRESS
+};
+
+struct retro_message_ext
+{
+   /* Message string to be displayed/logged */
+   const char *msg;
+   /* Duration (in ms) of message when targeting the OSD */
+   unsigned duration;
+   /* Message priority when targeting the OSD
+    * > When multiple concurrent messages are sent to
+    *   the frontend and the frontend does not have the
+    *   capacity to display them all, messages with the
+    *   *highest* priority value should be shown
+    * > There is no upper limit to a message priority
+    *   value (within the bounds of the unsigned data type)
+    * > In the reference frontend (RetroArch), the same
+    *   priority values are used for frontend-generated
+    *   notifications, which are typically assigned values
+    *   between 0 and 3 depending upon importance */
+   unsigned priority;
+   /* Message logging level (info, warn, error, etc.) */
+   enum retro_log_level level;
+   /* Message destination: OSD, logging interface or both */
+   enum retro_message_target target;
+   /* Message 'type' when targeting the OSD
+    * > RETRO_MESSAGE_TYPE_NOTIFICATION: Specifies that a
+    *   message should be handled in identical fashion to
+    *   a standard frontend-generated notification
+    * > RETRO_MESSAGE_TYPE_NOTIFICATION_ALT: Specifies that
+    *   message is a notification that requires user attention
+    *   or action, but that it should be displayed in a manner
+    *   that differs from standard frontend-generated notifications.
+    *   This would typically correspond to messages that should be
+    *   displayed immediately (independently from any internal
+    *   frontend message queue), and/or which should be visually
+    *   distinguishable from frontend-generated notifications.
+    *   For example, a core may wish to inform the user of
+    *   information related to a disk-change event. It is
+    *   expected that the frontend itself may provide a
+    *   notification in this case; if the core sends a
+    *   message of type RETRO_MESSAGE_TYPE_NOTIFICATION, an
+    *   uncomfortable 'double-notification' may occur. A message
+    *   of RETRO_MESSAGE_TYPE_NOTIFICATION_ALT should therefore
+    *   be presented such that visual conflict with regular
+    *   notifications does not occur
+    * > RETRO_MESSAGE_TYPE_STATUS: Indicates that message
+    *   is not a standard notification. This typically
+    *   corresponds to 'status' indicators, such as a core's
+    *   internal FPS, which are intended to be displayed
+    *   either permanently while a core is running, or in
+    *   a manner that does not suggest user attention or action
+    *   is required. 'Status' type messages should therefore be
+    *   displayed in a different on-screen location and in a manner
+    *   easily distinguishable from both standard frontend-generated
+    *   notifications and messages of type RETRO_MESSAGE_TYPE_NOTIFICATION_ALT
+    * > RETRO_MESSAGE_TYPE_PROGRESS: Indicates that message reports
+    *   the progress of an internal core task. For example, in cases
+    *   where a core itself handles the loading of content from a file,
+    *   this may correspond to the percentage of the file that has been
+    *   read. Alternatively, an audio/video playback core may use a
+    *   message of type RETRO_MESSAGE_TYPE_PROGRESS to display the current
+    *   playback position as a percentage of the runtime. 'Progress' type
+    *   messages should therefore be displayed as a literal progress bar,
+    *   where:
+    *   - 'retro_message_ext.msg' is the progress bar title/label
+    *   - 'retro_message_ext.progress' determines the length of
+    *     the progress bar
+    * NOTE: Message type is a *hint*, and may be ignored
+    * by the frontend. If a frontend lacks support for
+    * displaying messages via alternate means than standard
+    * frontend-generated notifications, it will treat *all*
+    * messages as having the type RETRO_MESSAGE_TYPE_NOTIFICATION */
+   enum retro_message_type type;
+   /* Task progress when targeting the OSD and message is
+    * of type RETRO_MESSAGE_TYPE_PROGRESS
+    * > -1:    Unmetered/indeterminate
+    * > 0-100: Current progress percentage
+    * NOTE: Since message type is a hint, a frontend may ignore
+    * progress values. Where relevant, a core should therefore
+    * include progress percentage within the message string,
+    * such that the message intent remains clear when displayed
+    * as a standard frontend-generated notification */
+   int8_t progress;
+};
+
+/* Describes how the libretro implementation maps a libretro input bind
+ * to its internal input system through a human readable string.
+ * This string can be used to better let a user configure input. */
+struct retro_input_descriptor
+{
+   /* Associates given parameters with a description. */
+   unsigned port;
+   unsigned device;
+   unsigned index;
+   unsigned id;
+
+   /* Human readable description for parameters.
+    * The pointer must remain valid until
+    * retro_unload_game() is called. */
+   const char *description;
+};
+
+struct retro_system_info
+{
+   /* All pointers are owned by libretro implementation, and pointers must
+    * remain valid until it is unloaded. */
+
+   const char *library_name;      /* Descriptive name of library. Should not
+                                   * contain any version numbers, etc. */
+   const char *library_version;   /* Descriptive version of core. */
+
+   const char *valid_extensions;  /* A string listing probably content
+                                   * extensions the core will be able to
+                                   * load, separated with pipe.
+                                   * I.e. "bin|rom|iso".
+                                   * Typically used for a GUI to filter
+                                   * out extensions. */
+
+   /* Libretro cores that need to have direct access to their content
+    * files, including cores which use the path of the content files to
+    * determine the paths of other files, should set need_fullpath to true.
+    *
+    * Cores should strive for setting need_fullpath to false,
+    * as it allows the frontend to perform patching, etc.
+    *
+    * If need_fullpath is true and retro_load_game() is called:
+    *    - retro_game_info::path is guaranteed to have a valid path
+    *    - retro_game_info::data and retro_game_info::size are invalid
+    *
+    * If need_fullpath is false and retro_load_game() is called:
+    *    - retro_game_info::path may be NULL
+    *    - retro_game_info::data and retro_game_info::size are guaranteed
+    *      to be valid
+    *
+    * See also:
+    *    - RETRO_ENVIRONMENT_GET_SYSTEM_DIRECTORY
+    *    - RETRO_ENVIRONMENT_GET_SAVE_DIRECTORY
+    */
+   bool        need_fullpath;
+
+   /* If true, the frontend is not allowed to extract any archives before
+    * loading the real content.
+    * Necessary for certain libretro implementations that load games
+    * from zipped archives. */
+   bool        block_extract;
+};
+
+/* Defines overrides which modify frontend handling of
+ * specific content file types.
+ * An array of retro_system_content_info_override is
+ * passed to RETRO_ENVIRONMENT_SET_CONTENT_INFO_OVERRIDE
+ * NOTE: In the following descriptions, references to
+ *       retro_load_game() may be replaced with
+ *       retro_load_game_special() */
+struct retro_system_content_info_override
+{
+   /* A list of file extensions for which the override
+    * should apply, delimited by a 'pipe' character
+    * (e.g. "md|sms|gg")
+    * Permitted file extensions are limited to those
+    * included in retro_system_info::valid_extensions
+    * and/or retro_subsystem_rom_info::valid_extensions */
+   const char *extensions;
+
+   /* Overrides the need_fullpath value set in
+    * retro_system_info and/or retro_subsystem_rom_info.
+    * To reiterate:
+    *
+    * If need_fullpath is true and retro_load_game() is called:
+    *    - retro_game_info::path is guaranteed to contain a valid
+    *      path to an existent file
+    *    - retro_game_info::data and retro_game_info::size are invalid
+    *
+    * If need_fullpath is false and retro_load_game() is called:
+    *    - retro_game_info::path may be NULL
+    *    - retro_game_info::data and retro_game_info::size are guaranteed
+    *      to be valid
+    *
+    * In addition:
+    *
+    * If need_fullpath is true and retro_load_game() is called:
+    *    - retro_game_info_ext::full_path is guaranteed to contain a valid
+    *      path to an existent file
+    *    - retro_game_info_ext::archive_path may be NULL
+    *    - retro_game_info_ext::archive_file may be NULL
+    *    - retro_game_info_ext::dir is guaranteed to contain a valid path
+    *      to the directory in which the content file exists
+    *    - retro_game_info_ext::name is guaranteed to contain the
+    *      basename of the content file, without extension
+    *    - retro_game_info_ext::ext is guaranteed to contain the
+    *      extension of the content file in lower case format
+    *    - retro_game_info_ext::data and retro_game_info_ext::size
+    *      are invalid
+    *
+    * If need_fullpath is false and retro_load_game() is called:
+    *    - If retro_game_info_ext::file_in_archive is false:
+    *       - retro_game_info_ext::full_path is guaranteed to contain
+    *         a valid path to an existent file
+    *       - retro_game_info_ext::archive_path may be NULL
+    *       - retro_game_info_ext::archive_file may be NULL
+    *       - retro_game_info_ext::dir is guaranteed to contain a
+    *         valid path to the directory in which the content file exists
+    *       - retro_game_info_ext::name is guaranteed to contain the
+    *         basename of the content file, without extension
+    *       - retro_game_info_ext::ext is guaranteed to contain the
+    *         extension of the content file in lower case format
+    *    - If retro_game_info_ext::file_in_archive is true:
+    *       - retro_game_info_ext::full_path may be NULL
+    *       - retro_game_info_ext::archive_path is guaranteed to
+    *         contain a valid path to an existent compressed file
+    *         inside which the content file is located
+    *       - retro_game_info_ext::archive_file is guaranteed to
+    *         contain a valid path to an existent content file
+    *         inside the compressed file referred to by
+    *         retro_game_info_ext::archive_path
+    *            e.g. for a compressed file '/path/to/foo.zip'
+    *            containing 'bar.sfc'
+    *             > retro_game_info_ext::archive_path will be '/path/to/foo.zip'
+    *             > retro_game_info_ext::archive_file will be 'bar.sfc'
+    *       - retro_game_info_ext::dir is guaranteed to contain a
+    *         valid path to the directory in which the compressed file
+    *         (containing the content file) exists
+    *       - retro_game_info_ext::name is guaranteed to contain
+    *         EITHER
+    *         1) the basename of the compressed file (containing
+    *            the content file), without extension
+    *         OR
+    *         2) the basename of the content file inside the
+    *            compressed file, without extension
+    *         In either case, a core should consider 'name' to
+    *         be the canonical name/ID of the the content file
+    *       - retro_game_info_ext::ext is guaranteed to contain the
+    *         extension of the content file inside the compressed file,
+    *         in lower case format
+    *    - retro_game_info_ext::data and retro_game_info_ext::size are
+    *      guaranteed to be valid */
+   bool need_fullpath;
+
+   /* If need_fullpath is false, specifies whether the content
+    * data buffer available in retro_load_game() is 'persistent'
+    *
+    * If persistent_data is false and retro_load_game() is called:
+    *    - retro_game_info::data and retro_game_info::size
+    *      are valid only until retro_load_game() returns
+    *    - retro_game_info_ext::data and retro_game_info_ext::size
+    *      are valid only until retro_load_game() returns
+    *
+    * If persistent_data is true and retro_load_game() is called:
+    *    - retro_game_info::data and retro_game_info::size
+    *      are valid until retro_deinit() returns
+    *    - retro_game_info_ext::data and retro_game_info_ext::size
+    *      are valid until retro_deinit() returns */
+   bool persistent_data;
+};
+
+/* Similar to retro_game_info, but provides extended
+ * information about the source content file and
+ * game memory buffer status.
+ * And array of retro_game_info_ext is returned by
+ * RETRO_ENVIRONMENT_GET_GAME_INFO_EXT
+ * NOTE: In the following descriptions, references to
+ *       retro_load_game() may be replaced with
+ *       retro_load_game_special() */
+struct retro_game_info_ext
+{
+   /* - If file_in_archive is false, contains a valid
+    *   path to an existent content file (UTF-8 encoded)
+    * - If file_in_archive is true, may be NULL */
+   const char *full_path;
+
+   /* - If file_in_archive is false, may be NULL
+    * - If file_in_archive is true, contains a valid path
+    *   to an existent compressed file inside which the
+    *   content file is located (UTF-8 encoded) */
+   const char *archive_path;
+
+   /* - If file_in_archive is false, may be NULL
+    * - If file_in_archive is true, contain a valid path
+    *   to an existent content file inside the compressed
+    *   file referred to by archive_path (UTF-8 encoded)
+    *      e.g. for a compressed file '/path/to/foo.zip'
+    *      containing 'bar.sfc'
+    *      > archive_path will be '/path/to/foo.zip'
+    *      > archive_file will be 'bar.sfc' */
+   const char *archive_file;
+
+   /* - If file_in_archive is false, contains a valid path
+    *   to the directory in which the content file exists
+    *   (UTF-8 encoded)
+    * - If file_in_archive is true, contains a valid path
+    *   to the directory in which the compressed file
+    *   (containing the content file) exists (UTF-8 encoded) */
+   const char *dir;
+
+   /* Contains the canonical name/ID of the content file
+    * (UTF-8 encoded). Intended for use when identifying
+    * 'complementary' content named after the loaded file -
+    * i.e. companion data of a different format (a CD image
+    * required by a ROM), texture packs, internally handled
+    * save files, etc.
+    * - If file_in_archive is false, contains the basename
+    *   of the content file, without extension
+    * - If file_in_archive is true, then string is
+    *   implementation specific. A frontend may choose to
+    *   set a name value of:
+    *   EITHER
+    *   1) the basename of the compressed file (containing
+    *      the content file), without extension
+    *   OR
+    *   2) the basename of the content file inside the
+    *      compressed file, without extension
+    *   RetroArch sets the 'name' value according to (1).
+    *   A frontend that supports routine loading of
+    *   content from archives containing multiple unrelated
+    *   content files may set the 'name' value according
+    *   to (2). */
+   const char *name;
+
+   /* - If file_in_archive is false, contains the extension
+    *   of the content file in lower case format
+    * - If file_in_archive is true, contains the extension
+    *   of the content file inside the compressed file,
+    *   in lower case format */
+   const char *ext;
+
+   /* String of implementation specific meta-data. */
+   const char *meta;
+
+   /* Memory buffer of loaded game content. Will be NULL:
+    * IF
+    * - retro_system_info::need_fullpath is true and
+    *   retro_system_content_info_override::need_fullpath
+    *   is unset
+    * OR
+    * - retro_system_content_info_override::need_fullpath
+    *   is true */
+   const void *data;
+
+   /* Size of game content memory buffer, in bytes */
+   size_t size;
+
+   /* True if loaded content file is inside a compressed
+    * archive */
+   bool file_in_archive;
+
+   /* - If data is NULL, value is unset/ignored
+    * - If data is non-NULL:
+    *   - If persistent_data is false, data and size are
+    *     valid only until retro_load_game() returns
+    *   - If persistent_data is true, data and size are
+    *     are valid until retro_deinit() returns */
+   bool persistent_data;
+};
+
+struct retro_game_geometry
+{
+   unsigned base_width;    /* Nominal video width of game. */
+   unsigned base_height;   /* Nominal video height of game. */
+   unsigned max_width;     /* Maximum possible width of game. */
+   unsigned max_height;    /* Maximum possible height of game. */
+
+   float    aspect_ratio;  /* Nominal aspect ratio of game. If
+                            * aspect_ratio is <= 0.0, an aspect ratio
+                            * of base_width / base_height is assumed.
+                            * A frontend could override this setting,
+                            * if desired. */
+};
+
+struct retro_system_timing
+{
+   double fps;             /* FPS of video content. */
+   double sample_rate;     /* Sampling rate of audio. */
+};
+
+struct retro_system_av_info
+{
+   struct retro_game_geometry geometry;
+   struct retro_system_timing timing;
+};
+
+struct retro_variable
+{
+   /* Variable to query in RETRO_ENVIRONMENT_GET_VARIABLE.
+    * If NULL, obtains the complete environment string if more
+    * complex parsing is necessary.
+    * The environment string is formatted as key-value pairs
+    * delimited by semicolons as so:
+    * "key1=value1;key2=value2;..."
+    */
+   const char *key;
+
+   /* Value to be obtained. If key does not exist, it is set to NULL. */
+   const char *value;
+};
+
+struct retro_core_option_display
+{
+   /* Variable to configure in RETRO_ENVIRONMENT_SET_CORE_OPTIONS_DISPLAY */
+   const char *key;
+
+   /* Specifies whether variable should be displayed
+    * when presenting core options to the user */
+   bool visible;
+};
+
+/* Maximum number of values permitted for a core option
+ * > Note: We have to set a maximum value due the limitations
+ *   of the C language - i.e. it is not possible to create an
+ *   array of structs each containing a variable sized array,
+ *   so the retro_core_option_definition values array must
+ *   have a fixed size. The size limit of 128 is a balancing
+ *   act - it needs to be large enough to support all 'sane'
+ *   core options, but setting it too large may impact low memory
+ *   platforms. In practise, if a core option has more than
+ *   128 values then the implementation is likely flawed.
+ *   To quote the above API reference:
+ *      "The number of possible options should be very limited
+ *       i.e. it should be feasible to cycle through options
+ *       without a keyboard."
+ */
+#define RETRO_NUM_CORE_OPTION_VALUES_MAX 128
+
+struct retro_core_option_value
+{
+   /* Expected option value */
+   const char *value;
+
+   /* Human-readable value label. If NULL, value itself
+    * will be displayed by the frontend */
+   const char *label;
+};
+
+struct retro_core_option_definition
+{
+   /* Variable to query in RETRO_ENVIRONMENT_GET_VARIABLE. */
+   const char *key;
+
+   /* Human-readable core option description (used as menu label) */
+   const char *desc;
+
+   /* Human-readable core option information (used as menu sublabel) */
+   const char *info;
+
+   /* Array of retro_core_option_value structs, terminated by NULL */
+   struct retro_core_option_value values[RETRO_NUM_CORE_OPTION_VALUES_MAX];
+
+   /* Default core option value. Must match one of the values
+    * in the retro_core_option_value array, otherwise will be
+    * ignored */
+   const char *default_value;
+};
+
+#ifdef __PS3__
+#undef local
+#endif
+
+struct retro_core_options_intl
+{
+   /* Pointer to an array of retro_core_option_definition structs
+    * - US English implementation
+    * - Must point to a valid array */
+   struct retro_core_option_definition *us;
+
+   /* Pointer to an array of retro_core_option_definition structs
+    * - Implementation for current frontend language
+    * - May be NULL */
+   struct retro_core_option_definition *local;
+};
+
+struct retro_core_option_v2_category
+{
+   /* Variable uniquely identifying the
+    * option category. Valid key characters
+    * are [a-z, A-Z, 0-9, _, -] */
+   const char *key;
+
+   /* Human-readable category description
+    * > Used as category menu label when
+    *   frontend has core option category
+    *   support */
+   const char *desc;
+
+   /* Human-readable category information
+    * > Used as category menu sublabel when
+    *   frontend has core option category
+    *   support
+    * > Optional (may be NULL or an empty
+    *   string) */
+   const char *info;
+};
+
+struct retro_core_option_v2_definition
+{
+   /* Variable to query in RETRO_ENVIRONMENT_GET_VARIABLE.
+    * Valid key characters are [a-z, A-Z, 0-9, _, -] */
+   const char *key;
+
+   /* Human-readable core option description
+    * > Used as menu label when frontend does
+    *   not have core option category support
+    *   e.g. "Video > Aspect Ratio" */
+   const char *desc;
+
+   /* Human-readable core option description
+    * > Used as menu label when frontend has
+    *   core option category support
+    *   e.g. "Aspect Ratio", where associated
+    *   retro_core_option_v2_category::desc
+    *   is "Video"
+    * > If empty or NULL, the string specified by
+    *   desc will be used as the menu label
+    * > Will be ignored (and may be set to NULL)
+    *   if category_key is empty or NULL */
+   const char *desc_categorized;
+
+   /* Human-readable core option information
+    * > Used as menu sublabel */
+   const char *info;
+
+   /* Human-readable core option information
+    * > Used as menu sublabel when frontend
+    *   has core option category support
+    *   (e.g. may be required when info text
+    *   references an option by name/desc,
+    *   and the desc/desc_categorized text
+    *   for that option differ)
+    * > If empty or NULL, the string specified by
+    *   info will be used as the menu sublabel
+    * > Will be ignored (and may be set to NULL)
+    *   if category_key is empty or NULL */
+   const char *info_categorized;
+
+   /* Variable specifying category (e.g. "video",
+    * "audio") that will be assigned to the option
+    * if frontend has core option category support.
+    * > Categorized options will be displayed in a
+    *   subsection/submenu of the frontend core
+    *   option interface
+    * > Specified string must match one of the
+    *   retro_core_option_v2_category::key values
+    *   in the associated retro_core_option_v2_category
+    *   array; If no match is not found, specified
+    *   string will be considered as NULL
+    * > If specified string is empty or NULL, option will
+    *   have no category and will be shown at the top
+    *   level of the frontend core option interface */
+   const char *category_key;
+
+   /* Array of retro_core_option_value structs, terminated by NULL */
+   struct retro_core_option_value values[RETRO_NUM_CORE_OPTION_VALUES_MAX];
+
+   /* Default core option value. Must match one of the values
+    * in the retro_core_option_value array, otherwise will be
+    * ignored */
+   const char *default_value;
+};
+
+struct retro_core_options_v2
+{
+   /* Array of retro_core_option_v2_category structs,
+    * terminated by NULL
+    * > If NULL, all entries in definitions array
+    *   will have no category and will be shown at
+    *   the top level of the frontend core option
+    *   interface
+    * > Will be ignored if frontend does not have
+    *   core option category support */
+   struct retro_core_option_v2_category *categories;
+
+   /* Array of retro_core_option_v2_definition structs,
+    * terminated by NULL */
+   struct retro_core_option_v2_definition *definitions;
+};
+
+struct retro_core_options_v2_intl
+{
+   /* Pointer to a retro_core_options_v2 struct
+    * > US English implementation
+    * > Must point to a valid struct */
+   struct retro_core_options_v2 *us;
+
+   /* Pointer to a retro_core_options_v2 struct
+    * - Implementation for current frontend language
+    * - May be NULL */
+   struct retro_core_options_v2 *local;
+};
+
+/* Used by the frontend to monitor changes in core option
+ * visibility. May be called each time any core option
+ * value is set via the frontend.
+ * - On each invocation, the core must update the visibility
+ *   of any dynamically hidden options using the
+ *   RETRO_ENVIRONMENT_SET_CORE_OPTIONS_DISPLAY environment
+ *   callback.
+ * - On the first invocation, returns 'true' if the visibility
+ *   of any core option has changed since the last call of
+ *   retro_load_game() or retro_load_game_special().
+ * - On each subsequent invocation, returns 'true' if the
+ *   visibility of any core option has changed since the last
+ *   time the function was called. */
+typedef bool (RETRO_CALLCONV *retro_core_options_update_display_callback_t)(void);
+struct retro_core_options_update_display_callback
+{
+   retro_core_options_update_display_callback_t callback;
+};
+
+struct retro_game_info
+{
+   const char *path;       /* Path to game, UTF-8 encoded.
+                            * Sometimes used as a reference for building other paths.
+                            * May be NULL if game was loaded from stdin or similar,
+                            * but in this case some cores will be unable to load `data`.
+                            * So, it is preferable to fabricate something here instead
+                            * of passing NULL, which will help more cores to succeed.
+                            * retro_system_info::need_fullpath requires
+                            * that this path is valid. */
+   const void *data;       /* Memory buffer of loaded game. Will be NULL
+                            * if need_fullpath was set. */
+   size_t      size;       /* Size of memory buffer. */
+   const char *meta;       /* String of implementation specific meta-data. */
+};
+
+#define RETRO_MEMORY_ACCESS_WRITE (1 << 0)
+   /* The core will write to the buffer provided by retro_framebuffer::data. */
+#define RETRO_MEMORY_ACCESS_READ (1 << 1)
+   /* The core will read from retro_framebuffer::data. */
+#define RETRO_MEMORY_TYPE_CACHED (1 << 0)
+   /* The memory in data is cached.
+    * If not cached, random writes and/or reading from the buffer is expected to be very slow. */
+struct retro_framebuffer
+{
+   void *data;                      /* The framebuffer which the core can render into.
+                                       Set by frontend in GET_CURRENT_SOFTWARE_FRAMEBUFFER.
+                                       The initial contents of data are unspecified. */
+   unsigned width;                  /* The framebuffer width used by the core. Set by core. */
+   unsigned height;                 /* The framebuffer height used by the core. Set by core. */
+   size_t pitch;                    /* The number of bytes between the beginning of a scanline,
+                                       and beginning of the next scanline.
+                                       Set by frontend in GET_CURRENT_SOFTWARE_FRAMEBUFFER. */
+   enum retro_pixel_format format;  /* The pixel format the core must use to render into data.
+                                       This format could differ from the format used in
+                                       SET_PIXEL_FORMAT.
+                                       Set by frontend in GET_CURRENT_SOFTWARE_FRAMEBUFFER. */
+
+   unsigned access_flags;           /* How the core will access the memory in the framebuffer.
+                                       RETRO_MEMORY_ACCESS_* flags.
+                                       Set by core. */
+   unsigned memory_flags;           /* Flags telling core how the memory has been mapped.
+                                       RETRO_MEMORY_TYPE_* flags.
+                                       Set by frontend in GET_CURRENT_SOFTWARE_FRAMEBUFFER. */
+};
+
+/* Used by a libretro core to override the current
+ * fastforwarding mode of the frontend */
+struct retro_fastforwarding_override
+{
+   /* Specifies the runtime speed multiplier that
+    * will be applied when 'fastforward' is true.
+    * For example, a value of 5.0 when running 60 FPS
+    * content will cap the fast-forward rate at 300 FPS.
+    * Note that the target multiplier may not be achieved
+    * if the host hardware has insufficient processing
+    * power.
+    * Setting a value of 0.0 (or greater than 0.0 but
+    * less than 1.0) will result in an uncapped
+    * fast-forward rate (limited only by hardware
+    * capacity).
+    * If the value is negative, it will be ignored
+    * (i.e. the frontend will use a runtime speed
+    * multiplier of its own choosing) */
+   float ratio;
+
+   /* If true, fastforwarding mode will be enabled.
+    * If false, fastforwarding mode will be disabled. */
+   bool fastforward;
+
+   /* If true, and if supported by the frontend, an
+    * on-screen notification will be displayed while
+    * 'fastforward' is true.
+    * If false, and if supported by the frontend, any
+    * on-screen fast-forward notifications will be
+    * suppressed */
+   bool notification;
+
+   /* If true, the core will have sole control over
+    * when fastforwarding mode is enabled/disabled;
+    * the frontend will not be able to change the
+    * state set by 'fastforward' until either
+    * 'inhibit_toggle' is set to false, or the core
+    * is unloaded */
+   bool inhibit_toggle;
+};
+
+/* During normal operation. Rate will be equal to the core's internal FPS. */
+#define RETRO_THROTTLE_NONE              0
+
+/* While paused or stepping single frames. Rate will be 0. */
+#define RETRO_THROTTLE_FRAME_STEPPING    1
+
+/* During fast forwarding.
+ * Rate will be 0 if not specifically limited to a maximum speed. */
+#define RETRO_THROTTLE_FAST_FORWARD      2
+
+/* During slow motion. Rate will be less than the core's internal FPS. */
+#define RETRO_THROTTLE_SLOW_MOTION       3
+
+/* While rewinding recorded save states. Rate can vary depending on the rewind
+ * speed or be 0 if the frontend is not aiming for a specific rate. */
+#define RETRO_THROTTLE_REWINDING         4
+
+/* While vsync is active in the video driver and the target refresh rate is
+ * lower than the core's internal FPS. Rate is the target refresh rate. */
+#define RETRO_THROTTLE_VSYNC             5
+
+/* When the frontend does not throttle in any way. Rate will be 0.
+ * An example could be if no vsync or audio output is active. */
+#define RETRO_THROTTLE_UNBLOCKED         6
+
+struct retro_throttle_state
+{
+   /* The current throttling mode. Should be one of the values above. */
+   unsigned mode;
+
+   /* How many times per second the frontend aims to call retro_run.
+    * Depending on the mode, it can be 0 if there is no known fixed rate.
+    * This won't be accurate if the total processing time of the core and
+    * the frontend is longer than what is available for one frame. */
+   float rate;
+};
+
+/* Callbacks */
+
+/* Environment callback. Gives implementations a way of performing
+ * uncommon tasks. Extensible. */
+typedef bool (RETRO_CALLCONV *retro_environment_t)(unsigned cmd, void *data);
+
+/* Render a frame. Pixel format is 15-bit 0RGB1555 native endian
+ * unless changed (see RETRO_ENVIRONMENT_SET_PIXEL_FORMAT).
+ *
+ * Width and height specify dimensions of buffer.
+ * Pitch specifices length in bytes between two lines in buffer.
+ *
+ * For performance reasons, it is highly recommended to have a frame
+ * that is packed in memory, i.e. pitch == width * byte_per_pixel.
+ * Certain graphic APIs, such as OpenGL ES, do not like textures
+ * that are not packed in memory.
+ */
+typedef void (RETRO_CALLCONV *retro_video_refresh_t)(const void *data, unsigned width,
+      unsigned height, size_t pitch);
+
+/* Renders a single audio frame. Should only be used if implementation
+ * generates a single sample at a time.
+ * Format is signed 16-bit native endian.
+ */
+typedef void (RETRO_CALLCONV *retro_audio_sample_t)(int16_t left, int16_t right);
+
+/* Renders multiple audio frames in one go.
+ *
+ * One frame is defined as a sample of left and right channels, interleaved.
+ * I.e. int16_t buf[4] = { l, r, l, r }; would be 2 frames.
+ * Only one of the audio callbacks must ever be used.
+ */
+typedef size_t (RETRO_CALLCONV *retro_audio_sample_batch_t)(const int16_t *data,
+      size_t frames);
+
+/* Polls input. */
+typedef void (RETRO_CALLCONV *retro_input_poll_t)(void);
+
+/* Queries for input for player 'port'. device will be masked with
+ * RETRO_DEVICE_MASK.
+ *
+ * Specialization of devices such as RETRO_DEVICE_JOYPAD_MULTITAP that
+ * have been set with retro_set_controller_port_device()
+ * will still use the higher level RETRO_DEVICE_JOYPAD to request input.
+ */
+typedef int16_t (RETRO_CALLCONV *retro_input_state_t)(unsigned port, unsigned device,
+      unsigned index, unsigned id);
+
+/* Sets callbacks. retro_set_environment() is guaranteed to be called
+ * before retro_init().
+ *
+ * The rest of the set_* functions are guaranteed to have been called
+ * before the first call to retro_run() is made. */
+RETRO_API void retro_set_environment(retro_environment_t);
+RETRO_API void retro_set_video_refresh(retro_video_refresh_t);
+RETRO_API void retro_set_audio_sample(retro_audio_sample_t);
+RETRO_API void retro_set_audio_sample_batch(retro_audio_sample_batch_t);
+RETRO_API void retro_set_input_poll(retro_input_poll_t);
+RETRO_API void retro_set_input_state(retro_input_state_t);
+
+/* Library global initialization/deinitialization. */
+RETRO_API void retro_init(void);
+RETRO_API void retro_deinit(void);
+
+/* Must return RETRO_API_VERSION. Used to validate ABI compatibility
+ * when the API is revised. */
+RETRO_API unsigned retro_api_version(void);
+
+/* Gets statically known system info. Pointers provided in *info
+ * must be statically allocated.
+ * Can be called at any time, even before retro_init(). */
+RETRO_API void retro_get_system_info(struct retro_system_info *info);
+
+/* Gets information about system audio/video timings and geometry.
+ * Can be called only after retro_load_game() has successfully completed.
+ * NOTE: The implementation of this function might not initialize every
+ * variable if needed.
+ * E.g. geom.aspect_ratio might not be initialized if core doesn't
+ * desire a particular aspect ratio. */
+RETRO_API void retro_get_system_av_info(struct retro_system_av_info *info);
+
+/* Sets device to be used for player 'port'.
+ * By default, RETRO_DEVICE_JOYPAD is assumed to be plugged into all
+ * available ports.
+ * Setting a particular device type is not a guarantee that libretro cores
+ * will only poll input based on that particular device type. It is only a
+ * hint to the libretro core when a core cannot automatically detect the
+ * appropriate input device type on its own. It is also relevant when a
+ * core can change its behavior depending on device type.
+ *
+ * As part of the core's implementation of retro_set_controller_port_device,
+ * the core should call RETRO_ENVIRONMENT_SET_INPUT_DESCRIPTORS to notify the
+ * frontend if the descriptions for any controls have changed as a
+ * result of changing the device type.
+ */
+RETRO_API void retro_set_controller_port_device(unsigned port, unsigned device);
+
+/* Resets the current game. */
+RETRO_API void retro_reset(void);
+
+/* Runs the game for one video frame.
+ * During retro_run(), input_poll callback must be called at least once.
+ *
+ * If a frame is not rendered for reasons where a game "dropped" a frame,
+ * this still counts as a frame, and retro_run() should explicitly dupe
+ * a frame if GET_CAN_DUPE returns true.
+ * In this case, the video callback can take a NULL argument for data.
+ */
+RETRO_API void retro_run(void);
+
+/* Returns the amount of data the implementation requires to serialize
+ * internal state (save states).
+ * Between calls to retro_load_game() and retro_unload_game(), the
+ * returned size is never allowed to be larger than a previous returned
+ * value, to ensure that the frontend can allocate a save state buffer once.
+ */
+RETRO_API size_t retro_serialize_size(void);
+
+/* Serializes internal state. If failed, or size is lower than
+ * retro_serialize_size(), it should return false, true otherwise. */
+RETRO_API bool retro_serialize(void *data, size_t size);
+RETRO_API bool retro_unserialize(const void *data, size_t size);
+
+RETRO_API void retro_cheat_reset(void);
+RETRO_API void retro_cheat_set(unsigned index, bool enabled, const char *code);
+
+/* Loads a game.
+ * Return true to indicate successful loading and false to indicate load failure.
+ */
+RETRO_API bool retro_load_game(const struct retro_game_info *game);
+
+/* Loads a "special" kind of game. Should not be used,
+ * except in extreme cases. */
+RETRO_API bool retro_load_game_special(
+  unsigned game_type,
+  const struct retro_game_info *info, size_t num_info
+);
+
+/* Unloads the currently loaded game. Called before retro_deinit(void). */
+RETRO_API void retro_unload_game(void);
+
+/* Gets region of game. */
+RETRO_API unsigned retro_get_region(void);
+
+/* Gets region of memory. */
+RETRO_API void *retro_get_memory_data(unsigned id);
+RETRO_API size_t retro_get_memory_size(unsigned id);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/bindings/libretro/rvvm_libretro.info b/app/src/main/java/libengine/RVVM/src/bindings/libretro/rvvm_libretro.info
new file mode 100644
index 00000000..5fe5334d
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/bindings/libretro/rvvm_libretro.info
@@ -0,0 +1,24 @@
+# Software Information
+display_name = "RVVM"
+display_version = "0.6-git"
+authors = "LekKit"
+categories = "Virtual machine"
+license = "GPLv3+"
+permissions = ""
+supported_extensions = "rvvm"
+
+# Hardware Information
+manufacturer = "RVVM"
+systemname = "RVVM"
+systemid = "rvvm"
+
+# Libretro Features
+database = "RVVM"
+supports_no_game = "false"
+libretro_saves = "false"
+cheats = "false"
+needs_fullpath = "true"
+disk_control = "false"
+is_experimental = "true"
+
+description = "A port of the RVVM (RISC-V Virtual Machine) to libretro."
diff --git a/app/src/main/java/libengine/RVVM/src/bit_ops.h b/app/src/main/java/libengine/RVVM/src/bit_ops.h
new file mode 100644
index 00000000..94b4413c
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/bit_ops.h
@@ -0,0 +1,377 @@
+/*
+bit_ops.h - Bit operations
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This Source Code Form is subject to the terms of the Mozilla Public
+License, v. 2.0. If a copy of the MPL was not distributed with this
+file, You can obtain one at https://mozilla.org/MPL/2.0/.
+
+Alternatively, the contents of this file may be used under the terms
+of the GNU General Public License as published by the Free Software
+Foundation, either version 3 of the License, or any later version.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef RVVM_BIT_OPS_H
+#define RVVM_BIT_OPS_H
+
+#include "compiler.h"
+#include "rvvm_types.h"
+
+// For optimized bit_orc_b() implementation
+#if (defined(__x86_64__) && defined(GNU_EXTS)) || defined(_M_X64)
+#include <emmintrin.h>
+#elif defined(__aarch64__) && defined(GNU_EXTS)
+#include <arm_neon.h>
+#endif
+
+// Simple bit operations (sign-extend, etc) for internal usage
+
+/*
+ * Sign-extend bits in the lower part of val into signed i64
+ * Usage:
+ *     int ext = sign_extend(val, 20);
+ *
+ *     [ext is now equal to signed lower 20 bits of val]
+ */
+static forceinline int64_t sign_extend(uint64_t val, bitcnt_t bits)
+{
+    return ((int64_t)(val << (64 - bits))) >> (64 - bits);
+}
+
+// Generate bitmask of given size
+static forceinline uint64_t bit_mask(bitcnt_t count)
+{
+    return (1ULL << count) - 1;
+}
+
+// Cut bits from val at given position (from lower bit)
+static forceinline uint64_t bit_cut(uint64_t val, bitcnt_t pos, bitcnt_t bits)
+{
+    return (val >> pos) & bit_mask(bits);
+}
+
+// Replace bits in val at given position (from lower bit) by rep
+static inline uint64_t bit_replace(uint64_t val, bitcnt_t pos, bitcnt_t bits, uint64_t rep)
+{
+    return (val & (~(bit_mask(bits) << pos))) | ((rep & bit_mask(bits)) << pos);
+}
+
+// Check if Nth bit of val is 1
+static forceinline bool bit_check(uint64_t val, bitcnt_t pos)
+{
+    return (val >> pos) & 0x1;
+}
+
+// Normalize the value to nearest next power of two
+static inline uint64_t bit_next_pow2(uint64_t val)
+{
+    // Fast path for proper pow2 values
+    if (!(val & (val - 1))) return val;
+    // Bit twiddling hacks
+    val -= 1;
+    val |= (val >> 1);
+    val |= (val >> 2);
+    val |= (val >> 4);
+    val |= (val >> 8);
+    val |= (val >> 16);
+    val |= (val >> 32);
+    return val + 1;
+}
+
+// Rotate u32 left
+static forceinline uint32_t bit_rotl32(uint32_t val, bitcnt_t bits)
+{
+    return (val << (bits & 0x1F)) | (val >> ((32 - bits) & 0x1F));
+}
+
+// Rotate u64 left
+static forceinline uint64_t bit_rotl64(uint64_t val, bitcnt_t bits)
+{
+    return (val << (bits & 0x3F)) | (val >> ((64 - bits) & 0x3F));
+}
+
+// Rotate u32 right
+static forceinline uint32_t bit_rotr32(uint32_t val, bitcnt_t bits)
+{
+    return (val >> (bits & 0x1F)) | (val << ((32 - bits) & 0x1F));
+}
+
+// Rotate u64 right
+static forceinline uint64_t bit_rotr64(uint64_t val, bitcnt_t bits)
+{
+    return (val >> (bits & 0x3F)) | (val << ((64 - bits) & 0x3F));
+}
+
+// Count leading zeroes (from highest bit position) in u32
+static inline bitcnt_t bit_clz32(uint32_t val)
+{
+    if (unlikely(!val)) return 32;
+#if GNU_BUILTIN(__builtin_clz)
+    return __builtin_clz(val);
+#else
+    bitcnt_t ret = 0;
+    bitcnt_t tmp = (!(val >> 16)) << 4;
+    val >>= 16 - tmp;
+    ret += tmp;
+    tmp = (!(val >> 8)) << 3;
+    val >>= 8 - tmp;
+    ret += tmp;
+    tmp = (!(val >> 4)) << 2;
+    val >>= 4 - tmp;
+    ret += tmp;
+    tmp = (!(val >> 2)) << 1;
+    val >>= 2 - tmp;
+    ret += tmp;
+    tmp = !(val >> 1);
+    val >>= 1 - tmp;
+    ret += tmp;
+    return ret + !(val & 1);
+#endif
+}
+
+// Count leading zeroes (from highest bit position) in u64
+static inline bitcnt_t bit_clz64(uint64_t val)
+{
+    if (unlikely(!val)) return 64;
+#if GNU_BUILTIN(__builtin_clzll) && defined(HOST_64BIT)
+    return __builtin_clzll(val);
+#else
+    bitcnt_t tmp = (!(val >> 32)) << 5;
+    return bit_clz32(val >> (32 - tmp)) + tmp;
+#endif
+}
+
+// Count trailing zeroes (from lowest bit position) in u32
+static inline bitcnt_t bit_ctz32(uint32_t val)
+{
+    if (unlikely(!val)) return 32;
+#if GNU_BUILTIN(__builtin_ctz)
+    return __builtin_ctz(val);
+#else
+    bitcnt_t ret = 0;
+    bitcnt_t tmp = (!((uint16_t)val)) << 4;
+    val >>= tmp;
+    ret += tmp;
+    tmp = (!((uint8_t)val)) << 3;
+    val >>= tmp;
+    ret += tmp;
+    tmp = (!(val & 0xF)) << 2;
+    val >>= tmp;
+    ret += tmp;
+    tmp = (!(val & 0x3)) << 1;
+    val >>= tmp;
+    ret += tmp;
+    return ret + !(val & 0x1);
+#endif
+}
+
+// Count trailing zeroes (from lowest bit position) in u64
+static inline bitcnt_t bit_ctz64(uint64_t val)
+{
+    if (unlikely(!val)) return 64;
+#if GNU_BUILTIN(__builtin_ctzll) && defined(HOST_64BIT)
+    return __builtin_ctzll(val);
+#else
+    bitcnt_t tmp = (!((uint32_t)val)) << 5;
+    return bit_ctz32(val >> tmp) + tmp;
+#endif
+}
+
+// Count raised bits in u32
+static inline bitcnt_t bit_popcnt32(uint32_t val)
+{
+#if GNU_BUILTIN(__builtin_popcount)
+    return __builtin_popcount(val);
+#else
+    val -= (val >> 1) & 0x55555555;
+    val = (val & 0x33333333) + ((val >> 2) & 0x33333333);
+    val = (val + (val >> 4)) & 0x0F0F0F0F;
+    val += val >>  8;
+    return (val + (val >> 16)) & 0x3F;
+#endif
+}
+
+// Count raised bits in u64
+static inline bitcnt_t bit_popcnt64(uint64_t val)
+{
+#if GNU_BUILTIN(__builtin_popcountll) && defined(HOST_64BIT)
+    return __builtin_popcountll(val);
+#else
+    return bit_popcnt32(val) + bit_popcnt32(val >> 32);
+#endif
+}
+
+// Bitwise OR-combine, byte granule for orc.b instruction emulation
+static inline uint64_t bit_orc_b(uint64_t val)
+{
+#if (defined(__x86_64__) && defined(GNU_EXTS)) || defined(_M_X64)
+    __m128i in = _mm_set_epi64x(0, val);
+    __m128i zero = _mm_set_epi64x(0, 0);
+    __m128i cmp = _mm_cmpeq_epi8(in, zero);
+    __m128i orc = _mm_cmpeq_epi8(cmp, zero);
+    return _mm_cvtsi128_si64(orc);
+#elif defined(__aarch64__) && defined(GNU_EXTS)
+    uint8x8_t in = vreinterpret_u8_u64(vcreate_u64(val));
+    uint8x8_t orc = vtst_u8(in, in);
+    return vget_lane_u64(vreinterpret_u64_u8(orc), 0);
+#else
+    val |= ((val >> 1) | (val << 1)) & 0x7E7E7E7E7E7E7E7EULL;
+    val |= ((val >> 2) | (val << 2)) & 0x3C3C3C3C3C3C3C3CULL;
+    val |= (val >> 4) & 0x0F0F0F0F0F0F0F0FULL;
+    val |= (val << 4) & 0xF0F0F0F0F0F0F0F0ULL;
+    return val;
+#endif
+}
+
+/*
+ * clmul using SSE intrins for future investigation:
+    __m128i a_vec = _mm_cvtsi64_si128(a);
+    __m128i b_vec = _mm_cvtsi64_si128(b);
+    return _mm_cvtsi128_si64(_mm_clmulepi64_si128(a_vec, b_vec, 0));
+ *
+ * clmulh using SSE intrins:
+    __m128i a_vec = _mm_cvtsi64_si128(a);
+    __m128i b_vec = _mm_cvtsi64_si128(b);
+    return _mm_extract_epi64(_mm_clmulepi64_si128(a_vec, b_vec, 0), 1);
+ */
+
+// Carry-less multiply
+static inline uint32_t bit_clmul32(uint32_t a, uint32_t b)
+{
+    uint32_t ret = 0;
+    do {
+        if (b & 1) ret ^= a;
+        b >>= 1;
+    } while ((a <<= 1));
+    return ret;
+}
+
+static inline uint64_t bit_clmul64(uint64_t a, uint64_t b)
+{
+    uint64_t ret = 0;
+    do {
+        if (b & 1) ret ^= a;
+        b >>= 1;
+    } while ((a <<= 1));
+    return ret;
+}
+
+static inline uint32_t bit_clmulh32(uint32_t a, uint32_t b)
+{
+    uint32_t ret = 0;
+    bitcnt_t i = 31;
+    do {
+        b >>= 1;
+        if (b & 1) ret ^= (a >> i);
+        i--;
+    } while (b);
+    return ret;
+}
+
+static inline uint64_t bit_clmulh64(uint64_t a, uint64_t b)
+{
+    uint64_t ret = 0;
+    bitcnt_t i = 63;
+    do {
+        b >>= 1;
+        if (b & 1) ret ^= (a >> i);
+        i--;
+    } while (b);
+    return ret;
+}
+
+static inline uint32_t bit_clmulr32(uint32_t a, uint32_t b)
+{
+    uint32_t ret = 0;
+    bitcnt_t i = 31;
+    do {
+        if (b & 1) ret ^= (a >> i);
+        b >>= 1;
+        i--;
+    } while (b);
+    return ret;
+}
+
+static inline uint64_t bit_clmulr64(uint64_t a, uint64_t b)
+{
+    uint64_t ret = 0;
+    bitcnt_t i = 63;
+    do {
+        if (b & 1) ret ^= (a >> i);
+        b >>= 1;
+        i--;
+    } while (b);
+    return ret;
+}
+
+// Bswap 32-bit value (From BE to LE or vice versa)
+static inline uint32_t byteswap_uint32(uint32_t val)
+{
+    return (((val & 0xFF000000) >> 24) |
+            ((val & 0x00FF0000) >> 8)  |
+            ((val & 0x0000FF00) << 8)  |
+            ((val & 0x000000FF) << 24));
+}
+
+// Bswap 64-bit value (From BE to LE or vice versa)
+static inline uint64_t byteswap_uint64(uint64_t val)
+{
+    return (((val & 0xFF00000000000000) >> 56) |
+            ((val & 0x00FF000000000000) >> 40) |
+            ((val & 0x0000FF0000000000) >> 24) |
+            ((val & 0x000000FF00000000) >> 8)  |
+            ((val & 0x00000000FF000000) << 8)  |
+            ((val & 0x0000000000FF0000) << 24) |
+            ((val & 0x000000000000FF00) << 40) |
+            ((val & 0x00000000000000FF) << 56));
+}
+
+// Get high 64 bits from signed i64 x i64 -> 128 bit multiplication
+static inline uint64_t mulh_uint64(int64_t a, int64_t b)
+{
+#ifdef INT128_SUPPORT
+    return ((int128_t)a * (int128_t)b) >> 64;
+#else
+    int64_t lo_lo = (a & 0xFFFFFFFF) * (b & 0xFFFFFFFF);
+    int64_t hi_lo = (a >> 32)        * (b & 0xFFFFFFFF);
+    int64_t lo_hi = (a & 0xFFFFFFFF) * (b >> 32);
+    int64_t hi_hi = (a >> 32)        * (b >> 32);
+    int64_t cross = (lo_lo >> 32) + (hi_lo & 0xFFFFFFFF) + lo_hi;
+    return (hi_lo >> 32) + (cross >> 32) + hi_hi;
+#endif
+}
+
+// Get high 64 bits from unsigned u64 x u64 -> 128 bit multiplication
+static inline uint64_t mulhu_uint64(uint64_t a, uint64_t b)
+{
+#ifdef INT128_SUPPORT
+    return ((uint128_t)a * (uint128_t)b) >> 64;
+#else
+    uint64_t lo_lo = (a & 0xFFFFFFFF) * (b & 0xFFFFFFFF);
+    uint64_t hi_lo = (a >> 32)        * (b & 0xFFFFFFFF);
+    uint64_t lo_hi = (a & 0xFFFFFFFF) * (b >> 32);
+    uint64_t hi_hi = (a >> 32)        * (b >> 32);
+    uint64_t cross = (lo_lo >> 32) + (hi_lo & 0xFFFFFFFF) + lo_hi;
+    return (hi_lo >> 32) + (cross >> 32) + hi_hi;
+#endif
+}
+
+// Get high 64 bits from signed * unsigned i64 x u64 -> 128 bit multiplication
+static inline uint64_t mulhsu_uint64(int64_t a, uint64_t b)
+{
+#ifdef INT128_SUPPORT
+    return ((int128_t)a * (uint128_t)b) >> 64;
+#else
+    int64_t lo_lo = (a & 0xFFFFFFFF) * (b & 0xFFFFFFFF);
+    int64_t hi_lo = (a >> 32)        * (b & 0xFFFFFFFF);
+    int64_t lo_hi = (a & 0xFFFFFFFF) * (b >> 32);
+    int64_t hi_hi = (a >> 32)        * (b >> 32);
+    uint64_t cross = (lo_lo >> 32) + (hi_lo & 0xFFFFFFFF) + lo_hi;
+    return (hi_lo >> 32) + (cross >> 32) + hi_hi;
+#endif
+}
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/blk_io.c b/app/src/main/java/libengine/RVVM/src/blk_io.c
new file mode 100644
index 00000000..dc8140e6
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/blk_io.c
@@ -0,0 +1,468 @@
+/*
+blk_io.c - Cross-platform Block & File IO library
+Copyright (C) 2022 KotB <github.com/0xCatPKG>
+                   LekKit <github.com/LekKit>
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+// Force 64-bit file offsets
+#define _FILE_OFFSET_BITS 64
+#define _LARGEFILE64_SOURCE
+
+// Needed for pread()/pwrite(), syscall() when not passing -std=gnu..
+#define _GNU_SOURCE
+#define _BSD_SOURCE
+#define _DEFAULT_SOURCE
+
+#include "blk_io.h"
+
+// Maximum buffer size processed per internal IO syscall
+#define RVFILE_MAX_BUFF 0x10000000
+
+#if (defined(__unix__) || defined(__APPLE__) || defined(__HAIKU__)) && !defined(USE_STDIO)
+// POSIX implementation using open, pread, pwrite...
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <sys/stat.h>
+#include <sys/file.h>
+#define POSIX_FILE_IMPL
+
+#ifndef O_CLOEXEC
+#define O_CLOEXEC 0
+#endif
+
+#ifdef __FreeBSD__
+#include <sys/syscall.h> // For SYS_fspacectl()
+#endif
+
+static bool try_lock_fd(int fd)
+{
+    struct flock flk = {
+        .l_type = F_WRLCK,
+        .l_whence = SEEK_SET,
+    };
+    return fcntl(fd, F_SETLK, &flk) == 0 || (errno != EACCES && errno != EAGAIN);
+}
+
+#elif defined(_WIN32) && !defined(UNDER_CE) && !defined(USE_STDIO)
+// Win32 implementation using CreateFile, OVERLAPPED, ReadFile...
+#include <windows.h>
+#define WIN32_FILE_IMPL
+// Prototypes for older winapi headers
+#define DEVIOCTL_SET_SPARSE    0x000900c4
+#define DEVIOCTL_SET_ZERO_DATA 0x000980c8
+typedef struct {
+    LARGE_INTEGER FileOffset;
+    LARGE_INTEGER BeyondFinalZero;
+} SET_ZERO_DATA_INFO;
+
+#else
+// C stdio implementation using fopen, fread...
+// Emulates pread by using locks around fseek+fread
+#include <stdio.h>
+
+#define FILE_POS_INVALID 0
+#define FILE_POS_READ    1
+#define FILE_POS_WRITE   2
+#endif
+
+// RVVM internal headers come after system headers because of safe_free()
+#include "mem_ops.h"
+#include "utils.h"
+#include "spinlock.h"
+#include "threading.h"
+
+struct blk_io_rvfile {
+    uint64_t size;
+    uint64_t pos;
+#if defined(POSIX_FILE_IMPL)
+    int fd;
+#elif defined(WIN32_FILE_IMPL)
+    HANDLE handle;
+#else
+    uint64_t pos_real;
+    uint8_t  pos_state;
+    spinlock_t lock;
+    FILE* fp;
+#endif
+};
+
+rvfile_t* rvopen(const char* filepath, uint8_t mode)
+{
+#if defined(POSIX_FILE_IMPL)
+    int open_flags = O_CLOEXEC;
+    if (mode & RVFILE_RW) {
+        if (mode & RVFILE_TRUNC) open_flags |= O_TRUNC;
+        if (mode & RVFILE_CREAT) {
+            open_flags |= O_CREAT;
+            if (mode & RVFILE_EXCL) open_flags |= O_EXCL;
+        }
+        open_flags |= O_RDWR;
+    } else open_flags |= O_RDONLY;
+
+    int fd = open(filepath, open_flags, 0644);
+    if (fd == -1) return NULL;
+
+    if ((mode & RVFILE_EXCL) && !try_lock_fd(fd)) {
+        rvvm_error("File %s is busy", filepath);
+        close(fd);
+        return NULL;
+    }
+
+    rvfile_t* file = safe_new_obj(rvfile_t);
+    file->size = lseek(fd, 0, SEEK_END);
+    file->pos = 0;
+    file->fd = fd;
+    return file;
+#elif defined(WIN32_FILE_IMPL)
+    DWORD access = GENERIC_READ | ((mode & RVFILE_RW) ? GENERIC_WRITE : 0);
+    DWORD share = (mode & RVFILE_EXCL) ? 0 : (FILE_SHARE_READ | FILE_SHARE_WRITE);
+    DWORD disp = OPEN_EXISTING;
+    if (mode & RVFILE_RW) {
+        if (mode & RVFILE_CREAT) {
+            disp = OPEN_ALWAYS;
+            if (mode & RVFILE_TRUNC) disp = CREATE_ALWAYS;
+        } else {
+            if (mode & RVFILE_TRUNC) disp = TRUNCATE_EXISTING;
+        }
+    }
+
+    size_t path_len = rvvm_strlen(filepath);
+    wchar_t* u16_path = safe_new_arr(wchar_t, path_len + 1);
+    MultiByteToWideChar(CP_UTF8, 0, filepath, -1, u16_path, path_len + 1);
+    HANDLE handle = CreateFileW(u16_path, access, share, NULL, disp, FILE_ATTRIBUTE_NORMAL, NULL);
+    free(u16_path);
+
+    if (handle == INVALID_HANDLE_VALUE) {
+        DWORD last_error = GetLastError();
+        if (last_error == ERROR_SHARING_VIOLATION) rvvm_error("File %s is busy", filepath);
+        if (last_error == ERROR_FILE_NOT_FOUND && !(mode & (RVFILE_CREAT | RVFILE_TRUNC))) {
+            // Retry opening existing file using system locale (oh...)
+            handle = CreateFileA(filepath, access, share, NULL, disp, FILE_ATTRIBUTE_NORMAL, NULL);
+            if (handle != INVALID_HANDLE_VALUE) rvvm_warn("Non UTF-8 filepath \"%s\"", filepath);
+        }
+    }
+    if (handle == INVALID_HANDLE_VALUE) return NULL;
+
+    DWORD sizeh = 0;
+    DWORD sizel = GetFileSize(handle, &sizeh);
+    DWORD tmp = 0;
+    DeviceIoControl(handle, DEVIOCTL_SET_SPARSE, NULL, 0, NULL, 0, &tmp, NULL);
+
+    rvfile_t* file = safe_new_obj(rvfile_t);
+    file->size = ((uint64_t)sizeh) << 32 | sizel;
+    file->pos = 0;
+    file->handle = handle;
+    return file;
+#else
+    const char* open_mode = "rb";
+    if ((mode & RVFILE_TRUNC) && (mode & RVFILE_RW)) {
+        open_mode = "wb+";
+    } else if (mode & RVFILE_RW) {
+        open_mode = "rb+";
+    }
+
+    FILE* fp = fopen(filepath, open_mode);
+    if (!fp && (mode & RVFILE_RW) && (mode & RVFILE_CREAT)) fp = fopen(filepath, "wb+");
+    if (!fp) return NULL;
+
+    rvfile_t* file = safe_new_obj(rvfile_t);
+    fseek(fp, 0, SEEK_END);
+    file->size = ftell(fp);
+    file->pos = 0;
+    file->pos_state = FILE_POS_INVALID;
+    file->fp = fp;
+    spin_init(&file->lock);
+    return file;
+#endif
+}
+
+void rvclose(rvfile_t *file)
+{
+    if (!file) return;
+#if defined(POSIX_FILE_IMPL)
+    close(file->fd);
+#elif defined(WIN32_FILE_IMPL)
+    CloseHandle(file->handle);
+#else
+    spin_lock_slow(&file->lock);
+    fclose(file->fp);
+    spin_unlock(&file->lock);
+#endif
+    free(file);
+}
+
+uint64_t rvfilesize(rvfile_t* file)
+{
+    if (!file) return 0;
+    return atomic_load_uint64(&file->size);
+}
+
+#if defined(POSIX_FILE_IMPL) && defined(RVREAD_MMAP_FILE)
+#include <sys/mman.h>
+
+/*
+ * This is an experimental memory usage optimization, which remaps
+ * the destination buffer to be a file mapping which you just read.
+ * Under memory pressure, this allows swapping elimination.
+ * TODO: This is currently sub-optimal in regard to vm.max_map_count,
+ * and may cause OOM. Use with care!
+ */
+static void rvread_mmap_file(rvfile_t* file, void* destination, size_t count, uint64_t offset)
+{
+    if (count < 0x1000) return;
+    size_t low = ((size_t)destination) & 0xFFFULL;
+    uint8_t* buffer = ((uint8_t*)destination) + low;
+    size_t size = (count - low) & (~0xFFFULL);
+    offset += low;
+    if (!size || (offset & 0xFFF)) return;
+    mmap(buffer, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_FIXED, file->fd, offset);
+}
+#endif
+
+size_t rvread(rvfile_t* file, void* destination, size_t count, uint64_t offset)
+{
+    if (!file || count == 0) return 0;
+    uint64_t pos = (offset == RVFILE_CURPOS) ? file->pos : offset;
+    uint8_t* buffer = destination;
+    size_t ret = 0;
+#if defined(POSIX_FILE_IMPL)
+    while (ret < count) {
+        size_t size = EVAL_MIN(count - ret, RVFILE_MAX_BUFF);
+        ssize_t tmp = pread(file->fd, buffer + ret, size, pos + ret);
+        if (tmp > 0) ret += tmp;
+        if (tmp == 0 || (tmp < 0 && errno != EINTR) || pos + ret >= rvfilesize(file)) break;
+    }
+#ifdef RVREAD_MMAP_FILE
+    rvread_mmap_file(file, destination, ret, pos);
+#endif
+#elif defined(WIN32_FILE_IMPL)
+    while (ret < count) {
+        size_t size = EVAL_MIN(count - ret, RVFILE_MAX_BUFF);
+        OVERLAPPED overlapped = { .OffsetHigh = (pos + ret) >> 32, .Offset = (uint32_t)(pos + ret) };
+        DWORD tmp = 0;
+        ReadFile(file->handle, buffer + ret, size, &tmp, &overlapped);
+        ret += tmp;
+        if (tmp == 0 || pos + ret >= rvfilesize(file)) break;
+    }
+#else
+    spin_lock_slow(&file->lock);
+    if (pos != file->pos_real || !(file->pos_state & FILE_POS_READ)) {
+        fseek(file->fp, pos, SEEK_SET);
+    }
+    while (ret < count) {
+        size_t size = EVAL_MIN(count - ret, RVFILE_MAX_BUFF);
+        size_t tmp = fread(buffer + ret, 1, size, file->fp);
+        ret += tmp;
+        if (tmp == 0 || pos + ret >= rvfilesize(file)) break;
+    }
+    file->pos_real = pos + ret;
+    file->pos_state = FILE_POS_READ;
+    spin_unlock(&file->lock);
+#endif
+    if (offset == RVFILE_CURPOS) file->pos += ret;
+    return ret;
+}
+
+size_t rvwrite(rvfile_t* file, const void* source, size_t count, uint64_t offset)
+{
+    if (!file || count == 0) return 0;
+    uint64_t pos = (offset == RVFILE_CURPOS) ? file->pos : offset;
+    const uint8_t* buffer = source;
+    size_t ret = 0;
+#if defined(POSIX_FILE_IMPL)
+    while (ret < count) {
+        size_t size = EVAL_MIN(count - ret, RVFILE_MAX_BUFF);
+        ssize_t tmp = pwrite(file->fd, buffer + ret, size, pos + ret);
+        if (tmp > 0) ret += tmp;
+        if (tmp == 0 || (tmp < 0 && errno != EINTR)) break;
+    }
+#elif defined(WIN32_FILE_IMPL)
+    while (ret < count) {
+        size_t size = EVAL_MIN(count - ret, RVFILE_MAX_BUFF);
+        OVERLAPPED overlapped = { .OffsetHigh = (pos + ret) >> 32, .Offset = (uint32_t)(pos + ret) };
+        DWORD tmp = 0;
+        WriteFile(file->handle, buffer + ret, size, &tmp, &overlapped);
+        ret += tmp;
+        if (tmp == 0) break;
+    }
+#else
+    spin_lock_slow(&file->lock);
+    if (pos != file->pos_real || !(file->pos_state & FILE_POS_WRITE)) {
+        fseek(file->fp, pos, SEEK_SET);
+    }
+    while (ret < count) {
+        size_t size = EVAL_MIN(count - ret, RVFILE_MAX_BUFF);
+        size_t tmp = fwrite(buffer + ret, 1, size, file->fp);
+        ret += tmp;
+        if (tmp == 0) break;
+    }
+    file->pos_real = pos + ret;
+    file->pos_state = FILE_POS_WRITE;
+    spin_unlock(&file->lock);
+#endif
+    if (offset == RVFILE_CURPOS) file->pos += ret;
+    uint64_t file_size = 0;
+    do {
+        file_size = atomic_load_uint64(&file->size);
+        if (likely(pos + ret <= file->size)) break;
+    } while (!atomic_cas_uint64_ex(&file->size, file_size, pos + ret, true, ATOMIC_RELEASE, ATOMIC_ACQUIRE));
+    return ret;
+}
+
+bool rvtrim(rvfile_t* file, uint64_t offset, uint64_t count)
+{
+    if (!file) return false;
+#if defined(POSIX_FILE_IMPL) && defined(__linux__) && defined(FALLOC_FL_PUNCH_HOLE) && defined(FALLOC_FL_KEEP_SIZE)
+    return fallocate(file->fd, FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE, offset, count) == 0;
+#elif defined(POSIX_FILE_IMPL) && defined(__FreeBSD__) && defined(SYS_fspacectl)
+    struct {
+        off_t r_offset;
+        off_t r_len;
+    } rmsr = {
+        .r_offset = offset,
+        .r_len = count,
+    };
+    // Use fspacectl(SPACECTL_DEALLOC) added in FreeBSD 14
+    return syscall(SYS_fspacectl, file->fd, 1, &rmsr, 0, NULL) == 0;
+#elif defined(WIN32_FILE_IMPL)
+    SET_ZERO_DATA_INFO fz = {0};
+    DWORD tmp = 0;
+    fz.FileOffset.QuadPart = offset;
+    fz.BeyondFinalZero.QuadPart = offset + count;
+    return DeviceIoControl(file->handle, DEVIOCTL_SET_ZERO_DATA, &fz, sizeof(fz), NULL, 0 , &tmp, NULL);
+#else
+    UNUSED(file);
+    UNUSED(offset);
+    UNUSED(count);
+    return false;
+#endif
+}
+
+bool rvseek(rvfile_t* file, int64_t offset, uint8_t startpos)
+{
+    if (!file || startpos > RVFILE_END) return false;
+    if (startpos == RVFILE_CUR) {
+        offset = file->pos + offset;
+    } else if (startpos == RVFILE_END) {
+        offset = rvfilesize(file) - offset;
+    }
+    if (startpos != RVFILE_SET && offset < 0) return false;
+    file->pos = (uint64_t)offset;
+    return true;
+}
+
+uint64_t rvtell(rvfile_t* file)
+{
+    if (!file) return -1;
+    return file->pos;
+}
+
+bool rvflush(rvfile_t* file)
+{
+    if (!file) return false;
+    // Do not issue kernel-side buffer flushing
+#if defined(POSIX_FILE_IMPL)
+    //return fsync(file->fd) == 0;
+    return true;
+#elif defined(WIN32_FILE_IMPL)
+    //return FlushFileBuffers(file->handle);
+    return true;
+#else
+    return fflush(file->fp) == 0;
+#endif
+}
+
+bool rvtruncate(rvfile_t* file, uint64_t length)
+{
+    if (!file) return false;
+    file->size = length;
+#if defined(POSIX_FILE_IMPL)
+    return ftruncate(file->fd, length) == 0;
+#elif defined(WIN32_FILE_IMPL)
+    LONG high_len = length >> 32;
+    SetFilePointer(file->handle, (uint32_t)length, &high_len, FILE_BEGIN);
+    return SetEndOfFile(file->handle);
+#else
+    char tmp = 0;
+    if (length) {
+        spin_lock_slow(&file->lock);
+        fseek(file->fp, length - 1, SEEK_SET);
+        fread(&tmp, 1, 1, file->fp);
+        fseek(file->fp, length - 1, SEEK_SET);
+        fwrite(&tmp, 1, 1, file->fp);
+        file->pos_state = FILE_POS_INVALID;
+        spin_unlock(&file->lock);
+    }
+    return true;
+#endif
+}
+
+/*
+ * Block device layer
+ */
+
+// Raw block device implementation
+// Be careful with function prototypes
+static const blkdev_type_t blkdev_type_raw = {
+    .name = "raw",
+    .close = (void*)rvclose,
+    .read = (void*)rvread,
+    .write = (void*)rvwrite,
+    .trim = (void*)rvtrim,
+    .sync = (void*)rvflush,
+};
+
+static blkdev_t* blk_open_raw(const char* filename, uint8_t filemode)
+{
+    rvfile_t* file = rvopen(filename, filemode);
+    if (!file) return NULL;
+    blkdev_t* dev = safe_new_obj(blkdev_t);
+    dev->type = &blkdev_type_raw;
+    dev->size = rvfilesize(file);
+    dev->data = file;
+    return dev;
+}
+
+static bool check_file_ext(const char* filename, const char* ext)
+{
+    const char* r = NULL;
+    while (true) {
+        const char* tmp = rvvm_strfind(filename, ext);
+        if (tmp == NULL) break;
+        r = tmp;
+        filename = r + 1;
+    }
+    return r && rvvm_strcmp(r, ext);
+}
+
+blkdev_t* blk_open(const char* filename, uint8_t opts)
+{
+    uint8_t filemode = (opts & BLKDEV_RW) ? (RVFILE_RW | RVFILE_EXCL) : 0;
+    if (check_file_ext(filename, ".bdi")) {
+        return NULL;
+    }
+    if (check_file_ext(filename, ".qcow2")) {
+        rvvm_error("QCOW2 images aren't supported yet");
+        return NULL;
+    }
+    return blk_open_raw(filename, filemode);
+}
+
+void blk_close(blkdev_t* dev)
+{
+    if (dev) {
+        dev->type->close(dev->data);
+        free(dev);
+    }
+}
diff --git a/app/src/main/java/libengine/RVVM/src/blk_io.h b/app/src/main/java/libengine/RVVM/src/blk_io.h
new file mode 100644
index 00000000..9182eecf
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/blk_io.h
@@ -0,0 +1,158 @@
+/*
+blk_io.h - Cross-platform Block & File IO library
+Copyright (C) 2022 KotB <github.com/0xCatPKG>
+                   LekKit <github.com/LekKit>
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef BLK_IO_H
+#define BLK_IO_H
+
+#include <stdbool.h>
+#include <stdint.h>
+#include <stddef.h>
+
+/*
+ * File API
+ */
+
+#define RVFILE_RW    1    // Open file in read/write mode
+#define RVFILE_CREAT 2    // Create file if it doesn't exist (for RW only)
+#define RVFILE_EXCL  4    // Prevent other processes from opening this file
+#define RVFILE_TRUNC 8    // Truncate file conents upon opening (for RW only)
+
+#define RVFILE_SET   0    // Set file cursor
+#define RVFILE_CUR   1    // Move file cursor
+#define RVFILE_END   2    // Set file cursor relative to end
+
+// Use file cursor as offset for read/write
+// Not suitable for async IO
+#define RVFILE_CURPOS ((uint64_t)-1)
+
+typedef struct blk_io_rvfile rvfile_t;
+
+rvfile_t* rvopen(const char* filepath, uint8_t mode); // Returns NULL on failure
+void      rvclose(rvfile_t* file);
+
+uint64_t  rvfilesize(rvfile_t* file);
+
+// If offset == RVFILE_CURPOS, uses current file position as offset
+// Otherwise is equialent to pread/pwrite, and is thread-safe
+size_t    rvread(rvfile_t* file, void* destination, size_t count, uint64_t offset);
+size_t    rvwrite(rvfile_t* file, const void* source, size_t count, uint64_t offset);
+
+bool      rvseek(rvfile_t* file, int64_t offset, uint8_t startpos);
+uint64_t  rvtell(rvfile_t* file);
+bool      rvtrim(rvfile_t* file, uint64_t offset, uint64_t count);
+bool      rvflush(rvfile_t* file);
+bool      rvtruncate(rvfile_t* file, uint64_t length);
+
+/*
+ * Block device API
+ */
+
+#define BLKDEV_RW  RVFILE_RW
+
+#define BLKDEV_SET RVFILE_SET
+#define BLKDEV_CUR RVFILE_CUR
+#define BLKDEV_END RVFILE_END
+
+#define BLKDEV_CURPOS RVFILE_CURPOS
+
+typedef struct {
+    const char* name;
+    void     (*close)(void* dev);
+    size_t   (*read)(void* dev, void* dst, size_t count, uint64_t offset);
+    size_t   (*write)(void* dev, const void* src, size_t count, uint64_t offset);
+    bool     (*trim)(void* dev, uint64_t offset, uint64_t count);
+    bool     (*sync)(void* dev);
+} blkdev_type_t;
+
+typedef struct blkdev_t blkdev_t;
+
+struct blkdev_t {
+    const blkdev_type_t* type;
+    void* data;
+    uint64_t size;
+    uint64_t pos;
+};
+
+blkdev_t* blk_open(const char* filename, uint8_t opts);
+void      blk_close(blkdev_t* dev);
+
+static inline uint64_t blk_getsize(blkdev_t* dev)
+{
+    if (!dev) return 0;
+    return dev->size;
+}
+
+static inline size_t blk_read(blkdev_t* dev, void* dst, size_t count, uint64_t offset)
+{
+    if (!dev) return 0;
+    uint64_t real_pos = (offset == RVFILE_CURPOS) ? dev->pos : offset;
+    if (real_pos + count > dev->size) return 0;
+    size_t ret = dev->type->read(dev->data, dst, count, real_pos);
+    if (offset == RVFILE_CURPOS) dev->pos += ret;
+    return ret;
+}
+
+// It's illegal to seek out of device bounds,
+// resizing the device is also impossible
+static inline size_t blk_write(blkdev_t* dev, const void* src, size_t count, uint64_t offset)
+{
+    if (!dev) return 0;
+    uint64_t real_pos = (offset == RVFILE_CURPOS) ? dev->pos : offset;
+    if (real_pos + count > dev->size) return 0;
+    size_t ret = dev->type->write(dev->data, src, count, real_pos);
+    if (offset == RVFILE_CURPOS) dev->pos += ret;
+    return ret;
+}
+
+static inline bool blk_seek(blkdev_t* dev, int64_t offset, uint8_t startpos)
+{
+    if (!dev) return false;
+    if (startpos == BLKDEV_CUR) {
+        offset = dev->pos + offset;
+    } else if (startpos == BLKDEV_END) {
+        offset = dev->size - offset;
+    } else if (startpos != BLKDEV_SET) {
+        return false;
+    }
+    if (((uint64_t)offset) <= dev->size) {
+        dev->pos = offset;
+        return true;
+    } else {
+        return false;
+    }
+}
+
+static inline uint64_t blk_tell(blkdev_t* dev)
+{
+    if (!dev) return 0;
+    return dev->pos;
+}
+
+static inline bool blk_trim(blkdev_t* dev, uint64_t offset, uint64_t count)
+{
+    if (!dev || !dev->type->trim) return false;
+    uint64_t real_pos = (offset == RVFILE_CURPOS) ? dev->pos : offset;
+    if (real_pos + count > dev->size) return false;
+    return dev->type->trim(dev->data, real_pos, count);
+}
+
+static inline bool blk_sync(blkdev_t* dev)
+{
+    if (!dev || !dev->type->sync) return false;
+    return dev->type->sync(dev->data);
+}
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/compiler.h b/app/src/main/java/libengine/RVVM/src/compiler.h
new file mode 100644
index 00000000..ddf5667e
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/compiler.h
@@ -0,0 +1,265 @@
+/*
+compiler.h - Compilers tricks and features
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef COMPILER_H
+#define COMPILER_H
+
+#include <stdint.h>
+
+#if defined(__GNUC__) || defined(__llvm__) || defined(__INTEL_COMPILER)
+#define GNU_EXTS 1
+#endif
+
+#if defined(__GNUC__) && !defined(__llvm__) && !defined(__INTEL_COMPILER)
+#define GCC_CHECK_VER(major, minor) (__GNUC__ > major || \
+        (__GNUC__ == major && __GNUC_MINOR__ >= minor))
+#else
+#define GCC_CHECK_VER(major, minor) 0
+#endif
+
+#ifdef __clang__
+#define CLANG_CHECK_VER(major, minor) (__clang_major__ > major || \
+          (__clang_major__ == major && __clang_minor__ >= minor))
+#else
+#define CLANG_CHECK_VER(major, minor) 0
+#endif
+
+// Check GNU attribute presence
+#if defined(GNU_EXTS) && defined(__has_attribute)
+#define GNU_ATTRIBUTE(attr) __has_attribute(attr)
+#else
+#define GNU_ATTRIBUTE(attr) 0
+#endif
+
+// Check GNU builtin presence
+#if defined(GNU_EXTS) && defined(__has_builtin)
+#define GNU_BUILTIN(builtin) __has_builtin(builtin)
+#else
+#define GNU_BUILTIN(builtin) 0
+#endif
+
+// Check header presence
+#ifdef __has_include
+#define CHECK_INCLUDE(include) __has_include(#include)
+#else
+#define CHECK_INCLUDE(include) 1
+#endif
+
+// Branch optimization hints
+#if GNU_BUILTIN(__builtin_expect)
+#define likely(x)     __builtin_expect(!!(x),1)
+#define unlikely(x)   __builtin_expect(!!(x),0)
+#else
+#define likely(x)     (x)
+#define unlikely(x)   (x)
+#endif
+
+#if GNU_BUILTIN(__builtin_prefetch) && !defined(NO_PREFETCH)
+#define mem_prefetch(addr, rw, loc) __builtin_prefetch(addr, !!(rw), loc)
+#else
+#define mem_prefetch(addr, rw, loc)
+#endif
+
+// Never inline this function
+#if GNU_ATTRIBUTE(__noinline__)
+#define NOINLINE      __attribute__((__noinline__))
+#elif defined(_MSC_VER)
+#define NOINLINE      __declspec(noinline)
+#else
+#define NOINLINE
+#endif
+
+#if GNU_ATTRIBUTE(__destructor__)
+#define GNU_DESTRUCTOR __attribute__((__destructor__))
+#else
+#define GNU_DESTRUCTOR
+#endif
+
+#if GNU_ATTRIBUTE(__constructor__)
+#define GNU_CONSTRUCTOR __attribute__((__constructor__))
+#else
+#define GNU_CONSTRUCTOR
+#endif
+
+/*
+ * This is used to remove unnecessary register spills from algorithm fast path
+ * when a slow path call is present. Hopefully one day similar thing will appear in GCC.
+ *
+ * This attribute is BROKEN before Clang 17 and generates broken binaries if used <17!!!
+ */
+#if CLANG_CHECK_VER(17, 0) && GNU_ATTRIBUTE(__preserve_most__) && !defined(__EMSCRIPTEN__)
+#define slow_path __attribute__((__preserve_most__,__noinline__,__cold__))
+#elif GNU_ATTRIBUTE(__cold__)
+#define slow_path NOINLINE __attribute__((__cold__))
+#else
+#define slow_path NOINLINE
+#endif
+
+// Always inline this function into the caller
+#if GNU_ATTRIBUTE(__always_inline__)
+#define forceinline inline __attribute__((__always_inline__))
+#elif defined(_MSC_VER)
+#define forceinline __forceinline
+#else
+#define forceinline inline
+#endif
+
+// Inline all function calls into the caller marked with flatten_calls. Use with care!
+#if GNU_ATTRIBUTE(__flatten__)
+#define flatten_calls __attribute__((__flatten__))
+#else
+#define flatten_calls
+#endif
+
+// Warn if return value is unused
+#if GNU_ATTRIBUTE(__warn_unused_result__)
+#define warn_unused_ret __attribute__((__warn_unused_result__))
+#else
+#define warn_unused_ret
+#endif
+
+// Explicitly mark deallocator for an allocator function
+#if GNU_ATTRIBUTE(__malloc__)
+#define deallocate_with(deallocator) warn_unused_ret __attribute__((__malloc__,__malloc__(deallocator, 1)))
+#else
+#define deallocate_with(deallocator) warn_unused_ret
+#endif
+
+// Match GCC macro __SANITIZE_THREAD__, __SANITIZE_ADDRESS__ on Clang, provide __SANITIZE_MEMORY__
+#if defined(__clang__) && defined(__has_feature)
+#if __has_feature(address_sanitizer) && !defined(__SANITIZE_ADDRESS__)
+#define __SANITIZE_ADDRESS__
+#endif
+#if __has_feature(thread_sanitizer) && !defined(__SANITIZE_THREAD__)
+#define __SANITIZE_THREAD__
+#endif
+#if __has_feature(memory_sanitizer) && !defined(__SANITIZE_MEMORY__)
+#define __SANITIZE_MEMORY__
+#endif
+#endif
+
+// Suppress ThreadSanitizer in places with false alarms (emulated load/stores or RCU)
+// Guest dataraces hinder normal code instrumentation, so this is handy
+#if defined(__SANITIZE_THREAD__) && !defined(USE_SANITIZE_FULL) && GNU_ATTRIBUTE(__no_sanitize__)
+#define TSAN_SUPPRESS __attribute__((__no_sanitize__("thread")))
+#else
+#define TSAN_SUPPRESS
+#endif
+
+// Suppress MemorySanitizer in places with false alarms (non-instrumented syscalls, X11 libs, etc)
+#if defined(__SANITIZE_MEMORY__) && !defined(USE_SANITIZE_FULL) && GNU_ATTRIBUTE(__no_sanitize__)
+#define MSAN_SUPPRESS __attribute__((__no_sanitize__("memory")))
+#else
+#define MSAN_SUPPRESS
+#endif
+
+// Optimization pragmas (Clang doesn't support this)
+#if GCC_CHECK_VER(4, 4)
+#define SOURCE_OPTIMIZATION_NONE _Pragma("GCC optimize(\"O0\")")
+#define SOURCE_OPTIMIZATION_O2 _Pragma("GCC optimize(\"O2\")")
+#define SOURCE_OPTIMIZATION_O3 _Pragma("GCC optimize(\"O3\")")
+#else
+#define SOURCE_OPTIMIZATION_NONE
+#define SOURCE_OPTIMIZATION_O2
+#define SOURCE_OPTIMIZATION_O3
+#endif
+#if GCC_CHECK_VER(12, 1)
+#define SOURCE_OPTIMIZATION_SIZE _Pragma("GCC optimize(\"Oz\")")
+#elif GCC_CHECK_VER(4, 4)
+#define SOURCE_OPTIMIZATION_SIZE _Pragma("GCC optimize(\"Os\")")
+#else
+#define SOURCE_OPTIMIZATION_SIZE
+#endif
+
+// Pushable size optimization attribute, Clang supports this to some degree
+#if CLANG_CHECK_VER(8, 0) && GNU_ATTRIBUTE(__minsize__)
+#define PUSH_OPTIMIZATION_SIZE _Pragma("clang attribute push (__attribute__((__minsize__)), apply_to=function)")
+#define POP_OPTIMIZATION_SIZE _Pragma("clang attribute pop")
+#elif GCC_CHECK_VER(4, 4)
+#define PUSH_OPTIMIZATION_SIZE _Pragma("GCC push_options") SOURCE_OPTIMIZATION_SIZE
+#define POP_OPTIMIZATION_SIZE _Pragma("GCC pop_options")
+#else
+#define PUSH_OPTIMIZATION_SIZE
+#define POP_OPTIMIZATION_SIZE
+#endif
+
+// Guess endianness based on arch/common macros
+// Able to detect big-endian MIPS, ARM, PowerPC, PA-RISC, s390
+#if (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__) || defined(__MIPSEB__) || \
+    defined(__ARMEB__) || defined(__hppa__) || defined(__hppa64__) || defined(__s390__)
+#define HOST_BIG_ENDIAN 1
+#elif !defined(GNU_EXTS) || (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)
+#define HOST_LITTLE_ENDIAN 1
+#endif
+
+// Determine whether host has fast misaligned access (Hint)
+#if defined(__i386__) || defined(__x86_64__) || defined(_M_IX86) || defined(_M_AMD64) || defined(__aarch64__)
+#define HOST_FAST_MISALIGN 1
+#else
+// Not sure about other arches, misaligns may be very slow or crash
+#define HOST_NO_MISALIGN 1
+#endif
+
+#define UNUSED(x) (void)x
+
+// Determine host bitness (Hint)
+#if UINTPTR_MAX == UINT64_MAX
+#define HOST_64BIT 1
+#elif UINTPTR_MAX == UINT32_MAX
+#define HOST_32BIT 1
+#endif
+
+// Unwrap a token or a token value into a string literal
+#define MACRO_MKSTRING(x) #x
+#define MACRO_TOSTRING(x) MACRO_MKSTRING(x)
+
+// GNU extension that omits file path, use if available
+#ifndef __FILE_NAME__
+#define __FILE_NAME__ __FILE__
+#endif
+
+// Unwraps to example.c@128
+#define SOURCE_LINE __FILE_NAME__ "@" MACRO_TOSTRING(__LINE__)
+
+#define MACRO_ASSERT_NAMED(cond, name) typedef char static_assert_at_line_##name[(cond) ? 1 : -1]
+#define MACRO_ASSERT_UNWRAP(cond, tok) MACRO_ASSERT_NAMED(cond, tok)
+
+// Static build-time assertions
+#ifdef IGNORE_BUILD_ASSERTS
+#define BUILD_ASSERT(cond)
+#elif __STDC_VERSION__ >= 201112LL && !defined(__chibicc__)
+#define BUILD_ASSERT(cond) _Static_assert(cond, MACRO_TOSTRING(cond))
+#else
+#define BUILD_ASSERT(cond) MACRO_ASSERT_UNWRAP(cond, __LINE__)
+#endif
+
+// Same as BUILD_ASSERT, but produces an expression with value 0
+#ifdef IGNORE_BUILD_ASSERTS
+#define BUILD_ASSERT_EXPR(cond) 0
+#else
+#define BUILD_ASSERT_EXPR(cond) (sizeof(char[(cond) ? 1 : -1]) - 1)
+#endif
+
+// Weak symbol linkage (Runtime library probing)
+#if defined(GNU_EXTS)
+#define WEAK_LINKAGE(symbol) _Pragma(MACRO_TOSTRING(weak symbol))
+#else
+#define WEAK_LINKAGE(symbol)
+#endif
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/cpu/fpu_lib.h b/app/src/main/java/libengine/RVVM/src/cpu/fpu_lib.h
new file mode 100644
index 00000000..93c1014f
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/cpu/fpu_lib.h
@@ -0,0 +1,266 @@
+/*
+fpu_lib.h - Floating-point handling library
+Copyright (C) 2024  LekKit <github.com/LekKit>
+
+This Source Code Form is subject to the terms of the Mozilla Public
+License, v. 2.0. If a copy of the MPL was not distributed with this
+file, You can obtain one at https://mozilla.org/MPL/2.0/.
+
+Alternatively, the contents of this file may be used under the terms
+of the GNU General Public License as published by the Free Software
+Foundation, either version 3 of the License, or any later version.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef RVVM_FPU_LIB_H
+#define RVVM_FPU_LIB_H
+
+#include "../compiler.h"
+#include "../fpu_ops.h"
+#include "../mem_ops.h"
+#include "../bit_ops.h"
+
+/* well... */
+#if defined(_WIN32) && defined(__clang__)
+#define _C_COMPLEX_T
+typedef _Complex double _C_double_complex;
+typedef _Complex float _C_float_complex;
+typedef _Complex long double _C_ldouble_complex;
+#endif
+#include <math.h>
+
+#define fpu_isnan(x) isnan(x)
+
+static forceinline bool fpu_is_snanf(float f)
+{
+    uint32_t i;
+    memcpy(&i, &f, sizeof(f));
+    return fpu_isnan(f) && !bit_check(i, 22);
+}
+
+static forceinline bool fpu_is_snand(double d)
+{
+    uint64_t i;
+    memcpy(&i, &d, sizeof(d));
+    return fpu_isnan(d) && !bit_check(i, 51);
+}
+
+static forceinline bool fpu_signbitf(float f)
+{
+    uint32_t i;
+    memcpy(&i, &f, sizeof(f));
+    return i >> 31;
+}
+
+static forceinline bool fpu_signbitd(double d)
+{
+    uint64_t i;
+    memcpy(&i, &d, sizeof(d));
+    return i >> 63;
+}
+
+static forceinline float fpu_sqrtf(float val)
+{
+    float ret = sqrtf(val);
+    if (unlikely(val < 0 && !fetestexcept(FE_INVALID))) feraiseexcept(FE_INVALID);
+    return ret;
+}
+
+static forceinline double fpu_sqrtd(double val)
+{
+    double ret = sqrt(val);
+    if (unlikely(val < 0 && !fetestexcept(FE_INVALID))) feraiseexcept(FE_INVALID);
+    return ret;
+}
+
+static forceinline float fpu_copysignf(float a, float b)
+{
+    return copysignf(a, b);
+}
+
+static forceinline double fpu_copysignd(double a, double b)
+{
+    return copysign(a, b);
+}
+
+static forceinline float fpu_copysignxf(float a, float b)
+{
+    uint32_t ia, ib;
+    memcpy(&ia, &a, sizeof(a));
+    memcpy(&ib, &b, sizeof(b));
+    ib ^= ia;
+    memcpy(&b, &ib, sizeof(b));
+    return fpu_copysignf(a, b);
+}
+
+static forceinline double fpu_copysignxd(double a, double b)
+{
+    uint64_t ia, ib;
+    memcpy(&ia, &a, sizeof(a));
+    memcpy(&ib, &b, sizeof(b));
+    ib ^= ia;
+    memcpy(&b, &ib, sizeof(b));
+    return fpu_copysignd(a, b);
+}
+
+static forceinline float fpu_fmaf(float a, float b, float c)
+{
+#ifdef UNDER_CE // WinCE libc doesn't have fma()
+    return a * b + c;
+#else
+    return fmaf(a, b, c);
+#endif
+}
+
+static forceinline double fpu_fmad(double a, double b, double c)
+{
+#ifdef UNDER_CE // WinCE libc doesn't have fma()
+    return a * b + c;
+#else
+    return fma(a, b, c);
+#endif
+}
+
+static forceinline float fpu_minf(float x, float y)
+{
+#if defined(__riscv_f)
+    // On real RISC-V, fmin/fmax actually behave the way we need
+    return fminf(x, y);
+#else
+#if defined(GNU_EXTS)
+    // isless/isgreater are non-signalling comparisons
+    if (isless(x, y)) {
+        return x;
+    } else if (likely(isless(y, x))) {
+        return y;
+    }
+#endif
+    if (unlikely(fpu_isnan(x))) {
+        // If one of operands is NaN, return a different operand
+        if (fpu_is_snanf(x) || fpu_is_snanf(y)) {
+            feraiseexcept(FE_INVALID);
+        }
+        return y;
+    } else if (unlikely(fpu_isnan(y))) {
+        if (fpu_is_snanf(x) || fpu_is_snanf(y)) {
+            feraiseexcept(FE_INVALID);
+        }
+        return x;
+#if !defined(GNU_EXTS)
+    } else if (x < y) {
+        return x;
+    } else if (y < x) {
+        return y;
+#endif
+    } else {
+        // -0.0 is less than 0.0, but not handled by isless/isgreater
+        return fpu_signbitf(x) ? x : y;
+    }
+#endif
+}
+
+static forceinline float fpu_maxf(float x, float y)
+{
+#if defined(__riscv_f)
+    return fmaxf(x, y);
+#else
+#if defined(GNU_EXTS)
+    if (isgreater(x, y)) {
+        return x;
+    } else if (likely(isgreater(y, x))) {
+        return y;
+    }
+#endif
+    if (unlikely(fpu_isnan(x))) {
+        if (fpu_is_snanf(x) || fpu_is_snanf(y)) {
+            feraiseexcept(FE_INVALID);
+        }
+        return y;
+    } else if (unlikely(fpu_isnan(y))) {
+        if (fpu_is_snanf(x) || fpu_is_snanf(y)) {
+            feraiseexcept(FE_INVALID);
+        }
+        return x;
+#if !defined(GNU_EXTS)
+    } else if (x > y) {
+        return x;
+    } else if (y > x) {
+        return y;
+#endif
+    } else {
+        return fpu_signbitf(x) ? y : x;
+    }
+#endif
+}
+
+static forceinline double fpu_mind(double x, double y)
+{
+#if defined(__riscv_d)
+    return fmin(x, y);
+#else
+#if defined(GNU_EXTS)
+    if (isless(x, y)) {
+        return x;
+    } else if (likely(isless(y, x))) {
+        return y;
+    }
+#endif
+    if (unlikely(fpu_isnan(x))) {
+        if (fpu_is_snand(x) || fpu_is_snand(y)) {
+            feraiseexcept(FE_INVALID);
+        }
+        return y;
+    } else if (unlikely(fpu_isnan(y))) {
+        if (fpu_is_snand(x) || fpu_is_snand(y)) {
+            feraiseexcept(FE_INVALID);
+        }
+        return x;
+#if !defined(GNU_EXTS)
+    } else if (x < y) {
+        return x;
+    } else if (y < x) {
+        return y;
+#endif
+    } else {
+        return fpu_signbitd(x) ? x : y;
+    }
+#endif
+}
+
+static forceinline double fpu_maxd(double x, double y)
+{
+#if defined(__riscv_d)
+    return fmax(x, y);
+#else
+#if defined(GNU_EXTS)
+    if (isgreater(x, y)) {
+        return x;
+    } else if (likely(isgreater(y, x))) {
+        return y;
+    }
+#endif
+    if (unlikely(fpu_isnan(x))) {
+        if (fpu_is_snand(x) || fpu_is_snand(y)) {
+            feraiseexcept(FE_INVALID);
+        }
+        return y;
+    } else if (unlikely(fpu_isnan(y))) {
+        if (fpu_is_snand(x) || fpu_is_snand(y)) {
+            feraiseexcept(FE_INVALID);
+        }
+        return x;
+#if !defined(GNU_EXTS)
+    } else if (x > y) {
+        return x;
+    } else if (y > x) {
+        return y;
+#endif
+    } else {
+        return fpu_signbitd(x) ? y : x;
+    }
+#endif
+}
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/cpu/riscv64_interpreter.c b/app/src/main/java/libengine/RVVM/src/cpu/riscv64_interpreter.c
new file mode 100644
index 00000000..c99dd637
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/cpu/riscv64_interpreter.c
@@ -0,0 +1,26 @@
+/*
+riscv_interpreter64.c - RISC-V 64-bit template interpreter
+Copyright (C) 2024  LekKit <github.com/LekKit>
+
+This Source Code Form is subject to the terms of the Mozilla Public
+License, v. 2.0. If a copy of the MPL was not distributed with this
+file, You can obtain one at https://mozilla.org/MPL/2.0/.
+
+Alternatively, the contents of this file may be used under the terms
+of the GNU General Public License as published by the Free Software
+Foundation, either version 3 of the License, or any later version.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#define RV64
+#define riscv_run_interpreter riscv64_run_interpreter
+
+#include "../compiler.h"
+
+// The interpreter is faster on GCC with -O3 optimization for whatever reason.
+// This overrides the optimization level set for the whole codebase
+SOURCE_OPTIMIZATION_O3
+
+#include "riscv_interpreter.h"
diff --git a/app/src/main/java/libengine/RVVM/src/cpu/riscv_atomics.h b/app/src/main/java/libengine/RVVM/src/cpu/riscv_atomics.h
new file mode 100644
index 00000000..00470ca7
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/cpu/riscv_atomics.h
@@ -0,0 +1,214 @@
+/*
+riscv_atomics.h - RISC-V Atomics interpreter
+Copyright (C) 2024  LekKit <github.com/LekKit>
+
+This Source Code Form is subject to the terms of the Mozilla Public
+License, v. 2.0. If a copy of the MPL was not distributed with this
+file, You can obtain one at https://mozilla.org/MPL/2.0/.
+
+Alternatively, the contents of this file may be used under the terms
+of the GNU General Public License as published by the Free Software
+Foundation, either version 3 of the License, or any later version.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef RISCV_ATOMICS_H
+#define RISCV_ATOMICS_H
+
+#define RISCV_AMO_LR   0x2
+#define RISCV_AMO_SC   0x3
+#define RISCV_AMO_SWAP 0x1
+#define RISCV_AMO_ADD  0x0
+#define RISCV_AMO_XOR  0x4
+#define RISCV_AMO_AND  0xC
+#define RISCV_AMO_OR   0x8
+#define RISCV_AMO_MIN  0x10
+#define RISCV_AMO_MAX  0x14
+#define RISCV_AMO_MINU 0x18
+#define RISCV_AMO_MAXU 0x1C
+
+static void riscv_invalidate_lrsc(rvvm_hart_t *vm)
+{
+    vector_foreach(vm->machine->harts, i) {
+        rvvm_hart_t* hart = vector_at(vm->machine->harts, i);
+        if (hart != vm) {
+            atomic_store_uint32(&hart->lrsc, false);
+        }
+    }
+}
+
+static forceinline void riscv_emulate_atomic_w(rvvm_hart_t *vm, const uint32_t insn)
+{
+    const uint32_t op = insn >> 27;
+    const regid_t rds = bit_cut(insn, 7, 5);
+    const regid_t rs1 = bit_cut(insn, 15, 5);
+    const regid_t rs2 = bit_cut(insn, 20, 5);
+    const xaddr_t addr = riscv_read_reg(vm, rs1);
+    const uint32_t val = riscv_read_reg(vm, rs2);
+    uint8_t buff[4]; // MMIO atomics bounce buffer
+
+    if (unlikely(addr & 3)) {
+        riscv_trap(vm, TRAP_STORE_MISALIGN, 0);
+        return;
+    }
+
+    void* ptr = riscv_vma_translate_w(vm, addr, buff, sizeof(buff));
+    if (unlikely(ptr == NULL)) return;
+
+    switch (op) {
+        case RISCV_AMO_LR:
+            // Mark our reservation
+            atomic_store_uint32(&vm->lrsc, true);
+            vm->lrsc_cas = atomic_load_uint32_le(ptr);
+            riscv_write_reg(vm, rds, (int32_t)vm->lrsc_cas);
+            break;
+        case RISCV_AMO_SC:
+            // Invalidate all other reservations
+            riscv_invalidate_lrsc(vm);
+
+            // If our reservation is valid, perform a CAS
+            if (atomic_load_uint32(&vm->lrsc) && atomic_cas_uint32_le(ptr, vm->lrsc_cas, val)) {
+                riscv_write_reg(vm, rds, 0);
+            } else {
+                riscv_write_reg(vm, rds, 1);
+            }
+
+            // Invalidate this hart reservation
+            atomic_store_uint32(&vm->lrsc, false);
+            break;
+        case RISCV_AMO_SWAP:
+            riscv_write_reg(vm, rds, (int32_t)atomic_swap_uint32_le(ptr, val));
+            break;
+        case RISCV_AMO_ADD:
+            riscv_write_reg(vm, rds, (int32_t)atomic_add_uint32_le(ptr, val));
+            break;
+        case RISCV_AMO_XOR:
+            riscv_write_reg(vm, rds, (int32_t)atomic_xor_uint32_le(ptr, val));
+            break;
+        case RISCV_AMO_AND:
+            riscv_write_reg(vm, rds, (int32_t)atomic_and_uint32_le(ptr, val));
+            break;
+        case RISCV_AMO_OR:
+            riscv_write_reg(vm, rds, (int32_t)atomic_or_uint32_le(ptr, val));
+            break;
+        case RISCV_AMO_MIN:
+            riscv_write_reg(vm, rds, (int32_t)atomic_min_int32_le(ptr, val));
+            break;
+        case RISCV_AMO_MAX:
+            riscv_write_reg(vm, rds, (int32_t)atomic_max_int32_le(ptr, val));
+            break;
+        case RISCV_AMO_MINU:
+            riscv_write_reg(vm, rds, (int32_t)atomic_minu_uint32_le(ptr, val));
+            break;
+        case RISCV_AMO_MAXU:
+            riscv_write_reg(vm, rds, (int32_t)atomic_maxu_uint32_le(ptr, val));
+            break;
+        default:
+            riscv_illegal_insn(vm, insn);
+            break;
+    }
+
+    if (unlikely(ptr == buff)) {
+        riscv_mmu_vma_mmio_write(vm, addr, buff, sizeof(buff));
+    }
+}
+
+#ifdef RV64
+
+static forceinline void riscv_emulate_atomic_d(rvvm_hart_t *vm, const uint32_t insn)
+{
+    const uint32_t op = insn >> 27;
+    const regid_t rds = bit_cut(insn, 7, 5);
+    const regid_t rs1 = bit_cut(insn, 15, 5);
+    const regid_t rs2 = bit_cut(insn, 20, 5);
+    const xaddr_t addr = riscv_read_reg(vm, rs1);
+    const uint64_t val = riscv_read_reg(vm, rs2);
+    uint8_t buff[8]; // MMIO atomics bounce buffer
+
+    if (unlikely(addr & 7)) {
+        riscv_trap(vm, TRAP_STORE_MISALIGN, 0);
+        return;
+    }
+
+    void* ptr = riscv_vma_translate_w(vm, addr, buff, sizeof(buff));
+    if (unlikely(ptr == NULL)) return;
+
+    switch (op) {
+        case RISCV_AMO_LR:
+            // Mark our reservation
+            atomic_store_uint32(&vm->lrsc, true);
+            vm->lrsc_cas = atomic_load_uint64_le(ptr);
+            vm->registers[rds] = vm->lrsc_cas;
+            break;
+        case RISCV_AMO_SC:
+            // Invalidate all other reservations
+            riscv_invalidate_lrsc(vm);
+
+            // If our reservation is valid, perform a CAS
+            if (atomic_load_uint32(&vm->lrsc) && atomic_cas_uint64_le(ptr, vm->lrsc_cas, val)) {
+                riscv_write_reg(vm, rds, 0);
+            } else {
+                riscv_write_reg(vm, rds, 1);
+            }
+
+            // Invalidate this hart reservation
+            atomic_store_uint32(&vm->lrsc, false);
+            break;
+        case RISCV_AMO_SWAP:
+            vm->registers[rds] = atomic_swap_uint64_le(ptr, val);
+            break;
+        case RISCV_AMO_ADD:
+            vm->registers[rds] = atomic_add_uint64_le(ptr, val);
+            break;
+        case RISCV_AMO_XOR:
+            vm->registers[rds] = atomic_xor_uint64_le(ptr, val);
+            break;
+        case RISCV_AMO_AND:
+            vm->registers[rds] = atomic_and_uint64_le(ptr, val);
+            break;
+        case RISCV_AMO_OR:
+            vm->registers[rds] = atomic_or_uint64_le(ptr, val);
+            break;
+        case RISCV_AMO_MIN:
+            vm->registers[rds] = atomic_min_int64_le(ptr, val);
+            break;
+        case RISCV_AMO_MAX:
+            vm->registers[rds] = atomic_max_int64_le(ptr, val);
+            break;
+        case RISCV_AMO_MINU:
+            vm->registers[rds] = atomic_minu_uint64_le(ptr, val);
+            break;
+        case RISCV_AMO_MAXU:
+            vm->registers[rds] = atomic_maxu_uint64_le(ptr, val);
+            break;
+        default:
+            riscv_illegal_insn(vm, insn);
+            break;
+    }
+
+    if (unlikely(ptr == buff)) {
+        riscv_mmu_vma_mmio_write(vm, addr, buff, sizeof(buff));
+    }
+}
+
+#endif
+
+static forceinline void riscv_emulate_a_opc_amo(rvvm_hart_t* vm, const uint32_t insn)
+{
+    const uint32_t funct3 = bit_cut(insn, 12, 3);
+    switch (funct3) {
+        case 0x2:
+            riscv_emulate_atomic_w(vm, insn);
+            return;
+#ifdef RV64
+        case 0x3:
+            riscv_emulate_atomic_d(vm, insn);
+            return;
+#endif
+    }
+    riscv_illegal_insn(vm, insn);
+}
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/cpu/riscv_base.h b/app/src/main/java/libengine/RVVM/src/cpu/riscv_base.h
new file mode 100644
index 00000000..574fb910
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/cpu/riscv_base.h
@@ -0,0 +1,968 @@
+/*
+riscv_base.h - RISC-V Base Integer ISA interpreter
+Copyright (C) 2024  LekKit <github.com/LekKit>
+
+This Source Code Form is subject to the terms of the Mozilla Public
+License, v. 2.0. If a copy of the MPL was not distributed with this
+file, You can obtain one at https://mozilla.org/MPL/2.0/.
+
+Alternatively, the contents of this file may be used under the terms
+of the GNU General Public License as published by the Free Software
+Foundation, either version 3 of the License, or any later version.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef RISCV_BASE_H
+#define RISCV_BASE_H
+
+#include "../riscv_priv.h"
+#include "riscv_atomics.h"
+
+#ifdef USE_FPU
+#include "riscv_fpu.h"
+#endif
+
+// Base 5-bit opcodes in inst[6:2]
+#define RISCV_OPC_LOAD     0x0
+#define RISCV_OPC_LOAD_FP  0x1
+#define RISCV_OPC_MISC_MEM 0x3
+#define RISCV_OPC_OP_IMM   0x4
+#define RISCV_OPC_AUIPC    0x5
+#define RISCV_OPC_OP_IMM32 0x6
+#define RISCV_OPC_STORE    0x8
+#define RISCV_OPC_STORE_FP 0x9
+#define RISCV_OPC_AMO      0xB
+#define RISCV_OPC_OP       0xC
+#define RISCV_OPC_LUI      0xD
+#define RISCV_OPC_OP32     0xE
+#define RISCV_OPC_FMADD    0x10
+#define RISCV_OPC_FMSUB    0x11
+#define RISCV_OPC_FNMSUB   0x12
+#define RISCV_OPC_FNMADD   0x13
+#define RISCV_OPC_OP_FP    0x14
+#define RISCV_OPC_BRANCH   0x18
+#define RISCV_OPC_JALR     0x19
+#define RISCV_OPC_JAL      0x1B
+#define RISCV_OPC_SYSTEM   0x1C
+
+#ifdef RV64
+#define bit_clz(val) bit_clz64(val)
+#define bit_ctz(val) bit_ctz64(val)
+#define bit_popcnt(val) bit_popcnt64(val)
+#define bit_rotl(val, bits) bit_rotl64(val, bits)
+#define bit_rotr(val, bits) bit_rotr64(val, bits)
+#define bit_clmul(a, b) bit_clmul64(a, b)
+#define bit_clmulh(a, b) bit_clmulh64(a, b)
+#define bit_clmulr(a, b) bit_clmulr64(a, b)
+#else
+#define bit_clz(val) bit_clz32(val)
+#define bit_ctz(val) bit_ctz32(val)
+#define bit_popcnt(val) bit_popcnt32(val)
+#define bit_rotl(val, bits) bit_rotl32(val, bits)
+#define bit_rotr(val, bits) bit_rotr32(val, bits)
+#define bit_clmul(a, b) bit_clmul32(a, b)
+#define bit_clmulh(a, b) bit_clmulh32(a, b)
+#define bit_clmulr(a, b) bit_clmulr32(a, b)
+#endif
+
+static forceinline bitcnt_t decode_i_shamt(const uint32_t insn)
+{
+#ifdef RV64
+    return bit_cut(insn, 20, 6);
+#else
+    return bit_cut(insn, 20, 5);
+#endif
+}
+
+// TODO optimize?
+static forceinline bitcnt_t decode_i_shift_funct7(const uint32_t insn)
+{
+#ifdef RV64
+    return (insn >> 26) << 1;
+#else
+    return insn >> 25;
+#endif
+}
+
+static forceinline sxlen_t decode_i_branch_off(const uint32_t insn)
+{
+    const xlen_t imm = (bit_cut(insn, 31, 1) << 12)
+                     | (bit_cut(insn, 7, 1)  << 11)
+                     | (bit_cut(insn, 25, 6) << 5)
+                     | (bit_cut(insn, 8, 4)  << 1);
+    return sign_extend(imm, 13);
+}
+
+static forceinline sxlen_t decode_i_jal_off(const uint32_t insn)
+{
+    // May be replaced by translation table
+    const xlen_t  imm = (bit_cut(insn, 31, 1)  << 20)
+                      | (bit_cut(insn, 12, 8)  << 12)
+                      | (bit_cut(insn, 20, 1)  << 11)
+                      | (bit_cut(insn, 21, 10) << 1);
+    return sign_extend(imm, 21);
+}
+
+static forceinline void riscv_emulate_i_opc_load(rvvm_hart_t* vm, const uint32_t insn)
+{
+    const uint32_t funct3 = bit_cut(insn, 12, 3);
+    const regid_t rds = bit_cut(insn, 7, 5);
+    const regid_t rs1 = bit_cut(insn, 15, 5);
+    const sxlen_t offset = sign_extend(bit_cut(insn, 20, 12), 12);
+    const xlen_t  addr = riscv_read_reg(vm, rs1) + offset;
+    switch (funct3) {
+        case 0x0: // lb
+            rvjit_trace_lb(rds, rs1, offset, 4);
+            riscv_load_s8(vm, addr, rds);
+            return;
+        case 0x1: // lh
+            rvjit_trace_lh(rds, rs1, offset, 4);
+            riscv_load_s16(vm, addr, rds);
+            return;
+        case 0x2: // lw
+            rvjit_trace_lw(rds, rs1, offset, 4);
+            riscv_load_s32(vm, addr, rds);
+            return;
+#ifdef RV64
+        case 0x3: // ld
+            rvjit_trace_ld(rds, rs1, offset, 4);
+            riscv_load_u64(vm, addr, rds);
+            return;
+#endif
+        case 0x4: // lbu
+            rvjit_trace_lbu(rds, rs1, offset, 4);
+            riscv_load_u8(vm, addr, rds);
+            return;
+        case 0x5: // lhu
+            rvjit_trace_lhu(rds, rs1, offset, 4);
+            riscv_load_u16(vm, addr, rds);
+            return;
+#ifdef RV64
+        case 0x6: // lwu
+            rvjit_trace_lwu(rds, rs1, offset, 4);
+            riscv_load_u32(vm, addr, rds);
+            return;
+#endif
+    }
+    riscv_illegal_insn(vm, insn);
+}
+
+static forceinline void riscv_emulate_i_opc_imm(rvvm_hart_t* vm, const uint32_t insn)
+{
+    const uint32_t funct3 = bit_cut(insn, 12, 3);
+    const regid_t rds = bit_cut(insn, 7, 5);
+    const regid_t rs1 = bit_cut(insn, 15, 5);
+    const xlen_t imm = sign_extend(bit_cut(insn, 20, 12), 12);
+    const xlen_t src = riscv_read_reg(vm, rs1);
+    switch (funct3) {
+        case 0x0: // addi
+            rvjit_trace_addi(rds, rs1, imm, 4);
+            riscv_write_reg(vm, rds, src + imm);
+            return;
+        case 0x1: {
+            const bitcnt_t shamt = decode_i_shamt(insn);
+            switch (decode_i_shift_funct7(insn)) {
+                case 0x0: // slli
+                    rvjit_trace_slli(rds, rs1, shamt, 4);
+                    riscv_write_reg(vm, rds, src << shamt);
+                    return;
+                case 0x14: // bseti (Zbs)
+                    rvjit_trace_bseti(rds, rs1, shamt, 4);
+                    riscv_write_reg(vm, rds, src | (((xlen_t)1U) << shamt));
+                    return;
+                case 0x24: // bclri (Zbs)
+                    rvjit_trace_bclri(rds, rs1, shamt, 4);
+                    riscv_write_reg(vm, rds, src & ~(((xlen_t)1U) << shamt));
+                    return;
+                case 0x34: // binvi (Zbs)
+                    rvjit_trace_binvi(rds, rs1, shamt, 4);
+                    riscv_write_reg(vm, rds, src ^ (((xlen_t)1U) << shamt));
+                    return;
+                case 0x30:
+                    switch (shamt) {
+                        case 0x0: // clz (Zbb)
+                            // TODO: JIT
+                            riscv_write_reg(vm, rds, bit_clz(src));
+                            return;
+                        case 0x1: // ctz (Zbb)
+                            // TODO: JIT
+                            riscv_write_reg(vm, rds, bit_ctz(src));
+                            return;
+                        case 0x2: // cpop (Zbb)
+                            // TODO: JIT
+                            riscv_write_reg(vm, rds, bit_popcnt(src));
+                            return;
+                        case 0x4: // sext.b (Zbb)
+                            rvjit_trace_sext_b(rds, rs1, 4);
+                            riscv_write_reg(vm, rds, (int8_t)src);
+                            return;
+                        case 0x5: // sext.h (Zbb)
+                            rvjit_trace_sext_h(rds, rs1, 4);
+                            riscv_write_reg(vm, rds, (int16_t)src);
+                            return;
+                    }
+                    break;
+            }
+            break;
+        }
+        case 0x2: // slti
+            rvjit_trace_slti(rds, rs1, imm, 4);
+            riscv_write_reg(vm, rds, (((sxlen_t)src) < ((sxlen_t)imm)) ? 1 : 0);
+            return;
+        case 0x3: // sltiu
+            rvjit_trace_sltiu(rds, rs1, imm, 4);
+            riscv_write_reg(vm, rds, (src < imm) ? 1 : 0);
+            return;
+        case 0x4: // xori
+            rvjit_trace_xori(rds, rs1, imm, 4);
+            riscv_write_reg(vm, rds, src ^ imm);
+            return;
+        case 0x5: {
+            const bitcnt_t shamt = decode_i_shamt(insn);
+            switch (decode_i_shift_funct7(insn)) {
+                case 0x0: // srli
+                    rvjit_trace_srli(rds, rs1, shamt, 4);
+                    riscv_write_reg(vm, rds, src >> shamt);
+                    return;
+                case 0x20: // srai
+                    rvjit_trace_srai(rds, rs1, shamt, 4);
+                    riscv_write_reg(vm, rds, ((sxlen_t)src) >> shamt);
+                    return;
+                case 0x14:
+                    if (likely(shamt == 0x7)) { // orc.b (Zbb)
+                        // TODO: JIT
+                        riscv_write_reg(vm, rds, bit_orc_b(src));
+                        return;
+                    }
+                    break;
+                case 0x24: // bexti (Zbs)
+                    rvjit_trace_bexti(rds, rs1, shamt, 4);
+                    riscv_write_reg(vm, rds, (src >> shamt) & 1);
+                    return;
+                case 0x34:
+#ifdef RV64
+                    if (likely(shamt == 0x38)) { // rev8 (Zbb), RV64 encoding
+                        // TODO: JIT
+                        riscv_write_reg(vm, rds, byteswap_uint64(src));
+                        return;
+                    }
+#else
+                    if (likely(shamt == 0x18)) { // rev8 (Zbb), RV32 encoding
+                        // TODO: JIT
+                        riscv_write_reg(vm, rds, byteswap_uint32(src));
+                        return;
+                    }
+#endif
+                    break;
+                case 0x30: // rori (Zbb)
+                    rvjit_trace_rori(rds, rs1, shamt, 4);
+                    riscv_write_reg(vm, rds, bit_rotr(src, shamt));
+                    return;
+            }
+            break;
+        }
+        case 0x6: // ori
+            rvjit_trace_ori(rds, rs1, imm, 4);
+            riscv_write_reg(vm, rds, src | imm);
+            return;
+        case 0x7: // andi
+            rvjit_trace_andi(rds, rs1, imm, 4);
+            riscv_write_reg(vm, rds, src & imm);
+            return;
+    }
+    riscv_illegal_insn(vm, insn);
+}
+
+static forceinline void riscv_emulate_i_auipc(rvvm_hart_t* vm, const uint32_t insn)
+{
+    const regid_t rds = bit_cut(insn, 7, 5);
+    const xlen_t imm = sign_extend(insn & 0xFFFFF000, 32);
+    const xlen_t pc = riscv_read_reg(vm, REGISTER_PC);
+
+    rvjit_trace_auipc(rds, imm, 4);
+    riscv_write_reg(vm, rds, pc + imm);
+}
+
+#ifdef RV64
+
+static forceinline void riscv_emulate_i_opc_imm32(rvvm_hart_t* vm, const uint32_t insn)
+{
+    const uint32_t funct3 = bit_cut(insn, 12, 3);
+    const regid_t rds = bit_cut(insn, 7, 5);
+    const regid_t rs1 = bit_cut(insn, 15, 5);
+    const uint32_t src = riscv_read_reg(vm, rs1);
+    switch (funct3) {
+        case 0x0: { // addiw
+            const uint32_t imm = sign_extend(bit_cut(insn, 20, 12), 12);
+            rvjit_trace_addiw(rds, rs1, imm, 4);
+            vm->registers[rds] = (int32_t)(src + imm);
+            return;
+        }
+        case 0x1:
+            switch (insn >> 25) {
+                case 0x0: { // slliw
+                    const bitcnt_t shamt = bit_cut(insn, 20, 5);
+                    rvjit_trace_slliw(rds, rs1, shamt, 4);
+                    riscv_write_reg(vm, rds, (int32_t)(src << shamt));
+                    return;
+                }
+                case 0x4:
+                case 0x5: { // slli.uw
+                    const bitcnt_t shamt = bit_cut(insn, 20, 6);
+                    rvjit_trace_slli_uw(rds, rs1, shamt, 4);
+                    riscv_write_reg(vm, rds, ((xlen_t)src) << shamt);
+                    return;
+                }
+                case 0x30:
+                    switch (bit_cut(insn, 20, 5)) {
+                        case 0x0: // clzw (Zbb)
+                            // TODO: JIT
+                            riscv_write_reg(vm, rds, bit_clz32(src));
+                            return;
+                        case 0x1: // ctzw (Zbb)
+                            // TODO: JIT
+                            riscv_write_reg(vm, rds, bit_ctz32(src));
+                            return;
+                        case 0x2: // cpopw (Zbb)
+                            // TODO: JIT
+                            riscv_write_reg(vm, rds, bit_popcnt32(src));
+                            return;
+                    }
+                    break;
+            }
+            break;
+        case 0x5: {
+            const bitcnt_t shamt = bit_cut(insn, 20, 5);
+            switch (insn >> 25) {
+                case 0x0: // srli
+                    rvjit_trace_srliw(rds, rs1, shamt, 4);
+                    riscv_write_reg(vm, rds, (int32_t)(src >> shamt));
+                    return;
+                case 0x20: // srai
+                    rvjit_trace_sraiw(rds, rs1, shamt, 4);
+                    riscv_write_reg(vm, rds, ((int32_t)src) >> shamt);
+                    return;
+                case 0x30: // roriw (Zbb)
+                    rvjit_trace_roriw(rds, rs1, shamt, 4);
+                    riscv_write_reg(vm, rds, (int32_t)bit_rotr32(src, shamt));
+                    return;
+            }
+            break;
+        }
+    }
+    riscv_illegal_insn(vm, insn);
+}
+
+#endif
+
+static forceinline void riscv_emulate_i_opc_store(rvvm_hart_t* vm, const uint32_t insn)
+{
+    const uint32_t funct3 = bit_cut(insn, 12, 3);
+    const regid_t rs1 = bit_cut(insn, 15, 5);
+    const regid_t rs2 = bit_cut(insn, 20, 5);
+    const sxlen_t offset = sign_extend(bit_cut(insn, 7, 5) | (bit_cut(insn, 25, 7) << 5), 12);
+    const xlen_t addr = riscv_read_reg(vm, rs1) + offset;
+    switch (funct3) {
+        case 0x0: // sb
+            rvjit_trace_sb(rs2, rs1, offset, 4);
+            riscv_store_u8(vm, addr, rs2);
+            return;
+        case 0x1: // sh
+            rvjit_trace_sh(rs2, rs1, offset, 4);
+            riscv_store_u16(vm, addr, rs2);
+            return;
+        case 0x2: // sw
+            rvjit_trace_sw(rs2, rs1, offset, 4);
+            riscv_store_u32(vm, addr, rs2);
+            return;
+#ifdef RV64
+        case 0x3: // sd
+            rvjit_trace_sd(rs2, rs1, offset, 4);
+            riscv_store_u64(vm, addr, rs2);
+            return;
+#endif
+    }
+    riscv_illegal_insn(vm, insn);
+}
+
+static forceinline void riscv_emulate_i_opc_op(rvvm_hart_t* vm, const uint32_t insn)
+{
+    const uint32_t funct3 = bit_cut(insn, 12, 3);
+    const uint32_t funct7 = insn >> 25;
+    const regid_t rds = bit_cut(insn, 7, 5);
+    const regid_t rs1 = bit_cut(insn, 15, 5);
+    const regid_t rs2 = bit_cut(insn, 20, 5);
+    const xlen_t reg1 = riscv_read_reg(vm, rs1);
+    const xlen_t reg2 = riscv_read_reg(vm, rs2);
+    switch (funct3) {
+        case 0x0:
+            switch (funct7) {
+                case 0x0: // add
+                    rvjit_trace_add(rds, rs1, rs2, 4);
+                    riscv_write_reg(vm, rds, reg1 + reg2);
+                    return;
+                case 0x20: // sub
+                    rvjit_trace_sub(rds, rs1, rs2, 4);
+                    riscv_write_reg(vm, rds, reg1 - reg2);
+                    return;
+                case 0x1: // mul
+                    rvjit_trace_mul(rds, rs1, rs2, 4);
+                    riscv_write_reg(vm, rds, reg1 * reg2);
+                    return;
+            }
+            break;
+        case 0x1:
+            switch (funct7) {
+                case 0x0: // sll
+                    rvjit_trace_sll(rds, rs1, rs2, 4);
+                    riscv_write_reg(vm, rds, reg1 << (reg2 & bit_mask(SHAMT_BITS)));
+                    return;
+                case 0x1: // mulh
+                    rvjit_trace_mulh(rds, rs1, rs2, 4);
+#ifdef RV64
+                    riscv_write_reg(vm, rds, mulh_uint64(reg1, reg2));
+#else
+                    riscv_write_reg(vm, rds, ((int64_t)(sxlen_t)reg1 * (int64_t)(sxlen_t)reg2) >> 32);
+#endif
+                    return;
+                case 0x5: // clmul (Zbc)
+                    riscv_write_reg(vm, rds, bit_clmul(reg1, reg2));
+                    return;
+                case 0x14: // bset (Zbs)
+                    rvjit_trace_bset(rds, rs1, rs2, 4);
+                    riscv_write_reg(vm, rds, reg1 | (((xlen_t)1U) << (reg2 & bit_mask(SHAMT_BITS))));
+                    return;
+                case 0x24: // bclr (Zbs)
+                    rvjit_trace_bclr(rds, rs1, rs2, 4);
+                    riscv_write_reg(vm, rds, reg1 & ~(((xlen_t)1U) << (reg2 & bit_mask(SHAMT_BITS))));
+                    return;
+                case 0x34: // binv (Zbs)
+                    rvjit_trace_binv(rds, rs1, rs2, 4);
+                    riscv_write_reg(vm, rds, reg1 ^ (((xlen_t)1U) << (reg2 & bit_mask(SHAMT_BITS))));
+                    return;
+                case 0x30: // rol (Zbb)
+                    rvjit_trace_rol(rds, rs1, rs2, 4);
+                    riscv_write_reg(vm, rds, bit_rotl(reg1, reg2 & bit_mask(SHAMT_BITS)));
+                    return;
+            }
+            break;
+        case 0x2:
+            switch (funct7) {
+                case 0x0: // slt
+                    rvjit_trace_slt(rds, rs1, rs2, 4);
+                    riscv_write_reg(vm, rds, (((sxlen_t)reg1) < ((sxlen_t)reg2)) ? 1 : 0);
+                    return;
+                case 0x1: // mulhsu
+                    rvjit_trace_mulhsu(rds, rs1, rs2, 4);
+#ifdef RV64
+                    riscv_write_reg(vm, rds, mulhsu_uint64(reg1, reg2));
+#else
+                    riscv_write_reg(vm, rds, ((int64_t)(sxlen_t)reg1 * (uint64_t)reg2) >> 32);
+#endif
+                    return;
+                case 0x5: // clmulr (Zbc)
+                    riscv_write_reg(vm, rds, bit_clmulr(reg1, reg2));
+                    return;
+                case 0x10: // sh1add (Zba)
+                    rvjit_trace_shadd(rds, rs1, rs2, 1, 4);
+                    riscv_write_reg(vm, rds, reg2 + (reg1 << 1));
+                    return;
+            }
+            break;
+        case 0x3:
+            switch (funct7) {
+                case 0x0: // sltu
+                    rvjit_trace_sltu(rds, rs1, rs2, 4);
+                    riscv_write_reg(vm, rds, (reg1 < reg2) ? 1 : 0);
+                    return;
+                case 0x1: // mulhu
+                    rvjit_trace_mulhu(rds, rs1, rs2, 4);
+#ifdef RV64
+                    riscv_write_reg(vm, rds, mulhu_uint64(reg1, reg2));
+#else
+                    riscv_write_reg(vm, rds, ((uint64_t)reg1 * (uint64_t)reg2) >> 32);
+#endif
+                    return;
+                case 0x5: // clmulh (Zbc)
+                    riscv_write_reg(vm, rds, bit_clmulh(reg1, reg2));
+                    return;
+            }
+            break;
+        case 0x4:
+            switch (funct7) {
+                case 0x0: // xor
+                    rvjit_trace_xor(rds, rs1, rs2, 4);
+                    riscv_write_reg(vm, rds, reg1 ^ reg2);
+                    return;
+                case 0x1: { // div
+                    sxlen_t result = -1;
+                    rvjit_trace_div(rds, rs1, rs2, 4);
+                    if ((sxlen_t)reg1 == DIV_OVERFLOW_RS1 && (sxlen_t)reg2 == -1) {
+                        // overflow
+                        result = DIV_OVERFLOW_RS1;
+                    } else if (reg2 != 0) {
+                        // division by zero check (we already setup result var for error)
+                        result = (sxlen_t)reg1 / (sxlen_t)reg2;
+                    }
+                    riscv_write_reg(vm, rds, result);
+                    return;
+                }
+                case 0x10: // sh2add (Zba)
+                    rvjit_trace_shadd(rds, rs1, rs2, 2, 4);
+                    riscv_write_reg(vm, rds, reg2 + (reg1 << 2));
+                    return;
+                case 0x20: // xnor (Zbb)
+                    rvjit_trace_xnor(rds, rs1, rs2, 4);
+                    riscv_write_reg(vm, rds, reg1 ^ ~reg2);
+                    return;
+#ifndef RV64
+                case 0x4: // zext.h (Zbb), RV32 encoding
+                    if (likely(!rs2)) {
+                        rvjit_trace_andi(rds, rs1, 0xFFFF, 4);
+                        riscv_write_reg(vm, rds, (uint16_t)reg1);
+                        return;
+                    }
+                    break;
+#endif
+                case 0x5: // min (Zbb)
+                    rvjit_trace_min(rds, rs1, rs2, 4);
+                    riscv_write_reg(vm, rds, EVAL_MIN((sxlen_t)reg1, (sxlen_t)reg2));
+                    return;
+            }
+            break;
+        case 0x5:
+            switch (funct7) {
+                case 0x0: // srl
+                    rvjit_trace_srl(rds, rs1, rs2, 4);
+                    riscv_write_reg(vm, rds, reg1 >> (reg2 & bit_mask(SHAMT_BITS)));
+                    return;
+                case 0x20: // sra
+                    rvjit_trace_sra(rds, rs1, rs2, 4);
+                    riscv_write_reg(vm, rds, ((sxlen_t)reg1) >> (reg2 & bit_mask(SHAMT_BITS)));
+                    return;
+                case 0x1: { // divu
+                    xlen_t result = (sxlen_t)-1;
+                    rvjit_trace_divu(rds, rs1, rs2, 4);
+                    // division by zero check (we already setup result var for error)
+                    if (reg2 != 0) {
+                        result = reg1 / reg2;
+                    }
+                    riscv_write_reg(vm, rds, result);
+                    return;
+                }
+                case 0x24: // bext (Zbs)
+                    rvjit_trace_bext(rds, rs1, rs2, 4);
+                    riscv_write_reg(vm, rds, (reg1 >> (reg2 & bit_mask(SHAMT_BITS))) & 1);
+                    return;
+                case 0x5: // minu (Zbb)
+                    rvjit_trace_minu(rds, rs1, rs2, 4);
+                    riscv_write_reg(vm, rds, EVAL_MIN(reg1, reg2));
+                    return;
+                case 0x30: // ror (Zbb)
+                    rvjit_trace_ror(rds, rs1, rs2, 4);
+                    riscv_write_reg(vm, rds, bit_rotr(reg1, reg2 & bit_mask(SHAMT_BITS)));
+                    return;
+                case 0x7: // czero.eqz (Zicond)
+                    // TODO: JIT
+                    riscv_write_reg(vm, rds, reg2 ? reg1 : 0);
+                    return;
+            }
+            break;
+        case 0x6:
+            switch (funct7) {
+                case 0x0: // or
+                    rvjit_trace_or(rds, rs1, rs2, 4);
+                    riscv_write_reg(vm, rds, reg1 | reg2);
+                    return;
+                case 0x1: { // rem
+                    sxlen_t result = reg1;
+                    rvjit_trace_rem(rds, rs1, rs2, 4);
+                    // overflow
+                    if ((sxlen_t)reg1 == DIV_OVERFLOW_RS1 && (sxlen_t)reg2 == -1) {
+                        result = 0;
+                    // division by zero check (we already setup result var for error)
+                    } else if (reg2 != 0) {
+                        result = (sxlen_t)reg1 % (sxlen_t)reg2;
+                    }
+                    riscv_write_reg(vm, rds, result);
+                    return;
+                }
+                case 0x10: // sh3add (Zba)
+                    rvjit_trace_shadd(rds, rs1, rs2, 3, 4);
+                    riscv_write_reg(vm, rds, reg2 + (reg1 << 3));
+                    return;
+                case 0x20: // orn (Zbb)
+                    rvjit_trace_orn(rds, rs1, rs2, 4);
+                    riscv_write_reg(vm, rds, reg1 | ~reg2);
+                    return;
+                case 0x5: // max (Zbb)
+                    rvjit_trace_max(rds, rs1, rs2, 4);
+                    riscv_write_reg(vm, rds, EVAL_MAX((sxlen_t)reg1, (sxlen_t)reg2));
+                    return;
+            }
+            break;
+        case 0x7:
+            switch (funct7) {
+                case 0x0: // and
+                    rvjit_trace_and(rds, rs1, rs2, 4);
+                    riscv_write_reg(vm, rds, reg1 & reg2);
+                    return;
+                case 0x1: { // remu
+                    xlen_t result = reg1;
+                    rvjit_trace_remu(rds, rs1, rs2, 4);
+                    // division by zero check (we already setup result var for error)
+                    if (reg2 != 0) {
+                        result = reg1 % reg2;
+                    }
+                    riscv_write_reg(vm, rds, result);
+                    return;
+                }
+                case 0x20: // andn (Zbb)
+                    rvjit_trace_andn(rds, rs1, rs2, 4);
+                    riscv_write_reg(vm, rds, reg1 & ~reg2);
+                    return;
+                case 0x5: // maxu (Zbb)
+                    rvjit_trace_maxu(rds, rs1, rs2, 4);
+                    riscv_write_reg(vm, rds, EVAL_MAX(reg1, reg2));
+                    return;
+                case 0x7: // czero.nez (Zicond)
+                    // TODO: JIT
+                    riscv_write_reg(vm, rds, reg2 ? 0 : reg1);
+                    return;
+            }
+            break;
+    }
+    riscv_illegal_insn(vm, insn);
+}
+
+static forceinline void riscv_emulate_i_lui(rvvm_hart_t* vm, const uint32_t insn)
+{
+    const regid_t rds = bit_cut(insn, 7, 5);
+    const xlen_t imm = sign_extend(insn & 0xFFFFF000, 32);
+
+    rvjit_trace_li(rds, imm, 4);
+    riscv_write_reg(vm, rds, imm);
+}
+
+#ifdef RV64
+
+static forceinline void riscv_emulate_i_opc_op32(rvvm_hart_t* vm, const uint32_t insn)
+{
+    const uint32_t funct3 = bit_cut(insn, 12, 3);
+    const uint32_t funct7 = insn >> 25;
+    const regid_t rds = bit_cut(insn, 7, 5);
+    const regid_t rs1 = bit_cut(insn, 15, 5);
+    const regid_t rs2 = bit_cut(insn, 20, 5);
+    const uint32_t reg1 = riscv_read_reg(vm, rs1);
+    const uint32_t reg2 = riscv_read_reg(vm, rs2);
+    switch (funct3) {
+        case 0x0:
+            switch (funct7) {
+                case 0x0: // addw
+                    rvjit_trace_addw(rds, rs1, rs2, 4);
+                    riscv_write_reg(vm, rds, (int32_t)(reg1 + reg2));
+                    return;
+                case 0x20: // subw
+                    rvjit_trace_subw(rds, rs1, rs2, 4);
+                    riscv_write_reg(vm, rds, (int32_t)(reg1 - reg2));
+                    return;
+                case 0x1: // mulw
+                    rvjit_trace_mulw(rds, rs1, rs2, 4);
+                    riscv_write_reg(vm, rds, (int32_t)(reg1 * reg2));
+                    return;
+                case 0x4: // add.uw (Zba)
+                    rvjit_trace_shadd_uw(rds, rs1, rs2, 0, 4);
+                    riscv_write_reg(vm, rds, riscv_read_reg(vm, rs2) + ((xlen_t)reg1));
+                    return;
+            }
+            break;
+        case 0x1:
+            switch (funct7) {
+                case 0x0: // sllw
+                    rvjit_trace_sllw(rds, rs1, rs2, 4);
+                    riscv_write_reg(vm, rds, (int32_t)(reg1 << (reg2 & 0x1F)));
+                    return;
+                case 0x30: // rolw (Zbb)
+                    rvjit_trace_rolw(rds, rs1, rs2, 4);
+                    riscv_write_reg(vm, rds, (int32_t)bit_rotl32(reg1, reg2 & bit_mask(SHAMT_BITS)));
+                    return;
+            }
+            break;
+        case 0x2:
+            switch (funct7) {
+                case 0x10: // sh1add.uw (Zba)
+                    rvjit_trace_shadd_uw(rds, rs1, rs2, 1, 4);
+                    riscv_write_reg(vm, rds, riscv_read_reg(vm, rs2) + (((xlen_t)reg1) << 1));
+                    return;
+            }
+            break;
+        case 0x4:
+            switch (funct7) {
+                case 0x1: { // divw
+                    int32_t result = -1;
+                    rvjit_trace_divw(rds, rs1, rs2, 4);
+                    // overflow
+                    if ((int32_t)reg1 == ((int32_t)0x80000000U) && (int32_t)reg2 == -1) {
+                        result = ((int32_t)0x80000000U);
+                    // division by zero check (we already setup result var for error)
+                    } else if (reg2 != 0) {
+                        result = (int32_t)reg1 / (int32_t)reg2;
+                    }
+                    riscv_write_reg(vm, rds, result);
+                    return;
+                }
+                case 0x10: // sh2add.uw (Zba)
+                    rvjit_trace_shadd_uw(rds, rs1, rs2, 2, 4);
+                    riscv_write_reg(vm, rds, riscv_read_reg(vm, rs2) + (((xlen_t)reg1) << 2));
+                    return;
+#ifdef RV64
+                case 0x4: // zext.h (Zbb), RV64 encoding
+                    if (likely(!rs2)) {
+                        rvjit_trace_andi(rds, rs1, 0xFFFF, 4);
+                        riscv_write_reg(vm, rds, (uint16_t)reg1);
+                        return;
+                    }
+                    break;
+#endif
+            }
+            break;
+        case 0x5:
+            switch (funct7) {
+                case 0x0: // srlw
+                    rvjit_trace_srlw(rds, rs1, rs2, 4);
+                    riscv_write_reg(vm, rds, (int32_t)(reg1 >> (reg2 & 0x1F)));
+                    return;
+                case 0x20: // sraw
+                    rvjit_trace_sraw(rds, rs1, rs2, 4);
+                    riscv_write_reg(vm, rds, (int32_t)(((int32_t)reg1) >> (reg2 & 0x1F)));
+                    return;
+                case 0x1: { // divuw
+                    uint32_t result = -1;
+                    rvjit_trace_divuw(rds, rs1, rs2, 4);
+                    // overflow
+                    if (reg2 != 0) {
+                        result = reg1 / reg2;
+                    }
+                    riscv_write_reg(vm, rds, (int32_t)result);
+                    return;
+                }
+                case 0x30: // rorw (Zbb)
+                    rvjit_trace_rorw(rds, rs1, rs2, 4);
+                    riscv_write_reg(vm, rds, (int32_t)bit_rotr32(reg1, reg2 & bit_mask(SHAMT_BITS)));
+                    return;
+            }
+            break;
+        case 0x6:
+            switch (funct7) {
+                case 0x1: { // remw
+                    int32_t result = reg1;
+                    rvjit_trace_remw(rds, rs1, rs2, 4);
+                    // overflow
+                    if ((int32_t)reg1 == ((int32_t)0x80000000U) && (int32_t)reg2 == -1) {
+                        result = 0;
+                    // division by zero check (we already setup result var for error)
+                    } else if (reg2 != 0) {
+                        result = (int32_t)reg1 % (int32_t)reg2;
+                    }
+                    riscv_write_reg(vm, rds, result);
+                    return;
+                }
+                case 0x10: // sh3add.uw (Zba)
+                    rvjit_trace_shadd_uw(rds, rs1, rs2, 3, 4);
+                    riscv_write_reg(vm, rds, riscv_read_reg(vm, rs2) + (((xlen_t)reg1) << 3));
+                    return;
+            }
+            break;
+        case 0x7:
+            switch (funct7) {
+                case 0x1: { // remuw
+                    uint32_t result = reg1;
+                    rvjit_trace_remuw(rds, rs1, rs2, 4);
+                    // division by zero check (we already setup result var for error)
+                    if (reg2 != 0) {
+                        result = reg1 % reg2;
+                    }
+                    riscv_write_reg(vm, rds, (int32_t)result);
+                    return;
+                }
+            }
+            break;
+    }
+    riscv_illegal_insn(vm, insn);
+}
+
+#endif
+
+static forceinline void riscv_emulate_i_opc_branch(rvvm_hart_t* vm, const uint32_t insn)
+{
+    const uint32_t funct3 = bit_cut(insn, 12, 3);
+    const regid_t rs1 = bit_cut(insn, 15, 5);
+    const regid_t rs2 = bit_cut(insn, 20, 5);
+    const sxlen_t offset = decode_i_branch_off(insn);
+    switch (funct3) {
+        case 0x0: // beq
+            if (riscv_read_reg(vm, rs1) == riscv_read_reg(vm, rs2)) {
+                const xlen_t pc = riscv_read_reg(vm, REGISTER_PC);
+                rvjit_trace_beq(rs1, rs2, offset, 4, 4);
+                riscv_write_reg(vm, REGISTER_PC, pc + offset - 4);
+            } else {
+                rvjit_trace_bne(rs1, rs2, 4, offset, 4);
+            }
+            return;
+        case 0x1: // bne
+            if (riscv_read_reg(vm, rs1) != riscv_read_reg(vm, rs2)) {
+                const xlen_t pc = riscv_read_reg(vm, REGISTER_PC);
+                rvjit_trace_bne(rs1, rs2, offset, 4, 4);
+                riscv_write_reg(vm, REGISTER_PC, pc + offset - 4);
+            } else {
+                rvjit_trace_beq(rs1, rs2, 4, offset, 4);
+            }
+            return;
+        case 0x4: // blt
+            if (riscv_read_reg_s(vm, rs1) < riscv_read_reg_s(vm, rs2)) {
+                const xlen_t pc = riscv_read_reg(vm, REGISTER_PC);
+                rvjit_trace_blt(rs1, rs2, offset, 4, 4);
+                riscv_write_reg(vm, REGISTER_PC, pc + offset - 4);
+            } else {
+                rvjit_trace_bge(rs1, rs2, 4, offset, 4);
+            }
+            return;
+        case 0x5: // bge
+            if (riscv_read_reg_s(vm, rs1) >= riscv_read_reg_s(vm, rs2)) {
+                const xlen_t pc = riscv_read_reg(vm, REGISTER_PC);
+                rvjit_trace_bge(rs1, rs2, offset, 4, 4);
+                riscv_write_reg(vm, REGISTER_PC, pc + offset - 4);
+            } else {
+                rvjit_trace_blt(rs1, rs2, 4, offset, 4);
+            }
+            return;
+        case 0x6: // bltu
+            if (riscv_read_reg(vm, rs1) < riscv_read_reg(vm, rs2)) {
+                const xlen_t pc = riscv_read_reg(vm, REGISTER_PC);
+                rvjit_trace_bltu(rs1, rs2, offset, 4, 4);
+                riscv_write_reg(vm, REGISTER_PC, pc + offset - 4);
+            } else {
+                rvjit_trace_bgeu(rs1, rs2, 4, offset, 4);
+            }
+            return;
+        case 0x7: // bgeu
+            if (riscv_read_reg(vm, rs1) >= riscv_read_reg(vm, rs2)) {
+                const xlen_t pc = riscv_read_reg(vm, REGISTER_PC);
+                rvjit_trace_bgeu(rs1, rs2, offset, 4, 4);
+                riscv_write_reg(vm, REGISTER_PC, pc + offset - 4);
+            } else {
+                rvjit_trace_bltu(rs1, rs2, 4, offset, 4);
+            }
+            return;
+    }
+    riscv_illegal_insn(vm, insn);
+}
+
+static forceinline void riscv_emulate_i_jalr(rvvm_hart_t* vm, const uint32_t insn)
+{
+    const regid_t rds = bit_cut(insn, 7, 5);
+    const regid_t rs1 = bit_cut(insn, 15, 5);
+    const sxlen_t offset = sign_extend(bit_cut(insn, 20, 12), 12);
+    const xlen_t pc = riscv_read_reg(vm, REGISTER_PC);
+    const xlen_t jmp_addr = riscv_read_reg(vm, rs1);
+
+    rvjit_trace_jalr(rds, rs1, offset, 4);
+    riscv_write_reg(vm, rds, pc + 4);
+    riscv_write_reg(vm, REGISTER_PC, ((jmp_addr + offset)&(~(xlen_t)1)) - 4);
+}
+
+static forceinline void riscv_emulate_i_jal(rvvm_hart_t* vm, const uint32_t insn)
+{
+    const regid_t rds = bit_cut(insn, 7, 5);
+    const sxlen_t offset = decode_i_jal_off(insn);
+    const xlen_t pc = riscv_read_reg(vm, REGISTER_PC);
+
+    rvjit_trace_jal(rds, offset, 4);
+    riscv_write_reg(vm, rds, pc + 4);
+    riscv_write_reg(vm, REGISTER_PC, pc + offset - 4);
+}
+
+static forceinline void riscv_emulate_i(rvvm_hart_t* vm, const uint32_t insn)
+{
+    const uint32_t op = bit_cut(insn, 2, 5);
+    switch (op) {
+        case RISCV_OPC_LOAD:
+            riscv_emulate_i_opc_load(vm, insn);
+            return;
+#ifdef USE_FPU
+        case RISCV_OPC_LOAD_FP:
+            riscv_emulate_f_opc_load(vm, insn);
+            return;
+#endif
+        case RISCV_OPC_MISC_MEM:
+            riscv_emulate_opc_misc_mem(vm, insn);
+            return;
+        case RISCV_OPC_OP_IMM:
+            riscv_emulate_i_opc_imm(vm, insn);
+            return;
+        case RISCV_OPC_AUIPC:
+            riscv_emulate_i_auipc(vm, insn);
+            return;
+#ifdef RV64
+        case RISCV_OPC_OP_IMM32:
+            riscv_emulate_i_opc_imm32(vm, insn);
+            return;
+#endif
+        case RISCV_OPC_STORE:
+            riscv_emulate_i_opc_store(vm, insn);
+            return;
+#ifdef USE_FPU
+        case RISCV_OPC_STORE_FP:
+            riscv_emulate_f_opc_store(vm, insn);
+            return;
+#endif
+        case RISCV_OPC_AMO:
+            riscv_emulate_a_opc_amo(vm, insn);
+            return;
+        case RISCV_OPC_OP:
+            riscv_emulate_i_opc_op(vm, insn);
+            return;
+        case RISCV_OPC_LUI:
+            riscv_emulate_i_lui(vm, insn);
+            return;
+#ifdef RV64
+        case RISCV_OPC_OP32:
+            riscv_emulate_i_opc_op32(vm, insn);
+            return;
+#endif
+#ifdef USE_FPU
+        case RISCV_OPC_FMADD:
+            riscv_emulate_f_fmadd(vm, insn);
+            return;
+        case RISCV_OPC_FMSUB:
+            riscv_emulate_f_fmsub(vm, insn);
+            return;
+        case RISCV_OPC_FNMSUB:
+            riscv_emulate_f_fnmsub(vm, insn);
+            return;
+        case RISCV_OPC_FNMADD:
+            riscv_emulate_f_fnmadd(vm, insn);
+            return;
+        case RISCV_OPC_OP_FP:
+            riscv_emulate_f_opc_op(vm, insn);
+            return;
+#endif
+        case RISCV_OPC_BRANCH:
+            riscv_emulate_i_opc_branch(vm, insn);
+            return;
+        case RISCV_OPC_JALR:
+            riscv_emulate_i_jalr(vm, insn);
+            return;
+        case RISCV_OPC_JAL:
+            riscv_emulate_i_jal(vm, insn);
+            return;
+        case RISCV_OPC_SYSTEM:
+            riscv_emulate_opc_system(vm, insn);
+            return;
+    }
+    riscv_illegal_insn(vm, insn);
+}
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/cpu/riscv_compressed.h b/app/src/main/java/libengine/RVVM/src/cpu/riscv_compressed.h
new file mode 100644
index 00000000..a1bca27d
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/cpu/riscv_compressed.h
@@ -0,0 +1,612 @@
+/*
+riscv_compressed.h - RISC-V Compressed ISA interpreter
+Copyright (C) 2024  LekKit <github.com/LekKit>
+
+This Source Code Form is subject to the terms of the Mozilla Public
+License, v. 2.0. If a copy of the MPL was not distributed with this
+file, You can obtain one at https://mozilla.org/MPL/2.0/.
+
+Alternatively, the contents of this file may be used under the terms
+of the GNU General Public License as published by the Free Software
+Foundation, either version 3 of the License, or any later version.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef RISCV_COMPRESSED_H
+#define RISCV_COMPRESSED_H
+
+// Provides entry point to riscv_emulate_i()
+#include "riscv_base.h"
+
+static forceinline xlen_t decode_c_addi4spn_imm(const uint16_t insn)
+{
+    return (bit_cut(insn, 6, 1)  << 2)
+         | (bit_cut(insn, 5, 1)  << 3)
+         | (bit_cut(insn, 11, 2) << 4)
+         | (bit_cut(insn, 7, 4)  << 6);
+}
+
+static forceinline sxlen_t decode_c_jal_imm(const uint16_t insn)
+{
+    const xlen_t imm = (bit_cut(insn, 3, 3)  << 1)
+                     | (bit_cut(insn, 11, 1) << 4)
+                     | (bit_cut(insn, 2, 1)  << 5)
+                     | (bit_cut(insn, 7, 1)  << 6)
+                     | (bit_cut(insn, 6, 1)  << 7)
+                     | (bit_cut(insn, 9, 2)  << 8)
+                     | (bit_cut(insn, 8, 1)  << 10)
+                     | (bit_cut(insn, 12, 1) << 11);
+    return sign_extend(imm, 12);
+}
+
+static forceinline xlen_t decode_c_ld_off(const uint16_t insn)
+{
+    return (bit_cut(insn, 10, 3) << 3)
+         | (bit_cut(insn, 5, 2)  << 6);
+}
+
+static forceinline xlen_t decode_c_lw_off(const uint16_t insn)
+{
+    return (bit_cut(insn, 6, 1)  << 2)
+         | (bit_cut(insn, 10, 3) << 3)
+         | (bit_cut(insn, 5, 1)  << 6);
+}
+
+static forceinline xlen_t decode_c_ldsp_off(const uint16_t insn)
+{
+    return (bit_cut(insn, 5, 2)  << 3)
+         | (bit_cut(insn, 12, 1) << 5)
+         | (bit_cut(insn, 2, 3)  << 6);
+}
+
+static forceinline xlen_t decode_c_lwsp_off(const uint16_t insn)
+{
+    return (bit_cut(insn, 4, 3)  << 2)
+         | (bit_cut(insn, 12, 1) << 5)
+         | (bit_cut(insn, 2, 2)  << 6);
+}
+
+static forceinline xlen_t decode_c_sdsp_off(const uint16_t insn)
+{
+    return (bit_cut(insn, 10, 3) << 3)
+         | (bit_cut(insn, 7, 3)  << 6);
+}
+
+static forceinline xlen_t decode_c_swsp_off(const uint16_t insn)
+{
+    return (bit_cut(insn, 9, 4) << 2)
+         | (bit_cut(insn, 7, 2) << 6);
+}
+
+static forceinline sxlen_t decode_c_alu_imm(const uint16_t insn)
+{
+    return sign_extend((bit_cut(insn, 12, 1) << 5)
+                     | (bit_cut(insn, 2, 5)), 6);
+}
+
+static forceinline sxlen_t decode_c_addi16sp_off(const uint16_t insn)
+{
+    return sign_extend((bit_cut(insn, 6, 1)  << 4)
+                     | (bit_cut(insn, 2, 1)  << 5)
+                     | (bit_cut(insn, 5, 1)  << 6)
+                     | (bit_cut(insn, 3, 2)  << 7)
+                     | (bit_cut(insn, 12, 1) << 9), 10);
+}
+
+static forceinline sxlen_t decode_c_lui_imm(const uint16_t insn)
+{
+    return sign_extend((bit_cut(insn, 2, 5)  << 12)
+                     | (bit_cut(insn, 12, 1) << 17), 18);
+}
+
+static forceinline sxlen_t decode_c_branch_imm(const uint16_t insn)
+{
+    const xlen_t imm = (bit_cut(insn, 3, 2)  << 1)
+                     | (bit_cut(insn, 10, 2) << 3)
+                     | (bit_cut(insn, 2, 1)  << 5)
+                     | (bit_cut(insn, 5, 2)  << 6)
+                     | (bit_cut(insn, 12, 1) << 8);
+    return sign_extend(imm, 9);
+}
+
+static forceinline bitcnt_t decode_c_shamt(const uint16_t insn)
+{
+#ifdef RV64
+    return bit_cut(insn, 2, 5)
+        | (bit_cut(insn, 12, 1) << 5);
+#else
+    return bit_cut(insn, 2, 5);
+#endif
+}
+
+static forceinline void riscv_emulate_c_c0(rvvm_hart_t* vm, const uint16_t insn)
+{
+    const regid_t rds = bit_cut(insn, 2, 3) + 8;
+    const regid_t rs1 = bit_cut(insn, 7, 3) + 8;
+    switch (insn >> 13) {
+        case 0x0: // c.addi4spn
+            if (likely(insn)) {
+                const xlen_t imm = decode_c_addi4spn_imm(insn);
+                const xlen_t sp = riscv_read_reg(vm, REGISTER_X2);
+                rvjit_trace_addi(rds, REGISTER_X2, imm, 2);
+                riscv_write_reg(vm, rds, sp + imm);
+                return;
+            }
+            break;
+#ifdef USE_FPU
+        case 0x1:
+            if (likely(fpu_is_enabled(vm))) { // c.fld
+                const xlen_t offset = decode_c_ld_off(insn);
+                const xlen_t addr = riscv_read_reg(vm, rs1) + offset;
+                riscv_load_double(vm, addr, rds);
+                return;
+            }
+            break;
+#endif
+        case 0x2: { // c.lw
+            const xlen_t offset = decode_c_lw_off(insn);
+            const xlen_t addr = riscv_read_reg(vm, rs1) + offset;
+            rvjit_trace_lw(rds, rs1, offset, 2);
+            riscv_load_s32(vm, addr, rds);
+            return;
+        }
+#if defined(USE_FPU) && !defined(RV64)
+        case 0x3:
+            if (likely(fpu_is_enabled(vm))) { // c.flw (RV32)
+                const xlen_t offset = decode_c_lw_off(insn);
+                const xlen_t addr = riscv_read_reg(vm, rs1) + offset;
+                riscv_load_float(vm, addr, rds);
+                return;
+            }
+            break;
+#endif
+#ifdef RV64
+        case 0x3: { // c.ld (RV64)
+            const xlen_t offset = decode_c_ld_off(insn);
+            const xlen_t addr = riscv_read_reg(vm, rs1) + offset;
+            rvjit_trace_ld(rds, rs1, offset, 2);
+            riscv_load_u64(vm, addr, rds);
+            return;
+        }
+#endif
+        case 0x4: // Zcb
+            switch (bit_cut(insn, 10, 3)) {
+                case 0x0: { // c.lbu (Zcb)
+                    const xlen_t offset = ((insn & 0x20) >> 4) | ((insn & 0x40) >> 6);
+                    const xlen_t addr = riscv_read_reg(vm, rs1) + offset;
+                    rvjit_trace_lbu(rds, rs1, offset, 2);
+                    riscv_load_u8(vm, addr, rds);
+                    return;
+                }
+                case 0x1: {
+                    const xlen_t offset = (insn & 0x20) >> 4;
+                    const xlen_t addr = riscv_read_reg(vm, rs1) + offset;
+                    if (insn & 0x40) { // c.lh (Zcb)
+                        rvjit_trace_lh(rds, rs1, offset, 2);
+                        riscv_load_s16(vm, addr, rds);
+                    } else { // c.lhu (Zcb)
+                        rvjit_trace_lhu(rds, rs1, offset, 2);
+                        riscv_load_u16(vm, addr, rds);
+                    }
+                    return;
+                }
+                case 0x2: { // c.sb (Zcb)
+                    const xlen_t offset = ((insn & 0x20) >> 4) | ((insn & 0x40) >> 6);
+                    const xlen_t addr = riscv_read_reg(vm, rs1) + offset;
+                    rvjit_trace_sb(rds, rs1, offset, 2);
+                    riscv_store_u8(vm, addr, rds);
+                    return;
+                }
+                case 0x3:
+                    if (!(insn & 0x40)) { // c.sh (Zcb)
+                        const xlen_t offset = (insn & 0x20) >> 4;
+                        const xlen_t addr = riscv_read_reg(vm, rs1) + offset;
+                        rvjit_trace_sh(rds, rs1, offset, 2);
+                        riscv_store_u16(vm, addr, rds);
+                        return;
+
+                    }
+                    break;
+            }
+            break;
+#ifdef USE_FPU
+        case 0x5:
+            if (likely(fpu_is_enabled(vm))) { // c.fsd
+                const xlen_t offset = decode_c_ld_off(insn);
+                const xlen_t addr = riscv_read_reg(vm, rs1) + offset;
+                riscv_store_double(vm, addr, rds);
+                return;
+            }
+            break;
+#endif
+        case 0x6: { // c.sw
+            const xlen_t offset = decode_c_lw_off(insn);
+            const xlen_t addr = riscv_read_reg(vm, rs1) + offset;
+            rvjit_trace_sw(rds, rs1, offset, 2);
+            riscv_store_u32(vm, addr, rds);
+            return;
+        }
+#if defined(USE_FPU) && !defined(RV64)
+        case 0x7:
+            if (likely(fpu_is_enabled(vm))) { // c.fsw (RV32)
+                const xlen_t offset = decode_c_lw_off(insn);
+                const xlen_t addr = riscv_read_reg(vm, rs1) + offset;
+                riscv_store_float(vm, addr, rds);
+                return;
+            }
+            break;
+#endif
+#ifdef RV64
+        case 0x7: { // c.sd (RV64)
+            const xlen_t offset = decode_c_ld_off(insn);
+            const xlen_t addr = riscv_read_reg(vm, rs1) + offset;
+            rvjit_trace_sd(rds, rs1, offset, 2);
+            riscv_store_u64(vm, addr, rds);
+            return;
+        }
+#endif
+    }
+    riscv_illegal_insn(vm, insn);
+}
+
+
+static forceinline void riscv_emulate_c_misc_alu(rvvm_hart_t* vm, const uint16_t insn)
+{
+    const regid_t rds = bit_cut(insn, 7, 3) + 8;
+    const xlen_t reg1 = riscv_read_reg(vm, rds);
+    const uint8_t funct6 = bit_cut(insn, 10, 2);
+
+    switch (funct6) {
+        case 0x0: { // c.srli
+            const bitcnt_t shamt = decode_c_shamt(insn);
+            rvjit_trace_srli(rds, rds, shamt, 2);
+            riscv_write_reg(vm, rds, reg1 >> shamt);
+            return;
+        }
+        case 0x1: { // c.srai
+            const bitcnt_t shamt = decode_c_shamt(insn);
+            rvjit_trace_srai(rds, rds, shamt, 2);
+            riscv_write_reg(vm, rds, ((sxlen_t)reg1) >> shamt);
+            return;
+        }
+        case 0x2: { // c.andi
+            const sxlen_t imm = decode_c_alu_imm(insn);
+            rvjit_trace_andi(rds, rds, imm, 2);
+            riscv_write_reg(vm, rds, reg1 & imm);
+            return;
+        }
+        case 0x3: {
+            const uint8_t funct2 = bit_cut(insn, 5, 2);
+            const regid_t rs2 = bit_cut(insn, 2, 3) + 8;
+            if (!bit_check(insn, 12)) {
+                const xlen_t reg2 = riscv_read_reg(vm, rs2);
+                switch (funct2) {
+                    case 0x0: // c.sub
+                        rvjit_trace_sub(rds, rds, rs2, 2);
+                        riscv_write_reg(vm, rds, reg1 - reg2);
+                        return;
+                    case 0x1: // c.xor
+                        rvjit_trace_xor(rds, rds, rs2, 2);
+                        riscv_write_reg(vm, rds, reg1 ^ reg2);
+                        return;
+                    case 0x2: // c.or
+                        rvjit_trace_or(rds, rds, rs2, 2);
+                        riscv_write_reg(vm, rds, reg1 | reg2);
+                        return;
+                    case 0x3: // c.and
+                        rvjit_trace_and(rds, rds, rs2, 2);
+                        riscv_write_reg(vm, rds, reg1 & reg2);
+                        return;
+                }
+            } else {
+                switch (funct2) {
+#ifdef RV64
+                    case 0x0: { // c.subw
+                        const xlen_t reg2 = riscv_read_reg(vm, rs2);
+                        rvjit_trace_subw(rds, rds, rs2, 2);
+                        riscv_write_reg(vm, rds, (int32_t)(reg1 - reg2));
+                        return;
+                    }
+                    case 0x1: { // c.addw
+                        const xlen_t reg2 = riscv_read_reg(vm, rs2);
+                        rvjit_trace_addw(rds, rds, rs2, 2);
+                        riscv_write_reg(vm, rds, (int32_t)(reg1 + reg2));
+                        return;
+                    }
+#endif
+                    case 0x2: { // c.mul (Zcb + M)
+                        const xlen_t reg2 = riscv_read_reg(vm, rs2);
+                        rvjit_trace_mul(rds, rds, rs2, 2);
+                        riscv_write_reg(vm, rds, reg1 * reg2);
+                        return;
+                    }
+                    case 0x3:
+                        switch (bit_cut(insn, 2, 3)) {
+                            case 0x0: // c.zext.b (Zcb)
+                                rvjit_trace_andi(rds, rds, 0xFF, 2);
+                                riscv_write_reg(vm, rds, (uint8_t)reg1);
+                                return;
+                            case 0x1: // c.sext.b (Zcb + Zbb)
+                                rvjit_trace_sext_b(rds, rds, 2);
+                                riscv_write_reg(vm, rds, (int8_t)reg1);
+                                return;
+                            case 0x2: // c.zext.h (Zcb + Zbb)
+                                rvjit_trace_andi(rds, rds, 0xFFFF, 2);
+                                riscv_write_reg(vm, rds, (uint16_t)reg1);
+                                return;
+                            case 0x3: // c.sext.h (Zcb + Zbb)
+                                rvjit_trace_sext_h(rds, rds, 2);
+                                riscv_write_reg(vm, rds, (int16_t)reg1);
+                                return;
+#ifdef RV64
+                            case 0x4: // c.zext.w (Zcb + Zba), RV64 only
+                                rvjit_trace_shadd_uw(rds, rds, REGISTER_ZERO, 0, 2);
+                                riscv_write_reg(vm, rds, (uint32_t)reg1);
+                                return;
+#endif
+                            case 0x5: // c.not (Zcb)
+                                rvjit_trace_xori(rds, rds, -1, 2);
+                                riscv_write_reg(vm, rds, ~reg1);
+                                return;
+                        }
+                        break;
+                }
+            }
+            break;
+        }
+    }
+    riscv_illegal_insn(vm, insn);
+}
+
+static forceinline void riscv_emulate_c_c1(rvvm_hart_t* vm, const uint16_t insn)
+{
+    switch (insn >> 13) {
+        case 0x0: { // c.addi
+            const regid_t rds = bit_cut(insn, 7, 5);
+            const xlen_t src = riscv_read_reg(vm, rds);
+            const sxlen_t imm = decode_c_alu_imm(insn);
+            rvjit_trace_addi(rds, rds, imm, 2);
+            riscv_write_reg(vm, rds, src + imm);
+            return;
+        }
+        case 0x1: { // c.jal (RV32), c.addiw (RV64)
+#ifdef RV64
+            const regid_t rds = bit_cut(insn, 7, 5);
+            const xlen_t src = riscv_read_reg(vm, rds);
+            const sxlen_t imm = decode_c_alu_imm(insn);
+            rvjit_trace_addiw(rds, rds, imm, 2);
+            riscv_write_reg(vm, rds, (int32_t)(src + imm));
+#else
+            const xlen_t pc = riscv_read_reg(vm, REGISTER_PC);
+            const sxlen_t offset = decode_c_jal_imm(insn);
+            rvjit_trace_jal(REGISTER_X1, offset, 2);
+            riscv_write_reg(vm, REGISTER_X1, pc + 2);
+            riscv_write_reg(vm, REGISTER_PC, pc + offset - 2);
+#endif
+            return;
+        }
+        case 0x2: { // c.li
+            const regid_t rds = bit_cut(insn, 7, 5);
+            const sxlen_t imm = decode_c_alu_imm(insn);
+            rvjit_trace_li(rds, imm, 2);
+            riscv_write_reg(vm, rds, imm);
+            return;
+        }
+        case 0x3: { // c.addi16sp (rds == X2), c.lui (rds != X2)
+            const regid_t rds = bit_cut(insn, 7, 5);
+            if (rds == REGISTER_X2) {
+                const sxlen_t off = decode_c_addi16sp_off(insn);
+                const xlen_t sp = riscv_read_reg(vm, REGISTER_X2);
+                rvjit_trace_addi(REGISTER_X2, REGISTER_X2, off, 2);
+                riscv_write_reg(vm, REGISTER_X2, sp + off);
+            } else {
+                const sxlen_t imm = decode_c_lui_imm(insn);
+                rvjit_trace_li(rds, imm, 2);
+                riscv_write_reg(vm, rds, imm);
+            }
+            return;
+        }
+        case 0x4: // MISC ALU
+            riscv_emulate_c_misc_alu(vm, insn);
+            return;
+        case 0x5: { // c.j
+            const xlen_t pc = riscv_read_reg(vm, REGISTER_PC);
+            const sxlen_t offset = decode_c_jal_imm(insn);
+            rvjit_trace_jal(REGISTER_ZERO, offset, 2);
+            riscv_write_reg(vm, REGISTER_PC, pc + offset - 2);
+            return;
+        }
+        case 0x6: { // c.beqz
+            const regid_t rs1 = bit_cut(insn, 7, 3) + 8;
+            const xlen_t src = riscv_read_reg(vm, rs1);
+            const sxlen_t offset = decode_c_branch_imm(insn);
+            if (src == 0) {
+                const xlen_t pc = riscv_read_reg(vm, REGISTER_PC);
+                rvjit_trace_beq(rs1, REGISTER_ZERO, offset, 2, 2);
+                riscv_write_reg(vm, REGISTER_PC, pc + offset - 2);
+            } else {
+                rvjit_trace_bne(rs1, REGISTER_ZERO, 2, offset, 2);
+            }
+            return;
+        }
+        case 0x7: { // c.bnez
+            const regid_t rs1 = bit_cut(insn, 7, 3) + 8;
+            const xlen_t src = riscv_read_reg(vm, rs1);
+            const sxlen_t offset = decode_c_branch_imm(insn);
+            if (src != 0) {
+                const xlen_t pc = riscv_read_reg(vm, REGISTER_PC);
+                rvjit_trace_bne(rs1, REGISTER_ZERO, offset, 2, 2);
+                riscv_write_reg(vm, REGISTER_PC, pc + offset - 2);
+            } else {
+                rvjit_trace_beq(rs1, REGISTER_ZERO, 2, offset, 2);
+            }
+            return;
+        }
+    }
+    riscv_illegal_insn(vm, insn);
+}
+
+static forceinline void riscv_emulate_c_jr_mv(rvvm_hart_t* vm, const uint16_t insn)
+{
+    const regid_t rds = bit_cut(insn, 7, 5);
+    const regid_t rs2 = bit_cut(insn, 2, 5);
+
+    if (bit_check(insn, 12)) {
+        if (likely(rds != 0)) {
+            if (rs2 != 0) {
+                // c.add
+                const xlen_t reg1 = riscv_read_reg(vm, rds);
+                const xlen_t reg2 = riscv_read_reg(vm, rs2);
+                rvjit_trace_add(rds, rds, rs2, 2);
+                riscv_write_reg(vm, rds, reg1 + reg2);
+            } else {
+                // c.jalr
+                const xlen_t reg1 = riscv_read_reg(vm, rds);
+                const xlen_t pc = riscv_read_reg(vm, REGISTER_PC);
+                rvjit_trace_jalr(REGISTER_X1, rds, 0, 2);
+                riscv_write_reg(vm, REGISTER_X1, pc + 2);
+                riscv_write_reg(vm, REGISTER_PC, reg1 - 2);
+            }
+        } else {
+            // c.ebreak
+            riscv_trap(vm, TRAP_BREAKPOINT, 0);
+        }
+    } else {
+        if (rs2 != 0) {
+            // c.mv
+            const xlen_t reg2 = riscv_read_reg(vm, rs2);
+            rvjit_trace_addi(rds, rs2, 0, 2);
+            riscv_write_reg(vm, rds, reg2);
+        } else {
+            // c.jr
+            const xlen_t reg1 = riscv_read_reg(vm, rds);
+            rvjit_trace_jalr(REGISTER_ZERO, rds, 0, 2);
+            riscv_write_reg(vm, REGISTER_PC, reg1 - 2);
+        }
+    }
+}
+
+static forceinline void riscv_emulate_c_c2(rvvm_hart_t* vm, const uint16_t insn)
+{
+    switch (insn >> 13) {
+        case 0x0: { // c.slli
+            const regid_t rds = bit_cut(insn, 7, 5);
+            const xlen_t src = riscv_read_reg(vm, rds);
+            const bitcnt_t shamt = decode_c_shamt(insn);
+            rvjit_trace_slli(rds, rds, shamt, 2);
+            riscv_write_reg(vm, rds, src << shamt);
+            return;
+        }
+#ifdef USE_FPU
+        case 0x1:
+            if (likely(fpu_is_enabled(vm))) { // c.fldsp
+                const regid_t rds = bit_cut(insn, 7, 5);
+                const xlen_t offset = decode_c_ldsp_off(insn);
+                const xlen_t addr = riscv_read_reg(vm, REGISTER_X2) + offset;
+                riscv_load_double(vm, addr, rds);
+                return;
+            }
+            break;
+#endif
+        case 0x2: { // c.lwsp
+            const regid_t rds = bit_cut(insn, 7, 5);
+            const xlen_t offset = decode_c_lwsp_off(insn);
+            const xlen_t addr = riscv_read_reg(vm, REGISTER_X2) + offset;
+            rvjit_trace_lw(rds, REGISTER_X2, offset, 2);
+            riscv_load_s32(vm, addr, rds);
+            return;
+        }
+#if defined(USE_FPU) && !defined(RV64)
+        case 0x3:
+            if (likely(fpu_is_enabled(vm))) { // c.flwsp (RV32)
+                const regid_t rds = bit_cut(insn, 7, 5);
+                const xlen_t offset = decode_c_lwsp_off(insn);
+                const xlen_t addr = riscv_read_reg(vm, REGISTER_X2) + offset;
+                riscv_load_float(vm, addr, rds);
+                return;
+            }
+            break;
+#endif
+#ifdef RV64
+        case 0x3: { // c.ldsp (RV64)
+            const regid_t rds = bit_cut(insn, 7, 5);
+            const xlen_t offset = decode_c_ldsp_off(insn);
+            const xlen_t addr = riscv_read_reg(vm, REGISTER_X2) + offset;
+            rvjit_trace_ld(rds, REGISTER_X2, offset, 2);
+            riscv_load_u64(vm, addr, rds);
+            return;
+        }
+#endif
+        case 0x4:
+            riscv_emulate_c_jr_mv(vm, insn);
+            return;
+#ifdef USE_FPU
+        case 0x5:
+            if (likely(fpu_is_enabled(vm))) { // c.fsdsp
+                const regid_t rds = bit_cut(insn, 2, 5);
+                const xlen_t offset = decode_c_sdsp_off(insn);
+                const xlen_t addr = riscv_read_reg(vm, REGISTER_X2) + offset;
+                riscv_store_double(vm, addr, rds);
+                return;
+            }
+            break;
+#endif
+        case 0x6: { // c.swsp
+            const regid_t rds = bit_cut(insn, 2, 5);
+            const xlen_t offset = decode_c_swsp_off(insn);
+            const xlen_t addr = riscv_read_reg(vm, REGISTER_X2) + offset;
+            rvjit_trace_sw(rds, REGISTER_X2, offset, 2);
+            riscv_store_u32(vm, addr, rds);
+            return;
+        }
+#if defined(USE_FPU) && !defined(RV64)
+        case 0x7:
+            if (likely(fpu_is_enabled(vm))) { // c.fswsp (RV32)
+                const regid_t rds = bit_cut(insn, 2, 5);
+                const xlen_t offset = decode_c_lwsp_off(insn);
+                const xlen_t addr = riscv_read_reg(vm, REGISTER_X2) + offset;
+                riscv_store_float(vm, addr, rds);
+                return;
+            }
+            break;
+#endif
+#ifdef RV64
+        case 0x7: { // c.sdsp (RV64)
+            const regid_t rds = bit_cut(insn, 2, 5);
+            const xlen_t offset = decode_c_sdsp_off(insn);
+            const xlen_t addr = riscv_read_reg(vm, REGISTER_X2) + offset;
+            rvjit_trace_sd(rds, REGISTER_X2, offset, 2);
+            riscv_store_u64(vm, addr, rds);
+            return;
+        }
+#endif
+    }
+    riscv_illegal_insn(vm, insn);
+}
+
+static forceinline void riscv_emulate_insn(rvvm_hart_t* vm, const uint32_t insn)
+{
+    const uint32_t op = insn & 0x3;
+    switch (op) {
+        case 0x0:
+            riscv_emulate_c_c0(vm, insn);
+            vm->registers[REGISTER_PC] += 2;
+            return;
+        case 0x1:
+            riscv_emulate_c_c1(vm, insn);
+            vm->registers[REGISTER_PC] += 2;
+            return;
+        case 0x2:
+            riscv_emulate_c_c2(vm, insn);
+            vm->registers[REGISTER_PC] += 2;
+            return;
+        case 0x3:
+            riscv_emulate_i(vm, insn);
+            vm->registers[REGISTER_PC] += 4;
+            return;
+    }
+}
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/cpu/riscv_fpu.h b/app/src/main/java/libengine/RVVM/src/cpu/riscv_fpu.h
new file mode 100644
index 00000000..a662ba76
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/cpu/riscv_fpu.h
@@ -0,0 +1,673 @@
+/*
+riscv_fpu.h - RISC-V Floating-Point ISA interpreter template
+Copyright (C) 2024  LekKit <github.com/LekKit>
+
+This Source Code Form is subject to the terms of the Mozilla Public
+License, v. 2.0. If a copy of the MPL was not distributed with this
+file, You can obtain one at https://mozilla.org/MPL/2.0/.
+
+Alternatively, the contents of this file may be used under the terms
+of the GNU General Public License as published by the Free Software
+Foundation, either version 3 of the License, or any later version.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef RISCV_FPU_H
+#define RISCV_FPU_H
+
+#include "fpu_lib.h"
+
+#define RISCV_FADD_S   0x0
+#define RISCV_FSUB_S   0x4
+#define RISCV_FMUL_S   0x8
+#define RISCV_FDIV_S   0xC
+#define RISCV_FSQRT_S  0x2C // rs2 field is zero
+#define RISCV_FSGNJ_S  0x10 // rm field encodes funct3
+#define RISCV_FCLAMP_S 0x14 // rm field encodes funct3, fmin/fmax
+#define RISCV_FCVT_W_S 0x60 // rs2 field encodes conversion type
+#define RISCV_FMVCLS_S 0x70 // rs2 field is zero, rm encodes fmv.x.w or fclass
+#define RISCV_FCMP_S   0x50 // rm field encodes funct3
+#define RISCV_FCVT_S_W 0x68 // rs2 field encodes conversion type
+#define RISCV_FMV_W_X  0x78 // rs2, rm fields are zero
+
+#define RISCV_FADD_D   0x1
+#define RISCV_FSUB_D   0x5
+#define RISCV_FMUL_D   0x9
+#define RISCV_FDIV_D   0xD
+#define RISCV_FSQRT_D  0x2D // rs2 field is zero
+#define RISCV_FSGNJ_D  0x11 // rm field encodes funct3
+#define RISCV_FCLAMP_D 0x15 // rm field encodes funct3, fmin/fmax
+#define RISCV_FCVT_S_D 0x20 // rs2 is 1
+#define RISCV_FCVT_D_S 0x21 // rs2 is 0
+#define RISCV_FCVT_W_D 0x61 // rs2 field encodes conversion type
+#define RISCV_FMVCLS_D 0x71 // rs2 field is zero, rm encodes fmv.x.w or fclass
+#define RISCV_FCMP_D   0x51 // rm field encodes funct3
+#define RISCV_FCVT_D_W 0x69 // rs2 field encodes conversion type
+#define RISCV_FMV_D_X  0x79 // rs2, rm fields are zero
+
+// FPU fclass instruction results
+#define FCL_NEG_INF       0x0
+#define FCL_NEG_NORMAL    0x1
+#define FCL_NEG_SUBNORMAL 0x2
+#define FCL_NEG_ZERO      0x3
+#define FCL_POS_ZERO      0x4
+#define FCL_POS_SUBNORMAL 0x5
+#define FCL_POS_NORMAL    0x6
+#define FCL_POS_INF       0x7
+#define FCL_NAN_SIG       0x8
+#define FCL_NAN_QUIET     0x9
+
+// Bit-precise register reads
+static forceinline float fpu_view_s(rvvm_hart_t* vm, regid_t reg)
+{
+    return read_float_nanbox(&vm->fpu_registers[reg]);
+}
+
+// Normalized register reads
+static forceinline float fpu_read_s(rvvm_hart_t* vm, regid_t reg)
+{
+    return read_float_normalize(&vm->fpu_registers[reg]);
+}
+
+// For bit-precise float register writes
+static forceinline void fpu_emit_s(rvvm_hart_t* vm, regid_t reg, float val)
+{
+    fpu_set_fs(vm, FS_DIRTY);
+    write_float_nanbox(&vm->fpu_registers[reg], val);
+}
+
+// Canonizes the written result
+static forceinline void fpu_write_s(rvvm_hart_t* vm, regid_t reg, float val)
+{
+    if (unlikely(fpu_isnan(val))) {
+        uint32_t canonic_nan = 0x7fc00000;
+        memcpy(&val, &canonic_nan, sizeof(val));
+    }
+    fpu_emit_s(vm, reg, val);
+}
+
+static forceinline double fpu_read_d(rvvm_hart_t* vm, regid_t reg)
+{
+    return vm->fpu_registers[reg];
+}
+
+static forceinline void fpu_emit_d(rvvm_hart_t* vm, regid_t reg, double val)
+{
+    fpu_set_fs(vm, FS_DIRTY);
+    vm->fpu_registers[reg] = val;
+}
+
+static forceinline void fpu_write_d(rvvm_hart_t* vm, regid_t reg, double val)
+{
+    if (unlikely(fpu_isnan(val))) {
+        uint64_t canonic_nan = 0x7ff8000000000000;
+        memcpy(&val, &canonic_nan, sizeof(val));
+    }
+    fpu_emit_d(vm, reg, val);
+}
+
+// FPU operations lowering
+
+static forceinline uint8_t fpu_fclassf(float x)
+{
+    switch (fpclassify(x)) {
+        case FP_INFINITE:  return fpu_signbitf(x) ? FCL_NEG_INF : FCL_POS_INF;
+        case FP_NORMAL:    return fpu_signbitf(x) ? FCL_NEG_NORMAL : FCL_POS_NORMAL;
+        case FP_SUBNORMAL: return fpu_signbitf(x) ? FCL_NEG_SUBNORMAL : FCL_POS_SUBNORMAL;
+        case FP_ZERO:      return fpu_signbitf(x) ? FCL_NEG_ZERO : FCL_POS_ZERO;
+        default:           return fpu_is_snanf(x) ? FCL_NAN_SIG : FCL_NAN_QUIET;
+    }
+}
+
+static forceinline uint8_t fpu_fclassd(double x)
+{
+    switch (fpclassify(x)) {
+        case FP_INFINITE:  return fpu_signbitd(x) ? FCL_NEG_INF : FCL_POS_INF;
+        case FP_NORMAL:    return fpu_signbitd(x) ? FCL_NEG_NORMAL : FCL_POS_NORMAL;
+        case FP_SUBNORMAL: return fpu_signbitd(x) ? FCL_NEG_SUBNORMAL : FCL_POS_SUBNORMAL;
+        case FP_ZERO:      return fpu_signbitd(x) ? FCL_NEG_ZERO : FCL_POS_ZERO;
+        default:           return fpu_is_snand(x) ? FCL_NAN_SIG : FCL_NAN_QUIET;
+    }
+}
+
+static forceinline float fpu_round_evenf(float val) {
+    float even;
+    float frac = modff(val, &even);
+    if (frac < 0.5f && frac > -0.5f) {
+        return even;
+    } else {
+        return even + (even > 0.0f ? 1.0f : -1.0f);
+    }
+}
+
+static forceinline double fpu_round_evend(double val) {
+    double even;
+    double frac = modf(val, &even);
+    if (frac < 0.5 && frac > -0.5) {
+        return even;
+    } else {
+        return even + (even > 0.0 ? 1.0 : -1.0);
+    }
+}
+
+/*
+ * This probably should be done using softfp, since dynamic RM
+ * could mess with libm internals
+ */
+static float fpu_round_to_rmf(float x, uint8_t rm)
+{
+    float ret;
+    switch (rm) {
+        case RM_RNE: ret = fpu_round_evenf(x); break;
+        case RM_RTZ: ret = truncf(x);      break;
+        case RM_RDN: ret = floorf(x);      break;
+        case RM_RUP: ret = ceilf(x);       break;
+        case RM_RMM: ret = roundf(x);      break;
+        default:     ret = rintf(x);       break;
+    }
+    /*
+     * Some libm implementations omit implementing FE_INEXACT flag
+     * We check if we need to fix this at all first, since writing an exception
+     * stalls the host pipeline, and is generally expensive.
+     *
+     * Another option could be "exception overlays" in hart context,
+     * combined with host exceptions in fcsr.
+     */
+    if (unlikely(ret != x && !fetestexcept(FE_INEXACT))) feraiseexcept(FE_INEXACT);
+    return ret;
+}
+
+static double fpu_round_to_rmd(double x, uint8_t rm)
+{
+    double ret;
+    switch (rm) {
+        case RM_RNE: ret = fpu_round_evend(x); break;
+        case RM_RTZ: ret = trunc(x);      break;
+        case RM_RDN: ret = floor(x);      break;
+        case RM_RUP: ret = ceil(x);       break;
+        case RM_RMM: ret = round(x);      break;
+        default:     ret = rint(x);       break;
+    }
+    if (unlikely(ret != x && !fetestexcept(FE_INEXACT))) feraiseexcept(FE_INEXACT);
+    return ret;
+}
+
+static forceinline int32_t fpu_f2int_u32(float x, float rm)
+{
+    if (likely(rm == RM_RTZ && x > -1.f && x < 4294967296.f)) return (uint32_t)x;
+    float ret = fpu_round_to_rmf(x, rm);
+    if (unlikely(fpu_isnan(ret) || ret < 0.f || ret > 4294967295.f)) {
+        feraiseexcept(FE_INVALID);
+        if (fpu_isnan(x) || !fpu_signbitf(x)) return ~0;
+        return 0;
+    }
+    return (uint32_t)ret;
+}
+
+static forceinline int32_t fpu_d2int_u32(double x, float rm)
+{
+    if (likely(rm == RM_RTZ && x > -1.0 && x < 4294967296.0)) return (uint32_t)x;
+    double ret = fpu_round_to_rmd(x, rm);
+    if (unlikely(fpu_isnan(ret) || ret < 0.0 || ret > 4294967295.0)) {
+        feraiseexcept(FE_INVALID);
+        if (fpu_isnan(x) || !fpu_signbitf(x)) return ~0;
+        return 0;
+    }
+    return (uint32_t)ret;
+}
+
+static forceinline int32_t fpu_f2int_i32(float x, uint8_t rm)
+{
+    if (likely(rm == RM_RTZ && x > -2147483649.f && x < 2147483648.f)) return (int32_t)x;
+    float ret = fpu_round_to_rmf(x, rm);
+    if (unlikely(fpu_isnan(ret) || (ret < -2147483648.f) || (ret > 2147483647.f))) {
+        feraiseexcept(FE_INVALID);
+        if (fpu_isnan(x) || !fpu_signbitf(x)) return ~(uint32_t)0 >> 1;
+        return ~(~(uint32_t)0 >> 1);
+    }
+    return (int32_t)ret;
+}
+
+static forceinline int32_t fpu_d2int_i32(double x, uint8_t rm)
+{
+    if (likely(rm == RM_RTZ && x > -2147483649.0 && x < 2147483648.0)) return (int32_t)x;
+    double ret = fpu_round_to_rmd(x, rm);
+    if (unlikely(fpu_isnan(ret) || (ret < -2147483648.0) || (ret > 2147483647.0))) {
+        feraiseexcept(FE_INVALID);
+        if (fpu_isnan(x) || !fpu_signbitd(x)) return ~(uint32_t)0 >> 1;
+        return ~(~(uint32_t)0 >> 1);
+    }
+    return (int32_t)ret;
+}
+
+static forceinline int64_t fpu_f2int_u64(float x, uint8_t rm)
+{
+    if (likely(rm == RM_RTZ && x > -1.f && x < 18446744073709551616.f)) return (uint64_t)x;
+    float ret = fpu_round_to_rmf(x, rm);
+    if (unlikely(fpu_isnan(ret) || ret < 0.f || ret > 18446744073709551615.f)) {
+        feraiseexcept(FE_INVALID);
+        if (fpu_isnan(x) || !fpu_signbitf(x)) return ~(uint64_t)0;
+        return 0;
+    }
+    return (uint64_t)ret;
+}
+
+static forceinline int64_t fpu_d2int_u64(double x, uint8_t rm)
+{
+    if (likely(rm == RM_RTZ && x > -1.0 && x < 18446744073709551616.0)) return (uint64_t)x;
+    double ret = fpu_round_to_rmd(x, rm);
+    if (unlikely(fpu_isnan(ret) || ret < 0.0 || ret > 18446744073709551615.0)) {
+        feraiseexcept(FE_INVALID);
+        if (fpu_isnan(x) || !fpu_signbitd(x)) return ~(uint64_t)0;
+        return 0;
+    }
+    return (uint64_t)ret;
+}
+
+static forceinline int64_t fpu_f2int_i64(float x, uint8_t rm)
+{
+    if (likely(rm == RM_RTZ && x > -9223372036854775809.f && x < 9223372036854775808.f)) return (int64_t)x;
+    float ret = fpu_round_to_rmf(x, rm);
+    if (unlikely(fpu_isnan(ret) || (ret < -9223372036854775808.f) || (ret > 9223372036854775807.f))) {
+        feraiseexcept(FE_INVALID);
+        if (fpu_isnan(x) || !fpu_signbitf(x)) return ~(uint64_t)0 >> 1;
+        return ~(~(uint64_t)0 >> 1);
+    }
+    return (int64_t)ret;
+}
+
+static forceinline int64_t fpu_d2int_i64(double x, uint8_t rm)
+{
+    if (likely(rm == RM_RTZ && x > -9223372036854775809.0 && x < 9223372036854775808.0)) return (int64_t)x;
+    double ret = fpu_round_to_rmd(x, rm);
+    if (unlikely(fpu_isnan(ret) || (ret < -9223372036854775808.0) || (ret > 9223372036854775807.0))) {
+        feraiseexcept(FE_INVALID);
+        if (fpu_isnan(x) || !fpu_signbitd(x)) return ~(uint64_t)0 >> 1;
+        return ~(~(uint64_t)0 >> 1);
+    }
+    return (int64_t)ret;
+}
+
+static forceinline int32_t fpu_bitcast_fp2int_32(float f)
+{
+    int32_t i;
+    memcpy(&i, &f, sizeof(i));
+    return i;
+}
+
+static forceinline float fpu_bitcast_int2fp_32(uint32_t i)
+{
+    float f;
+    memcpy(&f, &i, sizeof(f));
+    return f;
+}
+
+static forceinline int64_t fpu_bitcast_fp2int_64(double f)
+{
+    int64_t i;
+    memcpy(&i, &f, sizeof(i));
+    return i;
+}
+
+static forceinline double fpu_bitcast_int2fp_64(uint64_t i)
+{
+    double f;
+    memcpy(&f, &i, sizeof(f));
+    return f;
+}
+
+static forceinline void riscv_emulate_f_opc_load(rvvm_hart_t* vm, const uint32_t insn)
+{
+    const uint32_t funct3 = bit_cut(insn, 12, 3);
+    const regid_t rds = bit_cut(insn, 7, 5);
+    const regid_t rs1 = bit_cut(insn, 15, 5);
+    const sxlen_t offset = sign_extend(bit_cut(insn, 20, 12), 12);
+    const xlen_t  addr = riscv_read_reg(vm, rs1) + offset;
+    if (likely(fpu_is_enabled(vm))) switch (funct3) {
+        case 0x2: // flw
+            riscv_load_float(vm, addr, rds);
+            return;
+        case 0x3: // fld
+            riscv_load_double(vm, addr, rds);
+            return;
+    }
+    riscv_illegal_insn(vm, insn);
+}
+
+static forceinline void riscv_emulate_f_opc_store(rvvm_hart_t* vm, const uint32_t insn)
+{
+    const uint32_t funct3 = bit_cut(insn, 12, 3);
+    const regid_t rs1 = bit_cut(insn, 15, 5);
+    const regid_t rs2 = bit_cut(insn, 20, 5);
+    const sxlen_t offset = sign_extend(bit_cut(insn, 7, 5) | (bit_cut(insn, 25, 7) << 5), 12);
+    const xlen_t addr = riscv_read_reg(vm, rs1) + offset;
+    if (likely(fpu_is_enabled(vm))) switch (funct3) {
+        case 0x2: // fsw
+            riscv_store_float(vm, addr, rs2);
+            return;
+        case 0x3: // fsd
+            riscv_store_double(vm, addr, rs2);
+            return;
+    }
+    riscv_illegal_insn(vm, insn);
+}
+
+static forceinline void riscv_emulate_f_fmadd(rvvm_hart_t* vm, const uint32_t insn)
+{
+    const regid_t rds = bit_cut(insn, 7, 5);
+    const regid_t rs1 = bit_cut(insn, 15, 5);
+    const regid_t rs2 = bit_cut(insn, 20, 5);
+    const uint32_t funct2 = bit_cut(insn, 25, 2);
+    const regid_t rs3 = insn >> 27;
+    if (likely(fpu_is_enabled(vm))) switch (funct2) {
+        case 0x0: // fmadd.s
+            fpu_write_s(vm, rds, fpu_fmaf(fpu_read_s(vm, rs1), fpu_read_s(vm, rs2), fpu_read_s(vm, rs3)));
+            return;
+        case 0x1: // fmadd.d
+            fpu_write_d(vm, rds, fpu_fmad(fpu_read_d(vm, rs1), fpu_read_d(vm, rs2), fpu_read_d(vm, rs3)));
+            return;
+    }
+    riscv_illegal_insn(vm, insn);
+}
+
+static forceinline void riscv_emulate_f_fmsub(rvvm_hart_t* vm, const uint32_t insn)
+{
+    const regid_t rds = bit_cut(insn, 7, 5);
+    const regid_t rs1 = bit_cut(insn, 15, 5);
+    const regid_t rs2 = bit_cut(insn, 20, 5);
+    const uint32_t funct2 = bit_cut(insn, 25, 2);
+    const regid_t rs3 = insn >> 27;
+    if (likely(fpu_is_enabled(vm))) switch (funct2) {
+        case 0x0: // fmsub.s
+            fpu_write_s(vm, rds, fpu_fmaf(fpu_read_s(vm, rs1), fpu_read_s(vm, rs2), -fpu_read_s(vm, rs3)));
+            return;
+        case 0x1: // fmsub.d
+            fpu_write_d(vm, rds, fpu_fmad(fpu_read_d(vm, rs1), fpu_read_d(vm, rs2), -fpu_read_d(vm, rs3)));
+            return;
+    }
+    riscv_illegal_insn(vm, insn);
+}
+
+static forceinline void riscv_emulate_f_fnmsub(rvvm_hart_t* vm, const uint32_t insn)
+{
+    const regid_t rds = bit_cut(insn, 7, 5);
+    const regid_t rs1 = bit_cut(insn, 15, 5);
+    const regid_t rs2 = bit_cut(insn, 20, 5);
+    const uint32_t funct2 = bit_cut(insn, 25, 2);
+    const regid_t rs3 = insn >> 27;
+    if (likely(fpu_is_enabled(vm))) switch (funct2) {
+        case 0x0: // fnmsub.s
+            fpu_write_s(vm, rds, -fpu_fmaf(fpu_read_s(vm, rs1), fpu_read_s(vm, rs2), -fpu_read_s(vm, rs3)));
+            return;
+        case 0x1: // fnmsub.d
+            fpu_write_d(vm, rds, -fpu_fmad(fpu_read_d(vm, rs1), fpu_read_d(vm, rs2), -fpu_read_d(vm, rs3)));
+            return;
+    }
+    riscv_illegal_insn(vm, insn);
+}
+
+static forceinline void riscv_emulate_f_fnmadd(rvvm_hart_t* vm, const uint32_t insn)
+{
+    const regid_t rds = bit_cut(insn, 7, 5);
+    const regid_t rs1 = bit_cut(insn, 15, 5);
+    const regid_t rs2 = bit_cut(insn, 20, 5);
+    const uint32_t funct2 = bit_cut(insn, 25, 2);
+    const regid_t rs3 = insn >> 27;
+    if (likely(fpu_is_enabled(vm))) switch (funct2) {
+        case 0x0: // fnmadd.s
+            fpu_write_s(vm, rds, -fpu_fmaf(fpu_read_s(vm, rs1), fpu_read_s(vm, rs2), fpu_read_s(vm, rs3)));
+            return;
+        case 0x1: // fnmadd.d
+            fpu_write_d(vm, rds, -fpu_fmad(fpu_read_d(vm, rs1), fpu_read_d(vm, rs2), fpu_read_d(vm, rs3)));
+            return;
+    }
+    riscv_illegal_insn(vm, insn);
+}
+
+static forceinline void riscv_emulate_f_opc_op(rvvm_hart_t* vm, const uint32_t insn)
+{
+    const regid_t rds = bit_cut(insn, 7, 5);
+    const uint8_t rm  = bit_cut(insn, 12, 3);
+    const regid_t rs1 = bit_cut(insn, 15, 5);
+    const regid_t rs2 = bit_cut(insn, 20, 5);
+    const uint32_t funct7 = insn >> 25;
+    if (likely(fpu_is_enabled(vm))) switch (funct7) {
+        case RISCV_FADD_S:
+            fpu_write_s(vm, rds, fpu_read_s(vm, rs1) + fpu_read_s(vm, rs2));
+            return;
+        case RISCV_FADD_D:
+            fpu_write_d(vm, rds, fpu_read_d(vm, rs1) + fpu_read_d(vm, rs2));
+            return;
+        case RISCV_FSUB_S:
+            fpu_write_s(vm, rds, fpu_read_s(vm, rs1) - fpu_read_s(vm, rs2));
+            return;
+        case RISCV_FSUB_D:
+            fpu_write_d(vm, rds, fpu_read_d(vm, rs1) - fpu_read_d(vm, rs2));
+            return;
+        case RISCV_FMUL_S:
+            fpu_write_s(vm, rds, fpu_read_s(vm, rs1) * fpu_read_s(vm, rs2));
+            return;
+        case RISCV_FMUL_D:
+            fpu_write_d(vm, rds, fpu_read_d(vm, rs1) * fpu_read_d(vm, rs2));
+            return;
+        case RISCV_FDIV_S:
+            fpu_write_s(vm, rds, fpu_read_s(vm, rs1) / fpu_read_s(vm, rs2));
+            return;
+        case RISCV_FDIV_D:
+            fpu_write_d(vm, rds, fpu_read_d(vm, rs1) / fpu_read_d(vm, rs2));
+            return;
+        case RISCV_FSQRT_S:
+            if (likely(rs2 == 0)) {
+                fpu_write_s(vm, rds, fpu_sqrtf(fpu_read_s(vm, rs1)));
+                return;
+            }
+            break;
+        case RISCV_FSQRT_D:
+            if (likely(rs2 == 0)) {
+                fpu_write_d(vm, rds, fpu_sqrtd(fpu_read_d(vm, rs1)));
+                return;
+            }
+            break;
+        case RISCV_FSGNJ_S:
+            switch (rm) {
+                case 0x0: // fsgnj.s
+                    fpu_emit_s(vm, rds, fpu_copysignf(fpu_read_s(vm, rs1), fpu_read_s(vm, rs2)));
+                    return;
+                case 0x1: // fsgnjn.s
+                    fpu_emit_s(vm, rds, fpu_copysignf(fpu_read_s(vm, rs1), -fpu_read_s(vm, rs2)));
+                    return;
+                case 0x2: // fsgnjx.s
+                    fpu_emit_s(vm, rds, fpu_copysignxf(fpu_read_s(vm, rs1), fpu_read_s(vm, rs2)));
+                    return;
+            }
+            break;
+        case RISCV_FSGNJ_D:
+            switch (rm) {
+                case 0x0: // fsgnj.d
+                    fpu_emit_d(vm, rds, fpu_copysignd(fpu_read_d(vm, rs1), fpu_read_d(vm, rs2)));
+                    return;
+                case 0x1: // fsgnjn.d
+                    fpu_emit_d(vm, rds, fpu_copysignd(fpu_read_d(vm, rs1), -fpu_read_d(vm, rs2)));
+                    return;
+                case 0x2: // fsgnjx.d
+                    fpu_emit_d(vm, rds, fpu_copysignxd(fpu_read_d(vm, rs1), fpu_read_d(vm, rs2)));
+                    return;
+            }
+            break;
+        case RISCV_FCLAMP_S:
+            switch (rm) {
+                case 0x0: // fmin.s
+                    fpu_write_s(vm, rds, fpu_minf(fpu_read_s(vm, rs1), fpu_read_s(vm, rs2)));
+                    return;
+                case 0x1: // fmax.s
+                    fpu_write_s(vm, rds, fpu_maxf(fpu_read_s(vm, rs1), fpu_read_s(vm, rs2)));
+                    return;
+            }
+            break;
+        case RISCV_FCLAMP_D:
+            switch (rm) {
+                case 0x0: // fmin.d
+                    fpu_write_d(vm, rds, fpu_mind(fpu_read_d(vm, rs1), fpu_read_d(vm, rs2)));
+                    return;
+                case 0x1: // fmax.d
+                    fpu_write_d(vm, rds, fpu_maxd(fpu_read_d(vm, rs1), fpu_read_d(vm, rs2)));
+                    return;
+            }
+            break;
+        case RISCV_FCVT_S_D:
+            if (likely(rs2 == 1)) {
+                fpu_write_s(vm, rds, fpu_read_d(vm, rs1));
+                return;
+            }
+            break;
+        case RISCV_FCVT_D_S:
+            if (likely(rs2 == 0)) {
+                fpu_write_d(vm, rds, (double)fpu_read_s(vm, rs1));
+                return;
+            }
+            break;
+        case RISCV_FCVT_W_S:
+            switch (rs2) {
+                case 0x0: // fcvt.w.s
+                    riscv_write_reg(vm, rds, fpu_f2int_i32(fpu_read_s(vm, rs1), rm));
+                    return;
+                case 0x1: // fcvt.wu.s
+                    riscv_write_reg(vm, rds, fpu_f2int_u32(fpu_read_s(vm, rs1), rm));
+                    return;
+#ifdef RV64
+                case 0x2: // fcvt.l.s
+                    riscv_write_reg(vm, rds, fpu_f2int_i64(fpu_read_s(vm, rs1), rm));
+                    return;
+                case 0x3: // fcvt.lu.s
+                    riscv_write_reg(vm, rds, fpu_f2int_u64(fpu_read_s(vm, rs1), rm));
+                    return;
+#endif
+            }
+            break;
+        case RISCV_FCVT_W_D:
+            switch (rs2) {
+                case 0x0: // fcvt.w.d
+                    riscv_write_reg(vm, rds, fpu_d2int_i32(fpu_read_d(vm, rs1), rm));
+                    return;
+                case 0x1: // fcvt.wu.d
+                    riscv_write_reg(vm, rds, fpu_d2int_u32(fpu_read_d(vm, rs1), rm));
+                    return;
+#ifdef RV64
+                case 0x2: // fcvt.l.d
+                    riscv_write_reg(vm, rds, fpu_d2int_i64(fpu_read_d(vm, rs1), rm));
+                    return;
+                case 0x3: // fcvt.lu.d
+                    riscv_write_reg(vm, rds, fpu_d2int_u64(fpu_read_d(vm, rs1), rm));
+                    return;
+#endif
+            }
+            break;
+        case RISCV_FMVCLS_S:
+            if (likely(rs2 == 0)) {
+                switch (rm) {
+                    case 0x0: // fmv.x.w
+                        riscv_write_reg(vm, rds, fpu_bitcast_fp2int_32(fpu_view_s(vm, rs1)));
+                        return;
+                    case 0x1: // fclass.s
+                        riscv_write_reg(vm, rds, 1U << fpu_fclassf(fpu_view_s(vm, rs1)));
+                        return;
+                }
+            }
+            break;
+        case RISCV_FMVCLS_D:
+            if (likely(rs2 == 0)) {
+                switch (rm) {
+#ifdef RV64
+                    case 0x0: // fmv.x.d
+                        riscv_write_reg(vm, rds, fpu_bitcast_fp2int_64(fpu_read_d(vm, rs1)));
+                        return;
+#endif
+                    case 0x1: // fclass.d
+                        riscv_write_reg(vm, rds, 1U << fpu_fclassd(fpu_read_d(vm, rs1)));
+                        return;
+                }
+            }
+            break;
+        case RISCV_FCMP_S:
+            switch (rm) {
+                case 0x0: // fle.s
+                    riscv_write_reg(vm, rds, fpu_read_s(vm, rs1) <= fpu_read_s(vm, rs2));
+                    return;
+                case 0x1: // flt.s
+                    riscv_write_reg(vm, rds, fpu_read_s(vm, rs1) < fpu_read_s(vm, rs2));
+                    return;
+                case 0x2: // feq.s
+                    riscv_write_reg(vm, rds, fpu_read_s(vm, rs1) == fpu_read_s(vm, rs2));
+                    return;
+            }
+            break;
+        case RISCV_FCMP_D:
+            switch (rm) {
+                case 0x0: // fle.d
+                    riscv_write_reg(vm, rds, fpu_read_d(vm, rs1) <= fpu_read_d(vm, rs2));
+                    return;
+                case 0x1: // flt.d
+                    riscv_write_reg(vm, rds, fpu_read_d(vm, rs1) < fpu_read_d(vm, rs2));
+                    return;
+                case 0x2: // feq.d
+                    riscv_write_reg(vm, rds, fpu_read_d(vm, rs1) == fpu_read_d(vm, rs2));
+                    return;
+            }
+            break;
+        case RISCV_FCVT_S_W:
+            switch (rs2) {
+                case 0x0: // fcvt.s.w
+                    fpu_write_s(vm, rds, (float)(int32_t)riscv_read_reg(vm, rs1));
+                    return;
+                case 0x1: // fcvt.s.wu
+                    fpu_write_s(vm, rds, (float)(uint32_t)riscv_read_reg(vm, rs1));
+                    return;
+#ifdef RV64
+                case 0x2: // fcvt.s.l
+                    fpu_write_s(vm, rds, (float)(int64_t)riscv_read_reg(vm, rs1));
+                    return;
+                case 0x3: // fcvt.s.lu
+                    fpu_write_s(vm, rds, (float)(uint64_t)riscv_read_reg(vm, rs1));
+                    return;
+#endif
+            }
+            break;
+        case RISCV_FCVT_D_W:
+            switch (rs2) {
+                case 0x0: // fcvt.d.w
+                    fpu_write_d(vm, rds, (double)(int32_t)riscv_read_reg(vm, rs1));
+                    return;
+                case 0x1: // fcvt.d.wu
+                    fpu_write_d(vm, rds, (double)(uint32_t)riscv_read_reg(vm, rs1));
+                    return;
+#ifdef RV64
+                case 0x2: // fcvt.d.l
+                    fpu_write_d(vm, rds, (double)(int64_t)riscv_read_reg(vm, rs1));
+                    return;
+                case 0x3: // fcvt.d.lu
+                    fpu_write_d(vm, rds, (double)(uint64_t)riscv_read_reg(vm, rs1));
+                    return;
+#endif
+            }
+            break;
+        case RISCV_FMV_W_X:
+            if (likely(rs2 == 0 && rm == 0)) {
+                fpu_emit_s(vm, rds, fpu_bitcast_int2fp_32(riscv_read_reg(vm, rs1)));
+                return;
+            }
+            break;
+#ifdef RV64
+        case RISCV_FMV_D_X:
+            if (likely(rs2 == 0 && rm == 0)) {
+                fpu_emit_d(vm, rds, fpu_bitcast_int2fp_64(riscv_read_reg(vm, rs1)));
+                return;
+            }
+            break;
+#endif
+    }
+    riscv_illegal_insn(vm, insn);
+}
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/cpu/riscv_interpreter.c b/app/src/main/java/libengine/RVVM/src/cpu/riscv_interpreter.c
new file mode 100644
index 00000000..171dd343
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/cpu/riscv_interpreter.c
@@ -0,0 +1,19 @@
+/*
+riscv_interpreter.c - RISC-V 32-bit template interpreter
+Copyright (C) 2024  LekKit <github.com/LekKit>
+
+This Source Code Form is subject to the terms of the Mozilla Public
+License, v. 2.0. If a copy of the MPL was not distributed with this
+file, You can obtain one at https://mozilla.org/MPL/2.0/.
+
+Alternatively, the contents of this file may be used under the terms
+of the GNU General Public License as published by the Free Software
+Foundation, either version 3 of the License, or any later version.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#define riscv_run_interpreter riscv32_run_interpreter
+
+#include "riscv_interpreter.h"
diff --git a/app/src/main/java/libengine/RVVM/src/cpu/riscv_interpreter.h b/app/src/main/java/libengine/RVVM/src/cpu/riscv_interpreter.h
new file mode 100644
index 00000000..bf3bb5a4
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/cpu/riscv_interpreter.h
@@ -0,0 +1,118 @@
+/*
+riscv_interpreter.h - RISC-V Template interpreter
+Copyright (C) 2024  LekKit <github.com/LekKit>
+
+This Source Code Form is subject to the terms of the Mozilla Public
+License, v. 2.0. If a copy of the MPL was not distributed with this
+file, You can obtain one at https://mozilla.org/MPL/2.0/.
+
+Alternatively, the contents of this file may be used under the terms
+of the GNU General Public License as published by the Free Software
+Foundation, either version 3 of the License, or any later version.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef RISCV_INTERPRETER_H
+#define RISCV_INTERPRETER_H
+
+#include "../rvvm.h"
+#include "../riscv_cpu.h"
+#include "../riscv_hart.h"
+#include "../riscv_mmu.h"
+#include "riscv_jit.h"
+#include "../compiler.h"
+#include "../bit_ops.h"
+
+/*
+ * Interpreter helpers
+ */
+
+#ifdef RV64
+
+typedef uint64_t xlen_t;
+typedef int64_t sxlen_t;
+typedef uint64_t xaddr_t;
+#define SHAMT_BITS 6
+#define DIV_OVERFLOW_RS1 ((sxlen_t)0x8000000000000000ULL)
+
+#else
+
+typedef uint32_t xlen_t;
+typedef int32_t sxlen_t;
+typedef uint32_t xaddr_t;
+#define SHAMT_BITS 5
+#define DIV_OVERFLOW_RS1 ((sxlen_t)0x80000000U)
+
+#endif
+
+static forceinline xlen_t riscv_read_reg(rvvm_hart_t* vm, regid_t reg)
+{
+    return vm->registers[reg];
+}
+
+static forceinline sxlen_t riscv_read_reg_s(rvvm_hart_t* vm, regid_t reg)
+{
+    return vm->registers[reg];
+}
+
+static forceinline void riscv_write_reg(rvvm_hart_t* vm, regid_t reg, sxlen_t data)
+{
+    vm->registers[reg] = data;
+}
+
+// Provides entry point to riscv_emulate_insn()
+#include "riscv_compressed.h"
+
+/*
+ * JIT glue
+ */
+
+static forceinline void riscv_emulate(rvvm_hart_t *vm, const uint32_t instruction)
+{
+#if defined(USE_JIT) && (defined(RVJIT_NATIVE_64BIT) || !defined(RV64))
+    if (unlikely(vm->jit_compiling)) {
+        // If we hit non-compilable instruction or cross page boundaries, the block is finalized.
+        if (vm->block_ends || (vm->jit.virt_pc >> MMU_PAGE_SHIFT) != (vm->registers[REGISTER_PC] >> MMU_PAGE_SHIFT)) {
+            riscv_jit_finalize(vm);
+        }
+        vm->block_ends = true;
+    }
+#endif
+    riscv_emulate_insn(vm, instruction);
+}
+
+/*
+ * Optimized dispatch loop that does not fetch each instruction,
+ * and invokes MMU on page change instead.
+ * This gains us about 40-60% more performance depending on workload.
+ * Attention: Any TLB flush must clear vm->wait_event to
+ * restart dispatch loop, otherwise it will continue executing current page
+ */
+
+TSAN_SUPPRESS void riscv_run_interpreter(rvvm_hart_t* vm)
+{
+    size_t inst_ptr = 0;  // Updated before any read
+    uint32_t instruction = 0;
+    // page_addr should always mismatch pc by at least 1 page before execution
+    xlen_t page_addr = vm->registers[REGISTER_PC] + 0x1000;
+
+    // Execute instructions loop until some event occurs (interrupt, trap)
+    while (likely(vm->wait_event)) {
+        xlen_t inst_addr = vm->registers[REGISTER_PC];
+        if (likely(inst_addr - page_addr < 0xFFD)) {
+            instruction = read_uint32_le_m((vmptr_t)(size_t)(inst_ptr + TLB_VADDR(inst_addr)));
+        } else if (likely(riscv_fetch_inst(vm, inst_addr, &instruction))) {
+            // Update pointer to the current page in real memory
+            // If we are executing code from MMIO, direct memory fetch fails
+            const xlen_t vpn = vm->registers[REGISTER_PC] >> 12;
+            inst_ptr = vm->tlb[vpn & TLB_MASK].ptr;
+            page_addr = vm->tlb[vpn & TLB_MASK].e << 12;
+        } else break;
+        vm->registers[REGISTER_ZERO] = 0;
+        riscv_emulate(vm, instruction);
+    }
+}
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/cpu/riscv_jit.h b/app/src/main/java/libengine/RVVM/src/cpu/riscv_jit.h
new file mode 100644
index 00000000..5015c947
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/cpu/riscv_jit.h
@@ -0,0 +1,408 @@
+/*
+riscv_jit.h - RVJIT Tracing integration
+Copyright (C) 2024  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef RISCV_JIT_H
+#define RISCV_JIT_H
+
+#if defined(USE_JIT) && (!defined(RV64) || defined(RVJIT_NATIVE_64BIT))
+
+#include "../rvjit/rvjit_emit.h"
+
+// Block unrolling configuration
+#define UNROLL_MAX_BLOCK_SIZE 256
+
+/*
+ * RVJIT tracing helpers
+ */
+
+// Wraps trace-compile-trace-execute
+#define RVVM_RVJIT_TRACE(intrinsic, insn_size) \
+do { \
+    if (!vm->jit_compiling && riscv_jit_tlb_lookup(vm)) { \
+        vm->registers[REGISTER_PC] -= insn_size; \
+        return; \
+    } \
+    if (unlikely(vm->jit_compiling)) { \
+        intrinsic; \
+        vm->jit.pc_off += insn_size; \
+        vm->block_ends = false; \
+    } \
+} while (0)
+
+/*
+ * Load/store instructions are not trivially traceable - they may trigger a TLB miss
+ * exactly at the beggining of the block, thus failing to progress forward.
+ * If the PC is unchanged after executing the block, load/store tracing is disabled
+ * and instruction is interpreted, refilling the TLB.
+ *
+ * This may be also solved by resetting ldst_trace flag from JITed code upon TLB miss.
+ */
+#define RVVM_RVJIT_TRACE_LDST(intrinsic, insn_size) \
+do { \
+    virt_addr_t pc = vm->registers[REGISTER_PC]; \
+    if (!vm->jit_compiling && vm->ldst_trace && riscv_jit_tlb_lookup(vm)) { \
+        vm->ldst_trace = pc != vm->registers[REGISTER_PC]; \
+        vm->registers[REGISTER_PC] -= insn_size; \
+        return; \
+    } \
+    vm->ldst_trace = true; \
+    if (unlikely(vm->jit_compiling)) { \
+        intrinsic; \
+        vm->jit.pc_off += insn_size; \
+        vm->block_ends = false; \
+    } \
+} while (0)
+
+// JAL instruction applies jump offset to pc_off
+// We already check page cross in riscv_emulate()
+#define RVVM_RVJIT_TRACE_JAL(intrinsic, offset, insn_size) \
+do { \
+    if (!vm->jit_compiling && riscv_jit_tlb_lookup(vm)) { \
+        vm->registers[REGISTER_PC] -= insn_size; \
+        return; \
+    } \
+    if (unlikely(vm->jit_compiling)) { \
+        intrinsic; \
+        vm->jit.pc_off += offset; \
+        vm->block_ends = vm->jit.size > UNROLL_MAX_BLOCK_SIZE; \
+    } \
+} while (0)
+
+// Blocks immediately ends upon indirect jump (thus no need to trace it)
+#define RVVM_RVJIT_TRACE_JALR(intrinsic) \
+do { \
+    if (unlikely(vm->jit_compiling)) { \
+        intrinsic; \
+    } \
+} while (0)
+
+// Branches taken in interpreter are treated as likely branches and inlined
+#define RVVM_RVJIT_TRACE_BRANCH(intrinsic, target_off, falthrough_off, insn_size) \
+do { \
+    if (!vm->jit_compiling && riscv_jit_tlb_lookup(vm)) { \
+        vm->registers[REGISTER_PC] -= insn_size; \
+        return; \
+    } \
+    if (unlikely(vm->jit_compiling)) { \
+        vm->jit.pc_off += falthrough_off; \
+        intrinsic; \
+        vm->jit.pc_off += (target_off - falthrough_off); \
+        vm->block_ends = vm->jit.size > UNROLL_MAX_BLOCK_SIZE; \
+    } \
+} while (0)
+
+#else
+
+#define RVVM_RVJIT_TRACE(intrinsic, insn_size)
+#define RVVM_RVJIT_TRACE_LDST(intrinsic, insn_size)
+#define RVVM_RVJIT_TRACE_JAL(intrinsic, imm, insn_size)
+#define RVVM_RVJIT_TRACE_JALR(intrinsic)
+#define RVVM_RVJIT_TRACE_BRANCH(intrinsic, target_off, fallthrough_off, insn_size)
+
+#endif
+
+/*
+ * Bitmanip helpers
+ */
+
+#ifdef RVJIT_NATIVE_BITMANIP
+#define RVVM_RVJIT_TRACE_BITMANIP(intrinsic, insn_size) RVVM_RVJIT_TRACE(intrinsic, insn_size)
+#else
+#define RVVM_RVJIT_TRACE_BITMANIP(intrinsic, insn_size)
+#endif
+
+/*
+ * FPU tracing helpers
+ */
+
+#ifdef RVJIT_NATIVE_FPU
+#define RVVM_RVJIT_TRACE_FPU(intrinsic, insn_size)      RVVM_RVJIT_TRACE(intrinsic, insn_size)
+#define RVVM_RVJIT_TRACE_FPU_LDST(intrinsic, insn_size) RVVM_RVJIT_TRACE_LDST(intrinsic, insn_size)
+#else
+#define RVVM_RVJIT_TRACE_FPU(intrinsic, insn_size)
+#define RVVM_RVJIT_TRACE_FPU_LDST(intrinsic, insn_size)
+#endif
+
+/*
+ * RVJIT tracing intrinsics used by the interpreter
+ */
+
+#ifdef RV64
+
+// RV64IC
+#define rvjit_trace_add(rds, rs1, rs2, size)   RVVM_RVJIT_TRACE(rvjit64_add(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_sub(rds, rs1, rs2, size)   RVVM_RVJIT_TRACE(rvjit64_sub(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_or(rds, rs1, rs2, size)    RVVM_RVJIT_TRACE(rvjit64_or(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_and(rds, rs1, rs2, size)   RVVM_RVJIT_TRACE(rvjit64_and(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_xor(rds, rs1, rs2, size)   RVVM_RVJIT_TRACE(rvjit64_xor(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_sra(rds, rs1, rs2, size)   RVVM_RVJIT_TRACE(rvjit64_sra(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_srl(rds, rs1, rs2, size)   RVVM_RVJIT_TRACE(rvjit64_srl(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_sll(rds, rs1, rs2, size)   RVVM_RVJIT_TRACE(rvjit64_sll(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_addi(rds, rs1, imm, size)  RVVM_RVJIT_TRACE(rvjit64_addi(&vm->jit, rds, rs1, imm), size)
+#define rvjit_trace_ori(rds, rs1, imm, size)   RVVM_RVJIT_TRACE(rvjit64_ori(&vm->jit, rds, rs1, imm), size)
+#define rvjit_trace_andi(rds, rs1, imm, size)  RVVM_RVJIT_TRACE(rvjit64_andi(&vm->jit, rds, rs1, imm), size)
+#define rvjit_trace_xori(rds, rs1, imm, size)  RVVM_RVJIT_TRACE(rvjit64_xori(&vm->jit, rds, rs1, imm), size)
+#define rvjit_trace_srai(rds, rs1, imm, size)  RVVM_RVJIT_TRACE(rvjit64_srai(&vm->jit, rds, rs1, imm), size)
+#define rvjit_trace_srli(rds, rs1, imm, size)  RVVM_RVJIT_TRACE(rvjit64_srli(&vm->jit, rds, rs1, imm), size)
+#define rvjit_trace_slli(rds, rs1, imm, size)  RVVM_RVJIT_TRACE(rvjit64_slli(&vm->jit, rds, rs1, imm), size)
+#define rvjit_trace_slti(rds, rs1, imm, size)  RVVM_RVJIT_TRACE(rvjit64_slti(&vm->jit, rds, rs1, imm), size)
+#define rvjit_trace_sltiu(rds, rs1, imm, size) RVVM_RVJIT_TRACE(rvjit64_sltiu(&vm->jit, rds, rs1, imm), size)
+#define rvjit_trace_slt(rds, rs1, rs2, size)   RVVM_RVJIT_TRACE(rvjit64_slt(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_sltu(rds, rs1, rs2, size)  RVVM_RVJIT_TRACE(rvjit64_sltu(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_li(rds, imm, size)         RVVM_RVJIT_TRACE(rvjit64_li(&vm->jit, rds, imm), size)
+#define rvjit_trace_auipc(rds, imm, size)      RVVM_RVJIT_TRACE(rvjit64_auipc(&vm->jit, rds, imm), size)
+#define rvjit_trace_jal(rds, imm, size)        RVVM_RVJIT_TRACE_JAL(rvjit64_auipc(&vm->jit, rds, size), imm, size)
+#define rvjit_trace_jalr(rds, rs, imm, size)   RVVM_RVJIT_TRACE_JALR(rvjit64_jalr(&vm->jit, rds, rs, imm, size))
+
+#define rvjit_trace_addw(rds, rs1, rs2, size)  RVVM_RVJIT_TRACE(rvjit64_addw(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_subw(rds, rs1, rs2, size)  RVVM_RVJIT_TRACE(rvjit64_subw(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_sraw(rds, rs1, rs2, size)  RVVM_RVJIT_TRACE(rvjit64_sraw(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_srlw(rds, rs1, rs2, size)  RVVM_RVJIT_TRACE(rvjit64_srlw(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_sllw(rds, rs1, rs2, size)  RVVM_RVJIT_TRACE(rvjit64_sllw(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_addiw(rds, rs1, imm, size) RVVM_RVJIT_TRACE(rvjit64_addiw(&vm->jit, rds, rs1, imm), size)
+#define rvjit_trace_sraiw(rds, rs1, imm, size) RVVM_RVJIT_TRACE(rvjit64_sraiw(&vm->jit, rds, rs1, imm), size)
+#define rvjit_trace_srliw(rds, rs1, imm, size) RVVM_RVJIT_TRACE(rvjit64_srliw(&vm->jit, rds, rs1, imm), size)
+#define rvjit_trace_slliw(rds, rs1, imm, size) RVVM_RVJIT_TRACE(rvjit64_slliw(&vm->jit, rds, rs1, imm), size)
+
+#define rvjit_trace_sb(rds, rs1, off, size)    RVVM_RVJIT_TRACE_LDST(rvjit64_sb(&vm->jit, rds, rs1, off), size)
+#define rvjit_trace_lb(rds, rs1, off, size)    RVVM_RVJIT_TRACE_LDST(rvjit64_lb(&vm->jit, rds, rs1, off), size)
+#define rvjit_trace_lbu(rds, rs1, off, size)   RVVM_RVJIT_TRACE_LDST(rvjit64_lbu(&vm->jit, rds, rs1, off), size)
+#define rvjit_trace_sh(rds, rs1, off, size)    RVVM_RVJIT_TRACE_LDST(rvjit64_sh(&vm->jit, rds, rs1, off), size)
+#define rvjit_trace_lh(rds, rs1, off, size)    RVVM_RVJIT_TRACE_LDST(rvjit64_lh(&vm->jit, rds, rs1, off), size)
+#define rvjit_trace_lhu(rds, rs1, off, size)   RVVM_RVJIT_TRACE_LDST(rvjit64_lhu(&vm->jit, rds, rs1, off), size)
+#define rvjit_trace_sw(rds, rs1, off, size)    RVVM_RVJIT_TRACE_LDST(rvjit64_sw(&vm->jit, rds, rs1, off), size)
+#define rvjit_trace_lw(rds, rs1, off, size)    RVVM_RVJIT_TRACE_LDST(rvjit64_lw(&vm->jit, rds, rs1, off), size)
+#define rvjit_trace_lwu(rds, rs1, off, size)   RVVM_RVJIT_TRACE_LDST(rvjit64_lwu(&vm->jit, rds, rs1, off), size)
+#define rvjit_trace_sd(rds, rs1, off, size)    RVVM_RVJIT_TRACE_LDST(rvjit64_sd(&vm->jit, rds, rs1, off), size)
+#define rvjit_trace_ld(rds, rs1, off, size)    RVVM_RVJIT_TRACE_LDST(rvjit64_ld(&vm->jit, rds, rs1, off), size)
+
+#define rvjit_trace_beq(rs1, rs2, t, f, i)     RVVM_RVJIT_TRACE_BRANCH(rvjit64_beq(&vm->jit, rs1, rs2), t, f, i)
+#define rvjit_trace_bne(rs1, rs2, t, f, i)     RVVM_RVJIT_TRACE_BRANCH(rvjit64_bne(&vm->jit, rs1, rs2), t, f, i)
+#define rvjit_trace_blt(rs1, rs2, t, f, i)     RVVM_RVJIT_TRACE_BRANCH(rvjit64_blt(&vm->jit, rs1, rs2), t, f, i)
+#define rvjit_trace_bge(rs1, rs2, t, f, i)     RVVM_RVJIT_TRACE_BRANCH(rvjit64_bge(&vm->jit, rs1, rs2), t, f, i)
+#define rvjit_trace_bltu(rs1, rs2, t, f, i)    RVVM_RVJIT_TRACE_BRANCH(rvjit64_bltu(&vm->jit, rs1, rs2), t, f, i)
+#define rvjit_trace_bgeu(rs1, rs2, t, f, i)    RVVM_RVJIT_TRACE_BRANCH(rvjit64_bgeu(&vm->jit, rs1, rs2), t, f, i)
+
+// RV64M
+#define rvjit_trace_mul(rds, rs1, rs2, size)    RVVM_RVJIT_TRACE(rvjit64_mul(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_mulh(rds, rs1, rs2, size)   RVVM_RVJIT_TRACE(rvjit64_mulh(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_mulhu(rds, rs1, rs2, size)  RVVM_RVJIT_TRACE(rvjit64_mulhu(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_mulhsu(rds, rs1, rs2, size) RVVM_RVJIT_TRACE(rvjit64_mulhsu(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_mulw(rds, rs1, rs2, size)   RVVM_RVJIT_TRACE(rvjit64_mulw(&vm->jit, rds, rs1, rs2), size)
+
+#define rvjit_trace_div(rds, rs1, rs2, size)    RVVM_RVJIT_TRACE(rvjit64_div(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_divu(rds, rs1, rs2, size)   RVVM_RVJIT_TRACE(rvjit64_divu(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_rem(rds, rs1, rs2, size)    RVVM_RVJIT_TRACE(rvjit64_rem(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_remu(rds, rs1, rs2, size)   RVVM_RVJIT_TRACE(rvjit64_remu(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_divw(rds, rs1, rs2, size)   RVVM_RVJIT_TRACE(rvjit64_divw(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_divuw(rds, rs1, rs2, size)  RVVM_RVJIT_TRACE(rvjit64_divuw(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_remw(rds, rs1, rs2, size)   RVVM_RVJIT_TRACE(rvjit64_remw(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_remuw(rds, rs1, rs2, size)  RVVM_RVJIT_TRACE(rvjit64_remuw(&vm->jit, rds, rs1, rs2), size)
+
+// RV64 Zba
+#define rvjit_trace_shadd(rds, rs1, rs2, shift, size)    RVVM_RVJIT_TRACE_BITMANIP(rvjit64_shadd(&vm->jit, rds, rs1, rs2, shift), size)
+#define rvjit_trace_shadd_uw(rds, rs1, rs2, shift, size) RVVM_RVJIT_TRACE_BITMANIP(rvjit64_shadd_uw(&vm->jit, rds, rs1, rs2, shift), size)
+#define rvjit_trace_slli_uw(rds, rs1, imm, size)         RVVM_RVJIT_TRACE_BITMANIP(rvjit64_slli_uw(&vm->jit, rds, rs1, imm), size)
+
+// RV64 Zbb
+#define rvjit_trace_rol(rds, rs1, rs2, size)    RVVM_RVJIT_TRACE_BITMANIP(rvjit64_rol(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_rolw(rds, rs1, rs2, size)   RVVM_RVJIT_TRACE_BITMANIP(rvjit64_rolw(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_ror(rds, rs1, rs2, size)    RVVM_RVJIT_TRACE_BITMANIP(rvjit64_ror(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_rorw(rds, rs1, rs2, size)   RVVM_RVJIT_TRACE_BITMANIP(rvjit64_rorw(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_rori(rds, rs1, imm, size)   RVVM_RVJIT_TRACE_BITMANIP(rvjit64_rori(&vm->jit, rds, rs1, imm), size)
+#define rvjit_trace_roriw(rds, rs1, imm, size)  RVVM_RVJIT_TRACE_BITMANIP(rvjit64_roriw(&vm->jit, rds, rs1, imm), size)
+#define rvjit_trace_andn(rds, rs1, rs2, size)   RVVM_RVJIT_TRACE_BITMANIP(rvjit64_andn(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_orn(rds, rs1, rs2, size)    RVVM_RVJIT_TRACE_BITMANIP(rvjit64_orn(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_xnor(rds, rs1, rs2, size)   RVVM_RVJIT_TRACE_BITMANIP(rvjit64_xnor(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_max(rds, rs1, rs2, size)    RVVM_RVJIT_TRACE_BITMANIP(rvjit64_max(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_maxu(rds, rs1, rs2, size)   RVVM_RVJIT_TRACE_BITMANIP(rvjit64_maxu(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_min(rds, rs1, rs2, size)    RVVM_RVJIT_TRACE_BITMANIP(rvjit64_min(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_minu(rds, rs1, rs2, size)   RVVM_RVJIT_TRACE_BITMANIP(rvjit64_minu(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_sext_b(rds, rs1, size)      RVVM_RVJIT_TRACE_BITMANIP(rvjit64_sext_b(&vm->jit, rds, rs1), size)
+#define rvjit_trace_sext_h(rds, rs1, size)      RVVM_RVJIT_TRACE_BITMANIP(rvjit64_sext_h(&vm->jit, rds, rs1), size)
+
+// RV64 Zbs
+#define rvjit_trace_bext(rds, rs1, rs2, size)   RVVM_RVJIT_TRACE_BITMANIP(rvjit64_bext(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_bexti(rds, rs1, imm, size)  RVVM_RVJIT_TRACE_BITMANIP(rvjit64_bexti(&vm->jit, rds, rs1, imm), size)
+#define rvjit_trace_bclr(rds, rs1, rs2, size)   RVVM_RVJIT_TRACE_BITMANIP(rvjit64_bclr(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_bclri(rds, rs1, imm, size)  RVVM_RVJIT_TRACE_BITMANIP(rvjit64_bclri(&vm->jit, rds, rs1, imm), size)
+#define rvjit_trace_bset(rds, rs1, rs2, size)   RVVM_RVJIT_TRACE_BITMANIP(rvjit64_bset(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_bseti(rds, rs1, imm, size)  RVVM_RVJIT_TRACE_BITMANIP(rvjit64_bseti(&vm->jit, rds, rs1, imm), size)
+#define rvjit_trace_binv(rds, rs1, rs2, size)   RVVM_RVJIT_TRACE_BITMANIP(rvjit64_binv(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_binvi(rds, rs1, imm, size)  RVVM_RVJIT_TRACE_BITMANIP(rvjit64_binvi(&vm->jit, rds, rs1, imm), size)
+
+#else
+
+// RV32IC
+#define rvjit_trace_add(rds, rs1, rs2, size)   RVVM_RVJIT_TRACE(rvjit32_add(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_sub(rds, rs1, rs2, size)   RVVM_RVJIT_TRACE(rvjit32_sub(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_or(rds, rs1, rs2, size)    RVVM_RVJIT_TRACE(rvjit32_or(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_and(rds, rs1, rs2, size)   RVVM_RVJIT_TRACE(rvjit32_and(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_xor(rds, rs1, rs2, size)   RVVM_RVJIT_TRACE(rvjit32_xor(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_sra(rds, rs1, rs2, size)   RVVM_RVJIT_TRACE(rvjit32_sra(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_srl(rds, rs1, rs2, size)   RVVM_RVJIT_TRACE(rvjit32_srl(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_sll(rds, rs1, rs2, size)   RVVM_RVJIT_TRACE(rvjit32_sll(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_addi(rds, rs1, imm, size)  RVVM_RVJIT_TRACE(rvjit32_addi(&vm->jit, rds, rs1, imm), size)
+#define rvjit_trace_ori(rds, rs1, imm, size)   RVVM_RVJIT_TRACE(rvjit32_ori(&vm->jit, rds, rs1, imm), size)
+#define rvjit_trace_andi(rds, rs1, imm, size)  RVVM_RVJIT_TRACE(rvjit32_andi(&vm->jit, rds, rs1, imm), size)
+#define rvjit_trace_xori(rds, rs1, imm, size)  RVVM_RVJIT_TRACE(rvjit32_xori(&vm->jit, rds, rs1, imm), size)
+#define rvjit_trace_srai(rds, rs1, imm, size)  RVVM_RVJIT_TRACE(rvjit32_srai(&vm->jit, rds, rs1, imm), size)
+#define rvjit_trace_srli(rds, rs1, imm, size)  RVVM_RVJIT_TRACE(rvjit32_srli(&vm->jit, rds, rs1, imm), size)
+#define rvjit_trace_slli(rds, rs1, imm, size)  RVVM_RVJIT_TRACE(rvjit32_slli(&vm->jit, rds, rs1, imm), size)
+#define rvjit_trace_slti(rds, rs1, imm, size)  RVVM_RVJIT_TRACE(rvjit32_slti(&vm->jit, rds, rs1, imm), size)
+#define rvjit_trace_sltiu(rds, rs1, imm, size) RVVM_RVJIT_TRACE(rvjit32_sltiu(&vm->jit, rds, rs1, imm), size)
+#define rvjit_trace_slt(rds, rs1, rs2, size)   RVVM_RVJIT_TRACE(rvjit32_slt(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_sltu(rds, rs1, rs2, size)  RVVM_RVJIT_TRACE(rvjit32_sltu(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_li(rds, imm, size)         RVVM_RVJIT_TRACE(rvjit32_li(&vm->jit, rds, imm), size)
+#define rvjit_trace_auipc(rds, imm, size)      RVVM_RVJIT_TRACE(rvjit32_auipc(&vm->jit, rds, imm), size)
+#define rvjit_trace_jal(rds, imm, size)        RVVM_RVJIT_TRACE_JAL(rvjit32_auipc(&vm->jit, rds, size), imm, size)
+#define rvjit_trace_jalr(rds, rs, imm, size)   RVVM_RVJIT_TRACE_JALR(rvjit32_jalr(&vm->jit, rds, rs, imm, size))
+
+#define rvjit_trace_sb(rds, rs1, off, size)    RVVM_RVJIT_TRACE_LDST(rvjit32_sb(&vm->jit, rds, rs1, off), size)
+#define rvjit_trace_lb(rds, rs1, off, size)    RVVM_RVJIT_TRACE_LDST(rvjit32_lb(&vm->jit, rds, rs1, off), size)
+#define rvjit_trace_lbu(rds, rs1, off, size)   RVVM_RVJIT_TRACE_LDST(rvjit32_lbu(&vm->jit, rds, rs1, off), size)
+#define rvjit_trace_sh(rds, rs1, off, size)    RVVM_RVJIT_TRACE_LDST(rvjit32_sh(&vm->jit, rds, rs1, off), size)
+#define rvjit_trace_lh(rds, rs1, off, size)    RVVM_RVJIT_TRACE_LDST(rvjit32_lh(&vm->jit, rds, rs1, off), size)
+#define rvjit_trace_lhu(rds, rs1, off, size)   RVVM_RVJIT_TRACE_LDST(rvjit32_lhu(&vm->jit, rds, rs1, off), size)
+#define rvjit_trace_sw(rds, rs1, off, size)    RVVM_RVJIT_TRACE_LDST(rvjit32_sw(&vm->jit, rds, rs1, off), size)
+#define rvjit_trace_lw(rds, rs1, off, size)    RVVM_RVJIT_TRACE_LDST(rvjit32_lw(&vm->jit, rds, rs1, off), size)
+
+#define rvjit_trace_beq(rs1, rs2, t, f, i)     RVVM_RVJIT_TRACE_BRANCH(rvjit32_beq(&vm->jit, rs1, rs2), t, f, i)
+#define rvjit_trace_bne(rs1, rs2, t, f, i)     RVVM_RVJIT_TRACE_BRANCH(rvjit32_bne(&vm->jit, rs1, rs2), t, f, i)
+#define rvjit_trace_blt(rs1, rs2, t, f, i)     RVVM_RVJIT_TRACE_BRANCH(rvjit32_blt(&vm->jit, rs1, rs2), t, f, i)
+#define rvjit_trace_bge(rs1, rs2, t, f, i)     RVVM_RVJIT_TRACE_BRANCH(rvjit32_bge(&vm->jit, rs1, rs2), t, f, i)
+#define rvjit_trace_bltu(rs1, rs2, t, f, i)    RVVM_RVJIT_TRACE_BRANCH(rvjit32_bltu(&vm->jit, rs1, rs2), t, f, i)
+#define rvjit_trace_bgeu(rs1, rs2, t, f, i)    RVVM_RVJIT_TRACE_BRANCH(rvjit32_bgeu(&vm->jit, rs1, rs2), t, f, i)
+
+// RV32M
+#define rvjit_trace_mul(rds, rs1, rs2, size)    RVVM_RVJIT_TRACE(rvjit32_mul(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_mulh(rds, rs1, rs2, size)   RVVM_RVJIT_TRACE(rvjit32_mulh(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_mulhu(rds, rs1, rs2, size)  RVVM_RVJIT_TRACE(rvjit32_mulhu(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_mulhsu(rds, rs1, rs2, size) RVVM_RVJIT_TRACE(rvjit32_mulhsu(&vm->jit, rds, rs1, rs2), size)
+
+#define rvjit_trace_div(rds, rs1, rs2, size)    RVVM_RVJIT_TRACE(rvjit32_div(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_divu(rds, rs1, rs2, size)   RVVM_RVJIT_TRACE(rvjit32_divu(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_rem(rds, rs1, rs2, size)    RVVM_RVJIT_TRACE(rvjit32_rem(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_remu(rds, rs1, rs2, size)   RVVM_RVJIT_TRACE(rvjit32_remu(&vm->jit, rds, rs1, rs2), size)
+
+// RV32 Zba
+#define rvjit_trace_shadd(rds, rs1, rs2, shift, size)   RVVM_RVJIT_TRACE_BITMANIP(rvjit32_shadd(&vm->jit, rds, rs1, rs2, shift), size)
+
+// RV32 Zbb
+#define rvjit_trace_rol(rds, rs1, rs2, size)    RVVM_RVJIT_TRACE_BITMANIP(rvjit32_rol(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_ror(rds, rs1, rs2, size)    RVVM_RVJIT_TRACE_BITMANIP(rvjit32_ror(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_rori(rds, rs1, imm, size)   RVVM_RVJIT_TRACE_BITMANIP(rvjit32_rori(&vm->jit, rds, rs1, imm), size)
+#define rvjit_trace_andn(rds, rs1, rs2, size)   RVVM_RVJIT_TRACE_BITMANIP(rvjit32_andn(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_orn(rds, rs1, rs2, size)    RVVM_RVJIT_TRACE_BITMANIP(rvjit32_orn(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_xnor(rds, rs1, rs2, size)   RVVM_RVJIT_TRACE_BITMANIP(rvjit32_xnor(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_max(rds, rs1, rs2, size)    RVVM_RVJIT_TRACE_BITMANIP(rvjit32_max(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_maxu(rds, rs1, rs2, size)   RVVM_RVJIT_TRACE_BITMANIP(rvjit32_maxu(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_min(rds, rs1, rs2, size)    RVVM_RVJIT_TRACE_BITMANIP(rvjit32_min(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_minu(rds, rs1, rs2, size)   RVVM_RVJIT_TRACE_BITMANIP(rvjit32_minu(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_sext_b(rds, rs1, size)      RVVM_RVJIT_TRACE_BITMANIP(rvjit32_sext_b(&vm->jit, rds, rs1), size)
+#define rvjit_trace_sext_h(rds, rs1, size)      RVVM_RVJIT_TRACE_BITMANIP(rvjit32_sext_h(&vm->jit, rds, rs1), size)
+
+// RV32 Zbs
+#define rvjit_trace_bext(rds, rs1, rs2, size)   RVVM_RVJIT_TRACE_BITMANIP(rvjit32_bext(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_bexti(rds, rs1, imm, size)  RVVM_RVJIT_TRACE_BITMANIP(rvjit32_bexti(&vm->jit, rds, rs1, imm), size)
+#define rvjit_trace_bclr(rds, rs1, rs2, size)   RVVM_RVJIT_TRACE_BITMANIP(rvjit32_bclr(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_bclri(rds, rs1, imm, size)  RVVM_RVJIT_TRACE_BITMANIP(rvjit32_bclri(&vm->jit, rds, rs1, imm), size)
+#define rvjit_trace_bset(rds, rs1, rs2, size)   RVVM_RVJIT_TRACE_BITMANIP(rvjit32_bset(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_bseti(rds, rs1, imm, size)  RVVM_RVJIT_TRACE_BITMANIP(rvjit32_bseti(&vm->jit, rds, rs1, imm), size)
+#define rvjit_trace_binv(rds, rs1, rs2, size)   RVVM_RVJIT_TRACE_BITMANIP(rvjit32_binv(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_binvi(rds, rs1, imm, size)  RVVM_RVJIT_TRACE_BITMANIP(rvjit32_binvi(&vm->jit, rds, rs1, imm), size)
+
+#endif
+
+// RISC-V FPU
+#define rvjit_trace_fsw(rds, rs1, off, size) RVVM_RVJIT_TRACE_FPU_LDST(rvjit_fsw(&vm->jit, rds, rs1, off), size)
+#define rvjit_trace_flw(rds, rs1, off, size) RVVM_RVJIT_TRACE_FPU_LDST(rvjit_flw(&vm->jit, rds, rs1, off), size)
+#define rvjit_trace_fsd(rds, rs1, off, size) RVVM_RVJIT_TRACE_FPU_LDST(rvjit_fsd(&vm->jit, rds, rs1, off), size)
+#define rvjit_trace_fld(rds, rs1, off, size) RVVM_RVJIT_TRACE_FPU_LDST(rvjit_fld(&vm->jit, rds, rs1, off), size)
+
+#define rvjit_trace_fadd_s(rds, rs1, rs2, size)  RVVM_RVJIT_TRACE_FPU(rvjit_fadd_s(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_fadd_d(rds, rs1, rs2, size)  RVVM_RVJIT_TRACE_FPU(rvjit_fadd_d(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_fsub_s(rds, rs1, rs2, size)  RVVM_RVJIT_TRACE_FPU(rvjit_fsub_s(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_fsub_d(rds, rs1, rs2, size)  RVVM_RVJIT_TRACE_FPU(rvjit_fsub_d(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_fmul_s(rds, rs1, rs2, size)  RVVM_RVJIT_TRACE_FPU(rvjit_fmul_s(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_fmul_d(rds, rs1, rs2, size)  RVVM_RVJIT_TRACE_FPU(rvjit_fmul_d(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_fdiv_s(rds, rs1, rs2, size)  RVVM_RVJIT_TRACE_FPU(rvjit_fdiv_s(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_fdiv_d(rds, rs1, rs2, size)  RVVM_RVJIT_TRACE_FPU(rvjit_fdiv_d(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_fsqrt_s(rds, rs1, size)      RVVM_RVJIT_TRACE_FPU(rvjit_fsqrt_s(&vm->jit, rds, rs1), size)
+#define rvjit_trace_fsqrt_d(rds, rs1, size)      RVVM_RVJIT_TRACE_FPU(rvjit_fsqrt_d(&vm->jit, rds, rs1), size)
+
+#define rvjit_trace_fmadd_s(rds, rs1, rs2, rs3, size)  RVVM_RVJIT_TRACE_FPU(rvjit_fmadd_s(&vm->jit, rds, rs1, rs2, rs3), size)
+#define rvjit_trace_fmadd_d(rds, rs1, rs2, rs3, size)  RVVM_RVJIT_TRACE_FPU(rvjit_fmadd_d(&vm->jit, rds, rs1, rs2, rs3), size)
+#define rvjit_trace_fmsub_s(rds, rs1, rs2, rs3, size)  RVVM_RVJIT_TRACE_FPU(rvjit_fmsub_s(&vm->jit, rds, rs1, rs2, rs3), size)
+#define rvjit_trace_fmsub_d(rds, rs1, rs2, rs3, size)  RVVM_RVJIT_TRACE_FPU(rvjit_fmsub_d(&vm->jit, rds, rs1, rs2, rs3), size)
+#define rvjit_trace_fnmadd_s(rds, rs1, rs2, rs3, size) RVVM_RVJIT_TRACE_FPU(rvjit_fnmadd_s(&vm->jit, rds, rs1, rs2, rs3), size)
+#define rvjit_trace_fnmadd_d(rds, rs1, rs2, rs3, size) RVVM_RVJIT_TRACE_FPU(rvjit_fnmadd_d(&vm->jit, rds, rs1, rs2, rs3), size)
+#define rvjit_trace_fnmsub_s(rds, rs1, rs2, rs3, size) RVVM_RVJIT_TRACE_FPU(rvjit_fnmsub_s(&vm->jit, rds, rs1, rs2, rs3), size)
+#define rvjit_trace_fnmsub_d(rds, rs1, rs2, rs3, size) RVVM_RVJIT_TRACE_FPU(rvjit_fnmsub_d(&vm->jit, rds, rs1, rs2, rs3), size)
+
+#define rvjit_trace_fsgnj_s(rds, rs1, rs2, size)  RVVM_RVJIT_TRACE_FPU(rvjit_fsgnj_s(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_fsgnj_d(rds, rs1, rs2, size)  RVVM_RVJIT_TRACE_FPU(rvjit_fsgnj_d(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_fsgnjn_s(rds, rs1, rs2, size) RVVM_RVJIT_TRACE_FPU(rvjit_fsgnjn_s(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_fsgnjn_d(rds, rs1, rs2, size) RVVM_RVJIT_TRACE_FPU(rvjit_fsgnjn_d(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_fsgnjx_s(rds, rs1, rs2, size) RVVM_RVJIT_TRACE_FPU(rvjit_fsgnjx_s(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_fsgnjx_d(rds, rs1, rs2, size) RVVM_RVJIT_TRACE_FPU(rvjit_fsgnjx_d(&vm->jit, rds, rs1, rs2), size)
+
+#define rvjit_trace_fmin_s(rds, rs1, rs2, size) RVVM_RVJIT_TRACE_FPU(rvjit_fmin_s(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_fmin_d(rds, rs1, rs2, size) RVVM_RVJIT_TRACE_FPU(rvjit_fmin_d(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_fmax_s(rds, rs1, rs2, size) RVVM_RVJIT_TRACE_FPU(rvjit_fmax_s(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_fmax_d(rds, rs1, rs2, size) RVVM_RVJIT_TRACE_FPU(rvjit_fmax_d(&vm->jit, rds, rs1, rs2), size)
+
+#define rvjit_trace_feq_s(rds, rs1, rs2, size) RVVM_RVJIT_TRACE_FPU(rvjit_feq_s(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_feq_d(rds, rs1, rs2, size) RVVM_RVJIT_TRACE_FPU(rvjit_feq_d(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_flt_s(rds, rs1, rs2, size) RVVM_RVJIT_TRACE_FPU(rvjit_flt_s(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_flt_d(rds, rs1, rs2, size) RVVM_RVJIT_TRACE_FPU(rvjit_flt_d(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_fle_s(rds, rs1, rs2, size) RVVM_RVJIT_TRACE_FPU(rvjit_fle_s(&vm->jit, rds, rs1, rs2), size)
+#define rvjit_trace_fle_d(rds, rs1, rs2, size) RVVM_RVJIT_TRACE_FPU(rvjit_fle_d(&vm->jit, rds, rs1, rs2), size)
+
+#define rvjit_trace_fclass_s(rds, rs1, size)  RVVM_RVJIT_TRACE_FPU(rvjit_fclass_s(&vm->jit, rds, rs1), size)
+#define rvjit_trace_fclass_d(rds, rs1, size)  RVVM_RVJIT_TRACE_FPU(rvjit_fclass_d(&vm->jit, rds, rs1), size)
+#define rvjit_trace_fcvt_s_d(rds, rs1, size)  RVVM_RVJIT_TRACE_FPU(rvjit_fcvt_s_d(&vm->jit, rds, rs1), size)
+#define rvjit_trace_fcvt_d_s(rds, rs1, size)  RVVM_RVJIT_TRACE_FPU(rvjit_fcvt_d_s(&vm->jit, rds, rs1), size)
+#define rvjit_trace_fmv_w_x(rds, rs1, size)   RVVM_RVJIT_TRACE_FPU(rvjit_fmv_w_x(&vm->jit, rds, rs1), size)
+#define rvjit_trace_fmv_x_w(rds, rs1, size)   RVVM_RVJIT_TRACE_FPU(rvjit_fmv_x_w(&vm->jit, rds, rs1), size)
+#define rvjit_trace_fcvt_w_s(rds, rs1, size)  RVVM_RVJIT_TRACE_FPU(rvjit_fcvt_w_s(&vm->jit, rds, rs1), size)
+#define rvjit_trace_fcvt_wu_s(rds, rs1, size) RVVM_RVJIT_TRACE_FPU(rvjit_fcvt_wu_s(&vm->jit, rds, rs1), size)
+#define rvjit_trace_fcvt_s_w(rds, rs1, size)  RVVM_RVJIT_TRACE_FPU(rvjit_fcvt_s_w(&vm->jit, rds, rs1), size)
+#define rvjit_trace_fcvt_s_wu(rds, rs1, size) RVVM_RVJIT_TRACE_FPU(rvjit_fcvt_s_wu(&vm->jit, rds, rs1), size)
+#define rvjit_trace_fcvt_w_d(rds, rs1, size)  RVVM_RVJIT_TRACE_FPU(rvjit_fcvt_w_d(&vm->jit, rds, rs1), size)
+#define rvjit_trace_fcvt_wu_d(rds, rs1, size) RVVM_RVJIT_TRACE_FPU(rvjit_fcvt_wu_d(&vm->jit, rds, rs1), size)
+#define rvjit_trace_fcvt_d_w(rds, rs1, size)  RVVM_RVJIT_TRACE_FPU(rvjit_fcvt_d_w(&vm->jit, rds, rs1), size)
+#define rvjit_trace_fcvt_d_wu(rds, rs1, size) RVVM_RVJIT_TRACE_FPU(rvjit_fcvt_d_wu(&vm->jit, rds, rs1), size)
+
+#ifdef RV64
+
+// RV64-specific FPU
+#define rvjit_trace_fmv_d_x(rds, rs1, size)   RVVM_RVJIT_TRACE_FPU(rvjit_fmv_d_x(&vm->jit, rds, rs1), size)
+#define rvjit_trace_fmv_x_d(rds, rs1, size)   RVVM_RVJIT_TRACE_FPU(rvjit_fmv_x_d(&vm->jit, rds, rs1), size)
+#define rvjit_trace_fcvt_l_s(rds, rs1, size)  RVVM_RVJIT_TRACE_FPU(rvjit_fcvt_l_s(&vm->jit, rds, rs1), size)
+#define rvjit_trace_fcvt_lu_s(rds, rs1, size) RVVM_RVJIT_TRACE_FPU(rvjit_fcvt_lu_s(&vm->jit, rds, rs1), size)
+#define rvjit_trace_fcvt_s_l(rds, rs1, size)  RVVM_RVJIT_TRACE_FPU(rvjit_fcvt_s_l(&vm->jit, rds, rs1), size)
+#define rvjit_trace_fcvt_s_lu(rds, rs1, size) RVVM_RVJIT_TRACE_FPU(rvjit_fcvt_s_lu(&vm->jit, rds, rs1), size)
+#define rvjit_trace_fcvt_l_d(rds, rs1, size)  RVVM_RVJIT_TRACE_FPU(rvjit_fcvt_l_d(&vm->jit, rds, rs1), size)
+#define rvjit_trace_fcvt_lu_d(rds, rs1, size) RVVM_RVJIT_TRACE_FPU(rvjit_fcvt_lu_d(&vm->jit, rds, rs1), size)
+#define rvjit_trace_fcvt_d_l(rds, rs1, size)  RVVM_RVJIT_TRACE_FPU(rvjit_fcvt_d_l(&vm->jit, rds, rs1), size)
+#define rvjit_trace_fcvt_d_lu(rds, rs1, size) RVVM_RVJIT_TRACE_FPU(rvjit_fcvt_d_lu(&vm->jit, rds, rs1), size)
+
+#endif
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/devices/ata.c b/app/src/main/java/libengine/RVVM/src/devices/ata.c
new file mode 100644
index 00000000..9d99862c
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/ata.c
@@ -0,0 +1,865 @@
+/*
+ata.c - IDE/ATA disk controller
+Copyright (C) 2021  cerg2010cerg2010 <github.com/cerg2010cerg2010>
+                    LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "ata.h"
+#include "../blk_io.h"
+#include "../bit_ops.h"
+#include "../mem_ops.h"
+#include "../spinlock.h"
+#include "../utils.h"
+#include "../threading.h"
+#include "../fdtlib.h"
+
+// Data registers
+#define ATA_REG_DATA   0x00
+#define ATA_REG_ERR    0x01 // or FEATURE
+#define ATA_REG_NSECT  0x02
+#define ATA_REG_LBAL   0x03
+#define ATA_REG_LBAM   0x04
+#define ATA_REG_LBAH   0x05
+#define ATA_REG_DEVICE 0x06
+#define ATA_REG_STATUS 0x07 // or CMD
+
+// Control registers
+#define ATA_REG_CTL     0x00 // or alternate STATUS
+#define ATA_REG_DRVADDR 0x01
+
+// 16-bit registers - needed for LBA48
+#define ATA_REG_SHIFT 0
+typedef uint16_t atareg_t;
+
+// Error flags for ERR register
+#define ATA_ERR_AMNF  (1 << 0)
+#define ATA_ERR_TKZNF (1 << 1)
+#define ATA_ERR_ABRT  (1 << 2)
+#define ATA_ERR_MCR   (1 << 3)
+#define ATA_ERR_IDNF  (1 << 4)
+#define ATA_ERR_MC    (1 << 5)
+#define ATA_ERR_UNC   (1 << 6)
+#define ATA_ERR_BBK   (1 << 7)
+
+// Flags for STATUS register
+#define ATA_STATUS_ERR  (1 << 0)
+#define ATA_STATUS_IDX  (1 << 1)
+#define ATA_STATUS_CORR (1 << 2)
+#define ATA_STATUS_DRQ  (1 << 3)
+#define ATA_STATUS_SRV  (1 << 4) // or DSC aka Seek Complete, deprecated
+#define ATA_STATUS_DF   (1 << 5)
+#define ATA_STATUS_RDY  (1 << 6)
+#define ATA_STATUS_BSY  (1 << 7)
+
+// Flags for DRIVE/HEAD register
+#define ATA_DRIVE_DRV (1 << 4)
+#define ATA_DRIVE_LBA (1 << 6)
+
+// Commands
+#define ATA_CMD_IDENTIFY          0xEC
+#define ATA_CMD_INITIALIZE_DEVICE_PARAMS 0x91
+#define ATA_CMD_READ_SECTORS      0x20
+#define ATA_CMD_WRITE_SECTORS     0x30
+#define ATA_CMD_READ_DMA          0xC8
+#define ATA_CMD_WRITE_DMA         0xCA
+#define ATA_CMD_STANDBY_IMMEDIATE 0xE0
+#define ATA_CMD_IDLE_IMMEDIATE    0xE1
+#define ATA_CMD_STANDBY           0xE2
+#define ATA_CMD_IDLE              0xE3
+#define ATA_CMD_CHECK_POWER_MODE  0xE4
+#define ATA_CMD_SLEEP             0xE6
+
+// BMDMA registers
+#define ATA_BMDMA_CMD    0x0
+#define ATA_BMDMA_STATUS 0x2
+#define ATA_BMDMA_PRDT   0x4
+
+#define SECTOR_SIZE 512
+
+/* CHS is not supported - it's dead anyway...
+// Limits for C/H/S calculation
+// Max sectors per track: 255, usually 63 because of six bit numberring. Starts from 1
+#define MAX_SPT           63 // Sectors per track
+#define MAX_HPC           16 // Heads per cyllinder/track
+#define MAX_CYLLINDERS 65536 // 16-bit addressing limit
+*/
+
+#define DIV_ROUND_UP(x, d) (((x) + (d) - 1) / (d))
+
+struct ata_dev
+{
+    struct {
+        blkdev_t* blk;
+        size_t size; // In sectors
+        uint16_t bytes_to_rw;
+        uint16_t sectcount;
+        atareg_t lbal;
+        atareg_t lbam;
+        atareg_t lbah;
+        atareg_t drive;
+        atareg_t error;
+        uint8_t status;
+        uint8_t hob_shift;
+        bool nien; // Interrupt disable
+        uint8_t buf[SECTOR_SIZE];
+    } drive[2];
+    struct {
+        rvvm_addr_t prdt_addr;
+        spinlock_t lock;
+        uint8_t cmd;
+        uint8_t status;
+    } dma_info;
+    spinlock_t lock;
+    uint8_t curdrive;
+    pci_dev_t* pci_dev;
+};
+
+static uint64_t ata_get_lba(struct ata_dev *ata, bool is48bit)
+{
+    if (is48bit) {
+        return bit_cut(ata->drive[ata->curdrive].lbal, 0, 8)
+             | bit_cut(ata->drive[ata->curdrive].lbam, 0, 8) << 8
+             | bit_cut(ata->drive[ata->curdrive].lbah, 0, 8) << 16
+             | bit_cut(ata->drive[ata->curdrive].lbal, 8, 8) << 24
+             | (uint64_t)bit_cut(ata->drive[ata->curdrive].lbam, 8, 8) << 32
+             | (uint64_t)bit_cut(ata->drive[ata->curdrive].lbah, 8, 8) << 40;
+    } else {
+        return bit_cut(ata->drive[ata->curdrive].lbal, 0, 8)
+             | bit_cut(ata->drive[ata->curdrive].lbam, 0, 8) << 8
+             | bit_cut(ata->drive[ata->curdrive].lbah, 0, 8) << 16
+             | bit_cut(ata->drive[ata->curdrive].drive, 0, 4) << 24;
+    }
+}
+
+static void ata_send_interrupt(struct ata_dev *ata) {
+    pci_send_irq(ata->pci_dev, 0);
+}
+
+static void ata_clear_interrupt(struct ata_dev *ata) {
+    pci_clear_irq(ata->pci_dev, 0);
+}
+
+static void ata_copy_id_string(uint8_t* buf, const char* str, size_t size)
+{
+    // Reverse each byte pair since they are little-endian words
+    size_t len = rvvm_strnlen(str, size);
+    for (size_t i=0; i<len; ++i) {
+        buf[i ^ 1ULL] = str[i];
+    }
+}
+
+static void ata_cmd_identify(struct ata_dev *ata)
+{
+    uint8_t id_buf[SECTOR_SIZE] = {0};
+    write_uint16_le(id_buf,         0x40); // Non-removable, ATA device
+    write_uint16_le(id_buf + 2,   0xFFFF); // Logical cylinders
+    write_uint16_le(id_buf + 6,     0x10); // Sectors per track
+    write_uint16_le(id_buf + 12,    0x3F); // Logical heads
+    write_uint16_le(id_buf + 44,     0x4); // Number of bytes available in READ/WRITE LONG cmds
+    write_uint16_le(id_buf + 98,   0x300); // Capabilities - LBA supported, DMA supported
+    write_uint16_le(id_buf + 100, 0x4000); // Capabilities - bit 14 needs to be set as required by ATA/ATAPI-5 spec
+    write_uint16_le(id_buf + 102,  0x400); // PIO data transfer cycle timing mode
+    write_uint16_le(id_buf + 106,    0x7); // Fields 54-58, 64-70 and 88 are valid
+    write_uint16_le(id_buf + 108, 0xFFFF); // Logical cylinders
+    write_uint16_le(id_buf + 110,   0x10); // Logical heads
+    write_uint16_le(id_buf + 112,   0x3F); // Sectors per track
+    // Capacity in sectors
+    write_uint16_le(id_buf + 114,  ata->drive[ata->curdrive].size);
+    write_uint16_le(id_buf + 116,  ata->drive[ata->curdrive].size >> 16);
+    write_uint16_le(id_buf + 120,  ata->drive[ata->curdrive].size);
+    write_uint16_le(id_buf + 122,  ata->drive[ata->curdrive].size >> 16);
+    write_uint16_le(id_buf + 128,    0x3); // Advanced PIO modes supported
+    write_uint16_le(id_buf + 134,    0x1); // PIO transfer cycle time without flow control
+    write_uint16_le(id_buf + 136,    0x1); // PIO transfer cycle time with IORDY flow control
+    write_uint16_le(id_buf + 160,  0x100); // ATA major version
+    write_uint16_le(id_buf + 176, 0x80FF); // UDMA mode 7 active, All UDMA modes supported
+
+    // Serial Number
+    ata_copy_id_string(id_buf + 20, "DEADBEEF            ", 20);
+    // Firmware Revision
+    ata_copy_id_string(id_buf + 46, "R1059   ", 8);
+    // Model Number
+    ata_copy_id_string(id_buf + 54, "IDE HDD                                 ", 40);
+
+    memcpy(ata->drive[ata->curdrive].buf, id_buf, sizeof(id_buf));
+    ata->drive[ata->curdrive].bytes_to_rw = sizeof(id_buf);
+    ata->drive[ata->curdrive].status = ATA_STATUS_RDY | ATA_STATUS_SRV | ATA_STATUS_DRQ;
+    ata->drive[ata->curdrive].sectcount = 1;
+    ata_send_interrupt(ata);
+}
+
+static void ata_cmd_initialize_device_params(struct ata_dev *ata)
+{
+    // CHS translation is not supported
+    ata->drive[ata->curdrive].status |= ATA_STATUS_ERR;
+    ata->drive[ata->curdrive].error |= ATA_ERR_ABRT;
+}
+
+// Reads the data to buffer
+static bool ata_read_buf(struct ata_dev *ata)
+{
+    if (!blk_read(ata->drive[ata->curdrive].blk,
+                  ata->drive[ata->curdrive].buf,
+                  SECTOR_SIZE, BLKDEV_CURPOS)) {
+        return false;
+    }
+
+    ata->drive[ata->curdrive].bytes_to_rw = SECTOR_SIZE;
+    ata_send_interrupt(ata);
+    return true;
+}
+
+// Writes the data from buffer to drive
+static bool ata_write_buf(struct ata_dev *ata)
+{
+    if (!blk_write(ata->drive[ata->curdrive].blk,
+                   ata->drive[ata->curdrive].buf,
+                   SECTOR_SIZE, BLKDEV_CURPOS)) {
+        return false;
+    }
+
+    ata_send_interrupt(ata);
+    return true;
+}
+
+static void ata_cmd_read_sectors(struct ata_dev *ata)
+{
+    ata->drive[ata->curdrive].sectcount &= 0xff;
+    // Sector count of 0 means 256
+    if (ata->drive[ata->curdrive].sectcount == 0) {
+        ata->drive[ata->curdrive].sectcount = 256;
+    }
+
+    ata->drive[ata->curdrive].status |= ATA_STATUS_DRQ | ATA_STATUS_RDY;
+    if (!blk_seek(ata->drive[ata->curdrive].blk, ata_get_lba(ata, false) * SECTOR_SIZE, BLKDEV_SET)
+     || !ata_read_buf(ata)) {
+        ata->drive[ata->curdrive].status |= ATA_STATUS_ERR;
+        ata->drive[ata->curdrive].error |= ATA_ERR_UNC;
+    }
+}
+
+static void ata_cmd_write_sectors(struct ata_dev *ata)
+{
+    ata->drive[ata->curdrive].sectcount &= 0xff;
+    // Sector count of 0 means 256
+    if (ata->drive[ata->curdrive].sectcount == 0) {
+        ata->drive[ata->curdrive].sectcount = 256;
+    }
+
+    ata->drive[ata->curdrive].status |= ATA_STATUS_DRQ | ATA_STATUS_RDY;
+    if (!blk_seek(ata->drive[ata->curdrive].blk, ata_get_lba(ata, false) * SECTOR_SIZE, BLKDEV_SET)) {
+        ata->drive[ata->curdrive].status |= ATA_STATUS_ERR;
+        ata->drive[ata->curdrive].error |= ATA_ERR_UNC;
+    } else {
+        ata->drive[ata->curdrive].bytes_to_rw = SECTOR_SIZE;
+    }
+}
+
+static void ata_cmd_read_dma(struct ata_dev *ata)
+{
+    spin_lock(&ata->dma_info.lock);
+    ata->drive[ata->curdrive].sectcount &= 0xff;
+    // Sector count of 0 means 256
+    if (ata->drive[ata->curdrive].sectcount == 0) {
+        ata->drive[ata->curdrive].sectcount = 256;
+    }
+
+    ata->drive[ata->curdrive].status |= ATA_STATUS_RDY;
+    ata->drive[ata->curdrive].status &=
+            ~(ATA_STATUS_BSY
+            | ATA_STATUS_DF
+            | ATA_STATUS_DRQ
+            | ATA_STATUS_ERR);
+
+    if (!blk_seek(ata->drive[ata->curdrive].blk, ata_get_lba(ata, false) * SECTOR_SIZE, BLKDEV_SET)) {
+        ata->drive[ata->curdrive].status |= ATA_STATUS_ERR;
+        ata->drive[ata->curdrive].error |= ATA_ERR_UNC;
+        spin_unlock(&ata->dma_info.lock);
+        // No interrupt on error?
+    } else {
+        spin_unlock(&ata->dma_info.lock);
+        ata_send_interrupt(ata);
+    }
+}
+
+static void ata_cmd_write_dma(struct ata_dev *ata)
+{
+    spin_lock(&ata->dma_info.lock);
+    ata->drive[ata->curdrive].sectcount &= 0xff;
+    // Sector count of 0 means 256
+    if (ata->drive[ata->curdrive].sectcount == 0) {
+        ata->drive[ata->curdrive].sectcount = 256;
+    }
+
+    ata->drive[ata->curdrive].status |= ATA_STATUS_RDY;
+    ata->drive[ata->curdrive].status &=
+            ~(ATA_STATUS_BSY
+            | ATA_STATUS_DF
+            | ATA_STATUS_DRQ
+            | ATA_STATUS_ERR);
+
+    if (!blk_seek(ata->drive[ata->curdrive].blk, ata_get_lba(ata, false) * SECTOR_SIZE, BLKDEV_SET)) {
+        ata->drive[ata->curdrive].status |= ATA_STATUS_ERR;
+        ata->drive[ata->curdrive].error |= ATA_ERR_UNC;
+        spin_unlock(&ata->dma_info.lock);
+        // No interrupt on error?
+    } else {
+        spin_unlock(&ata->dma_info.lock);
+        ata_send_interrupt(ata);
+    }
+}
+
+static void ata_cmd_dummy_irq(struct ata_dev *ata)
+{
+    ata_send_interrupt(ata);
+}
+
+static void ata_cmd_check_power_mode(struct ata_dev *ata)
+{
+    ata->drive[ata->curdrive].sectcount = 0xff; // Always active
+    ata_send_interrupt(ata);
+}
+
+static void ata_handle_cmd(struct ata_dev *ata, uint8_t cmd)
+{
+    switch (cmd) {
+        case ATA_CMD_IDENTIFY: ata_cmd_identify(ata); break;
+        case ATA_CMD_INITIALIZE_DEVICE_PARAMS: ata_cmd_initialize_device_params(ata); break;
+        case ATA_CMD_READ_SECTORS: ata_cmd_read_sectors(ata); break;
+        case ATA_CMD_WRITE_SECTORS: ata_cmd_write_sectors(ata); break;
+        case ATA_CMD_READ_DMA: ata_cmd_read_dma(ata); break;
+        case ATA_CMD_WRITE_DMA: ata_cmd_write_dma(ata); break;
+        case ATA_CMD_CHECK_POWER_MODE: ata_cmd_check_power_mode(ata); break;
+        case ATA_CMD_SLEEP:
+        case ATA_CMD_IDLE:
+        case ATA_CMD_IDLE_IMMEDIATE:
+        case ATA_CMD_STANDBY:
+        case ATA_CMD_STANDBY_IMMEDIATE: ata_cmd_dummy_irq(ata); break;
+        default: rvvm_info("ATA unknown cmd 0x%02x", cmd); break;
+    }
+}
+
+static bool ata_data_mmio_read_handler(rvvm_mmio_dev_t* device, void* data, size_t offset, uint8_t size)
+{
+    struct ata_dev* ata = (struct ata_dev*)device->data;
+    offset >>= ATA_REG_SHIFT;
+    spin_lock(&ata->lock);
+    switch (offset) {
+        case ATA_REG_DATA:
+            if (ata->drive[ata->curdrive].bytes_to_rw >= size) {
+                uint8_t* addr = ata->drive[ata->curdrive].buf + SECTOR_SIZE - ata->drive[ata->curdrive].bytes_to_rw;
+                memcpy(data, addr, size);
+
+                ata->drive[ata->curdrive].bytes_to_rw -= size;
+                if (ata->drive[ata->curdrive].bytes_to_rw == 0) {
+                    ata->drive[ata->curdrive].status &= ~ATA_STATUS_DRQ;
+                    if (--ata->drive[ata->curdrive].sectcount != 0) {
+                        ata->drive[ata->curdrive].status |= ATA_STATUS_DRQ;
+                        if (!ata_read_buf(ata)) {
+                            ata->drive[ata->curdrive].status |= ATA_STATUS_ERR;
+                            ata->drive[ata->curdrive].error |= ATA_ERR_UNC;
+                        }
+                    }
+                }
+            } else {
+                memset(data, 0, size);
+            }
+            break;
+        case ATA_REG_ERR:
+            // OSDev says that this register is 16-bit,
+            // but there's no address stored so this seems wrong
+            if (size == 2) {
+                write_uint16_le(data, ata->drive[ata->curdrive].error);
+            } else {
+                write_uint8(data, ata->drive[ata->curdrive].error);
+            }
+            break;
+        case ATA_REG_NSECT:
+            write_uint8(data, ata->drive[ata->curdrive].sectcount >> ata->drive[ata->curdrive].hob_shift);
+            break;
+        case ATA_REG_LBAL:
+            write_uint8(data, ata->drive[ata->curdrive].lbal >> ata->drive[ata->curdrive].hob_shift);
+            break;
+        case ATA_REG_LBAM:
+            write_uint8(data, ata->drive[ata->curdrive].lbam >> ata->drive[ata->curdrive].hob_shift);
+            break;
+        case ATA_REG_LBAH:
+            write_uint8(data, ata->drive[ata->curdrive].lbah >> ata->drive[ata->curdrive].hob_shift);
+            break;
+        case ATA_REG_DEVICE:
+            write_uint8(data, ata->drive[ata->curdrive].drive | (1 << 5) | (1 << 7));
+            break;
+        case ATA_REG_STATUS:
+            write_uint8(data, ata->drive[ata->curdrive].status);
+            ata_clear_interrupt(ata);
+            break;
+        default:
+            memset(data, 0, size);
+            break;
+    }
+    spin_unlock(&ata->lock);
+
+    return true;
+}
+
+static bool ata_data_mmio_write_handler(rvvm_mmio_dev_t* device, void* data, size_t offset, uint8_t size)
+{
+    struct ata_dev* ata = (struct ata_dev*)device->data;
+    offset >>= ATA_REG_SHIFT;
+    spin_lock(&ata->lock);
+    switch (offset) {
+        case ATA_REG_DATA:
+            if (ata->drive[ata->curdrive].bytes_to_rw >= size) {
+                uint8_t* addr = ata->drive[ata->curdrive].buf + SECTOR_SIZE - ata->drive[ata->curdrive].bytes_to_rw;
+                memcpy(addr, data, size);
+
+                ata->drive[ata->curdrive].bytes_to_rw -= size;
+                if (ata->drive[ata->curdrive].bytes_to_rw == 0) {
+                    ata->drive[ata->curdrive].status &= ~ATA_STATUS_DRQ;
+                    if (--ata->drive[ata->curdrive].sectcount != 0) {
+                        ata->drive[ata->curdrive].status |= ATA_STATUS_DRQ;
+                        ata->drive[ata->curdrive].bytes_to_rw = SECTOR_SIZE;
+                    }
+                    if (!ata_write_buf(ata)) {
+                        ata->drive[ata->curdrive].status |= ATA_STATUS_ERR;
+                        ata->drive[ata->curdrive].error |= ATA_ERR_UNC;
+                    }
+                }
+            }
+            break;
+        case ATA_REG_ERR: // Features - ignore
+            break;
+        case ATA_REG_NSECT:
+            ata->drive[ata->curdrive].sectcount <<= 8;
+            ata->drive[ata->curdrive].sectcount |= read_uint8(data);
+            break;
+        case ATA_REG_LBAL:
+            ata->drive[ata->curdrive].lbal <<= 8;
+            ata->drive[ata->curdrive].lbal |= read_uint8(data);
+            break;
+        case ATA_REG_LBAM:
+            ata->drive[ata->curdrive].lbam <<= 8;
+            ata->drive[ata->curdrive].lbam |= read_uint8(data);
+            break;
+        case ATA_REG_LBAH:
+            ata->drive[ata->curdrive].lbah <<= 8;
+            ata->drive[ata->curdrive].lbah |= read_uint8(data);
+            break;
+        case ATA_REG_DEVICE:
+            ata->curdrive = bit_check(read_uint8(data), 4) ? 1 : 0;
+            ata->drive[ata->curdrive].drive = read_uint8(data);
+            break;
+        case ATA_REG_STATUS: // Command
+            // Not sure when error is cleared.
+            // Spec says that it contains status of the last command executed
+            ata->drive[ata->curdrive].error = 0;
+            ata->drive[ata->curdrive].status &= ~ATA_STATUS_ERR;
+            ata_handle_cmd(ata, read_uint8(data));
+            break;
+    }
+    spin_unlock(&ata->lock);
+
+    return true;
+}
+
+static bool ata_ctl_mmio_read_handler(rvvm_mmio_dev_t* device, void* data, size_t offset, uint8_t size)
+{
+    struct ata_dev* ata = (struct ata_dev*)device->data;
+    UNUSED(size);
+    offset >>= ATA_REG_SHIFT;
+    spin_lock(&ata->lock);
+    switch (offset) {
+        case ATA_REG_CTL: // Alternate STATUS
+            write_uint8(data, ata->drive[ata->curdrive].status);
+            ata_clear_interrupt(ata);
+            break;
+        case ATA_REG_DRVADDR: // TODO: Seems that Linux doesn't use this
+            break;
+    }
+    spin_unlock(&ata->lock);
+
+    return true;
+}
+
+static bool ata_ctl_mmio_write_handler(rvvm_mmio_dev_t* device, void* data, size_t offset, uint8_t size)
+{
+    struct ata_dev* ata = (struct ata_dev*)device->data;
+    UNUSED(size);
+    offset >>= ATA_REG_SHIFT;
+    spin_lock(&ata->lock);
+    switch (offset) {
+        case ATA_REG_CTL: // Device control
+            ata->drive[ata->curdrive].nien = bit_check(read_uint8(data), 1);
+            ata->drive[ata->curdrive].hob_shift = bit_check(read_uint8(data), 7) ? 8 : 0;
+            if (bit_check(read_uint8(data), 2)) {
+                // Soft reset
+                ata->drive[ata->curdrive].bytes_to_rw = 0;
+                ata->drive[ata->curdrive].lbal = 1; // Sectors start from 1
+                ata->drive[ata->curdrive].lbah = 0;
+                ata->drive[ata->curdrive].lbam = 0;
+                ata->drive[ata->curdrive].sectcount = 1;
+                ata->drive[ata->curdrive].drive = 0;
+                if (ata->drive[ata->curdrive].blk != NULL) {
+                    ata->drive[ata->curdrive].error = ATA_ERR_AMNF; // AMNF means OK here...
+                    ata->drive[ata->curdrive].status = ATA_STATUS_RDY | ATA_STATUS_SRV;
+                } else {
+                    ata->drive[ata->curdrive].error = 0;
+                    ata->drive[ata->curdrive].status = 0;
+                }
+            }
+            break;
+        case ATA_REG_DRVADDR: // TODO: Seems that Linux doesn't use this
+            break;
+    }
+    spin_unlock(&ata->lock);
+
+    return true;
+}
+
+static void ata_data_remove(rvvm_mmio_dev_t* device)
+{
+    struct ata_dev *ata = (struct ata_dev*)device->data;
+    spin_lock(&ata->dma_info.lock);
+    for (size_t i = 0; i < sizeof(ata->drive) / sizeof(ata->drive[0]); ++i) {
+        if (ata->drive[i].blk != NULL) {
+            blk_close(ata->drive[i].blk);
+        }
+    }
+    spin_unlock(&ata->dma_info.lock);
+
+    free(ata);
+}
+
+static rvvm_mmio_type_t ata_data_dev_type = {
+    .name = "ata_data",
+    .remove = ata_data_remove,
+};
+
+static void ata_remove_dummy(rvvm_mmio_dev_t* device)
+{
+    // Dummy remove, cleanup happends in ata_data_remove()
+    UNUSED(device);
+}
+
+static rvvm_mmio_type_t ata_ctl_dev_type = {
+    .name = "ata_ctl",
+    .remove = ata_remove_dummy,
+};
+
+static struct ata_dev* ata_create(const char* image_path, bool rw)
+{
+    blkdev_t* blk = blk_open(image_path, rw ? BLKDEV_RW : 0);
+    if (blk == NULL) return NULL;
+    struct ata_dev* ata = safe_new_obj(struct ata_dev);
+    ata->drive[0].blk = blk;
+    ata->drive[0].size = DIV_ROUND_UP(blk_getsize(blk), SECTOR_SIZE);
+    // Slave drives aren't supported
+    return ata;
+}
+
+PUBLIC bool ata_init_pio(rvvm_machine_t* machine, rvvm_addr_t data_base_addr, rvvm_addr_t ctl_base_addr, const char* image_path, bool rw)
+{
+    struct ata_dev* ata = ata_create(image_path, rw);
+    if (ata == NULL) return false;
+
+    rvvm_mmio_dev_t ata_data = {
+        .addr = data_base_addr,
+        .size = ((ATA_REG_STATUS + 1) << ATA_REG_SHIFT),
+        .data = ata,
+        .read = ata_data_mmio_read_handler,
+        .write = ata_data_mmio_write_handler,
+        .type = &ata_data_dev_type,
+        .min_op_size = 1,
+        .max_op_size = 2,
+    };
+    rvvm_attach_mmio(machine, &ata_data);
+
+    rvvm_mmio_dev_t ata_ctl = {
+        .addr = ctl_base_addr,
+        .size = ((ATA_REG_DRVADDR + 1) << ATA_REG_SHIFT),
+        .data = ata,
+        .read = ata_ctl_mmio_read_handler,
+        .write = ata_ctl_mmio_write_handler,
+        .type = &ata_ctl_dev_type,
+        .min_op_size = 1,
+        .max_op_size = 1,
+    };
+    rvvm_attach_mmio(machine, &ata_ctl);
+#ifdef USE_FDT
+    uint32_t reg_cells[8];
+    reg_cells[0] = ((uint64_t)data_base_addr) >> 32;
+    reg_cells[1] = data_base_addr;
+    reg_cells[4] = ((uint64_t)ctl_base_addr) >> 32;
+    reg_cells[5] = ctl_base_addr;
+    reg_cells[2] = reg_cells[6] = 0;
+    reg_cells[3] = reg_cells[7] = 0x1000;
+
+    struct fdt_node* ata_node = fdt_node_create_reg("ata", data_base_addr);
+    fdt_node_add_prop_cells(ata_node, "reg", reg_cells, 8);
+    fdt_node_add_prop_str(ata_node, "compatible", "ata-generic");
+    fdt_node_add_prop_u32(ata_node, "reg-shift", ATA_REG_SHIFT);
+    fdt_node_add_prop_u32(ata_node, "pio-mode", 4);
+    fdt_node_add_child(rvvm_get_fdt_soc(machine), ata_node);
+#endif
+    return true;
+}
+
+#ifdef USE_PCI
+
+static rvvm_mmio_type_t ata_bmdma_dev_type = {
+    .name = "ata_bmdma",
+    .remove = ata_remove_dummy,
+};
+
+static void ata_process_prdt(struct ata_dev* ata)
+{
+    blkdev_t* blk = ata->drive[ata->curdrive].blk;
+    bool is_read = bit_check(ata->dma_info.cmd, 3);
+    size_t to_process = ata->drive[ata->curdrive].sectcount * SECTOR_SIZE;
+    size_t processed = 0;
+    // According to spec, maximum amount of PRDT entries is 65536
+    // This should prevent malicious guests from hanging up the thread
+    for (size_t i=0; i<65536; ++i) {
+        // Read PRD
+        uint8_t* buf = pci_get_dma_ptr(ata->pci_dev, ata->dma_info.prdt_addr, 8);
+        if (buf == NULL) break;
+        uint32_t prd_physaddr = read_uint32_le_m(buf);
+        uint32_t prd_sectcount = read_uint32_le_m(buf + 4);
+
+        uint32_t buf_size = prd_sectcount & 0xffff;
+        // Value 0 means size of 64K
+        if (buf_size == 0) buf_size = 65536;
+
+        buf = pci_get_dma_ptr(ata->pci_dev, prd_physaddr, buf_size);
+        if (buf == NULL) break;
+
+        // Read/write data to/from RAM
+        if (is_read) {
+            if (blk_read(blk, buf, buf_size, BLKDEV_CURPOS) != buf_size) {
+                break;
+            }
+        } else {
+            if (blk_write(blk, buf, buf_size, BLKDEV_CURPOS) != buf_size) {
+                break;
+            }
+        }
+
+        processed += buf_size;
+
+        // If bit 31 is set, this is the last PRD
+        if (bit_check(prd_sectcount, 31)) break;
+
+        // All good, advance the pointer
+        ata->dma_info.prdt_addr += 8;
+    }
+
+    if (processed == to_process) {
+        // Everything OK
+        ata->dma_info.cmd &= ~(1 << 0);
+        ata->dma_info.status |= (1 << 2);
+    } else {
+        // Error
+        ata->dma_info.status |= (1 << 2) | (1 << 1);
+    }
+    ata_send_interrupt(ata);
+}
+
+static void* ata_worker(void* data)
+{
+    struct ata_dev* ata = (struct ata_dev*)data;
+    spin_lock(&ata->dma_info.lock);
+    ata_process_prdt(ata);
+    spin_unlock(&ata->dma_info.lock);
+    return NULL;
+}
+
+static bool ata_bmdma_mmio_read_handler(rvvm_mmio_dev_t* device, void* data, size_t offset, uint8_t size)
+{
+    struct ata_dev* ata = (struct ata_dev*)device->data;
+    switch (offset) {
+        case ATA_BMDMA_CMD:
+            if (size != 1) return false;
+            write_uint8(data, ata->dma_info.cmd);
+            break;
+        case ATA_BMDMA_STATUS:
+            if (size != 1) return false;
+            write_uint8(data, ata->dma_info.status
+                           | (ata->drive[0].blk != NULL) << 5
+                           | (ata->drive[1].blk != NULL) << 6);
+            break;
+        case ATA_BMDMA_PRDT:
+            if (size != 4) return false;
+            write_uint32_le(data, ata->dma_info.prdt_addr);
+            break;
+        default:
+            // Secondary controller not supported now
+            return false;
+    }
+
+    return true;
+}
+
+static bool ata_bmdma_mmio_write_handler(rvvm_mmio_dev_t* device, void* data, size_t offset, uint8_t size)
+{
+    struct ata_dev* ata = (struct ata_dev*)device->data;
+    bool process_prdt;
+    switch (offset) {
+        case ATA_BMDMA_CMD:
+            if (size != 1) return false;
+            spin_lock(&ata->dma_info.lock);
+            process_prdt = !(ata->dma_info.cmd & 1) && (read_uint8(data) & 1);
+            ata->dma_info.cmd = read_uint8(data);
+            spin_unlock(&ata->dma_info.lock);
+            if (process_prdt) {
+                thread_create_task(ata_worker, ata);
+            }
+            break;
+        case ATA_BMDMA_STATUS:
+            if (size != 1) return false;
+            spin_lock(&ata->dma_info.lock);
+            ata->dma_info.status &= ~(read_uint8(data) & 6);
+            if (!bit_check(ata->dma_info.status, 2)) {
+                ata_clear_interrupt(ata);
+            }
+            spin_unlock(&ata->dma_info.lock);
+            break;
+        case ATA_BMDMA_PRDT:
+            if (size != 4) return false;
+            spin_lock(&ata->dma_info.lock);
+            ata->dma_info.prdt_addr = read_uint32_le(data);
+            spin_unlock(&ata->dma_info.lock);
+            break;
+        default:
+            // Secondary controller not supported
+            return false;
+    }
+
+    return true;
+}
+
+static bool ata_ctl_read_primary(rvvm_mmio_dev_t* device, void* memory_data, size_t offset, uint8_t size)
+{
+    offset -= 2;
+    return ata_ctl_mmio_read_handler(device, memory_data, offset, size);
+}
+
+static bool ata_ctl_write_primary(rvvm_mmio_dev_t* device, void* memory_data, size_t offset, uint8_t size)
+{
+    offset -= 2;
+    return ata_ctl_mmio_write_handler(device, memory_data, offset, size);
+}
+
+/* No support for secondary BAR
+static bool ata_data_read_secondary(rvvm_mmio_dev_t* device, void* memory_data, paddr_t offset, uint8_t size)
+{
+    return ata_data_mmio_read_handler(device, memory_data, offset, size);
+}
+
+static bool ata_data_write_secondary(rvvm_mmio_dev_t* device, void* memory_data, paddr_t offset, uint8_t size)
+{
+    return ata_data_mmio_write_handler(device, memory_data, offset, size);
+}
+
+static bool ata_ctl_read_secondary(rvvm_mmio_dev_t* device, void* memory_data, paddr_t offset, uint8_t size)
+{
+    offset -= 2;
+    return ata_ctl_mmio_read_handler(device, memory_data, offset, size);
+}
+
+static bool ata_ctl_write_secondary(rvvm_mmio_dev_t* device, void* memory_data, paddr_t offset, uint8_t size)
+{
+    offset -= 2;
+    return ata_ctl_mmio_write_handler(device, memory_data, offset, size);
+}
+*/
+
+PUBLIC pci_dev_t* ata_init_pci(pci_bus_t* pci_bus, const char* image_path, bool rw)
+{
+    struct ata_dev* ata = ata_create(image_path, rw);
+    if (ata == NULL) return NULL;
+
+    pci_dev_desc_t ata_desc = {
+        .func[0] = {
+            .vendor_id = 0x8086,  // Intel (ata-generic kernel driver refuses to load with other vendors)
+            .device_id = 0x8c88,  // 9 Series Series Chipset Family SATA Controller [IDE Mode]
+            .class_code = 0x0101, // Mass Storage, IDE
+            .prog_if = 0x85,      // PCI native mode-only controller, supports bus mastering
+            .irq_pin = PCI_IRQ_PIN_INTA,
+            .bar[0] = {
+                .size = 4096,
+                .min_op_size = 1,
+                .max_op_size = 2,
+                .read = ata_data_mmio_read_handler,
+                .write = ata_data_mmio_write_handler,
+                .data = ata,
+                .type = &ata_data_dev_type,
+            },
+            .bar[1] = {
+                .size = 4096,
+                .min_op_size = 1,
+                .max_op_size = 1,
+                .read = ata_ctl_read_primary,
+                .write = ata_ctl_write_primary,
+                .data = ata,
+                .type = &ata_ctl_dev_type,
+            },
+/* No support for secondary BAR
+            .bar[2] = {
+                .size = 4096,
+                .min_op_size = 1,
+                .max_op_size = 2,
+                .read = ata_data_read_secondary,
+                .write = ata_data_write_secondary,
+            },
+            .bar[3] = {
+                .size = 4096,
+                .min_op_size = 1,
+                .max_op_size = 1,
+                .read = ata_ctl_read_secondary,
+                .write = ata_ctl_write_secondary,
+            },
+*/
+            .bar[4] = {
+                .size = 16,
+                .min_op_size = 1,
+                .max_op_size = 4,
+                .read = ata_bmdma_mmio_read_handler,
+                .write = ata_bmdma_mmio_write_handler,
+                .data = ata,
+                .type = &ata_bmdma_dev_type,
+            }
+        }
+    };
+
+    pci_dev_t* pci_dev = pci_bus_add_device(pci_bus, &ata_desc);
+    if (pci_dev) ata->pci_dev = pci_dev;
+    return pci_dev;
+}
+
+#else
+PUBLIC pci_dev_t* ata_init_pci(pci_bus_t* pci_bus, const char* image_path, bool rw) { UNUSED(pci_bus); UNUSED(image_path); UNUSED(rw); return NULL; }
+#endif
+
+PUBLIC bool ata_init_auto(rvvm_machine_t* machine, const char* image_path, bool rw)
+{
+#ifdef USE_PCI
+    pci_bus_t* pci_bus = rvvm_get_pci_bus(machine);
+    return pci_bus && ata_init_pci(pci_bus, image_path, rw);
+#else
+    rvvm_addr_t addr = rvvm_mmio_zone_auto(machine, ATA_DATA_DEFAULT_MMIO, 0x2000);
+    return ata_init_pio(machine, addr, addr + 0x1000, image_path, rw);
+#endif
+}
diff --git a/app/src/main/java/libengine/RVVM/src/devices/ata.h b/app/src/main/java/libengine/RVVM/src/devices/ata.h
new file mode 100644
index 00000000..1a076a38
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/ata.h
@@ -0,0 +1,34 @@
+/*
+ata.h - IDE/ATA disk controller
+Copyright (C) 2021  cerg2010cerg2010 <github.com/cerg2010cerg2010>
+                    LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef RVVM_ATA_H
+#define RVVM_ATA_H
+
+#include "../rvvmlib.h"
+#include "pci-bus.h"
+
+#define ATA_DATA_DEFAULT_MMIO 0x40000000
+#define ATA_CTL_DEFAULT_MMIO  0x40001000
+
+PUBLIC bool ata_init_pio(rvvm_machine_t* machine, rvvm_addr_t data_base_addr, rvvm_addr_t ctl_base_addr, const char* image_path, bool rw);
+PUBLIC pci_dev_t* ata_init_pci(pci_bus_t* pci_bus, const char* image_path, bool rw);
+
+PUBLIC bool ata_init_auto(rvvm_machine_t* machine, const char* image_path, bool rw);
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/devices/chardev.h b/app/src/main/java/libengine/RVVM/src/devices/chardev.h
new file mode 100644
index 00000000..ca5556ce
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/chardev.h
@@ -0,0 +1,91 @@
+/*
+chardev.h - Character device backend for UART
+Copyright (C) 2023  宋文武 <iyzsong@envs.net>
+                    LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef RVVM_CHARDEV_H
+#define RVVM_CHARDEV_H
+
+#include "../rvvmlib.h"
+
+/*
+ * IO Device - UART (or else) owning the chardev
+ * Chardev - Terminal, emulated VT, socket
+ */
+
+typedef struct rvvm_chardev chardev_t;
+
+struct rvvm_chardev {
+    // IO Dev -> Chardev calls
+    size_t (*read)(chardev_t* dev, void* buf, size_t nbytes);
+    size_t (*write)(chardev_t* dev, const void* buf, size_t nbytes);
+    uint32_t (*poll)(chardev_t* dev);
+
+    // Chardev -> IO Device notifications (IRQ)
+    void   (*notify)(void* io_dev, uint32_t flags);
+
+    // Common RVVM API features
+    void   (*update)(chardev_t* dev);
+    void   (*remove)(chardev_t* dev);
+
+    void* data;
+    void* io_dev;
+};
+
+#define CHARDEV_RX 0x1
+#define CHARDEV_TX 0x2
+
+static inline size_t chardev_read(chardev_t* dev, void* buf, size_t nbytes)
+{
+    if (dev) return dev->read(dev, buf, nbytes);
+    return 0;
+}
+
+static inline size_t chardev_write(chardev_t* dev, const void* buf, size_t nbytes)
+{
+    if (dev) return dev->write(dev, buf, nbytes);
+    return nbytes;
+}
+
+static inline uint32_t chardev_poll(chardev_t* dev)
+{
+    if (dev) return dev->poll(dev);
+    return CHARDEV_TX;
+}
+
+static inline void chardev_free(chardev_t* dev)
+{
+    if (dev && dev->remove) dev->remove(dev);
+}
+
+static inline void chardev_update(chardev_t* dev)
+{
+    if (dev && dev->update) dev->update(dev);
+}
+
+static inline void chardev_notify(chardev_t* dev, uint32_t flags)
+{
+    if (dev->notify) dev->notify(dev->io_dev, flags);
+}
+
+// Built-in chardev implementations
+
+PUBLIC chardev_t* chardev_term_create(void); // stdio
+PUBLIC chardev_t* chardev_fd_create(int rfd, int wfd); // POSIX fd
+PUBLIC chardev_t* chardev_pty_create(const char* path); // POSIX pipe/pty
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/devices/chardev_term.c b/app/src/main/java/libengine/RVVM/src/devices/chardev_term.c
new file mode 100644
index 00000000..4555905d
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/chardev_term.c
@@ -0,0 +1,302 @@
+/*
+chardev_term.c - Terminal backend for UART
+Copyright (C) 2023  LekKit <github.com/LekKit>
+                    宋文武 <iyzsong@envs.net>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "chardev.h"
+
+#if (defined(__unix__) || defined(__APPLE__) || defined(__HAIKU__)) && !defined(__EMSCRIPTEN__)
+#include <sys/types.h>
+#include <sys/select.h>
+#include <termios.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+#ifndef O_CLOEXEC
+#define O_CLOEXEC 0
+#endif
+
+#define POSIX_TERM_IMPL
+
+#elif defined(_WIN32) && !defined(UNDER_CE)
+#include <windows.h>
+#include <conio.h>
+
+#define WIN32_TERM_IMPL
+
+#else
+#include <stdio.h>
+#warning No UART input support!
+
+#endif
+
+// RVVM internal headers come after system headers because of safe_free()
+#include "../spinlock.h"
+#include "../rvtimer.h"
+#include "../ringbuf.h"
+#include "../utils.h"
+#include "../mem_ops.h"
+
+#if defined(POSIX_TERM_IMPL)
+static struct termios orig_term_opts = {0};
+#elif defined(WIN32_TERM_IMPL)
+static DWORD orig_input_mode = 0;
+static DWORD orig_output_mode = 0;
+#endif
+
+static void term_origmode(void)
+{
+#if defined(POSIX_TERM_IMPL)
+    tcsetattr(STDIN_FILENO, TCSAFLUSH, &orig_term_opts);
+#elif defined(WIN32_TERM_IMPL)
+    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), orig_input_mode);
+    SetConsoleMode(GetStdHandle(STD_OUTPUT_HANDLE), orig_output_mode);
+#endif
+}
+
+static void term_rawmode(void)
+{
+#if defined(POSIX_TERM_IMPL)
+    struct termios term_opts = {
+        .c_iflag = ICRNL,
+        .c_oflag = OPOST | ONLCR,
+        .c_cflag = orig_term_opts.c_cflag,
+        .c_lflag = 0,
+        .c_cc[VMIN] = 1,
+    };
+    tcgetattr(STDIN_FILENO, &orig_term_opts);
+    tcsetattr(STDIN_FILENO, TCSANOW, &term_opts);
+#elif defined(WIN32_TERM_IMPL)
+    SetConsoleOutputCP(CP_UTF8);
+    GetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), &orig_input_mode);
+    GetConsoleMode(GetStdHandle(STD_OUTPUT_HANDLE), &orig_output_mode);
+
+    // ENABLE_VIRTUAL_TERMINAL_INPUT
+    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), 0x200);
+    // ENABLE_PROCESSED_OUTPUT | ENABLE_VIRTUAL_TERMINAL_PROCESSING
+    SetConsoleMode(GetStdHandle(STD_OUTPUT_HANDLE), 0x5);
+#endif
+    call_at_deinit(term_origmode);
+}
+
+typedef struct {
+    chardev_t chardev;
+    spinlock_t lock;
+    spinlock_t io_lock;
+    uint32_t flags;
+    int rfd, wfd;
+    ringbuf_t rx, tx;
+    bool ctrl_a;
+} chardev_term_t;
+
+static uint32_t term_update_flags(chardev_term_t* term)
+{
+    uint32_t flags = 0;
+    if (ringbuf_avail(&term->rx)) flags |= CHARDEV_RX;
+    if (ringbuf_space(&term->tx)) flags |= CHARDEV_TX;
+
+    return flags & ~atomic_swap_uint32(&term->flags, flags);
+}
+
+static void term_push_io(chardev_term_t* term, char* buffer, size_t* rx_size, size_t* tx_size)
+{
+    size_t to_read = rx_size ? *rx_size : 0;
+    size_t to_write = tx_size ? *tx_size : 0;
+    if (rx_size) *rx_size = 0;
+    if (tx_size) *tx_size = 0;
+    UNUSED(term);
+#if defined(POSIX_TERM_IMPL)
+    fd_set rfds, wfds;
+    struct timeval timeout = {0};
+    int nfds = EVAL_MAX(term->rfd, term->wfd) + 1;
+    FD_ZERO(&rfds);
+    FD_ZERO(&wfds);
+    if (to_read) FD_SET(term->rfd, &rfds);
+    if (to_write) FD_SET(term->wfd, &wfds);
+    if ((to_read || to_write) && select(nfds, to_read ? &rfds : NULL, to_write ? &wfds : NULL, NULL, &timeout) > 0) {
+        if (to_write && FD_ISSET(term->wfd, &wfds)) {
+            int tmp = write(term->wfd, buffer, to_write);
+            *tx_size = tmp > 0 ? tmp : 0;
+        }
+        if (to_read && FD_ISSET(term->rfd, &rfds)) {
+            int tmp = read(term->rfd, buffer, to_read);
+            *rx_size = tmp > 0 ? tmp : 0;
+        }
+    }
+#elif defined(WIN32_TERM_IMPL)
+    if (to_write) {
+        DWORD count = 0;
+        WriteConsoleA(GetStdHandle(STD_OUTPUT_HANDLE), buffer, to_write, &count, NULL);
+        *tx_size = count;
+    }
+    if (to_read && _kbhit()) {
+        wchar_t w_buf[64] = {0};
+        size_t count = EVAL_MIN(to_read / 6, STATIC_ARRAY_SIZE(w_buf));
+        DWORD w_chars = 0;
+        ReadConsoleW(GetStdHandle(STD_INPUT_HANDLE), w_buf, count, &w_chars, NULL);
+        *rx_size = WideCharToMultiByte(CP_UTF8, 0,
+            w_buf, w_chars, buffer, to_read, NULL, NULL);
+    }
+#else
+    UNUSED(to_read);
+    if (to_write) {
+        printf("%s", buffer);
+        *tx_size = to_write;
+    }
+#endif
+}
+
+// Handles VM-related hotkeys
+static void term_process_input(chardev_term_t* term, char* buffer, size_t size)
+{
+    for (size_t i=0; i<size; ++i) {
+        if (term->ctrl_a) {
+            if (buffer[i] == 'x') {
+                // Exit on Ctrl+A, x
+                exit(0);
+            }
+        }
+
+        // Ctrl+A (SOH VT code)
+        term->ctrl_a = buffer[i] == 1;
+    }
+}
+
+static void term_update(chardev_t* dev)
+{
+    chardev_term_t* term = dev->data;
+    uint32_t flags = 0;
+    char buffer[256] = {0};
+    size_t rx_size = 0, tx_size = 0;
+
+    spin_lock(&term->io_lock);
+    spin_lock(&term->lock);
+    rx_size = EVAL_MIN(ringbuf_space(&term->rx), sizeof(buffer));
+    tx_size = ringbuf_peek(&term->tx, buffer, sizeof(buffer));
+    spin_unlock(&term->lock);
+
+    term_push_io(term, buffer, &rx_size, &tx_size);
+    term_process_input(term, buffer, rx_size);
+
+    spin_lock(&term->lock);
+    ringbuf_write(&term->rx, buffer, rx_size);
+    ringbuf_skip(&term->tx, tx_size);
+    flags = term_update_flags(term);
+    spin_unlock(&term->lock);
+    spin_unlock(&term->io_lock);
+
+    if (flags) chardev_notify(&term->chardev, flags);
+}
+
+static size_t term_read(chardev_t* dev, void* buf, size_t nbytes)
+{
+    chardev_term_t* term = dev->data;
+    size_t ret = 0;
+    spin_lock(&term->lock);
+    ret = ringbuf_read(&term->rx, buf, nbytes);
+    if (!ringbuf_avail(&term->rx) && spin_try_lock(&term->io_lock)) {
+        char buffer[256] = {0};
+        size_t rx_size = sizeof(buffer);
+        term_push_io(term, buffer, &rx_size, NULL);
+        ringbuf_write(&term->rx, buffer, rx_size);
+        spin_unlock(&term->io_lock);
+    }
+    term_update_flags(term);
+    spin_unlock(&term->lock);
+    return ret;
+}
+
+static size_t term_write(chardev_t* dev, const void* buf, size_t nbytes)
+{
+    chardev_term_t* term = dev->data;
+    size_t ret = 0;
+    spin_lock(&term->lock);
+    ret = ringbuf_write(&term->tx, buf, nbytes);
+    if (!ringbuf_space(&term->tx) && spin_try_lock(&term->io_lock)) {
+        char buffer[257] = {0};
+        size_t tx_size = ringbuf_peek(&term->tx, buffer, 256);
+        term_push_io(term, buffer, NULL, &tx_size);
+        ringbuf_skip(&term->tx, tx_size);
+        spin_unlock(&term->io_lock);
+    }
+    term_update_flags(term);
+    spin_unlock(&term->lock);
+    return ret;
+}
+
+static uint32_t term_poll(chardev_t* dev)
+{
+    chardev_term_t* term = dev->data;
+    return atomic_load_uint32(&term->flags);
+}
+
+static void term_remove(chardev_t* dev)
+{
+    chardev_term_t* term = dev->data;
+    term_update(dev);
+    ringbuf_destroy(&term->rx);
+    ringbuf_destroy(&term->tx);
+#ifdef POSIX_TERM_IMPL
+    if (term->rfd != 0) close(term->rfd);
+    if (term->wfd != 1 && term->wfd != term->rfd) close(term->wfd);
+#endif
+    free(term);
+}
+
+PUBLIC chardev_t* chardev_term_create(void)
+{
+    DO_ONCE(term_rawmode());
+    return chardev_fd_create(0, 1);
+}
+
+PUBLIC chardev_t* chardev_fd_create(int rfd, int wfd)
+{
+#ifndef POSIX_TERM_IMPL
+    if (rfd != 0 || wfd != 1) {
+        rvvm_error("No FD chardev support on non-POSIX");
+        return NULL;
+    }
+#endif
+
+    chardev_term_t* term = safe_new_obj(chardev_term_t);
+    ringbuf_create(&term->rx, 256);
+    ringbuf_create(&term->tx, 256);
+    term->chardev.data = term;
+    term->chardev.read = term_read;
+    term->chardev.write = term_write;
+    term->chardev.poll = term_poll;
+    term->chardev.update = term_update;
+    term->chardev.remove = term_remove;
+    term->rfd = rfd;
+    term->wfd = wfd;
+
+    return &term->chardev;
+}
+
+PUBLIC chardev_t* chardev_pty_create(const char* path)
+{
+    if (rvvm_strcmp(path, "stdout")) return chardev_term_create();
+    if (rvvm_strcmp(path, "null")) return NULL; // NULL chardev
+#ifdef POSIX_TERM_IMPL
+    int fd = open(path, O_RDWR | O_CLOEXEC);
+    if (fd >= 0) return chardev_fd_create(fd, fd);
+    rvvm_error("Could not open PTY %s", path);
+#else
+    rvvm_error("No PTY chardev support on non-POSIX");
+#endif
+    return NULL;
+}
diff --git a/app/src/main/java/libengine/RVVM/src/devices/clint.c b/app/src/main/java/libengine/RVVM/src/devices/clint.c
new file mode 100644
index 00000000..b39af3d9
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/clint.c
@@ -0,0 +1,168 @@
+/*
+clint.c - RISC-V Advanced Core Local Interruptor
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "clint.h"
+#include "../riscv_hart.h"
+#include "../mem_ops.h"
+#include "../bit_ops.h"
+
+#define CLINT_MMIO_SIZE    0x10000
+#define ACLINT_MSWI_SIZE   0x4000
+#define ACLINT_MTIMER_SIZE 0x8000
+
+static rvvm_mmio_type_t aclint_mswi_dev_type = {
+    .name = "aclint_mswi",
+};
+
+static rvvm_mmio_type_t aclint_mtimer_dev_type = {
+    .name = "aclint_mtimer",
+};
+
+static bool aclint_mswi_read(rvvm_mmio_dev_t* device, void* data, size_t offset, uint8_t size)
+{
+    size_t hartid = offset >> 2;
+    UNUSED(size);
+
+    if (hartid < vector_size(device->machine->harts)) {
+        rvvm_hart_t* vm = vector_at(device->machine->harts, hartid);
+        write_uint32_le_m(data, (riscv_interrupts_raised(vm) >> INTERRUPT_MSOFTWARE) & 1);
+        return true;
+    }
+
+    return false;
+}
+
+static bool aclint_mswi_write(rvvm_mmio_dev_t* device, void* data, size_t offset, uint8_t size)
+{
+    size_t hartid = offset >> 2;
+    UNUSED(size);
+
+    if (hartid < vector_size(device->machine->harts)) {
+        rvvm_hart_t* vm = vector_at(device->machine->harts, hartid);
+        if (read_uint32_le_m(data) & 1) {
+            riscv_interrupt(vm, INTERRUPT_MSOFTWARE);
+        } else {
+            riscv_interrupt_clear(vm, INTERRUPT_MSOFTWARE);
+        }
+        return true;
+    }
+
+    return false;
+}
+
+static bool aclint_mtimer_read(rvvm_mmio_dev_t* device, void* data, size_t offset, uint8_t size)
+{
+    size_t hartid = offset >> 3;
+    UNUSED(size);
+
+    if (offset == 0x7FF8) {
+        write_uint64_le_m(data, rvtimer_get(&device->machine->timer));
+        return true;
+    }
+
+    if (hartid < vector_size(device->machine->harts)) {
+        rvvm_hart_t* vm = vector_at(device->machine->harts, hartid);
+        write_uint64_le_m(data, rvtimecmp_get(&vm->mtimecmp));
+        return true;
+    }
+
+    return false;
+}
+
+static bool aclint_mtimer_write(rvvm_mmio_dev_t* device, void* data, size_t offset, uint8_t size)
+{
+    size_t hartid = offset >> 3;
+    UNUSED(size);
+
+    if (offset == 0x7FF8) {
+        rvtimer_rebase(&device->machine->timer, read_uint64_le_m(data));
+        return true;
+    }
+
+    if (hartid < vector_size(device->machine->harts)) {
+        rvvm_hart_t* vm = vector_at(device->machine->harts, hartid);
+        rvtimecmp_set(&vm->mtimecmp, read_uint64_le_m(data));
+        if (rvtimecmp_pending(&vm->mtimecmp)) {
+            riscv_interrupt(vm, INTERRUPT_MTIMER);
+        } else {
+            riscv_interrupt_clear(vm, INTERRUPT_MTIMER);
+        }
+        return true;
+    }
+
+    return false;
+}
+
+PUBLIC void clint_init(rvvm_machine_t* machine, rvvm_addr_t addr)
+{
+    rvvm_mmio_dev_t aclint_mswi = {
+        .addr = addr,
+        .size = ACLINT_MSWI_SIZE,
+        .min_op_size = 4,
+        .max_op_size = 4,
+        .read = aclint_mswi_read,
+        .write = aclint_mswi_write,
+        .type = &aclint_mswi_dev_type,
+    };
+
+    rvvm_mmio_dev_t aclint_mtimer = {
+        .addr = addr + ACLINT_MSWI_SIZE,
+        .size = ACLINT_MTIMER_SIZE,
+        .min_op_size = 8,
+        .max_op_size = 8,
+        .read = aclint_mtimer_read,
+        .write = aclint_mtimer_write,
+        .type = &aclint_mtimer_dev_type,
+    };
+
+    rvvm_attach_mmio(machine, &aclint_mswi);
+    rvvm_attach_mmio(machine, &aclint_mtimer);
+
+#ifdef USE_FDT
+    struct fdt_node* clint = fdt_node_create_reg("clint", addr);
+    struct fdt_node* cpus = fdt_node_find(rvvm_get_fdt_root(machine), "cpus");
+    size_t irq_ext_cells = vector_size(machine->harts) << 2;
+    uint32_t* irq_ext = safe_calloc(irq_ext_cells, sizeof(uint32_t));
+
+    fdt_node_add_prop_reg(clint, "reg", addr, CLINT_MMIO_SIZE);
+    fdt_node_add_prop(clint, "compatible", "sifive,clint0\0riscv,clint0", 27);
+
+    vector_foreach(machine->harts, i) {
+        struct fdt_node* cpu = fdt_node_find_reg(cpus, "cpu", i);
+        struct fdt_node* cpu_irq = fdt_node_find(cpu, "interrupt-controller");
+        if (cpu_irq) {
+            uint32_t irq_phandle = fdt_node_get_phandle(cpu_irq);
+            irq_ext[(i << 2)] = irq_ext[(i << 2) + 2] = irq_phandle;
+            irq_ext[(i << 2) + 1] = INTERRUPT_MSOFTWARE;
+            irq_ext[(i << 2) + 3] = INTERRUPT_MTIMER;
+        } else {
+            rvvm_warn("Missing nodes in FDT!");
+        }
+    }
+
+    fdt_node_add_prop_cells(clint, "interrupts-extended", irq_ext, irq_ext_cells);
+    fdt_node_add_child(rvvm_get_fdt_soc(machine), clint);
+    free(irq_ext);
+#endif
+}
+
+PUBLIC void clint_init_auto(rvvm_machine_t* machine)
+{
+    rvvm_addr_t addr = rvvm_mmio_zone_auto(machine, CLINT_DEFAULT_MMIO, CLINT_MMIO_SIZE);
+    clint_init(machine, addr);
+}
diff --git a/app/src/main/java/libengine/RVVM/src/devices/clint.h b/app/src/main/java/libengine/RVVM/src/devices/clint.h
new file mode 100644
index 00000000..f945125b
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/clint.h
@@ -0,0 +1,29 @@
+/*
+clint.h - RISC-V Advanced Core Local Interruptor
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef CLINT_H
+#define CLINT_H
+
+#include "../rvvmlib.h"
+
+#define CLINT_DEFAULT_MMIO 0x2000000
+
+PUBLIC void clint_init(rvvm_machine_t* machine, rvvm_addr_t addr);
+PUBLIC void clint_init_auto(rvvm_machine_t* machine);
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/devices/eth-oc.c b/app/src/main/java/libengine/RVVM/src/devices/eth-oc.c
new file mode 100644
index 00000000..434e255e
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/eth-oc.c
@@ -0,0 +1,564 @@
+/*
+eth-oc.c - OpenCores Ethernet MAC controller
+Copyright (C) 2021  cerg2010cerg2010 <github.com/cerg2010cerg2010>
+                    LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifdef USE_NET
+
+#include "eth-oc.h"
+#include "tap_api.h"
+#include "../mem_ops.h"
+#include "../spinlock.h"
+#include "../utils.h"
+
+#ifdef USE_FDT
+#include "../fdtlib.h"
+#endif
+
+// Device registers
+#define ETHOC_MODER         0x00 // Mode
+#define ETHOC_INT_SRC       0x04 // Interrupt Source
+#define ETHOC_INT_MASK      0x08 // Interrupt Mask
+#define ETHOC_IPGT          0x0C // Inter-packet Gap
+#define ETHOC_IPGR1         0x10
+#define ETHOC_IPGR2         0x14
+#define ETHOC_PACKETLEN     0x18 // Min/Max Packet Length
+#define ETHOC_COLLCONF      0x1C // Collision & Retry Configuration
+#define ETHOC_TX_BD_NUM     0x20 // Number of TX BD (Max 0x80)
+#define ETHOC_CTRLMODER     0x24 // Control Module Mode
+#define ETHOC_MIIMODER      0x28 // MII Mode
+#define ETHOC_MIICOMMAND    0x2C // MII Command
+#define ETHOC_MIIADDRESS    0x30 // MII Address
+#define ETHOC_MIITX_DATA    0x34 // MII TX Data
+#define ETHOC_MIIRX_DATA    0x38 // MII RX Data
+#define ETHOC_MIISTATUS     0x3C // MII Status
+#define ETHOC_MAC_ADDR0     0x40 // Four LSB bytes of MAC Address
+#define ETHOC_MAC_ADDR1     0x44 // Two MSB bytes of MAC Address
+#define ETHOC_ETH_HASH0_ADR 0x48
+#define ETHOC_ETH_HASH1_ADR 0x4C
+#define ETHOC_TXCTRL        0x50
+
+// MODER fields
+#define ETHOC_MODER_DMAEN    (1 << 17) // DMA Enable
+#define ETHOC_MODER_RECSMALL (1 << 16) // Receive Small Packets (<MINFL)
+#define ETHOC_MODER_PAD      (1 << 15) // Padding enabled
+#define ETHOC_MODER_HUGEN    (1 << 14) // Huge Packets Enable (<=64kB)
+#define ETHOC_MODER_CRCEN    (1 << 13) // TX appends CRC to every frame
+#define ETHOC_MODER_DLYCRCEN (1 << 12) // CRC calculation starts 4 bytes after the SFD
+#define ETHOC_MODER_RST      (1 << 11) // Reset MAC
+#define ETHOC_MODER_FULLD    (1 << 10) // Full Duplex
+#define ETHOC_MODER_EXDFREN  (1 << 9)  // MAC waits for the carrier indefinitely
+#define ETHOC_MODER_NOBCKOF  (1 << 8)  // No Backoff
+#define ETHOC_MODER_LOOPBCK  (1 << 7)  // Loopback (TX is looped back to the RX)
+#define ETHOC_MODER_IFG      (1 << 6)  // Interframe Gap
+#define ETHOC_MODER_PRO      (1 << 5)  // Promiscuous (Receive any fram)
+#define ETHOC_MODER_IAM      (1 << 4)  // IAM (Use hashtable to check address)
+#define ETHOC_MODER_BRO      (1 << 3)  // Reject all broadcast frames
+#define ETHOC_MODER_NOPRE    (1 << 2)  // No Preamble
+#define ETHOC_MODER_TXEN     (1 << 1)  // Transmit Enable
+#define ETHOC_MODER_RXEN     (1 << 0)  // Receive Enable
+
+// Interrupt numbers
+#define ETHOC_INT_RXC  0x6 // Control frame received
+#define ETHOC_INT_TXC  0x5 // control frame transmitted
+#define ETHOC_INT_BUSY 0x4 // Buffer received and discarded
+#define ETHOC_INT_RXE  0x3 // Receive error
+#define ETHOC_INT_RXB  0x2 // Frame received
+#define ETHOC_INT_TXE  0x1 // Transmit error
+#define ETHOC_INT_TXB  0x0 // Frame transmitted
+
+// CTRLMODER fields
+#define ETHOC_CTRLMODER_TXFLOW  (1 << 2) // Transmit Flow Control (Allow PAUSE)
+#define ETHOC_CTRLMODER_RXFLOW  (1 << 1) // Receive Flow Control (Block on PAUSE)
+#define ETHOC_CTRLMODER_PASSALL (1 << 0) // Pass all receive frames
+
+// MIIMODER fields
+#define ETHOC_MIIMODER_MIIMRST  (1 << 10) // Reset MIIM Module
+#define ETHOC_MIIMODER_MIINOPRE (1 << 8)  // No Preamble
+// CLKDIV in the lower 8 bits
+
+// MIICOMMAND fields
+#define ETHOC_MIICOMMAND_WCTRLDATA (1 << 2) // Write control data
+#define ETHOC_MIICOMMAND_RSTAT     (1 << 1) // Read status
+#define ETHOC_MIICOMMAND_SCANSTAT  (1 << 0) // Scan status
+
+// MIISTATUS fields
+#define ETHOC_MIISTATUS_NVALID   (1 << 2)
+#define ETHOC_MIISTATUS_BUSY     (1 << 1)
+#define ETHOC_MIISTATUS_LINKFAIL (1 << 0)
+
+// TXCTRL field
+#define ETHOC_TXCTRL_TXPAUSERQ (1 << 16)
+
+// Generic BD fields
+#define ETHOC_BD_IRQ   (1 << 14) // Send IRQ after BD operation
+#define ETHOC_BD_WRAP  (1 << 13) // This is the last BD in table
+
+// Transmit BD fields
+#define ETHOC_TXBD_RD  (1 << 15) // TX BD Ready
+#define ETHOC_TXBD_PAD (1 << 12) // Pad short packets
+#define ETHOC_TXBD_CRC (1 << 11) // Add CRC at the end of packet
+#define ETHOC_TXBD_UR  (1 << 8)
+#define ETHOC_TXBD_RL  (1 << 3)
+#define ETHOC_TXBD_LC  (1 << 2)
+#define ETHOC_TXBD_DF  (1 << 1)
+#define ETHOC_TXBD_CS  (1 << 0)
+
+// Receive BD fields
+#define ETHOC_RXBD_E   (1 << 15) // RX BD Empty
+#define ETHOC_RXBD_M   (1 << 7)
+#define ETHOC_RXBD_OR  (1 << 6)  // Memory Overrun
+#define ETHOC_RXBD_IS  (1 << 5)
+#define ETHOC_RXBD_DN  (1 << 4)
+#define ETHOC_RXBD_TL  (1 << 3)
+#define ETHOC_RXBD_SF  (1 << 2)
+#define ETHOC_RXBD_CRC (1 << 1)
+#define ETHOC_RXBD_LC  (1 << 0)
+
+// Max BD count
+#define ETHOC_BD_COUNT  0x80
+#define ETHOC_BD_BUFSIZ 0x400
+
+// BD register start address
+#define ETHOC_BD_ADDR   0x400
+
+#define MII_REG_BMCR    0
+#define MII_REG_BMSR    1
+#define MII_REG_PHYIDR1 2
+#define MII_REG_PHYIDR2 3
+
+// Buffer Descriptor
+struct ethoc_bd
+{
+    uint32_t data;
+    uint32_t ptr;
+};
+
+struct ethoc_dev
+{
+    struct ethoc_bd bdbuf[ETHOC_BD_COUNT];
+    tap_dev_t* tap;
+    spinlock_t lock;
+    spinlock_t rx_lock;
+
+    rvvm_machine_t* machine;
+    plic_ctx_t* plic;
+    uint32_t irq;
+    uint32_t cur_txbd;
+    uint32_t cur_rxbd;
+
+    uint32_t moder;
+    uint32_t int_src;
+    uint32_t int_mask;
+    uint32_t packetlen;
+    uint32_t collconf;
+    uint32_t tx_bd_num;
+    uint32_t ctrlmoder;
+    uint32_t miimoder;
+    uint32_t miiaddress;
+    uint32_t miitx_data;
+    uint32_t miirx_data;
+    uint32_t miistatus;
+    // IDK what HASH0/1 registers are for...
+    // Judging from Linux driver source, they're used with multicast filtering
+    uint32_t hash[2];
+    uint32_t txctrl;
+    uint8_t macaddr[6];
+};
+
+static void ethoc_interrupt(struct ethoc_dev *eth, uint8_t int_num)
+{
+    uint32_t irqs = atomic_or_uint32(&eth->int_src, (1 << int_num)) | (1 << int_num);
+    if (irqs & atomic_load_uint32(&eth->int_mask)) plic_send_irq(eth->plic, eth->irq);
+}
+
+static void ethoc_process_tx(struct ethoc_dev *eth)
+{
+    // Loop until the queue is drained
+    for (size_t i=0; i<ETHOC_BD_COUNT; ++i) {
+        struct ethoc_bd* txbd = &eth->bdbuf[eth->cur_txbd];
+        if (!(eth->moder & ETHOC_MODER_TXEN) || !(txbd->data & ETHOC_TXBD_RD)) {
+            // Nothing to send
+            return;
+        }
+
+        size_t size = (txbd->data >> 16) & 0xFFFF;
+        void* dma = rvvm_get_dma_ptr(eth->machine, txbd->ptr, size);
+        if (dma) {
+            int ret = tap_send(eth->tap, dma, size);
+            if (ret > 0) {
+                // Success
+                txbd->data &= ~ETHOC_TXBD_RD;
+                if (txbd->data & ETHOC_BD_IRQ) ethoc_interrupt(eth, ETHOC_INT_TXB);
+            } else {
+                // Transmit error
+                txbd->data = (txbd->data & ~ETHOC_TXBD_RD) | ETHOC_TXBD_RL;
+                ethoc_interrupt(eth, ETHOC_INT_TXE);
+            }
+        } else {
+            // DMA Error
+            txbd->data = (txbd->data & ~ETHOC_TXBD_RD) | ETHOC_TXBD_CS;
+            ethoc_interrupt(eth, ETHOC_INT_TXE);
+        }
+
+        if (txbd->data & ETHOC_BD_WRAP || eth->cur_txbd == eth->tx_bd_num) {
+            eth->cur_txbd = 0;
+        } else {
+            eth->cur_txbd++;
+        }
+    }
+}
+
+static bool ethoc_feed_rx(void* net_dev, const void* data, size_t size)
+{
+    struct ethoc_dev* eth = (struct ethoc_dev*)net_dev;
+
+    // Receiver disabled
+    if (!(atomic_load_uint32(&eth->moder) & ETHOC_MODER_RXEN)) return false;
+
+    spin_lock(&eth->rx_lock);
+    struct ethoc_bd* rxbd = &eth->bdbuf[eth->cur_rxbd];
+    uint32_t flags = atomic_load_uint32(&rxbd->data);
+    if (!(flags & ETHOC_RXBD_E)) {
+        // Ring overrun
+        spin_unlock(&eth->rx_lock);
+        return false;
+    }
+    flags &= ~ETHOC_RXBD_E;
+
+    size_t f_size = size + 4;
+    uint32_t size_lim = atomic_load_uint32(&eth->packetlen);
+    uint8_t* dma = rvvm_get_dma_ptr(eth->machine, atomic_load_uint32(&rxbd->ptr), f_size);
+    if (dma == NULL || f_size > (size_lim & 0xFFFF)) {
+        // DMA Error
+        atomic_store_uint32(&rxbd->data, flags | ETHOC_RXBD_OR);
+        spin_unlock(&eth->rx_lock);
+        ethoc_interrupt(eth, ETHOC_INT_RXE);
+        return false;
+    }
+
+    memcpy(dma, data, size);
+    memset(dma + size, 0, 4); // Append bogus CRC32 FCS
+    atomic_store_uint32(&rxbd->data, (f_size & 0xFFFF) << 16 | (flags & 0xFFFF));
+
+    if ((flags & ETHOC_BD_WRAP) || eth->cur_rxbd == ETHOC_BD_COUNT) {
+        eth->cur_rxbd = eth->tx_bd_num;
+    } else {
+        eth->cur_rxbd++;
+    }
+
+    spin_unlock(&eth->rx_lock);
+    if (flags & ETHOC_BD_IRQ) ethoc_interrupt(eth, ETHOC_INT_RXB);
+    return true;
+}
+
+static bool ethoc_data_mmio_read(rvvm_mmio_dev_t* dev, void* data, size_t offset, uint8_t size)
+{
+    struct ethoc_dev* eth = (struct ethoc_dev*)dev->data;
+    UNUSED(size);
+
+    spin_lock(&eth->lock);
+    switch (offset) {
+        case ETHOC_MODER:
+            write_uint32_le_m(data, atomic_load_uint32(&eth->moder));
+            break;
+        case ETHOC_INT_SRC:
+            write_uint32_le_m(data, atomic_load_uint32(&eth->int_src));
+            break;
+        case ETHOC_INT_MASK:
+            write_uint32_le_m(data, atomic_load_uint32(&eth->int_mask));
+            break;
+        case ETHOC_IPGT:
+        case ETHOC_IPGR1:
+        case ETHOC_IPGR2:
+            // ignore
+            write_uint32_le_m(data, 0);
+            break;
+        case ETHOC_PACKETLEN:
+            write_uint32_le_m(data, atomic_load_uint32(&eth->packetlen));
+            break;
+        case ETHOC_COLLCONF:
+            write_uint32_le_m(data, eth->collconf);
+            break;
+        case ETHOC_TX_BD_NUM:
+            write_uint32_le_m(data, eth->tx_bd_num);
+            break;
+        case ETHOC_CTRLMODER:
+            write_uint32_le_m(data, eth->ctrlmoder);
+            break;
+        case ETHOC_MIIMODER:
+            write_uint32_le_m(data, eth->miimoder);
+            break;
+        case ETHOC_MIICOMMAND:
+            write_uint32_le_m(data, 0);
+            break;
+        case ETHOC_MIIADDRESS:
+            write_uint32_le_m(data, eth->miiaddress);
+            break;
+        case ETHOC_MIITX_DATA:
+            write_uint32_le_m(data, eth->miitx_data);
+            break;
+        case ETHOC_MIIRX_DATA:
+            write_uint32_le_m(data, eth->miirx_data);
+            break;
+        case ETHOC_MIISTATUS:
+            write_uint32_le_m(data, eth->miistatus);
+            break;
+        case ETHOC_MAC_ADDR0:
+            tap_get_mac(eth->tap, eth->macaddr);
+            write_uint32_le_m(data, read_uint32_be_m(eth->macaddr + 2));
+            break;
+        case ETHOC_MAC_ADDR1:
+            tap_get_mac(eth->tap, eth->macaddr);
+            write_uint32_le_m(data, read_uint16_be_m(eth->macaddr));
+            break;
+        case ETHOC_ETH_HASH0_ADR:
+            write_uint32_le_m(data, eth->hash[0]);
+            break;
+        case ETHOC_ETH_HASH1_ADR:
+            write_uint32_le_m(data, eth->hash[1]);
+            break;
+        case ETHOC_TXCTRL:
+            write_uint32_le_m(data, eth->txctrl);
+            break;
+        default:
+            if (offset >= ETHOC_BD_ADDR && offset < ETHOC_BD_ADDR + ETHOC_BD_BUFSIZ) {
+                size_t bdid = (offset - ETHOC_BD_ADDR) >> 3;
+                struct ethoc_bd* bd = &eth->bdbuf[bdid];
+                if (offset & 4) {
+                    write_uint32_le_m(data, atomic_load_uint32(&bd->ptr));
+                } else {
+                    write_uint32_le_m(data, atomic_load_uint32(&bd->data));
+                }
+            } else {
+                write_uint32_le_m(data, 0);
+            }
+            break;
+    }
+
+    spin_unlock(&eth->lock);
+    return true;
+}
+
+static bool ethoc_data_mmio_write(rvvm_mmio_dev_t* dev, void* data, size_t offset, uint8_t size)
+{
+    struct ethoc_dev* eth = (struct ethoc_dev*)dev->data;
+    UNUSED(size);
+
+    spin_lock(&eth->lock);
+    switch (offset) {
+        case ETHOC_MODER: {
+                uint32_t new_moder = read_uint32_le_m(data);
+                if (eth->tx_bd_num == 0) new_moder &= ~ETHOC_MODER_TXEN;
+                if (eth->tx_bd_num >= ETHOC_BD_COUNT) new_moder &= ~ETHOC_MODER_RXEN;
+                uint32_t prev_moder = atomic_swap_uint32(&eth->moder, new_moder);
+                if ((prev_moder ^ new_moder) & ETHOC_MODER_RXEN) {
+                    // Toggled RX
+                    spin_lock(&eth->rx_lock);
+                    eth->cur_rxbd = eth->tx_bd_num;
+                    spin_unlock(&eth->rx_lock);
+                }
+
+                if ((prev_moder ^ new_moder) & ETHOC_MODER_TXEN) {
+                    // Toggled TX
+                    eth->cur_txbd = 0;
+                    ethoc_process_tx(eth);
+                }
+                break;
+            }
+        case ETHOC_INT_SRC:
+            // Bits are cleared by writing 1 to them
+            atomic_and_uint32(&eth->int_src, ~read_uint32_le_m(data));
+            break;
+        case ETHOC_INT_MASK:
+            atomic_store_uint32(&eth->int_mask, read_uint32_le_m(data));
+
+            if (atomic_load_uint32(&eth->int_src) & read_uint32_le_m(data)) {
+                plic_send_irq(eth->plic, eth->irq);
+            }
+            break;
+        case ETHOC_IPGT:
+        case ETHOC_IPGR1:
+        case ETHOC_IPGR2:
+            // Ignore
+            break;
+        case ETHOC_PACKETLEN:
+            atomic_store_uint32(&eth->packetlen, read_uint32_le_m(data));
+            break;
+        case ETHOC_COLLCONF:
+            eth->collconf = read_uint32_le_m(data);
+            break;
+        case ETHOC_TX_BD_NUM:
+            eth->tx_bd_num = EVAL_MIN(read_uint32_le_m(data), ETHOC_BD_COUNT);
+            break;
+        case ETHOC_CTRLMODER:
+            eth->ctrlmoder = read_uint32_le_m(data);
+            break;
+        case ETHOC_MIIMODER:
+            eth->miimoder = read_uint32_le_m(data);
+            break;
+        case ETHOC_MIICOMMAND:
+            if (read_uint32_le_m(data) & ETHOC_MIICOMMAND_RSTAT) {
+                if ((eth->miiaddress & 0x1f) == 0                     // PHY id 0
+                && ((eth->miiaddress >> 8) & 0x1f) == MII_REG_BMSR) { // Link is up
+                    eth->miirx_data = (1 << 2);
+                } else {
+                    eth->miirx_data = 0;
+                }
+            }
+            break;
+        case ETHOC_MIIADDRESS:
+            eth->miiaddress = read_uint32_le_m(data);
+            break;
+        case ETHOC_MIITX_DATA:
+            eth->miitx_data = read_uint32_le_m(data);
+            break;
+        case ETHOC_MIIRX_DATA:
+            // RO, but was RW in older spec
+            // eth->miirx_data = read_uint32_le_m(data);
+            break;
+        case ETHOC_MIISTATUS:
+            eth->miistatus = read_uint32_le_m(data);
+            break;
+        case ETHOC_MAC_ADDR0:
+            write_uint32_be_m(eth->macaddr + 2, read_uint32_le_m(data));
+            tap_set_mac(eth->tap, eth->macaddr);
+            break;
+        case ETHOC_MAC_ADDR1:
+            write_uint16_be_m(eth->macaddr, read_uint32_le_m(data));
+            tap_set_mac(eth->tap, eth->macaddr);
+            break;
+        case ETHOC_ETH_HASH0_ADR:
+            eth->hash[0] = read_uint32_le_m(data);
+            break;
+        case ETHOC_ETH_HASH1_ADR:
+            eth->hash[1] = read_uint32_le_m(data);
+            break;
+        case ETHOC_TXCTRL:
+            eth->txctrl = read_uint32_le_m(data);
+            break;
+        default:
+            if (offset >= ETHOC_BD_ADDR && offset < ETHOC_BD_ADDR + ETHOC_BD_BUFSIZ) {
+                size_t bdid = (offset - ETHOC_BD_ADDR) >> 3;
+                struct ethoc_bd* bd = &eth->bdbuf[bdid];
+                if (offset & 4) {
+                    atomic_store_uint32(&bd->ptr, read_uint32_le_m(data));
+                } else {
+                    atomic_store_uint32(&bd->data, read_uint32_le_m(data));
+                }
+
+                // TX BD might be modified
+                if (bdid < eth->tx_bd_num) {
+                    ethoc_process_tx(eth);
+                }
+            }
+            break;
+    }
+
+    spin_unlock(&eth->lock);
+    return true;
+}
+
+static void ethoc_reset(rvvm_mmio_dev_t* dev)
+{
+    struct ethoc_dev* eth = dev->data;
+    spin_lock(&eth->lock);
+    memset(&eth->bdbuf, 0, sizeof(eth->bdbuf));
+    eth->moder = ETHOC_MODER_PAD | ETHOC_MODER_CRCEN;
+    eth->int_src = 0;
+    eth->int_mask = 0;
+    eth->packetlen = 0x3C0600;
+    eth->collconf = 0xf003f;
+    eth->tx_bd_num = 0x40;
+    eth->ctrlmoder = 0;
+    eth->miimoder = 0x64;
+    eth->miiaddress = 0;
+    eth->miitx_data = 0;
+    eth->miirx_data = 0;
+    eth->miistatus = 0;
+    memset(eth->macaddr, 0, sizeof(eth->macaddr));
+    eth->hash[0] = 0;
+    eth->hash[1] = 0;
+    eth->txctrl = 0;
+    spin_unlock(&eth->lock);
+}
+
+static void ethoc_remove(rvvm_mmio_dev_t* device)
+{
+    struct ethoc_dev *eth = (struct ethoc_dev *) device->data;
+    tap_close(eth->tap);
+    free(eth);
+}
+
+static rvvm_mmio_type_t ethoc_dev_type = {
+    .name = "ethernet_oc",
+    .remove = ethoc_remove,
+    .reset = ethoc_reset,
+};
+
+PUBLIC rvvm_mmio_dev_t* ethoc_init(rvvm_machine_t* machine, tap_dev_t* tap,
+                                   rvvm_addr_t base_addr, plic_ctx_t* plic, uint32_t irq)
+{
+    struct ethoc_dev* eth = safe_new_obj(struct ethoc_dev);
+    tap_net_dev_t nic = {
+        .net_dev = eth,
+        .feed_rx = ethoc_feed_rx,
+    };
+
+    eth->plic = plic;
+    eth->irq = irq;
+    eth->machine = machine;
+
+    eth->tap = tap;
+    tap_attach(tap, &nic);
+
+    rvvm_mmio_dev_t ethoc_dev = {
+        .min_op_size = 4,
+        .max_op_size = 4,
+        .read = ethoc_data_mmio_read,
+        .write = ethoc_data_mmio_write,
+        .type = &ethoc_dev_type,
+        .addr = base_addr,
+        .size = 0x800,
+        .data = eth,
+    };
+    rvvm_mmio_dev_t* mmio = rvvm_attach_mmio(machine, &ethoc_dev);
+    if (mmio == NULL) return mmio;
+#ifdef USE_FDT
+    struct fdt_node* ethoc = fdt_node_create_reg("ethernet", base_addr);
+    fdt_node_add_prop_reg(ethoc, "reg", base_addr, 0x800);
+    fdt_node_add_prop_str(ethoc, "compatible", "opencores,ethoc");
+    fdt_node_add_prop_u32(ethoc, "interrupt-parent", plic_get_phandle(plic));
+    fdt_node_add_prop_u32(ethoc, "interrupts", irq);
+    fdt_node_add_child(rvvm_get_fdt_soc(machine), ethoc);
+#endif
+    return mmio;
+}
+
+PUBLIC rvvm_mmio_dev_t* ethoc_init_auto(rvvm_machine_t* machine)
+{
+    tap_dev_t* tap = tap_open();
+    if (tap == NULL) {
+        rvvm_error("Failed to create TAP device!");
+        return NULL;
+    }
+    plic_ctx_t* plic = rvvm_get_plic(machine);
+    rvvm_addr_t addr = rvvm_mmio_zone_auto(machine, ETHOC_DEFAULT_MMIO, 0x800);
+    return ethoc_init(machine, tap, addr, plic, plic_alloc_irq(plic));
+}
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/devices/eth-oc.h b/app/src/main/java/libengine/RVVM/src/devices/eth-oc.h
new file mode 100644
index 00000000..0bd0b3ce
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/eth-oc.h
@@ -0,0 +1,33 @@
+/*
+eth-oc.h - OpenCores Ethernet MAC controller
+Copyright (C) 2021  cerg2010cerg2010 <github.com/cerg2010cerg2010>
+                    LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef ETH_OC_H
+#define ETH_OC_H
+
+#include "../rvvmlib.h"
+#include "plic.h"
+#include "tap_api.h"
+
+#define ETHOC_DEFAULT_MMIO 0x21000000
+
+PUBLIC rvvm_mmio_dev_t* ethoc_init(rvvm_machine_t* machine, tap_dev_t* tap,
+                                   rvvm_addr_t base_addr, plic_ctx_t* plic, uint32_t irq);
+PUBLIC rvvm_mmio_dev_t* ethoc_init_auto(rvvm_machine_t* machine);
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/devices/framebuffer.c b/app/src/main/java/libengine/RVVM/src/devices/framebuffer.c
new file mode 100644
index 00000000..7a73a644
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/framebuffer.c
@@ -0,0 +1,83 @@
+/*
+framebuffer.c - Simple Framebuffer
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "framebuffer.h"
+#include "../utils.h"
+
+#ifdef USE_FDT
+#include "../fdtlib.h"
+#endif
+
+static void fb_remove(rvvm_mmio_dev_t* device)
+{
+    UNUSED(device);
+}
+
+static rvvm_mmio_type_t fb_dev_type = {
+    .name = "framebuffer",
+    .remove = fb_remove,
+};
+
+PUBLIC rvvm_mmio_dev_t* framebuffer_init(rvvm_machine_t* machine, rvvm_addr_t addr, const fb_ctx_t* fb)
+{
+    // Map the framebuffer into physical memory
+    rvvm_mmio_dev_t fb_region = {
+        .mapping = fb->buffer,
+        .addr = addr,
+        .size = framebuffer_size(fb),
+        .type = &fb_dev_type,
+    };
+    rvvm_mmio_dev_t* mmio = rvvm_attach_mmio(machine, &fb_region);
+    if (mmio == NULL) return mmio;
+#ifdef USE_FDT
+    struct fdt_node* fb_fdt = fdt_node_create_reg("framebuffer", addr);
+    fdt_node_add_prop_reg(fb_fdt, "reg", addr, fb_region.size);
+    fdt_node_add_prop_str(fb_fdt, "compatible", "simple-framebuffer");
+    switch (fb->format) {
+        case RGB_FMT_R5G6B5:
+            fdt_node_add_prop_str(fb_fdt, "format", "r5g6b5");
+            break;
+        case RGB_FMT_R8G8B8:
+            fdt_node_add_prop_str(fb_fdt, "format", "r8g8b8");
+            break;
+        case RGB_FMT_A8R8G8B8:
+            fdt_node_add_prop_str(fb_fdt, "format", "a8r8g8b8");
+            break;
+        case RGB_FMT_A8B8G8R8:
+            fdt_node_add_prop_str(fb_fdt, "format", "a8b8g8r8");
+            break;
+        default:
+            rvvm_warn("Unknown RGB format in framebuffer_init()!");
+            break;
+    }
+    fdt_node_add_prop_u32(fb_fdt, "width",  fb->width);
+    fdt_node_add_prop_u32(fb_fdt, "height", fb->height);
+    fdt_node_add_prop_u32(fb_fdt, "stride", framebuffer_stride(fb));
+
+    fdt_node_add_child(rvvm_get_fdt_soc(machine), fb_fdt);
+#endif
+    return mmio;
+}
+
+PUBLIC rvvm_mmio_dev_t* framebuffer_init_auto(rvvm_machine_t* machine, const fb_ctx_t* fb)
+{
+    rvvm_addr_t addr = rvvm_mmio_zone_auto(machine, 0x28000000, framebuffer_size(fb));
+    rvvm_mmio_dev_t* mmio = framebuffer_init(machine, addr, fb);
+    if (mmio != NULL) rvvm_append_cmdline(machine, "console=tty0");
+    return mmio;
+}
diff --git a/app/src/main/java/libengine/RVVM/src/devices/framebuffer.h b/app/src/main/java/libengine/RVVM/src/devices/framebuffer.h
new file mode 100644
index 00000000..5748915e
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/framebuffer.h
@@ -0,0 +1,98 @@
+/*
+framebuffer.h - Framebuffer context, RGB format handling
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef RVVM_FRAMEBUFFER_H
+#define RVVM_FRAMEBUFFER_H
+
+#include "../rvvmlib.h"
+
+#define RGB_FMT_INVALID  0x0
+#define RGB_FMT_R5G6B5   0x02
+#define RGB_FMT_R8G8B8   0x03
+#define RGB_FMT_A8R8G8B8 0x04 //!< Little-endian: BGRA, Big-endian: ARGB (Recommended)
+#define RGB_FMT_A8B8G8R8 0x14 //!< Little-endian: RGBA, Big-endian: ABGR
+
+//! Pixel RGB format
+typedef uint8_t rgb_fmt_t;
+
+//! Framebuffer context description
+typedef struct {
+    void*     buffer; //!< Buffer in host memory
+    uint32_t  width;  //!< Width in pixels
+    uint32_t  height; //!< Height in pixels
+    uint32_t  stride; //!< Line alignment. Set to 0 if unsure.
+    rgb_fmt_t format; //!< Pixel format
+} fb_ctx_t;
+
+/*
+ * Pixel format handling
+ */
+
+//! Get bytes per pixel for a format
+static inline size_t rgb_format_bytes(rgb_fmt_t format)
+{
+    switch (format) {
+        case RGB_FMT_R5G6B5:   return 2;
+        case RGB_FMT_R8G8B8:   return 3;
+        case RGB_FMT_A8R8G8B8: return 4;
+        case RGB_FMT_A8B8G8R8: return 4;
+    }
+    return 0;
+}
+
+//! Get bits per pixel (bpp) for a format
+static inline size_t rgb_format_bpp(rgb_fmt_t format)
+{
+    return rgb_format_bytes(format) << 3;
+}
+
+//! Get pixel format from bpp
+static inline rgb_fmt_t rgb_format_from_bpp(size_t bpp)
+{
+    switch (bpp) {
+        case 16: return RGB_FMT_R5G6B5;
+        case 24: return RGB_FMT_R8G8B8;
+        // Default to ARGB when bpp = 32, this is what most guests and hosts expect
+        case 32: return RGB_FMT_A8R8G8B8;
+    }
+    return RGB_FMT_INVALID;
+}
+
+/*
+ * Framebuffer API
+ */
+
+//! Calculate effective framebuffer stride
+static inline size_t framebuffer_stride(const fb_ctx_t* fb)
+{
+    return fb->stride ? fb->stride : fb->width * rgb_format_bytes(fb->format);
+}
+
+//! Calculate framebuffer region size
+static inline size_t framebuffer_size(const fb_ctx_t* fb)
+{
+    return framebuffer_stride(fb) * fb->height;
+}
+
+//! \brief   Attach framebuffer context to the machine.
+//! \warning The buffer is not freed automatically.
+PUBLIC rvvm_mmio_dev_t* framebuffer_init(rvvm_machine_t* machine, rvvm_addr_t addr, const fb_ctx_t* fb);
+
+PUBLIC rvvm_mmio_dev_t* framebuffer_init_auto(rvvm_machine_t* machine, const fb_ctx_t* fb);
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/devices/gpio-sifive.c b/app/src/main/java/libengine/RVVM/src/devices/gpio-sifive.c
new file mode 100644
index 00000000..20a5260c
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/gpio-sifive.c
@@ -0,0 +1,331 @@
+/*
+gpio-sifive.c - SiFive GPIO Controller
+Copyright (C) 2024  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "gpio-sifive.h"
+#include "plic.h"
+#include "../mem_ops.h"
+#include "../utils.h"
+#include "../fdtlib.h"
+
+// See https://static.dev.sifive.com/FU540-C000-v1.0.pdf
+
+#define GPIO_SIFIVE_REG_INPUT     0x00 // Pin input value
+#define GPIO_SIFIVE_REG_INPUT_EN  0x04 // Pin input enable
+#define GPIO_SIFIVE_REG_OUTPUT_EN 0x08 // Pin output enable
+#define GPIO_SIFIVE_REG_OUTPUT    0x0C // Pin output value
+#define GPIO_SIFIVE_REG_PUE       0x10 // Pull-up enable
+#define GPIO_SIFIVE_REG_DS        0x14 // Drive strength
+#define GPIO_SIFIVE_REG_RISE_IE   0x18 // Rise interrupt enable
+#define GPIO_SIFIVE_REG_RISE_IP   0x1C // Rise interrupt pending
+#define GPIO_SIFIVE_REG_FALL_IE   0x20 // Rise interrupt enable
+#define GPIO_SIFIVE_REG_FALL_IP   0x24 // Fall interrupt pending
+#define GPIO_SIFIVE_REG_HIGH_IE   0x28 // High interrupt enable
+#define GPIO_SIFIVE_REG_HIGH_IP   0x2C // High interrupt pending
+#define GPIO_SIFIVE_REG_LOW_IE    0x30 // Low interrupt enable
+#define GPIO_SIFIVE_REG_LOW_IP    0x34 // Low interrupt pending
+#define GPIO_SIFIVE_REG_OUT_XOR   0x40 // Output XOR (Invert)
+
+#define GPIO_SIFIVE_MMIO_SIZE 0x44
+
+typedef struct {
+    rvvm_gpio_dev_t* gpio;
+    plic_ctx_t* plic;
+    uint32_t plic_irqs[GPIO_SIFIVE_PINS];
+
+    // Cache IRQ lines state
+    uint32_t irqs;
+
+    // Input pins
+    uint32_t pins;
+
+    // Controller registers
+    uint32_t input_en;
+    uint32_t output_en;
+    uint32_t output;
+    uint32_t pue;
+    uint32_t ds;
+    uint32_t rise_ie;
+    uint32_t rise_ip;
+    uint32_t fall_ie;
+    uint32_t fall_ip;
+    uint32_t high_ie;
+    uint32_t high_ip;
+    uint32_t low_ie;
+    uint32_t low_ip;
+    uint32_t out_xor;
+} gpio_sifive_dev_t;
+
+static void gpio_sifive_update_irqs(gpio_sifive_dev_t* bus)
+{
+    // Combine pin IRQs
+    uint32_t ip = (atomic_load_uint32(&bus->rise_ip) & atomic_load_uint32(&bus->rise_ie))
+                | (atomic_load_uint32(&bus->fall_ip) & atomic_load_uint32(&bus->fall_ie))
+                | (atomic_load_uint32(&bus->high_ip) & atomic_load_uint32(&bus->high_ie))
+                | (atomic_load_uint32(&bus->low_ip)  & atomic_load_uint32(&bus->low_ie));
+
+    // Update PLIC IRQs
+    if (atomic_swap_uint32(&bus->irqs, ip) != ip) {
+        for (size_t i=0; i<GPIO_SIFIVE_PINS; ++i) {
+            if (ip & (1U << i)) {
+                plic_raise_irq(bus->plic, bus->plic_irqs[i]);
+            } else {
+                plic_lower_irq(bus->plic, bus->plic_irqs[i]);
+            }
+        }
+    }
+}
+
+static void gpio_sifive_update_pins(gpio_sifive_dev_t* bus, uint32_t pins)
+{
+    uint32_t old_pins = atomic_swap_uint32(&bus->pins, pins);
+    uint32_t enable = atomic_load_uint32(&bus->input_en);
+    uint32_t pins_rise = (pins & ~old_pins);
+    uint32_t pins_fall = (~pins & old_pins);
+    atomic_or_uint32(&bus->rise_ip, pins_rise & enable);
+    atomic_or_uint32(&bus->fall_ip, pins_fall & enable);
+    atomic_or_uint32(&bus->high_ip, pins & enable);
+    atomic_or_uint32(&bus->low_ip, ~pins & enable);
+    gpio_sifive_update_irqs(bus);
+}
+
+static void gpio_sifive_update_out(gpio_sifive_dev_t* bus)
+{
+    uint32_t out = atomic_load_uint32(&bus->output);
+    out &= atomic_load_uint32(&bus->output_en);
+    out ^= atomic_load_uint32(&bus->out_xor);
+    gpio_pins_out(bus->gpio, 0, out);
+}
+
+static bool gpio_sifive_pins_in(rvvm_gpio_dev_t* gpio, size_t off, uint32_t pins)
+{
+    if (off == 0) {
+        gpio_sifive_dev_t* bus = gpio->io_dev;
+        gpio_sifive_update_pins(bus, pins);
+        return true;
+    }
+    return false;
+}
+
+static uint32_t gpio_sifive_pins_read(rvvm_gpio_dev_t* gpio, size_t off)
+{
+    if (off == 0) {
+        gpio_sifive_dev_t* bus = gpio->io_dev;
+        uint32_t out = atomic_load_uint32(&bus->output);
+        out &= atomic_load_uint32(&bus->output_en);
+        out ^= atomic_load_uint32(&bus->out_xor);
+        return out;
+    }
+    return 0;
+}
+
+static bool gpio_sifive_mmio_read(rvvm_mmio_dev_t* dev, void* data, size_t offset, uint8_t size)
+{
+    gpio_sifive_dev_t* bus = dev->data;
+    memset(data, 0, size);
+    switch (offset) {
+        case GPIO_SIFIVE_REG_INPUT:
+            write_uint32_le_m(data, atomic_load_uint32(&bus->pins) & atomic_load_uint32(&bus->input_en));
+            break;
+        case GPIO_SIFIVE_REG_INPUT_EN:
+            write_uint32_le_m(data, atomic_load_uint32(&bus->input_en));
+            break;
+        case GPIO_SIFIVE_REG_OUTPUT_EN:
+            write_uint32_le_m(data, atomic_load_uint32(&bus->output_en));
+            break;
+        case GPIO_SIFIVE_REG_OUTPUT:
+            write_uint32_le_m(data, atomic_load_uint32(&bus->output));
+            break;
+        case GPIO_SIFIVE_REG_PUE:
+            write_uint32_le_m(data, atomic_load_uint32(&bus->pue));
+            break;
+        case GPIO_SIFIVE_REG_DS:
+            write_uint32_le_m(data, atomic_load_uint32(&bus->ds));
+            break;
+        case GPIO_SIFIVE_REG_RISE_IE:
+            write_uint32_le_m(data, atomic_load_uint32(&bus->rise_ie));
+            break;
+        case GPIO_SIFIVE_REG_RISE_IP:
+            write_uint32_le_m(data, atomic_load_uint32(&bus->rise_ip));
+            break;
+        case GPIO_SIFIVE_REG_FALL_IE:
+            write_uint32_le_m(data, atomic_load_uint32(&bus->fall_ie));
+            break;
+        case GPIO_SIFIVE_REG_FALL_IP:
+            write_uint32_le_m(data, atomic_load_uint32(&bus->fall_ip));
+            break;
+        case GPIO_SIFIVE_REG_HIGH_IE:
+            write_uint32_le_m(data, atomic_load_uint32(&bus->high_ie));
+            break;
+        case GPIO_SIFIVE_REG_HIGH_IP:
+            write_uint32_le_m(data, atomic_load_uint32(&bus->high_ip));
+            break;
+        case GPIO_SIFIVE_REG_LOW_IE:
+            write_uint32_le_m(data, atomic_load_uint32(&bus->low_ie));
+            break;
+        case GPIO_SIFIVE_REG_LOW_IP:
+            write_uint32_le_m(data, atomic_load_uint32(&bus->low_ip));
+            break;
+        case GPIO_SIFIVE_REG_OUT_XOR:
+            write_uint32_le_m(data, atomic_load_uint32(&bus->out_xor));
+            break;
+    }
+    return true;
+}
+
+static bool gpio_sifive_mmio_write(rvvm_mmio_dev_t* dev, void* data, size_t offset, uint8_t size)
+{
+    gpio_sifive_dev_t* bus = dev->data;
+    UNUSED(size);
+    switch (offset) {
+        case GPIO_SIFIVE_REG_INPUT_EN:
+            atomic_store_uint32(&bus->input_en, read_uint32_le_m(data));
+            gpio_sifive_update_pins(bus, atomic_load_uint32(&bus->pins));
+            break;
+        case GPIO_SIFIVE_REG_OUTPUT_EN:
+            atomic_store_uint32(&bus->output_en, read_uint32_le_m(data));
+            gpio_sifive_update_out(bus);
+            break;
+        case GPIO_SIFIVE_REG_OUTPUT:
+            atomic_store_uint32(&bus->output, read_uint32_le_m(data));
+            gpio_sifive_update_out(bus);
+            break;
+        case GPIO_SIFIVE_REG_PUE:
+            atomic_store_uint32(&bus->pue, read_uint32_le_m(data));
+            break;
+        case GPIO_SIFIVE_REG_DS:
+            atomic_store_uint32(&bus->ds, read_uint32_le_m(data));
+            break;
+        case GPIO_SIFIVE_REG_RISE_IE:
+            atomic_store_uint32(&bus->rise_ie, read_uint32_le_m(data));
+            gpio_sifive_update_irqs(bus);
+            break;
+        case GPIO_SIFIVE_REG_RISE_IP:
+            atomic_and_uint32(&bus->rise_ip, ~read_uint32_le_m(data));
+            gpio_sifive_update_irqs(bus);
+            break;
+        case GPIO_SIFIVE_REG_FALL_IE:
+            atomic_store_uint32(&bus->fall_ie, read_uint32_le_m(data));
+            gpio_sifive_update_irqs(bus);
+            break;
+        case GPIO_SIFIVE_REG_FALL_IP:
+            atomic_and_uint32(&bus->fall_ip, ~read_uint32_le_m(data));
+            gpio_sifive_update_irqs(bus);
+            break;
+        case GPIO_SIFIVE_REG_HIGH_IE:
+            atomic_store_uint32(&bus->high_ie, read_uint32_le_m(data));
+            gpio_sifive_update_irqs(bus);
+            break;
+        case GPIO_SIFIVE_REG_HIGH_IP:
+            atomic_and_uint32(&bus->high_ip, ~read_uint32_le_m(data));
+            gpio_sifive_update_irqs(bus);
+            break;
+        case GPIO_SIFIVE_REG_LOW_IE:
+            atomic_store_uint32(&bus->low_ie, read_uint32_le_m(data));
+            gpio_sifive_update_irqs(bus);
+            break;
+        case GPIO_SIFIVE_REG_LOW_IP:
+            atomic_and_uint32(&bus->low_ip, ~read_uint32_le_m(data));
+            gpio_sifive_update_irqs(bus);
+            break;
+        case GPIO_SIFIVE_REG_OUT_XOR:
+            atomic_store_uint32(&bus->out_xor, read_uint32_le_m(data));
+            gpio_sifive_update_out(bus);
+            break;
+    }
+    return true;
+}
+
+static void gpio_sifive_remove(rvvm_mmio_dev_t* dev)
+{
+    gpio_sifive_dev_t* bus = dev->data;
+    gpio_free(bus->gpio);
+    free(bus);
+}
+
+static void gpio_sifive_update(rvvm_mmio_dev_t* dev)
+{
+    gpio_sifive_dev_t* bus = dev->data;
+    gpio_update(bus->gpio);
+}
+
+static rvvm_mmio_type_t gpio_sifive_dev_type = {
+    .name = "gpio_sifive",
+    .remove = gpio_sifive_remove,
+    .update = gpio_sifive_update,
+};
+
+PUBLIC rvvm_mmio_dev_t* gpio_sifive_init(rvvm_machine_t* machine, rvvm_gpio_dev_t* gpio,
+                                           rvvm_addr_t base_addr, plic_ctx_t* plic, uint32_t* irqs)
+{
+    gpio_sifive_dev_t* bus = safe_new_obj(gpio_sifive_dev_t);
+    bus->gpio = gpio;
+    bus->plic = plic;
+
+    // Amount of IRQs controlls amount of GPIO pins
+    // Each GPIO pin should have a unique IRQ!
+    for (size_t i=0; i<GPIO_SIFIVE_PINS; ++i) {
+        bus->plic_irqs[i] = irqs[i];
+    }
+
+    if (gpio) {
+        gpio->io_dev = bus;
+        gpio->pins_in = gpio_sifive_pins_in;
+        gpio->pins_read = gpio_sifive_pins_read;
+    }
+
+    rvvm_mmio_dev_t gpio_sifive = {
+        .addr = base_addr,
+        .size = GPIO_SIFIVE_MMIO_SIZE,
+        .data = bus,
+        .read = gpio_sifive_mmio_read,
+        .write = gpio_sifive_mmio_write,
+        .type = &gpio_sifive_dev_type,
+        .min_op_size = 4,
+        .max_op_size = 4,
+    };
+
+    rvvm_mmio_dev_t* mmio = rvvm_attach_mmio(machine, &gpio_sifive);
+    if (mmio == NULL) return mmio;
+
+#ifdef USE_FDT
+    struct fdt_node* gpio_fdt = fdt_node_create_reg("gpio", base_addr);
+    fdt_node_add_prop_reg(gpio_fdt, "reg", base_addr, GPIO_SIFIVE_MMIO_SIZE);
+    fdt_node_add_prop_str(gpio_fdt, "compatible", "sifive,gpio0");
+    fdt_node_add_prop_u32(gpio_fdt, "interrupt-parent", plic_get_phandle(plic));
+    fdt_node_add_prop_cells(gpio_fdt, "interrupts", bus->plic_irqs, GPIO_SIFIVE_PINS);
+    fdt_node_add_prop(gpio_fdt, "gpio-controller", NULL, 0);
+    fdt_node_add_prop_u32(gpio_fdt, "#gpio-cells", 2);
+    fdt_node_add_prop(gpio_fdt, "interrupt-controller", NULL, 0);
+    fdt_node_add_prop_u32(gpio_fdt, "#interrupt-cells", 2);
+    fdt_node_add_prop_u32(gpio_fdt, "ngpios", 32);
+    fdt_node_add_prop_str(gpio_fdt, "status", "okay");
+    fdt_node_add_child(rvvm_get_fdt_soc(machine), gpio_fdt);
+#endif
+    return mmio;
+}
+
+PUBLIC rvvm_mmio_dev_t* gpio_sifive_init_auto(rvvm_machine_t* machine, rvvm_gpio_dev_t* gpio)
+{
+    plic_ctx_t* plic = rvvm_get_plic(machine);
+    rvvm_addr_t addr = rvvm_mmio_zone_auto(machine, GPIO_SIFIVE_DEFAULT_MMIO, GPIO_SIFIVE_MMIO_SIZE);
+    uint32_t irqs[GPIO_SIFIVE_PINS] = {0};
+    for (size_t i=0; i<GPIO_SIFIVE_PINS; ++i) {
+        irqs[i] = plic_alloc_irq(plic);
+    }
+    return gpio_sifive_init(machine, gpio, addr, plic, irqs);
+}
diff --git a/app/src/main/java/libengine/RVVM/src/devices/gpio-sifive.h b/app/src/main/java/libengine/RVVM/src/devices/gpio-sifive.h
new file mode 100644
index 00000000..9a619fc4
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/gpio-sifive.h
@@ -0,0 +1,34 @@
+/*
+gpio-sifive.h - SiFive GPIO Controller
+Copyright (C) 2024  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef RVVM_GPIO_SIFIVE_H
+#define RVVM_GPIO_SIFIVE_H
+
+#include "../rvvmlib.h"
+#include "gpio_api.h"
+
+#define GPIO_SIFIVE_PINS 32
+
+#define GPIO_SIFIVE_DEFAULT_MMIO 0x10060000
+
+PUBLIC rvvm_mmio_dev_t* gpio_sifive_init(rvvm_machine_t* machine, rvvm_gpio_dev_t* gpio,
+                                         rvvm_addr_t base_addr, plic_ctx_t* plic, uint32_t* irqs);
+
+PUBLIC rvvm_mmio_dev_t* gpio_sifive_init_auto(rvvm_machine_t* machine, rvvm_gpio_dev_t* gpio);
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/devices/gpio_api.h b/app/src/main/java/libengine/RVVM/src/devices/gpio_api.h
new file mode 100644
index 00000000..8cef5021
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/gpio_api.h
@@ -0,0 +1,68 @@
+/*
+gpio_api.h - General-Purpose IO API
+Copyright (C) 2024  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef RVVM_GPIO_API_H
+#define RVVM_GPIO_API_H
+
+typedef struct rvvm_gpio_dev rvvm_gpio_dev_t;
+
+struct rvvm_gpio_dev {
+    // IO Dev -> GPIO Dev calls
+    bool (*pins_out)(rvvm_gpio_dev_t* dev, size_t off, uint32_t pins);
+
+    // GPIO Dev -> IO Dev calls
+    bool     (*pins_in)(rvvm_gpio_dev_t* dev, size_t off, uint32_t pins);
+    uint32_t (*pins_read)(rvvm_gpio_dev_t* dev, size_t off);
+
+    // Common RVVM API features
+    void (*update)(rvvm_gpio_dev_t* dev);
+    void (*remove)(rvvm_gpio_dev_t* dev);
+
+    void* data;
+    void* io_dev;
+};
+
+static inline bool gpio_pins_out(rvvm_gpio_dev_t* dev, size_t off, uint32_t pins)
+{
+    if (dev && dev->pins_out) return dev->pins_out(dev, off, pins);
+    return false;
+}
+
+static inline bool gpio_write_pins(rvvm_gpio_dev_t* dev, size_t off, uint32_t pins)
+{
+    if (dev && dev->pins_in) return dev->pins_in(dev, off, pins);
+    return false;
+}
+
+static inline uint32_t gpio_read_pins(rvvm_gpio_dev_t* dev, size_t off)
+{
+    if (dev && dev->pins_read) return dev->pins_read(dev, off);
+    return 0;
+}
+
+static inline void gpio_free(rvvm_gpio_dev_t* dev)
+{
+    if (dev && dev->remove) dev->remove(dev);
+}
+
+static inline void gpio_update(rvvm_gpio_dev_t* dev)
+{
+    if (dev && dev->update) dev->update(dev);
+}
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/devices/gui_window.c b/app/src/main/java/libengine/RVVM/src/devices/gui_window.c
new file mode 100644
index 00000000..bbd9774a
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/gui_window.c
@@ -0,0 +1,292 @@
+/*
+gui_window.c - Framebuffer GUI Window
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "gui_window.h"
+#include "../mem_ops.h"
+#include "../utils.h"
+
+#ifdef USE_GUI
+
+typedef struct {
+    rvvm_machine_t* machine;
+    hid_keyboard_t* keyboard;
+    hid_mouse_t*    mouse;
+
+    bool ctrl;
+    bool alt;
+    bool grab;
+} gui_window_data_t;
+
+static const uint8_t rvvm_logo_pix[] = {
+    0xfc, 0x3f, 0xf0, 0x02, 0xcb, 0x0b, 0x2c, 0x3f, 0xf0, 0xcb,
+    0xf3, 0x03, 0x2f, 0xb0, 0xbc, 0xc0, 0xf2, 0xcf, 0xbf, 0x3e,
+    0xf2, 0xf9, 0x01, 0xe7, 0x07, 0xac, 0xdf, 0xcf, 0xeb, 0x23,
+    0x9f, 0x1f, 0x70, 0x7e, 0xc0, 0xfa, 0x31, 0xbc, 0x3e, 0x30,
+    0xe1, 0xc3, 0x86, 0x0f, 0x9b, 0x0f, 0xe0, 0xe7, 0xc3, 0x13,
+    0x3e, 0x6c, 0xf8, 0xb0, 0xf9, 0x00, 0x7e, 0xfe, 0x0f, 0x81,
+    0xcf, 0x01, 0x3e, 0x87, 0x0f, 0xe0, 0xe3, 0xc3, 0x03, 0xf8,
+    0x1c, 0xe0, 0x73, 0xf8, 0x00, 0x3e, 0xfd, 0xf8, 0x02, 0x7e,
+    0x00, 0xf8, 0x81, 0x2f, 0xd0, 0xdb, 0x8f, 0x2f, 0x20, 0x07,
+    0x80, 0x1c, 0xf8, 0x02, 0xbd, 0xe1, 0xe4, 0x01, 0x71, 0x00,
+    0xc4, 0x41, 0x18, 0x10, 0x16, 0x4e, 0x1e, 0x10, 0x07, 0x40,
+    0x1c, 0x84, 0x01, 0x61, 0x90, 0x84, 0x01, 0x51, 0x00, 0x44,
+    0x41, 0x10, 0x00, 0x04, 0x49, 0x18, 0x10, 0x05, 0x40, 0x14,
+    0x04, 0x01, 0x40, 0x50, 0x40, 0x00, 0x50, 0x00, 0x40, 0x41,
+    0x00, 0x10, 0x00, 0x05, 0x04, 0x00, 0x05, 0x00, 0x14, 0x04,
+    0x00, 0x01, 0x40, 0x00, 0x00, 0x40, 0x00, 0x00, 0x01, 0x00,
+    0x10, 0x00, 0x04, 0x00, 0x00, 0x04, 0x00, 0x10, 0x00, 0x00,
+    0x01, 0x00, 0x00, 0x00, 0x10, 0x00, 0x40, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
+};
+
+static void gui_window_grab_input(gui_window_t* win, bool grab)
+{
+    gui_window_data_t* data = win->data;
+    if (data->grab != grab && win->grab_input) {
+        data->grab = grab;
+        win->grab_input(win, data->grab);
+        if (win->set_title) {
+            if (data->grab) {
+                win->set_title(win, "RVVM - Press Ctrl+Alt+G to release grab");
+            } else {
+                win->set_title(win, "RVVM");
+            }
+        }
+    }
+}
+
+static void gui_window_free(gui_window_t* win)
+{
+    gui_window_grab_input(win, false);
+    if (win->remove) win->remove(win);
+    free(win->data);
+    free(win);
+}
+
+static void gui_window_update(rvvm_mmio_dev_t* dev)
+{
+    gui_window_t* win = dev->data;
+    if (win->poll) win->poll(win);
+    if (win->draw) win->draw(win);
+}
+
+static void gui_window_remove(rvvm_mmio_dev_t* dev)
+{
+    gui_window_t* win = dev->data;
+    gui_window_free(win);
+}
+
+static void gui_window_reset(rvvm_mmio_dev_t* dev)
+{
+    // Draw RVVM logo before guest takes over
+    // Never ask why or how this works :D
+    gui_window_t* win = dev->data;
+    fb_ctx_t* fb = &win->fb;
+    size_t bytes = rgb_format_bytes(fb->format);
+    size_t stride = framebuffer_stride(fb);
+    uint32_t pos_x = fb->width / 2 - 152;
+    uint32_t pos_y = fb->height / 2 - 80;
+
+    for (uint32_t y=0; y<fb->height; ++y) {
+        size_t tmp_stride = stride * y;
+        for (uint32_t x=0; x<fb->width; ++x) {
+            uint8_t pix = 0;
+            if (x >= pos_x && x - pos_x < 304 && y >= pos_y && y - pos_y < 160) {
+                uint32_t pos = ((y - pos_y) >> 3) * 38 + ((x - pos_x) >> 3);
+                pix = ((rvvm_logo_pix[pos >> 2] >> ((pos & 0x3) << 1)) & 0x3) << 6;
+            }
+            memset(((uint8_t*)fb->buffer) + tmp_stride + (x * bytes), pix, bytes);
+        }
+    }
+}
+
+static const rvvm_mmio_type_t gui_window_dev_type = {
+    .name = "gui_window",
+    .remove = gui_window_remove,
+    .update = gui_window_update,
+    .reset = gui_window_reset,
+};
+
+static void gui_on_close(gui_window_t* win)
+{
+    gui_window_data_t* data = win->data;
+    if (rvvm_has_arg("poweroff_key")) {
+        // Send poweroff request to the guest via keyboard key
+        hid_keyboard_press(data->keyboard, HID_KEY_POWER);
+        hid_keyboard_release(data->keyboard, HID_KEY_POWER);
+    } else {
+        rvvm_reset_machine(data->machine, false);
+    }
+}
+
+static void gui_on_focus_lost(gui_window_t* win)
+{
+    gui_window_data_t* data = win->data;
+
+    // Fix stuck buttons after lost focus (Alt+Tab, etc)
+    for (hid_key_t key = 0; key < 255; ++key) {
+        hid_keyboard_release(data->keyboard, key);
+    }
+
+    // Ungrab input
+    gui_window_grab_input(win, false);
+}
+
+static void gui_handle_modkeys(gui_window_data_t* data, hid_key_t key, bool pressed)
+{
+    switch (key) {
+        case HID_KEY_LEFTALT:
+        case HID_KEY_RIGHTALT:
+            data->alt = pressed;
+            break;
+        case HID_KEY_LEFTCTRL:
+        case HID_KEY_RIGHTCTRL:
+            data->ctrl = pressed;
+            break;
+    }
+}
+
+static void gui_on_key_press(gui_window_t* win, hid_key_t key)
+{
+    gui_window_data_t* data = win->data;
+    gui_handle_modkeys(data, key, true);
+    if (key == HID_KEY_G && data->alt && data->ctrl) {
+        gui_window_grab_input(win, !data->grab);
+        return;
+    }
+    hid_keyboard_press(data->keyboard, key);
+}
+
+static void gui_on_key_release(gui_window_t* win, hid_key_t key)
+{
+    gui_window_data_t* data = win->data;
+    gui_handle_modkeys(data, key, false);
+    hid_keyboard_release(data->keyboard, key);
+}
+
+static void gui_on_mouse_press(gui_window_t* win, hid_btns_t btns)
+{
+    gui_window_data_t* data = win->data;
+    hid_mouse_press(data->mouse, btns);
+}
+
+static void gui_on_mouse_release(gui_window_t* win, hid_btns_t btns)
+{
+    gui_window_data_t* data = win->data;
+    hid_mouse_release(data->mouse, btns);
+}
+
+static void gui_on_mouse_place(gui_window_t* win, int32_t x, int32_t y)
+{
+    gui_window_data_t* data = win->data;
+    hid_mouse_place(data->mouse, x, y);
+}
+
+static void gui_on_mouse_move(gui_window_t* win, int32_t x, int32_t y)
+{
+    gui_window_data_t* data = win->data;
+    hid_mouse_move(data->mouse, x, y);
+}
+
+static void gui_on_mouse_scroll(gui_window_t* win, int32_t offset)
+{
+    gui_window_data_t* data = win->data;
+    hid_mouse_scroll(data->mouse, offset);
+}
+
+bool gui_window_create(gui_window_t* win)
+{
+#ifdef _WIN32
+    if (!rvvm_has_arg("gui") || rvvm_strcmp(rvvm_getarg("gui"), "win32")) {
+        if (win32_window_init(win)) return true;
+    }
+#endif
+#ifdef __HAIKU__
+    if (!rvvm_has_arg("gui") || rvvm_strcmp(rvvm_getarg("gui"), "haiku")) {
+        if (haiku_window_init(win)) return true;
+    }
+#endif
+#ifdef USE_X11
+    if (!rvvm_has_arg("gui") || rvvm_strcmp(rvvm_getarg("gui"), "x11")) {
+        if (x11_window_init(win)) return true;
+    }
+#endif
+#ifdef USE_SDL
+    if (!rvvm_has_arg("gui") || rvvm_strcmp(rvvm_getarg("gui"), "sdl")) {
+        if (sdl_window_init(win)) return true;
+    }
+#endif
+    rvvm_error("No suitable windowing backends found!");
+    UNUSED(win);
+    return false;
+}
+
+bool gui_window_init_auto(rvvm_machine_t* machine, uint32_t width, uint32_t height)
+{
+    gui_window_t* win = safe_new_obj(gui_window_t);
+    gui_window_data_t* data = safe_new_obj(gui_window_data_t);
+
+    data->machine = machine;
+    data->keyboard = hid_keyboard_init_auto(machine);
+    data->mouse = hid_mouse_init_auto(machine);
+
+    hid_mouse_resolution(data->mouse, width, height);
+
+    win->data = data;
+    win->fb.width = width;
+    win->fb.height = height;
+    win->fb.format = RGB_FMT_A8R8G8B8;
+
+    win->on_close = gui_on_close;
+    win->on_focus_lost = gui_on_focus_lost;
+    win->on_key_press = gui_on_key_press;
+    win->on_key_release = gui_on_key_release;
+    win->on_mouse_press = gui_on_mouse_press;
+    win->on_mouse_release = gui_on_mouse_release;
+    win->on_mouse_place = gui_on_mouse_place;
+    win->on_mouse_move = gui_on_mouse_move;
+    win->on_mouse_scroll = gui_on_mouse_scroll;
+
+    if (!gui_window_create(win)) {
+        gui_window_free(win);
+        return false;
+    }
+
+    // Placeholder for window data, region size is 0
+    rvvm_mmio_dev_t win_placeholder = {
+        .data = win,
+        .type = &gui_window_dev_type,
+    };
+    rvvm_attach_mmio(machine, &win_placeholder);
+
+    framebuffer_init_auto(machine, &win->fb);
+
+    return true;
+}
+
+#else
+
+bool gui_window_init_auto(rvvm_machine_t* machine, uint32_t width, uint32_t height)
+{
+    UNUSED(machine);
+    UNUSED(width);
+    UNUSED(height);
+    return false;
+}
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/devices/gui_window.h b/app/src/main/java/libengine/RVVM/src/devices/gui_window.h
new file mode 100644
index 00000000..4a982f9c
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/gui_window.h
@@ -0,0 +1,65 @@
+/*
+gui_window.h - Framebuffer GUI Window
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef GUI_WINDOW_H
+#define GUI_WINDOW_H
+
+#include "framebuffer.h"
+#include "hid_api.h"
+
+typedef struct gui_window_t gui_window_t;
+
+struct gui_window_t {
+    void* win_data;
+    void* data;
+    fb_ctx_t fb;
+
+    // Calls into GUI implementation
+    void (*draw)(gui_window_t* win);
+    void (*poll)(gui_window_t* win);
+    void (*remove)(gui_window_t* win);
+    void (*grab_input)(gui_window_t* win, bool grab);
+    void (*set_title)(gui_window_t* win, const char* title);
+    void (*set_fullscreen)(gui_window_t* win, bool fullscreen); // TODO: Borderless fullscreen
+
+    // Calls from GUI implementation
+    void (*on_close)(gui_window_t* win);
+    void (*on_focus_lost)(gui_window_t* win);
+    void (*on_key_press)(gui_window_t* win, hid_key_t key);
+    void (*on_key_release)(gui_window_t* win, hid_key_t key);
+    void (*on_mouse_press)(gui_window_t* win, hid_btns_t btns);
+    void (*on_mouse_release)(gui_window_t* win, hid_btns_t btns);
+    void (*on_mouse_place)(gui_window_t* win, int32_t x, int32_t y);
+    void (*on_mouse_move)(gui_window_t* win, int32_t x, int32_t y);
+    void (*on_mouse_scroll)(gui_window_t* win, int32_t offset);
+};
+
+// Internal use
+bool x11_window_init(gui_window_t* win);
+bool wayland_window_init(gui_window_t* win); // TODO: Wayland GUI backend
+bool win32_window_init(gui_window_t* win);
+bool haiku_window_init(gui_window_t* win);
+bool sdl_window_init(gui_window_t* win);
+
+// Probe windowing backends and create a window. Returns false on failure.
+bool gui_window_create(gui_window_t* win);
+
+// Attach a framebuffer & HID mouse/keyboard to the VM. Returns false on failure.
+bool gui_window_init_auto(rvvm_machine_t* machine, uint32_t width, uint32_t height);
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/devices/haiku_window.cpp b/app/src/main/java/libengine/RVVM/src/devices/haiku_window.cpp
new file mode 100644
index 00000000..9ee56797
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/haiku_window.cpp
@@ -0,0 +1,360 @@
+/*
+haiku_window.cpp - Haiku RVVM Window
+Copyright (C) 2022  X547 <github.com/X547>
+                    LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+extern "C" {
+#include "gui_window.h"
+#include "../utils.h"
+}
+
+#include <Application.h>
+#include <Window.h>
+#include <View.h>
+#include <Bitmap.h>
+#include <Cursor.h>
+#include <OS.h>
+#include <private/shared/AutoDeleter.h>
+
+// C++ doesn't allow designated initializers like in win32window... Ugh
+// Luckily, Haiku has contiguous & small keycodes for a trivial array initializer
+
+// Don't ever touch this table, or The Order will not take kindly.
+// Otherwise be prepared to suffer the Consequences...
+static const hid_key_t haiku_key_to_hid_byte_map[] = {
+    HID_KEY_NONE,
+    HID_KEY_ESC,
+    HID_KEY_F1,
+    HID_KEY_F2,
+    HID_KEY_F3,
+    HID_KEY_F4,
+    HID_KEY_F5,
+    HID_KEY_F6,
+    HID_KEY_F7,
+    HID_KEY_F8,
+    HID_KEY_F9,
+    HID_KEY_F10,
+    HID_KEY_F11,
+    HID_KEY_F12,
+    HID_KEY_SYSRQ,
+    HID_KEY_SCROLLLOCK,
+    HID_KEY_PAUSE,
+    HID_KEY_GRAVE,
+    HID_KEY_1,
+    HID_KEY_2,
+    HID_KEY_3,
+    HID_KEY_4,
+    HID_KEY_5,
+    HID_KEY_6,
+    HID_KEY_7,
+    HID_KEY_8,
+    HID_KEY_9,
+    HID_KEY_0,
+    HID_KEY_MINUS,
+    HID_KEY_EQUAL,
+    HID_KEY_BACKSPACE,
+    HID_KEY_INSERT,
+    HID_KEY_HOME,
+    HID_KEY_PAGEUP,
+    HID_KEY_NUMLOCK,
+    HID_KEY_KPSLASH,
+    HID_KEY_KPASTERISK,
+    HID_KEY_KPMINUS,
+    HID_KEY_TAB,
+    HID_KEY_Q,
+    HID_KEY_W,
+    HID_KEY_E,
+    HID_KEY_R,
+    HID_KEY_T,
+    HID_KEY_Y,
+    HID_KEY_U,
+    HID_KEY_I,
+    HID_KEY_O,
+    HID_KEY_P,
+    HID_KEY_LEFTBRACE,
+    HID_KEY_RIGHTBRACE,
+    HID_KEY_BACKSLASH,
+    HID_KEY_DELETE,
+    HID_KEY_END,
+    HID_KEY_PAGEDOWN,
+    HID_KEY_KP7,
+    HID_KEY_KP8,
+    HID_KEY_KP9,
+    HID_KEY_KPPLUS,
+    HID_KEY_CAPSLOCK,
+    HID_KEY_A,
+    HID_KEY_S,
+    HID_KEY_D,
+    HID_KEY_F,
+    HID_KEY_G,
+    HID_KEY_H,
+    HID_KEY_J,
+    HID_KEY_K,
+    HID_KEY_L,
+    HID_KEY_SEMICOLON,
+    HID_KEY_APOSTROPHE,
+    HID_KEY_ENTER,
+    HID_KEY_KP4,
+    HID_KEY_KP5,
+    HID_KEY_KP6,
+    HID_KEY_LEFTSHIFT,
+    HID_KEY_Z,
+    HID_KEY_X,
+    HID_KEY_C,
+    HID_KEY_V,
+    HID_KEY_B,
+    HID_KEY_N,
+    HID_KEY_M,
+    HID_KEY_COMMA,
+    HID_KEY_DOT,
+    HID_KEY_SLASH,
+    HID_KEY_RIGHTSHIFT,
+    HID_KEY_UP,
+    HID_KEY_KP1,
+    HID_KEY_KP2,
+    HID_KEY_KP3,
+    HID_KEY_KPENTER,
+    HID_KEY_LEFTCTRL,
+    HID_KEY_LEFTALT,
+    HID_KEY_SPACE,
+    HID_KEY_RIGHTALT,
+    HID_KEY_RIGHTCTRL,
+    HID_KEY_LEFT,
+    HID_KEY_DOWN,
+    HID_KEY_RIGHT,
+    HID_KEY_KP0,
+    HID_KEY_KPDOT,
+    HID_KEY_LEFTMETA,
+    HID_KEY_RIGHTMETA,
+    HID_KEY_COMPOSE,
+    HID_KEY_102ND,
+    HID_KEY_YEN,
+    HID_KEY_RO,
+    HID_KEY_MUHENKAN,
+    HID_KEY_HENKAN,
+    HID_KEY_KATAKANAHIRAGANA,
+    HID_KEY_NONE, // Haiku keycode 0x6f unused?
+    HID_KEY_KPCOMMA,
+    // 0xf0 hangul?
+    // 0xf1 hanja?
+};
+
+static hid_key_t haiku_key_to_hid(uint32_t haiku_key)
+{
+    if (haiku_key < sizeof(haiku_key_to_hid_byte_map)) {
+        return haiku_key_to_hid_byte_map[haiku_key];
+    }
+    return HID_KEY_NONE;
+}
+
+class View: public BView {
+private:
+    ObjectDeleter<BBitmap> m_bitmap;
+    gui_window_t* m_win;
+
+public:
+    View(BRect frame, const char* name, uint32 resizingMode, uint32 flags, gui_window_t* win);
+    virtual ~View() {}
+
+    void AttachedToWindow() override;
+    void Draw(BRect dirty) override;
+    void MessageReceived(BMessage* msg) override;
+    void WindowActivated(bool active) override;
+
+    BBitmap* GetBitmap() {
+        return m_bitmap.Get();
+    }
+};
+
+class Window: public BWindow {
+private:
+    View* m_view;
+    gui_window_t* m_win;
+
+public:
+    Window(BRect frame, const char *title, gui_window_t* win);
+    virtual ~Window() {}
+
+    bool QuitRequested() override;
+
+    View* GetView() {
+        return m_view;
+    }
+};
+
+View::View(BRect frame, const char* name, uint32 resizingMode, uint32 flags, gui_window_t* win):
+    BView(frame, name, resizingMode, flags | B_WILL_DRAW),
+    m_win(win)
+{
+    SetViewColor(B_TRANSPARENT_COLOR);
+    SetLowColor(0, 0, 0);
+    m_bitmap.SetTo(new BBitmap(frame.OffsetToCopy(B_ORIGIN), B_RGBA32));
+}
+
+void View::AttachedToWindow()
+{
+    BCursor cursor(B_CURSOR_ID_NO_CURSOR);
+    SetViewCursor(&cursor);
+}
+
+void View::Draw(BRect dirty)
+{
+    UNUSED(dirty);
+    DrawBitmap(GetBitmap());
+}
+
+void View::MessageReceived(BMessage* msg)
+{
+    int32 key;
+    BPoint point;
+    int32 btns;
+    float wheel;
+    switch (msg->what) {
+        case B_KEY_DOWN:
+        case B_UNMAPPED_KEY_DOWN:
+            msg->FindInt32("be:key_repeat", &key);
+            if (key == 0) {
+                // Ignore key repeat events
+                msg->FindInt32("key", &key);
+                m_win->on_key_press(m_win, haiku_key_to_hid(key));
+            }
+            return;
+        case B_KEY_UP:
+        case B_UNMAPPED_KEY_UP:
+            msg->FindInt32("key", &key);
+            m_win->on_key_release(m_win, haiku_key_to_hid(key));
+            return;
+        case B_MOUSE_DOWN:
+            SetMouseEventMask(B_POINTER_EVENTS);
+            msg->FindInt32("buttons", &btns);
+            m_win->on_mouse_press(m_win, btns);
+            return;
+        case B_MOUSE_UP:
+            msg->FindInt32("buttons", &btns);
+            m_win->on_mouse_release(m_win, ~btns);
+            return;
+        case B_MOUSE_MOVED:
+            msg->FindPoint("where", &point);
+            m_win->on_mouse_place(m_win, point.x, point.y);
+            return;
+        case B_MOUSE_WHEEL_CHANGED:
+            msg->FindFloat("be:wheel_delta_y", &wheel);
+            m_win->on_mouse_scroll(m_win, (int32_t)wheel);
+            return;
+    }
+    return BView::MessageReceived(msg);
+}
+
+void View::WindowActivated(bool active)
+{
+    if (!active) {
+        m_win->on_focus_lost(m_win);
+    }
+}
+
+Window::Window(BRect frame, const char* title, gui_window_t* win):
+    BWindow(frame, title, B_TITLED_WINDOW_LOOK, B_NORMAL_WINDOW_FEEL, B_NOT_ZOOMABLE | B_NOT_RESIZABLE),
+    m_win(win)
+{
+    m_view = new View(frame.OffsetToCopy(B_ORIGIN), "view", B_FOLLOW_ALL, 0, win);
+    AddChild(m_view);
+    m_view->MakeFocus();
+}
+
+bool Window::QuitRequested()
+{
+    m_win->on_close(m_win);
+    return false;
+}
+
+static thread_id sAppThread = B_ERROR;
+
+static status_t app_thread(void *arg)
+{
+    UNUSED(arg);
+    be_app->Lock();
+    be_app->Run();
+    return B_OK;
+}
+
+static status_t init_application()
+{
+    if (be_app != NULL) return B_OK;
+
+    new BApplication("application/x-vnd.RVVM");
+    if (be_app == NULL) return B_NO_MEMORY;
+    be_app->Unlock();
+    sAppThread = spawn_thread(app_thread, "application", B_NORMAL_PRIORITY, NULL);
+    if (sAppThread < B_OK) return sAppThread;
+    resume_thread(sAppThread);
+
+    return B_OK;
+}
+
+static void haiku_window_draw(gui_window_t* win)
+{
+    Window* window = (Window*)win->win_data;
+    View* view = window->GetView();
+    view->LockLooper();
+    view->Invalidate();
+    view->UnlockLooper();
+}
+
+static void haiku_window_poll(gui_window_t* win)
+{
+    // Input events handling done from window thread. TODO: Check thread safety.
+    // Other GUI backends could implement threaded input too for better latency
+    UNUSED(win);
+}
+
+static void haiku_window_set_title(gui_window_t* win, const char* title)
+{
+    Window* window = (Window*)win->win_data;
+    window->SetTitle(title);
+}
+
+static void haiku_window_remove(gui_window_t* win)
+{
+    Window* window = (Window*)win->win_data;
+    View* view = window->GetView();
+    view->LockLooper();
+    window->Quit(); // Also deletes window
+}
+
+bool haiku_window_init(gui_window_t* win)
+{
+    if (init_application() < B_OK) {
+        rvvm_error("Failed to initialize be_app thread!");
+        return false;
+    }
+
+    Window* window = new Window(BRect(0, 0, win->fb.width - 1, win->fb.height - 1), "RVVM", win);
+    window->CenterOnScreen();
+    window->Show();
+
+    win->win_data = window;
+    win->fb.format = RGB_FMT_A8R8G8B8;
+    win->fb.buffer = window->GetView()->GetBitmap()->Bits();
+
+    win->draw = haiku_window_draw;
+    win->poll = haiku_window_poll;
+    win->remove = haiku_window_remove;
+    // TODO: haiku_window_grab_input with relative mouse mode
+    win->set_title = haiku_window_set_title;
+
+    return true;
+}
diff --git a/app/src/main/java/libengine/RVVM/src/devices/hid-keyboard.c b/app/src/main/java/libengine/RVVM/src/devices/hid-keyboard.c
new file mode 100644
index 00000000..c4d41650
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/hid-keyboard.c
@@ -0,0 +1,204 @@
+/*
+hid-keyboard.c - HID Keyboard
+Copyright (C) 2022  X512 <github.com/X547>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "i2c-hid.h"
+#include "hid_api.h"
+#include "../spinlock.h"
+#include "../utils.h"
+#include "../bit_ops.h"
+#include "../mem_ops.h"
+
+#define MAX_PRESSED_KEYS 6
+
+static const uint8_t keyboard_hid_report_descriptor[] = {
+    0x05, 0x01,     /* Usage Page (Generic Desktop) */
+    0x09, 0x06,     /* Usage (Keyboard) */
+    0xa1, 0x01,     /* Collection (Application) */
+    0x75, 0x01,     /*   Report Size (1) */
+    0x95, 0x08,     /*   Report Count (8) */
+    0x05, 0x07,     /*   Usage Page (Key Codes) */
+    0x19, 0xe0,     /*   Usage Minimum (224) */
+    0x29, 0xe7,     /*   Usage Maximum (231) */
+    0x15, 0x00,     /*   Logical Minimum (0) */
+    0x25, 0x01,     /*   Logical Maximum (1) */
+    0x81, 0x02,     /*   Input (Data, Variable, Absolute) */
+    0x95, 0x01,     /*   Report Count (1) */
+    0x75, 0x08,     /*   Report Size (8) */
+    0x81, 0x01,     /*   Input (Constant) */
+    0x95, 0x05,     /*   Report Count (5) */
+    0x75, 0x01,     /*   Report Size (1) */
+    0x05, 0x08,     /*   Usage Page (LEDs) */
+    0x19, 0x01,     /*   Usage Minimum (1) */
+    0x29, 0x05,     /*   Usage Maximum (5) */
+    0x91, 0x02,     /*   Output (Data, Variable, Absolute) */
+    0x95, 0x01,     /*   Report Count (1) */
+    0x75, 0x03,     /*   Report Size (3) */
+    0x91, 0x01,     /*   Output (Constant) */
+    0x95, 0x06,     /*   Report Count (6) */
+    0x75, 0x08,     /*   Report Size (8) */
+    0x15, 0x00,     /*   Logical Minimum (0) */
+    0x25, 0xff,     /*   Logical Maximum (255) */
+    0x05, 0x07,     /*   Usage Page (Key Codes) */
+    0x19, 0x00,     /*   Usage Minimum (0) */
+    0x29, 0xff,     /*   Usage Maximum (255) */
+    0x81, 0x00,     /*   Input (Data, Array) */
+    0xc0,       /* End Collection */
+};
+
+struct hid_keyboard {
+    hid_dev_t hid_dev;
+    spinlock_t lock;
+
+    uint8_t input_report[10];
+    uint8_t output_report[3];
+
+    // State
+    uint32_t keys_pressed_now[8];
+    uint32_t keys_pressed[8];
+    uint32_t leds;
+};
+
+static void hid_keyboard_reset(void* dev)
+{
+    hid_keyboard_t* kb = dev;
+    atomic_store_uint32(&kb->leds, 0);
+}
+
+static void hid_keyboard_fill_pressed_keys(hid_keyboard_t* kb, uint8_t* pressed)
+{
+    size_t count = 0;
+    memset(pressed, HID_KEY_NONE, MAX_PRESSED_KEYS);
+
+    for (size_t code_hi = 0; code_hi < 8; ++code_hi) {
+        uint32_t keys = atomic_swap_uint32(&kb->keys_pressed[code_hi], 0)
+                      | atomic_load_uint32(&kb->keys_pressed_now[code_hi]);
+        if (keys) {
+            for (bitcnt_t code_lo = 0; code_lo < 32; ++code_lo) {
+                if (bit_check(keys, code_lo)) {
+                    // Report a pressed button
+                    pressed[count++] = (code_hi << 5) | code_lo;
+                    if (count == MAX_PRESSED_KEYS) return;
+                }
+            }
+        }
+    }
+}
+
+static void hid_keyboard_read_report(void* dev, uint8_t report_type, uint8_t report_id,
+                                     uint32_t offset, uint8_t* val)
+{
+    hid_keyboard_t* kb = (hid_keyboard_t*)dev;
+    UNUSED(report_id);
+
+    spin_lock(&kb->lock);
+    if (report_type == REPORT_TYPE_INPUT) {
+        if (offset == 0) {
+            kb->input_report[0] = bit_cut(sizeof(kb->input_report), 0, 8);
+            kb->input_report[1] = bit_cut(sizeof(kb->input_report), 8, 8);
+            kb->input_report[2] = bit_cut(atomic_load_uint32(&kb->keys_pressed[7])
+                                        | atomic_load_uint32(&kb->keys_pressed_now[7]), 0, 8);
+            kb->input_report[3] = 0;
+            hid_keyboard_fill_pressed_keys(kb, &kb->input_report[4]);
+        }
+        if (offset < sizeof(kb->input_report)) {
+            *val = kb->input_report[offset];
+        }
+    } else {
+        *val = 0;
+    }
+    spin_unlock(&kb->lock);
+}
+
+static void hid_keyboard_write_report(void* dev, uint8_t report_type, uint8_t report_id,
+                                      uint32_t offset, uint8_t val)
+{
+    hid_keyboard_t* kb = (hid_keyboard_t*)dev;
+    UNUSED(report_id);
+
+    spin_lock(&kb->lock);
+    if (report_type == REPORT_TYPE_OUTPUT) {
+        if (offset < sizeof(kb->output_report)) {
+            kb->output_report[offset] = val;
+            if (offset == sizeof(kb->output_report) - 1) {
+                atomic_store_uint32(&kb->leds, kb->output_report[2]);
+            }
+        }
+    }
+    spin_unlock(&kb->lock);
+}
+
+static void hid_keyboard_remove(void* dev)
+{
+    hid_keyboard_t* kb = dev;
+    free(kb);
+}
+
+PUBLIC hid_keyboard_t* hid_keyboard_init_auto(rvvm_machine_t* machine)
+{
+    hid_keyboard_t* kb = safe_new_obj(hid_keyboard_t);
+
+    kb->hid_dev.dev = kb;
+
+    kb->hid_dev.report_desc = keyboard_hid_report_descriptor;
+    kb->hid_dev.report_desc_size = sizeof(keyboard_hid_report_descriptor);
+    kb->hid_dev.max_input_size = sizeof(kb->input_report);
+    kb->hid_dev.max_output_size = sizeof(kb->output_report);
+    kb->hid_dev.vendor_id = 1;
+    kb->hid_dev.product_id = 1;
+    kb->hid_dev.version_id = 1;
+
+    kb->hid_dev.reset = hid_keyboard_reset;
+    kb->hid_dev.read_report = hid_keyboard_read_report;
+    kb->hid_dev.write_report = hid_keyboard_write_report;
+    kb->hid_dev.remove = hid_keyboard_remove;
+
+    i2c_hid_init_auto(machine, &kb->hid_dev);
+
+    return kb;
+}
+
+PUBLIC void hid_keyboard_press(hid_keyboard_t* kb, hid_key_t key)
+{
+    // Key is guaranteed to be 1 byte according to HID spec
+    if (key != HID_KEY_NONE) {
+        uint32_t off = key >> 5;
+        uint32_t bit = 1U << (key & 0x1F);
+        uint32_t old_pressed = atomic_or_uint32(&kb->keys_pressed_now[off], bit);
+
+        // Send input_available if it's an actual key press
+        if (bit & ~old_pressed) {
+            // Mark that this key was pressed, prevents loosing keypresses
+            atomic_or_uint32(&kb->keys_pressed[off], bit);
+            kb->hid_dev.input_available(kb->hid_dev.host, 0);
+        }
+    }
+}
+
+PUBLIC void hid_keyboard_release(hid_keyboard_t* kb, hid_key_t key)
+{
+    if (key != HID_KEY_NONE) {
+        uint32_t off = key >> 5;
+        uint32_t bit = 1U << (key & 0x1F);
+        uint32_t old_pressed = atomic_and_uint32(&kb->keys_pressed_now[off], ~bit);
+
+        // Send input_available if it's an actual key release
+        if (old_pressed & bit) {
+            kb->hid_dev.input_available(kb->hid_dev.host, 0);
+        }
+    }
+}
diff --git a/app/src/main/java/libengine/RVVM/src/devices/hid-mouse.c b/app/src/main/java/libengine/RVVM/src/devices/hid-mouse.c
new file mode 100644
index 00000000..bfcc12b2
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/hid-mouse.c
@@ -0,0 +1,315 @@
+/*
+hid-mouse.c - HID Mouse/Tablet
+Copyright (C) 2022  X512 <github.com/X547>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "i2c-hid.h"
+#include "hid_api.h"
+#include "../spinlock.h"
+#include "../utils.h"
+#include "../bit_ops.h"
+
+static const uint8_t mouse_hid_report_descriptor[] = {
+    0x05, 0x01,     /* Usage Page (Generic Desktop) */
+    0x09, 0x02,     /* Usage (Mouse) */
+    0xa1, 0x01,     /* Collection (Application) */
+    0x09, 0x01,     /*   Usage (Pointer) */
+    0xa1, 0x00,     /*   Collection (Physical) */
+    0x05, 0x09,     /*     Usage Page (Button) */
+    0x19, 0x01,     /*     Usage Minimum (1) */
+    0x29, 0x05,     /*     Usage Maximum (5) */
+    0x15, 0x00,     /*     Logical Minimum (0) */
+    0x25, 0x01,     /*     Logical Maximum (1) */
+    0x95, 0x05,     /*     Report Count (5) */
+    0x75, 0x01,     /*     Report Size (1) */
+    0x81, 0x02,     /*     Input (Data, Variable, Absolute) */
+    0x95, 0x01,     /*     Report Count (1) */
+    0x75, 0x03,     /*     Report Size (3) */
+    0x81, 0x01,     /*     Input (Constant) */
+    0x05, 0x01,     /*     Usage Page (Generic Desktop) */
+    0x09, 0x30,     /*     Usage (X) */
+    0x09, 0x31,     /*     Usage (Y) */
+    0x09, 0x38,     /*     Usage (Wheel) */
+    0x15, 0x81,     /*     Logical Minimum (-0x7f) */
+    0x25, 0x7f,     /*     Logical Maximum (0x7f) */
+    0x75, 0x08,     /*     Report Size (8) */
+    0x95, 0x03,     /*     Report Count (3) */
+    0x81, 0x06,     /*     Input (Data, Variable, Relative) */
+    0xc0,       /*   End Collection */
+    0xc0,       /* End Collection */
+};
+
+static const uint8_t tablet_hid_report_descriptor[] = {
+    0x05, 0x01,     /* Usage Page (Generic Desktop) */
+    0x09, 0x02,     /* Usage (Mouse) */
+    0xa1, 0x01,     /* Collection (Application) */
+    0x09, 0x01,     /*   Usage (Pointer) */
+    0xa1, 0x00,     /*   Collection (Physical) */
+    0x05, 0x09,     /*     Usage Page (Button) */
+    0x19, 0x01,     /*     Usage Minimum (1) */
+    0x29, 0x03,     /*     Usage Maximum (3) */
+    0x15, 0x00,     /*     Logical Minimum (0) */
+    0x25, 0x01,     /*     Logical Maximum (1) */
+    0x95, 0x03,     /*     Report Count (3) */
+    0x75, 0x01,     /*     Report Size (1) */
+    0x81, 0x02,     /*     Input (Data, Variable, Absolute) */
+    0x95, 0x01,     /*     Report Count (1) */
+    0x75, 0x05,     /*     Report Size (5) */
+    0x81, 0x01,     /*     Input (Constant) */
+    0x05, 0x01,     /*     Usage Page (Generic Desktop) */
+    0x09, 0x30,     /*     Usage (X) */
+    0x09, 0x31,     /*     Usage (Y) */
+    0x15, 0x00,     /*     Logical Minimum (0) */
+    0x26, 0xff, 0x7f,   /*     Logical Maximum (0x7fff) */
+    0x35, 0x00,     /*     Physical Minimum (0) */
+    0x46, 0xff, 0x7f,   /*     Physical Maximum (0x7fff) */
+    0x75, 0x10,     /*     Report Size (16) */
+    0x95, 0x02,     /*     Report Count (2) */
+    0x81, 0x02,     /*     Input (Data, Variable, Absolute) */
+    0x05, 0x01,     /*     Usage Page (Generic Desktop) */
+    0x09, 0x38,     /*     Usage (Wheel) */
+    0x15, 0x81,     /*     Logical Minimum (-0x7f) */
+    0x25, 0x7f,     /*     Logical Maximum (0x7f) */
+    0x35, 0x00,     /*     Physical Minimum (same as logical) */
+    0x45, 0x00,     /*     Physical Maximum (same as logical) */
+    0x75, 0x08,     /*     Report Size (8) */
+    0x95, 0x01,     /*     Report Count (1) */
+    0x81, 0x06,     /*     Input (Data, Variable, Relative) */
+    0xc0,       /*   End Collection */
+    0xc0,       /* End Collection */
+};
+
+struct hid_mouse {
+    hid_dev_t mouse_hid_dev;
+    hid_dev_t tablet_hid_dev;
+
+    spinlock_t lock;
+    int32_t width;
+    int32_t height;
+
+    uint8_t input_report_mouse[6];
+    uint8_t input_report_tablet[8];
+
+    // state
+    bool tablet_mode;
+    int32_t tablet_x;
+    int32_t tablet_y;
+    int32_t mouse_delta_x;
+    int32_t mouse_delta_y;
+    int32_t scroll_y;
+    hid_btns_t btns_mouse;
+    hid_btns_t btns_tablet;
+};
+
+static void hid_mouse_reset(void* dev)
+{
+    hid_mouse_t* mouse = (hid_mouse_t*)dev;
+    spin_lock(&mouse->lock);
+    mouse->tablet_mode = true;
+    mouse->tablet_x = 0;
+    mouse->tablet_y = 0;
+    mouse->mouse_delta_x = 0;
+    mouse->mouse_delta_y = 0;
+    mouse->scroll_y = 0;
+    mouse->btns_mouse = 0;
+    mouse->btns_tablet = 0;
+    spin_unlock(&mouse->lock);
+}
+
+static void hid_mouse_read_report_mouse(void* dev,
+    uint8_t report_type, uint8_t report_id, uint32_t offset, uint8_t *val)
+{
+    UNUSED(report_id);
+    hid_mouse_t* mouse = (hid_mouse_t*)dev;
+    spin_lock(&mouse->lock);
+    if (report_type == REPORT_TYPE_INPUT) {
+        if (offset == 0) {
+            int32_t delta_x = mouse->mouse_delta_x / 3;
+            int32_t delta_y = mouse->mouse_delta_y / 3;
+            mouse->input_report_mouse[0] = bit_cut(sizeof(mouse->input_report_mouse), 0, 8);
+            mouse->input_report_mouse[1] = bit_cut(sizeof(mouse->input_report_mouse), 8, 8);
+            mouse->input_report_mouse[2] = mouse->btns_mouse;
+            mouse->input_report_mouse[3] = delta_x;
+            mouse->input_report_mouse[4] = delta_y;
+            mouse->input_report_mouse[5] = -mouse->scroll_y;
+            mouse->mouse_delta_x -= delta_x * 3;
+            mouse->mouse_delta_y -= delta_y * 3;
+            mouse->scroll_y = 0;
+        }
+        if (offset < sizeof(mouse->input_report_mouse))
+            *val = mouse->input_report_mouse[offset];
+    } else {
+        *val = 0;
+    }
+    spin_unlock(&mouse->lock);
+}
+
+static void hid_mouse_read_report_tablet(void* dev,
+    uint8_t report_type, uint8_t report_id, uint32_t offset, uint8_t *val)
+{
+    UNUSED(report_id);
+    hid_mouse_t* mouse = (hid_mouse_t*)dev;
+    spin_lock(&mouse->lock);
+    if (report_type == REPORT_TYPE_INPUT) {
+        if (offset == 0) {
+            mouse->input_report_tablet[0] = bit_cut(sizeof(mouse->input_report_tablet), 0, 8);
+            mouse->input_report_tablet[1] = bit_cut(sizeof(mouse->input_report_tablet), 8, 8);
+            mouse->input_report_tablet[2] = mouse->btns_tablet;
+            mouse->input_report_tablet[3] = bit_cut(mouse->tablet_x, 0, 8);
+            mouse->input_report_tablet[4] = bit_cut(mouse->tablet_x, 8, 8);
+            mouse->input_report_tablet[5] = bit_cut(mouse->tablet_y, 0, 8);
+            mouse->input_report_tablet[6] = bit_cut(mouse->tablet_y, 8, 8);
+            mouse->input_report_tablet[7] = -mouse->scroll_y;
+            mouse->scroll_y = 0;
+        }
+        if (offset < sizeof(mouse->input_report_tablet))
+            *val = mouse->input_report_tablet[offset];
+    } else {
+        *val = 0;
+    }
+    spin_unlock(&mouse->lock);
+}
+
+static void hid_mouse_write_report(void* dev,
+    uint8_t report_type, uint8_t report_id, uint32_t offset, uint8_t val)
+{
+    hid_mouse_t* mouse = (hid_mouse_t*)dev;
+    UNUSED(mouse);
+    UNUSED(report_type);
+    UNUSED(report_id);
+    UNUSED(offset);
+    UNUSED(val);
+}
+
+static void hid_mouse_remove(void* dev)
+{
+    hid_mouse_t* mouse = (hid_mouse_t*)dev;
+    free(mouse);
+}
+
+static void hid_mouse_setup(hid_dev_t *dev, hid_mouse_t *mouse, bool tablet)
+{
+    dev->dev = mouse;
+    dev->report_desc = tablet
+        ? tablet_hid_report_descriptor
+        : mouse_hid_report_descriptor;
+    dev->report_desc_size = tablet
+        ? sizeof(tablet_hid_report_descriptor)
+        : sizeof(mouse_hid_report_descriptor);
+    dev->max_input_size = tablet
+        ? sizeof(mouse->input_report_tablet)
+        : sizeof(mouse->input_report_mouse);
+    dev->max_output_size = 0;
+    dev->vendor_id = 1;
+    dev->product_id = 1;
+    dev->version_id = 1;
+    dev->reset = hid_mouse_reset;
+    dev->read_report = tablet
+        ? hid_mouse_read_report_tablet
+        : hid_mouse_read_report_mouse;
+    dev->write_report = hid_mouse_write_report;
+    dev->remove = tablet
+        ? NULL // Don't free the same object twice
+        : hid_mouse_remove;
+}
+
+PUBLIC hid_mouse_t* hid_mouse_init_auto(rvvm_machine_t* machine)
+{
+    hid_mouse_t* mouse = safe_new_obj(hid_mouse_t);
+
+    spin_init(&mouse->lock);
+
+    hid_mouse_setup(&mouse->tablet_hid_dev, mouse, true);
+    hid_mouse_setup(&mouse->mouse_hid_dev, mouse, false);
+
+    i2c_hid_init_auto(machine, &mouse->tablet_hid_dev);
+    i2c_hid_init_auto(machine, &mouse->mouse_hid_dev);
+
+    return mouse;
+}
+
+PUBLIC void hid_mouse_press(hid_mouse_t* mouse, hid_btns_t btns)
+{
+    spin_lock(&mouse->lock);
+    hid_dev_t *hid_dev;
+    if (mouse->tablet_mode) {
+        mouse->btns_tablet |= btns;
+        hid_dev = &mouse->tablet_hid_dev;
+    } else {
+        mouse->btns_mouse |= btns;
+        hid_dev = &mouse->mouse_hid_dev;
+    }
+    spin_unlock(&mouse->lock);
+    hid_dev->input_available(hid_dev->host, 0);
+}
+
+PUBLIC void hid_mouse_release(hid_mouse_t* mouse, hid_btns_t btns)
+{
+    spin_lock(&mouse->lock);
+    hid_dev_t *hid_dev = mouse->tablet_mode ? &mouse->tablet_hid_dev : &mouse->mouse_hid_dev;
+    mouse->btns_mouse &= ~btns;
+    mouse->btns_tablet &= ~btns;
+    spin_unlock(&mouse->lock);
+    hid_dev->input_available(hid_dev->host, 0);
+}
+
+PUBLIC void hid_mouse_scroll(hid_mouse_t* mouse, int32_t offset)
+{
+    spin_lock(&mouse->lock);
+    hid_dev_t *hid_dev = mouse->tablet_mode ? &mouse->tablet_hid_dev : &mouse->mouse_hid_dev;
+    mouse->scroll_y += offset;
+    spin_unlock(&mouse->lock);
+    hid_dev->input_available(hid_dev->host, 0);
+}
+
+PUBLIC void hid_mouse_resolution(hid_mouse_t* mouse, uint32_t width, uint32_t height)
+{
+    spin_lock(&mouse->lock);
+    mouse->width = width;
+    mouse->height = height;
+    spin_unlock(&mouse->lock);
+}
+
+PUBLIC void hid_mouse_move(hid_mouse_t* mouse, int32_t x, int32_t y)
+{
+    spin_lock(&mouse->lock);
+    mouse->mouse_delta_x += x;
+    mouse->mouse_delta_y += y;
+    bool is_input_avail = mouse->mouse_delta_x != 0 || mouse->mouse_delta_y != 0 || mouse->tablet_mode;
+    mouse->tablet_mode = false;
+    spin_unlock(&mouse->lock);
+    if (is_input_avail)
+        mouse->mouse_hid_dev.input_available(mouse->mouse_hid_dev.host, 0);
+}
+
+PUBLIC void hid_mouse_place(hid_mouse_t* mouse, int32_t x, int32_t y)
+{
+    bool is_input_avail = false;
+    spin_lock(&mouse->lock);
+    if (mouse->width > 0 && mouse->height > 0) {
+        if (x < 0) x = 0;
+        else if (x > mouse->width) x = mouse->width;
+        if (y < 0) y = 0;
+        else if (y > mouse->height) y = mouse->height;
+        mouse->tablet_x = (int32_t)((int64_t)x * 0x7fff / mouse->width);
+        mouse->tablet_y = (int32_t)((int64_t)y * 0x7fff / mouse->height);
+        is_input_avail = true;
+    }
+    mouse->tablet_mode = true;
+    spin_unlock(&mouse->lock);
+    if (is_input_avail)
+        mouse->tablet_hid_dev.input_available(mouse->tablet_hid_dev.host, 0);
+}
diff --git a/app/src/main/java/libengine/RVVM/src/devices/hid_api.h b/app/src/main/java/libengine/RVVM/src/devices/hid_api.h
new file mode 100644
index 00000000..994b0817
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/hid_api.h
@@ -0,0 +1,289 @@
+/*
+hid_api.h - Human Interface Devices API
+Copyright (C) 2022  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef RVVM_HID_API_H
+#define RVVM_HID_API_H
+
+#include "../rvvmlib.h"
+
+//! Keyboard key
+typedef uint8_t hid_key_t;
+
+//! Mouse button states bitfield
+typedef uint8_t hid_btns_t;
+
+//! HID Keyboard handle
+typedef struct hid_keyboard hid_keyboard_t;
+
+//! HID Mouse handle
+typedef struct hid_mouse    hid_mouse_t;
+
+//! \brief   Attach a HID keyboard to the machine
+//! \warning After rvvm_machine_free(), keyboard handle is no longer valid
+PUBLIC hid_keyboard_t* hid_keyboard_init_auto(rvvm_machine_t* machine);
+
+//! \brief   Attach a HID mouse to the machine
+//! \warning After rvvm_machine_free(), mouse handle is no longer valid
+PUBLIC hid_mouse_t*    hid_mouse_init_auto(rvvm_machine_t* machine);
+
+//! \brief Press a keyboard key
+PUBLIC void hid_keyboard_press(hid_keyboard_t* kb, hid_key_t key);
+
+//! \brief Release a keyboard key
+PUBLIC void hid_keyboard_release(hid_keyboard_t* kb, hid_key_t key);
+
+//! \brief Press mouse buttons
+PUBLIC void hid_mouse_press(hid_mouse_t* mouse, hid_btns_t btns);
+
+//! \brief Release mouse buttons
+PUBLIC void hid_mouse_release(hid_mouse_t* mouse, hid_btns_t btns);
+
+//! \brief Scroll mouse wheel (Positive offset goes downwards)
+PUBLIC void hid_mouse_scroll(hid_mouse_t* mouse, int32_t offset);
+
+//! \brief Set tablet resolution, must be called before hid_mouse_place()
+PUBLIC void hid_mouse_resolution(hid_mouse_t* mouse, uint32_t x, uint32_t y);
+
+//! \brief Relative mouse movement
+PUBLIC void hid_mouse_move(hid_mouse_t* mouse, int32_t x, int32_t y);
+
+//! \brief   Absolute mouse movement (Tablet mode for host cursor integration)
+//! \warning Set tablet resolution with hid_mouse_resolution() beforehand
+PUBLIC void hid_mouse_place(hid_mouse_t* mouse, int32_t x, int32_t y);
+
+/*
+ * Mouse definitions
+ */
+
+#define HID_BTN_NONE    0x0
+#define HID_BTN_LEFT    0x1 //!< Left mouse button
+#define HID_BTN_RIGHT   0x2 //!< Right mouse button
+#define HID_BTN_MIDDLE  0x4 //!< Middle mouse button (Scrollwheel)
+
+#define HID_SCROLL_UP   -1  //!< Scroll one unit upward
+#define HID_SCROLL_DOWN 1   //!< Scroll one unit downward
+
+/*
+ * Keyboard keycode definitions
+ */
+
+#define HID_KEY_NONE 0x00
+
+// Keyboard errors (Non-physical keys)
+#define HID_KEY_ERR_ROLLOVER  0x01
+#define HID_KEY_ERR_POSTFAIL  0x02
+#define HID_KEY_ERR_UNDEFINED 0x03
+
+// Typing keys
+#define HID_KEY_A 0x04
+#define HID_KEY_B 0x05
+#define HID_KEY_C 0x06
+#define HID_KEY_D 0x07
+#define HID_KEY_E 0x08
+#define HID_KEY_F 0x09
+#define HID_KEY_G 0x0a
+#define HID_KEY_H 0x0b
+#define HID_KEY_I 0x0c
+#define HID_KEY_J 0x0d
+#define HID_KEY_K 0x0e
+#define HID_KEY_L 0x0f
+#define HID_KEY_M 0x10
+#define HID_KEY_N 0x11
+#define HID_KEY_O 0x12
+#define HID_KEY_P 0x13
+#define HID_KEY_Q 0x14
+#define HID_KEY_R 0x15
+#define HID_KEY_S 0x16
+#define HID_KEY_T 0x17
+#define HID_KEY_U 0x18
+#define HID_KEY_V 0x19
+#define HID_KEY_W 0x1a
+#define HID_KEY_X 0x1b
+#define HID_KEY_Y 0x1c
+#define HID_KEY_Z 0x1d
+
+// Number keys
+#define HID_KEY_1 0x1e
+#define HID_KEY_2 0x1f
+#define HID_KEY_3 0x20
+#define HID_KEY_4 0x21
+#define HID_KEY_5 0x22
+#define HID_KEY_6 0x23
+#define HID_KEY_7 0x24
+#define HID_KEY_8 0x25
+#define HID_KEY_9 0x26
+#define HID_KEY_0 0x27
+
+// Control keys
+#define HID_KEY_ENTER      0x28
+#define HID_KEY_ESC        0x29
+#define HID_KEY_BACKSPACE  0x2a
+#define HID_KEY_TAB        0x2b
+#define HID_KEY_SPACE      0x2c
+#define HID_KEY_MINUS      0x2d
+#define HID_KEY_EQUAL      0x2e
+#define HID_KEY_LEFTBRACE  0x2f //!< Button [ {
+#define HID_KEY_RIGHTBRACE 0x30 //!< Button ] }
+#define HID_KEY_BACKSLASH  0x31
+#define HID_KEY_HASHTILDE  0x32 //!< Button # ~ (Huh? Never seen one.)
+#define HID_KEY_SEMICOLON  0x33 //!< Button ; :
+#define HID_KEY_APOSTROPHE 0x34 //!< Button ' "
+#define HID_KEY_GRAVE      0x35 //!< Button ` ~ (For dummies: Quake console button)
+#define HID_KEY_COMMA      0x36 //!< Button , <
+#define HID_KEY_DOT        0x37 //!< Button . >
+#define HID_KEY_SLASH      0x38
+#define HID_KEY_CAPSLOCK   0x39
+
+// Function keys
+#define HID_KEY_F1  0x3a
+#define HID_KEY_F2  0x3b
+#define HID_KEY_F3  0x3c
+#define HID_KEY_F4  0x3d
+#define HID_KEY_F5  0x3e
+#define HID_KEY_F6  0x3f
+#define HID_KEY_F7  0x40
+#define HID_KEY_F8  0x41
+#define HID_KEY_F9  0x42
+#define HID_KEY_F10 0x43
+#define HID_KEY_F11 0x44
+#define HID_KEY_F12 0x45
+
+// Editing keys
+#define HID_KEY_SYSRQ      0x46 //!< Print Screen (REISUB, anyone?)
+#define HID_KEY_SCROLLLOCK 0x47
+#define HID_KEY_PAUSE      0x48
+#define HID_KEY_INSERT     0x49
+#define HID_KEY_HOME       0x4a
+#define HID_KEY_PAGEUP     0x4b
+#define HID_KEY_DELETE     0x4c
+#define HID_KEY_END        0x4d
+#define HID_KEY_PAGEDOWN   0x4e
+#define HID_KEY_RIGHT      0x4f //!< Right Arrow
+#define HID_KEY_LEFT       0x50 //!< Left Arrow
+#define HID_KEY_DOWN       0x51 //!< Down Arrow
+#define HID_KEY_UP         0x52 //!< Up Arrow
+
+// Numpad keys
+#define HID_KEY_NUMLOCK    0x53
+#define HID_KEY_KPSLASH    0x54
+#define HID_KEY_KPASTERISK 0x55 //!< Button *
+#define HID_KEY_KPMINUS    0x56
+#define HID_KEY_KPPLUS     0x57
+#define HID_KEY_KPENTER    0x58
+#define HID_KEY_KP1        0x59
+#define HID_KEY_KP2        0x5a
+#define HID_KEY_KP3        0x5b
+#define HID_KEY_KP4        0x5c
+#define HID_KEY_KP5        0x5d
+#define HID_KEY_KP6        0x5e
+#define HID_KEY_KP7        0x5f
+#define HID_KEY_KP8        0x60
+#define HID_KEY_KP9        0x61
+#define HID_KEY_KP0        0x62
+#define HID_KEY_KPDOT      0x63
+
+// Non-US keyboard keys
+#define HID_KEY_102ND      0x64 //!< Non-US \ and |, also <> key on German-like keyboards
+#define HID_KEY_COMPOSE    0x65 //!< Compose key
+#define HID_KEY_POWER      0x66 //!< Poweroff key
+#define HID_KEY_KPEQUAL    0x67 //!< Keypad =
+
+// Function keys (F13 - F24)
+#define HID_KEY_F13 0x68
+#define HID_KEY_F14 0x69
+#define HID_KEY_F15 0x6a
+#define HID_KEY_F16 0x6b
+#define HID_KEY_F17 0x6c
+#define HID_KEY_F18 0x6d
+#define HID_KEY_F19 0x6e
+#define HID_KEY_F20 0x6f
+#define HID_KEY_F21 0x70
+#define HID_KEY_F22 0x71
+#define HID_KEY_F23 0x72
+#define HID_KEY_F24 0x73
+
+// Non-US Media/special keys
+#define HID_KEY_OPEN       0x74 //!< Execute
+#define HID_KEY_HELP       0x75
+#define HID_KEY_PROPS      0x76 //!< Context menu key (Near right Alt) - Linux evdev naming
+#define HID_KEY_MENU       0x76 //!< ^ Context menu key too, different naming
+#define HID_KEY_FRONT      0x77 //!< Select key
+#define HID_KEY_STOP       0x78
+#define HID_KEY_AGAIN      0x79
+#define HID_KEY_UNDO       0x7a
+#define HID_KEY_CUT        0x7b
+#define HID_KEY_COPY       0x7c
+#define HID_KEY_PASTE      0x7d
+#define HID_KEY_FIND       0x7e
+#define HID_KEY_MUTE       0x7f
+#define HID_KEY_VOLUMEUP   0x80
+#define HID_KEY_VOLUMEDOWN 0x81
+#define HID_KEY_KPCOMMA    0x85 //!< Keypad Comma (Brazilian keypad period key?)
+
+// International keys
+#define HID_KEY_RO               0x87 //!< International1 (Japanese Ro, \\ key)
+#define HID_KEY_KATAKANAHIRAGANA 0x88 //!< International2 (Japanese Katakana/Hiragana, second key right to spacebar)
+#define HID_KEY_YEN              0x89 //!< International3 (Japanese Yen)
+#define HID_KEY_HENKAN           0x8a //!< International4 (Japanese Henkan, key right to spacebar)
+#define HID_KEY_MUHENKAN         0x8b //!< International5 (Japanese Muhenkan, key left to spacebar)
+#define HID_KEY_KPJPCOMMA        0x8c //!< International6 (Japanese Comma? See HID spec...)
+
+// LANG keys
+#define HID_KEY_HANGEUL        0x90 //!< LANG1 (Korean Hangul/English toggle key)
+#define HID_KEY_HANJA          0x91 //!< LANG2 (Korean Hanja control key)
+#define HID_KEY_KATAKANA       0x92 //!< LANG3 (Japanese Katakana key)
+#define HID_KEY_HIRAGANA       0x93 //!< LANG4 (Japanese Hiragana key)
+#define HID_KEY_ZENKAKUHANKAKU 0x94 //!< LANG5 (Japanese Zenkaku/Hankaku key)
+
+// Additional keypad keys
+#define HID_KEY_KPLEFTPAREN  0xb6 //!< Keypad (
+#define HID_KEY_KPRIGHTPAREN 0xb7 //!< Keypad )
+
+// Modifier keys
+#define HID_KEY_LEFTCTRL   0xe0
+#define HID_KEY_LEFTSHIFT  0xe1
+#define HID_KEY_LEFTALT    0xe2
+#define HID_KEY_LEFTMETA   0xe3 //!< The one with the ugly Windows icon
+#define HID_KEY_RIGHTCTRL  0xe4
+#define HID_KEY_RIGHTSHIFT 0xe5
+#define HID_KEY_RIGHTALT   0xe6
+#define HID_KEY_RIGHTMETA  0xe7
+
+// Media keys
+#define HID_KEY_MEDIA_PLAYPAUSE    0xe8
+#define HID_KEY_MEDIA_STOPCD       0xe9
+#define HID_KEY_MEDIA_PREVIOUSSONG 0xea
+#define HID_KEY_MEDIA_NEXTSONG     0xeb
+#define HID_KEY_MEDIA_EJECTCD      0xec
+#define HID_KEY_MEDIA_VOLUMEUP     0xed
+#define HID_KEY_MEDIA_VOLUMEDOWN   0xee
+#define HID_KEY_MEDIA_MUTE         0xef
+#define HID_KEY_MEDIA_WWW          0xf0
+#define HID_KEY_MEDIA_BACK         0xf1
+#define HID_KEY_MEDIA_FORWARD      0xf2
+#define HID_KEY_MEDIA_STOP         0xf3
+#define HID_KEY_MEDIA_FIND         0xf4
+#define HID_KEY_MEDIA_SCROLLUP     0xf5
+#define HID_KEY_MEDIA_SCROLLDOWN   0xf6
+#define HID_KEY_MEDIA_EDIT         0xf7
+#define HID_KEY_MEDIA_SLEEP        0xf8
+#define HID_KEY_MEDIA_COFFEE       0xf9
+#define HID_KEY_MEDIA_REFRESH      0xfa
+#define HID_KEY_MEDIA_CALC         0xfb
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/devices/hid_dev.h b/app/src/main/java/libengine/RVVM/src/devices/hid_dev.h
new file mode 100644
index 00000000..4feea224
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/hid_dev.h
@@ -0,0 +1,62 @@
+/*
+hid_dev.h - Generic HID Device API
+Copyright (C) 2022  X512 <github.com/X547>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef RVVM_HID_DEV_H
+#define RVVM_HID_DEV_H
+
+#include <stdint.h>
+#include <stdbool.h>
+
+#define REPORT_TYPE_INPUT   1
+#define REPORT_TYPE_OUTPUT  2
+#define REPORT_TYPE_FEATURE 3
+
+#define HID_PROTOCOL_BOOT   0
+#define HID_PROTOCOL_REPORT 1
+
+#define HID_POWER_ON    0
+#define HID_POWER_SLEEP 1
+
+typedef struct {
+    void* host;
+    void* dev;
+
+    // static information
+    const uint8_t* report_desc;
+    uint16_t report_desc_size;
+    uint16_t max_input_size;
+    uint16_t max_output_size;
+    uint16_t vendor_id;
+    uint16_t product_id;
+    uint16_t version_id;
+
+    // device -> host calls
+    void (*input_available)(void* host, uint8_t report_id);
+
+    void (*reset)(void* dev);
+    void (*read_report )(void* dev, uint8_t report_type, uint8_t report_id, uint32_t offset, uint8_t *val);
+    void (*write_report)(void* dev, uint8_t report_type, uint8_t report_id, uint32_t offset, uint8_t val);
+    void (*get_idle)(void* dev, uint8_t report_id, uint16_t* idle /* milliseconds */);
+    void (*set_idle)(void* dev, uint8_t report_id, uint16_t idle);
+    void (*get_protocol)(void* dev, uint16_t* protocol);
+    void (*set_protocol)(void* dev, uint16_t protocol);
+    void (*set_power)(void* dev, uint16_t power);
+    void (*remove)(void* dev);
+} hid_dev_t;
+
+#endif    // RVVM_HID_DEV_H
diff --git a/app/src/main/java/libengine/RVVM/src/devices/i2c-hid.c b/app/src/main/java/libengine/RVVM/src/devices/i2c-hid.c
new file mode 100644
index 00000000..488c76d4
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/i2c-hid.c
@@ -0,0 +1,425 @@
+/*
+i2c-hid.c - i2c HID driver
+Copyright (C) 2022  X512 <github.com/X547>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "i2c-hid.h"
+#include "hid_api.h"
+#include "i2c-oc.h"
+#include "plic.h"
+#include "../spinlock.h"
+#include "../utils.h"
+#include "../bit_ops.h"
+
+#include <stdio.h>
+
+#ifdef USE_FDT
+#include "../fdtlib.h"
+#endif
+
+#define I2C_HID_DESC_REG    1
+#define I2C_HID_REPORT_REG  2
+#define I2C_HID_INPUT_REG   3
+#define I2C_HID_OUTPUT_REG  4
+#define I2C_HID_COMMAND_REG 5
+#define I2C_HID_DATA_REG    6
+
+#define I2C_HID_COMMAND_RESET        1
+#define I2C_HID_COMMAND_GET_REPORT   2
+#define I2C_HID_COMMAND_SET_REPORT   3
+#define I2C_HID_COMMAND_GET_IDLE     4
+#define I2C_HID_COMMAND_SET_IDLE     5
+#define I2C_HID_COMMAND_GET_PROTOCOL 6
+#define I2C_HID_COMMAND_SET_PROTOCOL 7
+#define I2C_HID_COMMAND_SET_POWER    8
+
+enum {
+    wHIDDescLength,
+    bcdVersion,
+    wReportDescLength,
+    wReportDescRegister,
+    wInputRegister,
+    wMaxInputLength,
+    wOutputRegister,
+    wMaxOutputLength,
+    wCommandRegister,
+    wDataRegister,
+    wVendorID,
+    wProductID,
+    wVersionID,
+};
+
+
+struct report_id_queue {
+    int16_t first;
+    int16_t last;
+    int16_t list[256];
+};
+
+typedef struct {
+    hid_dev_t* hid_dev;
+
+    spinlock_t  lock;
+
+    // IRQ data
+    plic_ctx_t* plic;
+    uint32_t irq;
+
+    struct report_id_queue report_id_queue;
+
+    // i2c IO state
+    bool is_write;
+    int32_t io_offset;
+    uint16_t reg;
+    uint8_t command;
+    uint8_t report_type;
+    uint8_t report_id;
+    uint16_t data_size;
+    uint16_t data_val;
+    bool is_reset;
+} i2c_hid_t;
+
+
+static void report_id_queue_init(struct report_id_queue* queue)
+{
+    queue->first = -1;
+    queue->last = -1;
+    for (int16_t i = 0; i < 256; i++)
+        queue->list[i] = -1;
+}
+
+static void report_id_queue_insert(struct report_id_queue* queue, uint8_t report_id)
+{
+    if (report_id == queue->last || queue->list[report_id] >= 0)
+        return;
+    if (queue->first < 0)
+        queue->first = report_id;
+    else
+        queue->list[queue->last] = report_id;
+    queue->last = report_id;
+}
+
+static int16_t report_id_queue_get(struct report_id_queue* queue)
+{
+    return queue->first;
+}
+
+static void report_id_queue_remove_at(struct report_id_queue* queue, uint8_t report_id)
+{
+    if (queue->first < 0) return;
+    if (report_id == queue->first) {
+        queue->first = queue->list[report_id];
+        if (queue->first < 0) queue->last = -1;
+    } else {
+        int16_t prev = queue->first;
+        while (prev >= 0 && queue->list[prev] != report_id) prev = queue->list[prev];
+        if (prev < 0) return;
+        queue->list[prev] = queue->list[report_id];
+    }
+    queue->list[report_id] = -1;
+}
+
+static void i2c_hid_reset(i2c_hid_t* i2c_hid, bool is_init)
+{
+    report_id_queue_init(&i2c_hid->report_id_queue);
+    i2c_hid->reg = I2C_HID_INPUT_REG;
+    i2c_hid->command = 0;
+    i2c_hid->report_type = 0;
+    i2c_hid->report_id = 0;
+    i2c_hid->is_reset = !is_init;
+
+    if (i2c_hid->hid_dev->reset) i2c_hid->hid_dev->reset(i2c_hid->hid_dev->dev);
+
+    if (!is_init)
+        plic_raise_irq(i2c_hid->plic, i2c_hid->irq);
+}
+
+static void i2c_hid_input_available(void* host, uint8_t report_id)
+{
+    i2c_hid_t* i2c_hid = (i2c_hid_t*)host;
+    spin_lock(&i2c_hid->lock);
+    if (!i2c_hid->is_reset) {
+        report_id_queue_insert(&i2c_hid->report_id_queue, report_id);
+        plic_raise_irq(i2c_hid->plic, i2c_hid->irq);
+    }
+    spin_unlock(&i2c_hid->lock);
+}
+
+static bool i2c_hid_read_data_size(i2c_hid_t* i2c_hid, uint32_t offset, uint8_t val)
+{
+    if (offset < 2)
+        i2c_hid->data_size = bit_replace(i2c_hid->data_size, offset*8, 8, val);
+    if (offset >= 1 && offset >= i2c_hid->data_size)
+        return false;
+    return true;
+}
+
+static void i2c_hid_read_report(i2c_hid_t* i2c_hid, uint8_t report_type, uint8_t report_id, uint32_t offset, uint8_t* val)
+{
+    i2c_hid->hid_dev->read_report(i2c_hid->hid_dev->dev, report_type, report_id, offset, val);
+    if (offset < 2)
+        i2c_hid->data_size = bit_replace(i2c_hid->data_size, offset*8, 8, *val);
+    if (report_type == REPORT_TYPE_INPUT && offset >= 1 && offset == (uint32_t)(i2c_hid->data_size > 2 ? i2c_hid->data_size - 1 : 1)) {
+        report_id_queue_remove_at(&i2c_hid->report_id_queue, report_id);
+        if (report_id_queue_get(&i2c_hid->report_id_queue) >= 0)
+            plic_raise_irq(i2c_hid->plic, i2c_hid->irq);
+        else
+            plic_lower_irq(i2c_hid->plic, i2c_hid->irq);
+    }
+}
+
+static bool i2c_hid_write_report(i2c_hid_t* i2c_hid, uint8_t report_type, uint8_t report_id, uint32_t offset, uint8_t val)
+{
+    if (!i2c_hid_read_data_size(i2c_hid, offset, val))
+        return false;
+    i2c_hid->hid_dev->write_report(i2c_hid->hid_dev->dev, report_type, report_id, offset, val);
+    return true;
+}
+
+static uint8_t i2c_hid_read_reg(i2c_hid_t* i2c_hid, uint16_t reg, uint32_t offset)
+{
+    switch (reg) {
+    case I2C_HID_DESC_REG: {
+        uint16_t field_val;
+        switch (offset/2) {
+        case wHIDDescLength:      field_val = 0x1e; break;
+        case bcdVersion:          field_val = 0x0100; break;
+        case wReportDescLength:   field_val = i2c_hid->hid_dev->report_desc_size; break;
+        case wReportDescRegister: field_val = I2C_HID_REPORT_REG; break;
+        case wInputRegister:      field_val = I2C_HID_INPUT_REG; break;
+        case wMaxInputLength:     field_val = i2c_hid->hid_dev->max_input_size; break;
+        case wOutputRegister:     field_val = I2C_HID_OUTPUT_REG; break;
+        case wMaxOutputLength:    field_val = i2c_hid->hid_dev->max_output_size; break;
+        case wCommandRegister:    field_val = I2C_HID_COMMAND_REG; break;
+        case wDataRegister:       field_val = I2C_HID_DATA_REG; break;
+        case wVendorID:           field_val = i2c_hid->hid_dev->vendor_id; break;
+        case wProductID:          field_val = i2c_hid->hid_dev->product_id; break;
+        case wVersionID:          field_val = i2c_hid->hid_dev->version_id; break;
+        default:                  field_val = 0; break;
+        }
+        return bit_cut(field_val, 8*(offset%2), 8);
+    }
+    case I2C_HID_REPORT_REG:
+        if (offset < i2c_hid->hid_dev->report_desc_size)
+            return i2c_hid->hid_dev->report_desc[offset];
+        break;
+    case I2C_HID_INPUT_REG: {
+        int16_t report_id = report_id_queue_get(&i2c_hid->report_id_queue);
+        if (report_id < 0) {
+            plic_lower_irq(i2c_hid->plic, i2c_hid->irq);
+            return 0;
+        }
+        uint8_t val = 0;
+        i2c_hid_read_report(i2c_hid, REPORT_TYPE_INPUT, report_id, offset, &val);
+        return val;
+    }
+    case I2C_HID_DATA_REG:
+        switch (i2c_hid->command) {
+        case I2C_HID_COMMAND_GET_REPORT: {
+            uint8_t val = 0;
+            i2c_hid_read_report(i2c_hid, i2c_hid->report_type, i2c_hid->report_id, offset, &val);
+            return val;
+        }
+        case I2C_HID_COMMAND_GET_IDLE: {
+            uint16_t field_val = 0;
+            switch (offset/2) {
+            case 0: field_val = 4; break;
+            case 1:
+                if (i2c_hid->hid_dev->get_idle)
+                    i2c_hid->hid_dev->get_idle(i2c_hid->hid_dev->dev, i2c_hid->report_id, &field_val);
+                break;
+            }
+            return bit_cut(field_val, 8*(offset%2), 8);
+        }
+        case I2C_HID_COMMAND_GET_PROTOCOL: {
+            uint16_t field_val = 0;
+            switch (offset/2) {
+            case 0: field_val = 4; break;
+            case 1:
+                if (i2c_hid->hid_dev->get_protocol)
+                    i2c_hid->hid_dev->get_protocol(i2c_hid->hid_dev->dev, &field_val);
+                break;
+            }
+            return bit_cut(field_val, 8*(offset%2), 8);
+        }
+        }
+        break;
+    }
+    return 0;
+}
+
+static bool i2c_hid_write_reg(i2c_hid_t* i2c_hid, uint16_t reg, uint32_t offset, uint8_t val)
+{
+    switch (reg) {
+    case I2C_HID_OUTPUT_REG:
+        return i2c_hid_write_report(i2c_hid, REPORT_TYPE_OUTPUT, 0, offset, val);
+    case I2C_HID_COMMAND_REG:
+        switch (offset) {
+        case 0:
+            i2c_hid->report_id   = bit_cut(val, 0, 4);
+            i2c_hid->report_type = bit_cut(val, 4, 2);
+            return true;
+        case 1:
+            i2c_hid->command = bit_cut(val, 0, 4);
+            //fprintf(stderr, "  command: %u\n", i2c_hid->command);
+            if (i2c_hid->report_id == 0xF)
+                return true;
+            break;
+        case 2:
+            i2c_hid->report_id = val;
+            break;
+        }
+        switch (i2c_hid->command) {
+        case I2C_HID_COMMAND_SET_IDLE:
+            if (i2c_hid->data_size == 4 && i2c_hid->hid_dev->set_idle)
+                i2c_hid->hid_dev->set_idle(i2c_hid->hid_dev->dev, i2c_hid->report_id, i2c_hid->data_val);
+            break;
+        case I2C_HID_COMMAND_SET_PROTOCOL:
+            if (i2c_hid->data_size == 4 && i2c_hid->hid_dev->set_protocol)
+                i2c_hid->hid_dev->set_protocol(i2c_hid->hid_dev->dev, i2c_hid->data_val);
+            break;
+        case I2C_HID_COMMAND_SET_POWER:
+            if (i2c_hid->hid_dev->set_power)
+                i2c_hid->hid_dev->set_power(i2c_hid->hid_dev->dev, i2c_hid->report_id%4);
+            break;
+        }
+        break;
+    case I2C_HID_DATA_REG:
+        if (i2c_hid->command == I2C_HID_COMMAND_SET_REPORT) {
+            return i2c_hid_write_report(i2c_hid, i2c_hid->report_type, i2c_hid->report_id, offset, val);
+        } else {
+            if (!i2c_hid_read_data_size(i2c_hid, offset, val))
+                return false;
+            if (offset/2 == 1)
+                i2c_hid->data_val = bit_replace(i2c_hid->data_val, offset*8, 8, val);
+            return true;
+        }
+        break;
+    }
+    return false;
+}
+
+static bool i2c_hid_start(void* dev, bool is_write)
+{
+    i2c_hid_t* i2c_hid = (i2c_hid_t*)dev;
+    spin_lock(&i2c_hid->lock);
+    //fprintf(stderr, "i2c_hid_start(is_write: %d)\n", is_write);
+    i2c_hid->is_write = is_write;
+    i2c_hid->io_offset = 0;
+    spin_unlock(&i2c_hid->lock);
+    return true;
+}
+
+static bool i2c_hid_write(void* dev, uint8_t byte)
+{
+    i2c_hid_t* i2c_hid = (i2c_hid_t*)dev;
+    spin_lock(&i2c_hid->lock);
+    //fprintf(stderr, "i2c_hid_write, io_offset: %u, val: %#02x\n", i2c_hid->io_offset, byte);
+    switch (i2c_hid->io_offset) {
+    case 0:
+    case 1:
+        i2c_hid->reg = bit_replace(i2c_hid->reg, i2c_hid->io_offset*8, 8, byte);
+        i2c_hid->io_offset++;
+        //if (i2c_hid->io_offset == 2) {
+        //  fprintf(stderr, "  reg: %u\n", i2c_hid->reg);
+        //}
+        break;
+    default:
+        if (i2c_hid_write_reg(i2c_hid, i2c_hid->reg, i2c_hid->io_offset - 2, byte))
+            i2c_hid->io_offset++;
+        else
+            i2c_hid->io_offset = 0;
+        break;
+    }
+    spin_unlock(&i2c_hid->lock);
+    return true;
+}
+
+static bool i2c_hid_read(void* dev, uint8_t* byte)
+{
+    i2c_hid_t* i2c_hid = (i2c_hid_t*)dev;
+    spin_lock(&i2c_hid->lock);
+    //fprintf(stderr, "i2c_hid_read, io_offset: %u\n", i2c_hid->io_offset);
+    *byte = i2c_hid_read_reg(i2c_hid, i2c_hid->reg, i2c_hid->io_offset++);
+    //fprintf(stderr, "  val: %#02x\n", *byte);
+    spin_unlock(&i2c_hid->lock);
+    return true;
+}
+
+static void i2c_hid_stop(void* dev)
+{
+    i2c_hid_t* i2c_hid = (i2c_hid_t*)dev;
+    spin_lock(&i2c_hid->lock);
+    //fprintf(stderr, "i2c_hid_stop\n");
+    i2c_hid->is_reset = false;
+    if (i2c_hid->command == I2C_HID_COMMAND_RESET) i2c_hid_reset(i2c_hid, false);
+    i2c_hid->reg = I2C_HID_INPUT_REG;
+    i2c_hid->command = 0;
+    i2c_hid->data_size = 0;
+    spin_unlock(&i2c_hid->lock);
+}
+
+static void i2c_hid_remove(void* dev)
+{
+    i2c_hid_t* i2c_hid = (i2c_hid_t*)dev;
+    if (i2c_hid->hid_dev->remove) i2c_hid->hid_dev->remove(i2c_hid->hid_dev->dev);
+    free(i2c_hid);
+}
+
+static void i2c_hid_init(rvvm_machine_t* machine, i2c_bus_t* bus, uint16_t addr, plic_ctx_t* plic, uint32_t irq, hid_dev_t* hid_dev)
+{
+    UNUSED(machine);
+    i2c_hid_t* i2c_hid = safe_new_obj(i2c_hid_t);
+
+    spin_init(&i2c_hid->lock);
+
+    i2c_dev_t i2c_dev = {
+        .addr = addr,
+        .data = i2c_hid,
+        .start = i2c_hid_start,
+        .write = i2c_hid_write,
+        .read = i2c_hid_read,
+        .stop = i2c_hid_stop,
+        .remove = i2c_hid_remove
+    };
+    addr = i2c_attach_dev(bus, &i2c_dev);
+
+    i2c_hid->plic = plic;
+    i2c_hid->irq = irq;
+
+    i2c_hid->hid_dev = hid_dev;
+    hid_dev->host = i2c_hid;
+    hid_dev->input_available = i2c_hid_input_available;
+
+    i2c_hid_reset(i2c_hid, true);
+
+#ifdef USE_FDT
+    struct fdt_node* i2c_fdt = fdt_node_create_reg("i2c", addr);
+    fdt_node_add_prop_str(i2c_fdt, "compatible", "hid-over-i2c");
+    fdt_node_add_prop_u32(i2c_fdt, "reg", addr);
+    fdt_node_add_prop_u32(i2c_fdt, "hid-descr-addr", I2C_HID_DESC_REG);
+    fdt_node_add_prop_u32(i2c_fdt, "interrupt-parent", plic_get_phandle(plic));
+    fdt_node_add_prop_u32(i2c_fdt, "interrupts", irq);
+    fdt_node_add_child(i2c_bus_fdt_node(bus), i2c_fdt);
+#endif
+}
+
+PUBLIC void i2c_hid_init_auto(rvvm_machine_t* machine, hid_dev_t* hid_dev)
+{
+    i2c_bus_t* bus = rvvm_get_i2c_bus(machine);
+    plic_ctx_t* plic = rvvm_get_plic(machine);
+    i2c_hid_init(machine, bus, I2C_AUTO_ADDR, plic, plic_alloc_irq(plic), hid_dev);
+}
diff --git a/app/src/main/java/libengine/RVVM/src/devices/i2c-hid.h b/app/src/main/java/libengine/RVVM/src/devices/i2c-hid.h
new file mode 100644
index 00000000..f94872d7
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/i2c-hid.h
@@ -0,0 +1,27 @@
+/*
+i2c-hid.h - I2C HID Host Controller Interface
+Copyright (C) 2022  X512 <github.com/X547>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef _I2C_HID_H_
+#define _I2C_HID_H_
+
+#include "hid_dev.h"
+#include "../rvvmlib.h"
+
+PUBLIC void i2c_hid_init_auto(rvvm_machine_t* machine, hid_dev_t* hid_dev);
+
+#endif  // _I2C_HID_H_
diff --git a/app/src/main/java/libengine/RVVM/src/devices/i2c-oc.c b/app/src/main/java/libengine/RVVM/src/devices/i2c-oc.c
new file mode 100644
index 00000000..4b1f1d1b
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/i2c-oc.c
@@ -0,0 +1,276 @@
+/*
+i2c-oc.c - OpenCores I2C Controller
+Copyright (C) 2022  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "i2c-oc.h"
+#include "plic.h"
+#include "../spinlock.h"
+#include "../vector.h"
+#include "../mem_ops.h"
+#include "../utils.h"
+
+#ifdef USE_FDT
+#include "../fdtlib.h"
+#endif
+
+struct i2c_bus {
+    vector_t(i2c_dev_t) devices;
+    plic_ctx_t* plic;
+    struct fdt_node* fdt_node;
+    uint32_t irq;
+    spinlock_t lock;
+    uint16_t sel_addr;
+    uint16_t clock;
+    uint8_t  control;
+    uint8_t  status;
+    uint8_t  tx_byte;
+    uint8_t  rx_byte;
+};
+
+#define I2C_OC_REG_SIZE 0x14
+
+// OpenCores I2C registers
+#define I2C_OC_CLKLO    0x00 // Clock prescale low byte
+#define I2C_OC_CLKHI    0x04 // Clock prescale high byte
+#define I2C_OC_CTR      0x08 // Control register
+#define I2C_OC_TXRXR    0x0C // Transmit & Receive register (W/R)
+#define I2C_OC_CRSR     0x10 // Command & Status Register (W/R)
+
+// Register values
+#define I2C_OC_CTR_MASK 0xC0 // Mask of legal bits
+#define I2C_OC_CTR_EN   0x80 // Core enable bit
+#define I2C_OC_CTR_IEN  0x40 // Interrupt enable bit
+
+#define I2C_OC_CR_STA   0x80 // Generate (repeated) start condition
+#define I2C_OC_CR_STO   0x40 // Generate stop condition
+#define I2C_OC_CR_RD    0x20 // Read from slave
+#define I2C_OC_CR_WR    0x10 // Write to slave
+#define I2C_OC_CR_ACK   0x08 // Send ACK (0) or NACK (1) to master
+#define I2C_OC_CR_IACK  0x01 // Interrupt acknowledge, clear a pending IRQ
+
+#define I2C_OC_SR_ACK   0x80 // Received ACK from slave (0), NACK is 1
+#define I2C_OC_SR_BSY   0x40 // I2C bus busy
+#define I2C_OC_SR_AL    0x20 // Arbitration lost
+#define I2C_OC_SR_TIP   0x02 // Transfer in progress
+#define I2C_OC_SR_IF    0x01 // Interrupt flag
+
+static void i2c_oc_interrupt(i2c_bus_t* bus)
+{
+    bus->status |= I2C_OC_SR_IF;
+    if (bus->control & I2C_OC_CTR_IEN) plic_send_irq(bus->plic, bus->irq);
+}
+
+static i2c_dev_t* i2c_oc_get_dev(i2c_bus_t* bus, uint16_t addr)
+{
+    vector_foreach(bus->devices, i) {
+        i2c_dev_t* i2c_dev = &vector_at(bus->devices, i);
+        if (i2c_dev->addr == addr) return i2c_dev;
+    }
+    return NULL;
+}
+
+static bool i2c_oc_mmio_read(rvvm_mmio_dev_t* dev, void* data, size_t offset, uint8_t size)
+{
+    i2c_bus_t* bus = dev->data;
+    memset(data, 0, size);
+    spin_lock(&bus->lock);
+    switch (offset) {
+        case I2C_OC_CLKLO:
+            write_uint8(data, bus->clock & 0xFF);
+            break;
+        case I2C_OC_CLKHI:
+            write_uint8(data, bus->clock >> 8);
+            break;
+        case I2C_OC_CTR:
+            write_uint8(data, bus->control);
+            break;
+        case I2C_OC_TXRXR:
+            write_uint8(data, bus->rx_byte);
+            break;
+        case I2C_OC_CRSR:
+            write_uint8(data, bus->status);
+            break;
+    }
+    spin_unlock(&bus->lock);
+    return true;
+}
+
+static bool i2c_oc_mmio_write(rvvm_mmio_dev_t* dev, void* data, size_t offset, uint8_t size)
+{
+    i2c_bus_t* bus = dev->data;
+    UNUSED(size);
+    spin_lock(&bus->lock);
+    switch (offset) {
+        case I2C_OC_CLKLO:
+            bus->clock = (bus->clock & 0xFF00) | read_uint8(data);
+            break;
+        case I2C_OC_CLKHI:
+            bus->clock = (bus->clock & 0xFF) | (read_uint8(data) << 8);
+            break;
+        case I2C_OC_CTR:
+            bus->control = read_uint8(data) & I2C_OC_CTR_MASK;
+            break;
+        case I2C_OC_TXRXR:
+            bus->tx_byte = read_uint8(data);
+            break;
+        case I2C_OC_CRSR: {
+            uint8_t cmd = read_uint8(data);
+            bus->status |= I2C_OC_SR_ACK;
+            if (cmd & I2C_OC_CR_IACK) {
+                // Clear a pending interrupt
+                bus->status &= ~I2C_OC_SR_IF;
+            }
+            if (cmd & I2C_OC_CR_STA) {
+                // Start the transaction
+                bus->sel_addr = 0xFFFF;
+                bus->status |= I2C_OC_SR_BSY;
+            }
+            if ((cmd & I2C_OC_CR_WR)) {
+                if (bus->sel_addr == 0xFFFF) {
+                    // Get device address, signal start of transaction
+                    bus->sel_addr = bus->tx_byte >> 1;
+                    i2c_dev_t* i2c_dev = i2c_oc_get_dev(bus, bus->sel_addr);
+                    bool is_write = !(bus->tx_byte & 1);
+                    if (i2c_dev && (!i2c_dev->start || i2c_dev->start(i2c_dev->data, is_write))) {
+                        bus->status &= ~I2C_OC_SR_ACK;
+                    }
+                } else {
+                    // Write byte
+                    i2c_dev_t* i2c_dev = i2c_oc_get_dev(bus, bus->sel_addr);
+                    if (i2c_dev && i2c_dev->write(i2c_dev->data, bus->tx_byte)) {
+                        bus->status &= ~I2C_OC_SR_ACK;
+                    }
+                }
+                i2c_oc_interrupt(bus);
+            }
+            if (cmd & I2C_OC_CR_RD) {
+                // Read byte
+                i2c_dev_t* i2c_dev = i2c_oc_get_dev(bus, bus->sel_addr);
+                if (i2c_dev && i2c_dev->read(i2c_dev->data, &bus->rx_byte)) {
+                    bus->status &= ~I2C_OC_SR_ACK;
+                }
+                i2c_oc_interrupt(bus);
+            }
+            if (cmd & I2C_OC_CR_STO) {
+                // End of transaction
+                i2c_dev_t* i2c_dev = i2c_oc_get_dev(bus, bus->sel_addr);
+                if (i2c_dev && i2c_dev->stop) i2c_dev->stop(i2c_dev->data);
+                bus->sel_addr = 0xFFFF;
+                bus->status &= ~I2C_OC_SR_BSY;
+                i2c_oc_interrupt(bus);
+            }
+            break;
+        }
+    }
+    spin_unlock(&bus->lock);
+    return true;
+}
+
+static void i2c_oc_remove(rvvm_mmio_dev_t* dev)
+{
+    i2c_bus_t* bus = dev->data;
+    vector_foreach(bus->devices, i) {
+        i2c_dev_t* i2c_dev = &vector_at(bus->devices, i);
+        if (i2c_dev->remove) i2c_dev->remove(i2c_dev->data);
+    }
+    vector_free(bus->devices);
+    free(bus);
+}
+
+static rvvm_mmio_type_t i2c_oc_dev_type = {
+    .name = "i2c_opencores",
+    .remove = i2c_oc_remove,
+};
+
+PUBLIC i2c_bus_t* i2c_oc_init(rvvm_machine_t* machine, rvvm_addr_t base_addr, plic_ctx_t* plic, uint32_t irq)
+{
+    i2c_bus_t* bus = safe_new_obj(i2c_bus_t);
+    bus->plic = plic;
+    bus->irq = irq;
+
+    rvvm_mmio_dev_t i2c_oc = {
+        .addr = base_addr,
+        .size = I2C_OC_REG_SIZE,
+        .data = bus,
+        .read = i2c_oc_mmio_read,
+        .write = i2c_oc_mmio_write,
+        .type = &i2c_oc_dev_type,
+        .min_op_size = 1,
+        .max_op_size = 4,
+    };
+    if (rvvm_attach_mmio(machine, &i2c_oc) == NULL) return NULL;
+
+#ifdef USE_FDT
+    struct fdt_node* i2c_clock = fdt_node_find(rvvm_get_fdt_soc(machine), "i2c_oc_osc");
+    if (i2c_clock == NULL) {
+        i2c_clock = fdt_node_create("i2c_oc_osc");
+        fdt_node_add_prop_str(i2c_clock, "compatible", "fixed-clock");
+        fdt_node_add_prop_u32(i2c_clock, "#clock-cells", 0);
+        fdt_node_add_prop_u32(i2c_clock, "clock-frequency", 20000000);
+        fdt_node_add_prop_str(i2c_clock, "clock-output-names", "clk");
+        fdt_node_add_child(rvvm_get_fdt_soc(machine), i2c_clock);
+    }
+
+    struct fdt_node* i2c_fdt = fdt_node_create_reg("i2c", base_addr);
+    fdt_node_add_prop_reg(i2c_fdt, "reg", base_addr, I2C_OC_REG_SIZE);
+    fdt_node_add_prop_str(i2c_fdt, "compatible", "opencores,i2c-ocores");
+    fdt_node_add_prop_u32(i2c_fdt, "interrupt-parent", plic_get_phandle(plic));
+    fdt_node_add_prop_u32(i2c_fdt, "interrupts", irq);
+    fdt_node_add_prop_u32(i2c_fdt, "clocks", fdt_node_get_phandle(i2c_clock));
+    fdt_node_add_prop_str(i2c_fdt, "clock-names", "clk");
+    fdt_node_add_prop_u32(i2c_fdt, "reg-shift", 2);
+    fdt_node_add_prop_u32(i2c_fdt, "reg-io-width", 1);
+    fdt_node_add_prop_u32(i2c_fdt, "opencores,ip-clock-frequency", 20000000);
+    fdt_node_add_prop_u32(i2c_fdt, "#address-cells", 1);
+    fdt_node_add_prop_u32(i2c_fdt, "#size-cells", 0);
+    fdt_node_add_prop_str(i2c_fdt, "status", "okay");
+    fdt_node_add_child(rvvm_get_fdt_soc(machine), i2c_fdt);
+    bus->fdt_node = i2c_fdt;
+#endif
+    rvvm_set_i2c_bus(machine, bus);
+    return bus;
+}
+
+PUBLIC i2c_bus_t* i2c_oc_init_auto(rvvm_machine_t* machine)
+{
+    plic_ctx_t* plic = rvvm_get_plic(machine);
+    rvvm_addr_t addr = rvvm_mmio_zone_auto(machine, I2C_OC_DEFAULT_MMIO, I2C_OC_REG_SIZE);
+    return i2c_oc_init(machine, addr, plic, plic_alloc_irq(plic));
+}
+
+PUBLIC uint16_t i2c_attach_dev(i2c_bus_t* bus, const i2c_dev_t* dev_desc)
+{
+    if (bus == NULL) return 0;
+    i2c_dev_t tmp = *dev_desc;
+    if (dev_desc->addr == I2C_AUTO_ADDR) tmp.addr = 0x8;
+    while (i2c_oc_get_dev(bus, tmp.addr)) {
+        if (dev_desc->addr == I2C_AUTO_ADDR) {
+            tmp.addr++;
+        } else {
+            rvvm_warn("Duplicate I2C device address on a single bus");
+            return 0;
+        }
+    }
+    vector_push_back(bus->devices, tmp);
+    return tmp.addr;
+}
+
+PUBLIC struct fdt_node* i2c_bus_fdt_node(i2c_bus_t* bus)
+{
+    if (bus == NULL) return NULL;
+    return bus->fdt_node;
+}
diff --git a/app/src/main/java/libengine/RVVM/src/devices/i2c-oc.h b/app/src/main/java/libengine/RVVM/src/devices/i2c-oc.h
new file mode 100644
index 00000000..cfdc0949
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/i2c-oc.h
@@ -0,0 +1,54 @@
+/*
+i2c-oc.h - OpenCores I2C Controller
+Copyright (C) 2022  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef RVVM_I2C_OC_H
+#define RVVM_I2C_OC_H
+
+#include "../rvvmlib.h"
+
+#define I2C_OC_DEFAULT_MMIO 0x10030000
+
+#define I2C_AUTO_ADDR 0x0 // Auto-pick I2C device address
+
+typedef struct {
+    // I2C bus address
+    uint16_t addr;
+    // Device-specific data
+    void*    data;
+    
+    // Start transaction, return device availability
+    bool (*start)(void* dev, bool is_write);
+    // Return false on NACK or no data to read
+    bool (*write)(void* dev, uint8_t byte);
+    bool (*read)(void* dev, uint8_t* byte);
+    // Stop the current transaction
+    void (*stop)(void* dev);
+    // Device cleanup
+    void (*remove)(void* dev);
+} i2c_dev_t;
+
+PUBLIC i2c_bus_t* i2c_oc_init(rvvm_machine_t* machine, rvvm_addr_t base_addr, plic_ctx_t* plic, uint32_t irq);
+PUBLIC i2c_bus_t* i2c_oc_init_auto(rvvm_machine_t* machine);
+
+// Returns assigned device address or zero on error
+PUBLIC uint16_t   i2c_attach_dev(i2c_bus_t* bus, const i2c_dev_t* dev_desc);
+
+// Get I2C controller FDT node for nested device nodes
+PUBLIC struct fdt_node* i2c_bus_fdt_node(i2c_bus_t* bus);
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/devices/mtd-physmap.c b/app/src/main/java/libengine/RVVM/src/devices/mtd-physmap.c
new file mode 100644
index 00000000..b228ec3f
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/mtd-physmap.c
@@ -0,0 +1,106 @@
+/*
+mtd-physmap.c - Memory Technology Device Mapping
+Copyright (C) 2023  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "mtd-physmap.h"
+#include "../blk_io.h"
+#include "../fdtlib.h"
+#include "../utils.h"
+
+typedef struct {
+    blkdev_t* blk;
+} mtd_dev_t;
+
+static void mtd_remove(rvvm_mmio_dev_t* dev)
+{
+    mtd_dev_t* mtd = dev->data;
+    blk_close(mtd->blk);
+    free(mtd);
+}
+
+static void mtd_reset(rvvm_mmio_dev_t* dev)
+{
+    mtd_dev_t* mtd = dev->data;
+    void* ptr = rvvm_get_dma_ptr(dev->machine, rvvm_get_opt(dev->machine, RVVM_OPT_MEM_BASE), blk_getsize(mtd->blk));
+    if (ptr) blk_read(mtd->blk, ptr, blk_getsize(mtd->blk), 0);
+}
+
+static rvvm_mmio_type_t mtd_type = {
+    .name = "mtd_physmap",
+    .remove = mtd_remove,
+    .reset = mtd_reset,
+};
+
+static bool mtd_mmio_read(rvvm_mmio_dev_t* dev, void* data, size_t offset, uint8_t size)
+{
+    mtd_dev_t* mtd = dev->data;
+    return blk_read(mtd->blk, data, size, offset) == size;
+}
+
+static bool mtd_mmio_write(rvvm_mmio_dev_t* dev, void* data, size_t offset, uint8_t size)
+{
+    mtd_dev_t* mtd = dev->data;
+    return blk_write(mtd->blk, data, size, offset) == size;
+}
+
+PUBLIC rvvm_mmio_dev_t* mtd_physmap_init_blk(rvvm_machine_t* machine, rvvm_addr_t addr, void* blk_dev)
+{
+    mtd_dev_t* mtd = safe_new_obj(mtd_dev_t);
+    mtd->blk = blk_dev;
+
+    rvvm_mmio_dev_t mtd_mmio = {
+        .addr = addr,
+        .size = blk_getsize(mtd->blk),
+        .min_op_size = 1,
+        .max_op_size = 8,
+        .read = mtd_mmio_read,
+        .write = mtd_mmio_write,
+        .data = mtd,
+        .type = &mtd_type,
+    };
+    rvvm_mmio_dev_t* mmio = rvvm_attach_mmio(machine, &mtd_mmio);
+    if (mmio == NULL) return mmio;
+#ifdef USE_FDT
+    struct fdt_node* mtd_fdt = fdt_node_create_reg("flash", mtd_mmio.addr);
+    fdt_node_add_prop_reg(mtd_fdt, "reg", mtd_mmio.addr, mtd_mmio.size);
+    fdt_node_add_prop_str(mtd_fdt, "compatible", "mtd-ram");
+    fdt_node_add_prop_u32(mtd_fdt, "bank-width", 0x1);
+    fdt_node_add_prop_u32(mtd_fdt, "#address-cells", 1);
+    fdt_node_add_prop_u32(mtd_fdt, "#size-cells", 1);
+    {
+        struct fdt_node* partition0 = fdt_node_create("partition@0");
+        uint32_t reg[2] = { 0, mtd_mmio.size, };
+        fdt_node_add_prop_cells(partition0, "reg", reg, 2);
+        fdt_node_add_prop_str(partition0, "label", "firmware");
+        fdt_node_add_child(mtd_fdt, partition0);
+    }
+    fdt_node_add_child(rvvm_get_fdt_soc(machine), mtd_fdt);
+#endif
+    return mmio;
+}
+
+PUBLIC rvvm_mmio_dev_t* mtd_physmap_init(rvvm_machine_t* machine, rvvm_addr_t addr, const char* image_path, bool rw)
+{
+    blkdev_t* blk = blk_open(image_path, rw ? BLKDEV_RW : 0);
+    if (blk == NULL) return NULL;
+    return mtd_physmap_init_blk(machine, addr, blk);
+}
+
+PUBLIC rvvm_mmio_dev_t* mtd_physmap_init_auto(rvvm_machine_t* machine, const char* image_path, bool rw)
+{
+    return mtd_physmap_init(machine, MTD_PHYSMAP_DEFAULT_MMIO, image_path, rw);
+}
diff --git a/app/src/main/java/libengine/RVVM/src/devices/mtd-physmap.h b/app/src/main/java/libengine/RVVM/src/devices/mtd-physmap.h
new file mode 100644
index 00000000..a69de2a0
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/mtd-physmap.h
@@ -0,0 +1,36 @@
+/*
+mtd-physmap.h - Memory Technology Device Mapping
+Copyright (C) 2023  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef RVVM_MTD_PHYSMAP_H
+#define RVVM_MTD_PHYSMAP_H
+
+#include "../rvvmlib.h"
+
+/*
+ * The main purpose of this device is to allow guests to flash
+ * different firmware into the board memory chip
+ */
+
+#define MTD_PHYSMAP_DEFAULT_MMIO 0x04000000
+
+PUBLIC rvvm_mmio_dev_t* mtd_physmap_init_blk(rvvm_machine_t* machine, rvvm_addr_t addr, void* blk_dev);
+PUBLIC rvvm_mmio_dev_t* mtd_physmap_init(rvvm_machine_t* machine, rvvm_addr_t addr, const char* image_path, bool rw);
+PUBLIC rvvm_mmio_dev_t* mtd_physmap_init_auto(rvvm_machine_t* machine, const char* image_path, bool rw);
+
+#endif
+
diff --git a/app/src/main/java/libengine/RVVM/src/devices/ns16550a.c b/app/src/main/java/libengine/RVVM/src/devices/ns16550a.c
new file mode 100644
index 00000000..b002b123
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/ns16550a.c
@@ -0,0 +1,258 @@
+/*
+ns16550a.c - NS16550A UART
+Copyright (C) 2021  LekKit <github.com/LekKit>
+                    Mr0maks <mr.maks0443@gmail.com>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "ns16550a.h"
+#include "chardev.h"
+#include "../spinlock.h"
+#include "../utils.h"
+#include "../mem_ops.h"
+
+#ifdef USE_FDT
+#include "../fdtlib.h"
+#endif
+
+#define NS16550A_MMIO_SIZE 0x8
+
+typedef struct {
+    chardev_t* chardev;
+    plic_ctx_t* plic;
+    uint32_t irq;
+
+    uint32_t ier;
+    uint32_t lcr;
+    uint32_t mcr;
+    uint32_t scr;
+    uint32_t dll;
+    uint32_t dlm;
+} ns16550a_dev_t;
+
+// Read
+#define NS16550A_REG_RBR_DLL 0x0
+#define NS16550A_REG_IIR     0x2
+// Write
+#define NS16550A_REG_THR_DLL 0x0
+#define NS16550A_REG_FCR     0x2
+// RW
+#define NS16550A_REG_IER_DLM 0x1
+#define NS16550A_REG_LCR     0x3
+#define NS16550A_REG_MCR     0x4
+#define NS16550A_REG_LSR     0x5
+#define NS16550A_REG_MSR     0x6
+#define NS16550A_REG_SCR     0x7
+
+#define NS16550A_IER_RECV    0x1
+#define NS16550A_IER_THR     0x2
+#define NS16550A_IER_LSR     0x4
+#define NS16550A_IER_MSR     0x8
+
+#define NS16550A_IIR_FIFO    0xC0
+#define NS16550A_IIR_NONE    0x1
+#define NS16550A_IIR_MSR     0x0
+#define NS16550A_IIR_THR     0x2
+#define NS16550A_IIR_RECV    0x4
+#define NS16550A_IIR_LSR     0x6
+
+#define NS16550A_LSR_RECV    0x1
+#define NS16550A_LSR_THR     0x60
+
+#define NS16550A_LCR_DLAB    0x80
+
+static void ns16550a_notify(void* io_dev, uint32_t flags)
+{
+    ns16550a_dev_t* uart = io_dev;
+    uint32_t ier = atomic_load_uint32(&uart->ier);
+    if (((flags & CHARDEV_RX) && (ier & NS16550A_IER_RECV))
+     || ((flags & CHARDEV_TX) && (ier & NS16550A_IER_THR))) {
+        plic_send_irq(uart->plic, uart->irq);
+    }
+}
+
+static bool ns16550a_mmio_read(rvvm_mmio_dev_t* dev, void* data, size_t offset, uint8_t size)
+{
+    ns16550a_dev_t* uart = dev->data;
+    memset(data, 0, size);
+
+    switch (offset) {
+        case NS16550A_REG_RBR_DLL:
+            if (atomic_load_uint32(&uart->lcr) & NS16550A_LCR_DLAB) {
+                write_uint8(data, atomic_load_uint32(&uart->dll));
+            } else if (chardev_poll(uart->chardev) & CHARDEV_RX) {
+                chardev_read(uart->chardev, data, 1);
+            }
+            break;
+        case NS16550A_REG_IER_DLM:
+            if (atomic_load_uint32(&uart->lcr) & NS16550A_LCR_DLAB) {
+                write_uint8(data, atomic_load_uint32(&uart->dlm));
+            } else {
+                write_uint8(data, atomic_load_uint32(&uart->ier));
+            }
+            break;
+        case NS16550A_REG_IIR: {
+            uint32_t flags = chardev_poll(uart->chardev);
+            uint32_t ier = atomic_load_uint32(&uart->ier);
+            if ((flags & CHARDEV_RX) && (ier & NS16550A_IER_RECV)) {
+                write_uint8(data, NS16550A_IIR_RECV | NS16550A_IIR_FIFO);
+            } else if ((flags & CHARDEV_TX) && (ier & NS16550A_IER_THR)) {
+                write_uint8(data, NS16550A_IIR_THR | NS16550A_IIR_FIFO);
+            } else {
+                write_uint8(data, NS16550A_IIR_NONE | NS16550A_IIR_FIFO);
+            }
+            break;
+        }
+        case NS16550A_REG_LCR:
+            write_uint8(data, atomic_load_uint32(&uart->lcr));
+            break;
+        case NS16550A_REG_MCR:
+            write_uint8(data, atomic_load_uint32(&uart->mcr));
+            break;
+        case NS16550A_REG_LSR: {
+            uint32_t flags = chardev_poll(uart->chardev);
+            write_uint8(data, ((flags & CHARDEV_RX) ? NS16550A_LSR_RECV : 0)
+                            | ((flags & CHARDEV_TX) ? NS16550A_LSR_THR : 0));
+            break;
+        }
+        case NS16550A_REG_MSR:
+            write_uint8(data, 0xF0);
+            break;
+        case NS16550A_REG_SCR:
+            write_uint8(data, atomic_load_uint32(&uart->scr));
+            break;
+        default:
+            write_uint8(data, 0);
+            break;
+    }
+    return true;
+}
+
+static bool ns16550a_mmio_write(rvvm_mmio_dev_t* dev, void* data, size_t offset, uint8_t size)
+{
+    ns16550a_dev_t* uart = dev->data;
+    UNUSED(size);
+
+    switch (offset) {
+        case NS16550A_REG_THR_DLL:
+            if (atomic_load_uint32(&uart->lcr) & NS16550A_LCR_DLAB) {
+                atomic_store_uint32(&uart->dll, read_uint8(data));
+            } else {
+                chardev_write(uart->chardev, data, 1);
+            }
+            break;
+        case NS16550A_REG_IER_DLM:
+            if (atomic_load_uint32(&uart->lcr) & NS16550A_LCR_DLAB) {
+                atomic_store_uint32(&uart->dlm, read_uint8(data));
+            } else {
+                atomic_store_uint32(&uart->ier, read_uint8(data));
+                // Trigger re-enabled interrupts, if any
+                ns16550a_notify(uart, chardev_poll(uart->chardev));
+            }
+            break;
+        case NS16550A_REG_LCR:
+            atomic_store_uint32(&uart->lcr, read_uint8(data));
+            break;
+        case NS16550A_REG_MCR:
+            atomic_store_uint32(&uart->mcr, read_uint8(data));
+            break;
+        case NS16550A_REG_SCR:
+            atomic_store_uint32(&uart->scr, read_uint8(data));
+            break;
+        default:
+            break;
+    }
+    return true;
+}
+
+static void ns16550a_update(rvvm_mmio_dev_t* dev)
+{
+    ns16550a_dev_t* uart = dev->data;
+    chardev_update(uart->chardev);
+}
+
+static void ns16550a_remove(rvvm_mmio_dev_t* dev)
+{
+    ns16550a_dev_t* uart = dev->data;
+    chardev_free(uart->chardev);
+    free(uart);
+}
+
+static rvvm_mmio_type_t ns16550a_dev_type = {
+    .name = "ns16550a",
+    .update = ns16550a_update,
+    .remove = ns16550a_remove,
+};
+
+PUBLIC rvvm_mmio_dev_t* ns16550a_init(rvvm_machine_t* machine, chardev_t* chardev,
+                                      rvvm_addr_t base_addr, plic_ctx_t* plic, uint32_t irq)
+{
+    ns16550a_dev_t* uart = safe_new_obj(ns16550a_dev_t);
+    uart->chardev = chardev;
+    uart->plic = plic;
+    uart->irq = irq;
+
+    if (chardev) {
+        chardev->io_dev = uart;
+        chardev->notify = ns16550a_notify;
+    }
+
+    rvvm_mmio_dev_t ns16550a = {
+        .addr = base_addr,
+        .size = NS16550A_MMIO_SIZE,
+        .min_op_size = 1,
+        .max_op_size = 1,
+        .read = ns16550a_mmio_read,
+        .write = ns16550a_mmio_write,
+        .data = uart,
+        .type = &ns16550a_dev_type,
+    };
+    rvvm_mmio_dev_t* mmio = rvvm_attach_mmio(machine, &ns16550a);
+    if (mmio == NULL) return mmio;
+#ifdef USE_FDT
+    struct fdt_node* uart_fdt = fdt_node_create_reg("uart", ns16550a.addr);
+    fdt_node_add_prop_reg(uart_fdt, "reg", ns16550a.addr, ns16550a.size);
+    fdt_node_add_prop_str(uart_fdt, "compatible", "ns16550a");
+    fdt_node_add_prop_u32(uart_fdt, "clock-frequency", 0x2625a00);
+    fdt_node_add_prop_u32(uart_fdt, "fifo-size", 16);
+    fdt_node_add_prop_str(uart_fdt, "status", "okay");
+    if (plic) {
+        fdt_node_add_prop_u32(uart_fdt, "interrupt-parent", plic_get_phandle(plic));
+        fdt_node_add_prop_u32(uart_fdt, "interrupts", irq);
+    }
+    fdt_node_add_child(rvvm_get_fdt_soc(machine), uart_fdt);
+#endif
+    return mmio;
+}
+
+PUBLIC rvvm_mmio_dev_t* ns16550a_init_auto(rvvm_machine_t* machine, chardev_t* chardev)
+{
+    plic_ctx_t* plic = rvvm_get_plic(machine);
+    rvvm_addr_t addr = rvvm_mmio_zone_auto(machine, NS16550A_DEFAULT_MMIO, NS16550A_MMIO_SIZE);
+    rvvm_mmio_dev_t* mmio = ns16550a_init(machine, chardev, addr, plic, plic_alloc_irq(plic));
+    if (addr == NS16550A_DEFAULT_MMIO && mmio != NULL) {
+        rvvm_append_cmdline(machine, "console=ttyS");
+#ifdef USE_FDT
+        struct fdt_node* chosen = fdt_node_find(rvvm_get_fdt_root(machine), "chosen");
+        fdt_node_add_prop_str(chosen, "stdout-path", "/soc/uart@10000000");
+#endif
+    }
+    return mmio;
+}
+
+PUBLIC rvvm_mmio_dev_t* ns16550a_init_term_auto(rvvm_machine_t* machine)
+{
+    return ns16550a_init_auto(machine, chardev_term_create());
+}
diff --git a/app/src/main/java/libengine/RVVM/src/devices/ns16550a.h b/app/src/main/java/libengine/RVVM/src/devices/ns16550a.h
new file mode 100644
index 00000000..14a947d3
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/ns16550a.h
@@ -0,0 +1,34 @@
+/*
+ns16550a.h - NS16550A UART
+Copyright (C) 2021  LekKit <github.com/LekKit>
+                    Mr0maks <mr.maks0443@gmail.com>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef RVVM_NS16550A_H
+#define RVVM_NS16550A_H
+
+#include "../rvvmlib.h"
+#include "plic.h"
+#include "chardev.h"
+
+#define NS16550A_DEFAULT_MMIO 0x10000000
+
+PUBLIC rvvm_mmio_dev_t* ns16550a_init(rvvm_machine_t* machine, chardev_t* chardev,
+                                      rvvm_addr_t base_addr, plic_ctx_t* plic, uint32_t irq);
+PUBLIC rvvm_mmio_dev_t* ns16550a_init_auto(rvvm_machine_t* machine, chardev_t* chardev);
+PUBLIC rvvm_mmio_dev_t* ns16550a_init_term_auto(rvvm_machine_t* machine);
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/devices/nvme.c b/app/src/main/java/libengine/RVVM/src/devices/nvme.c
new file mode 100644
index 00000000..1e718b7e
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/nvme.c
@@ -0,0 +1,621 @@
+/*
+nvme.c - Non-Volatile Memory Express
+Copyright (C) 2022  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "nvme.h"
+#include "../mem_ops.h"
+#include "../bit_ops.h"
+#include "../utils.h"
+#include "../spinlock.h"
+#include "../atomics.h"
+#include "../threading.h"
+#include "../blk_io.h"
+#include "../rvtimer.h"
+
+// Controller Registers
+#define NVME_CAP1  0x0   // Controller Capabilities
+#define NVME_CAP2  0x4
+#define NVME_VS    0x8   // Version
+#define NVME_INTMS 0xC   // Interrupt Mask Set
+#define NVME_INTMC 0x10  // Interrupt Mask Clear
+#define NVME_CC    0x14  // Controller Configuration
+#define NVME_CSTS  0x1C  // Controller Status
+#define NVME_AQA   0x24  // Admin Queue Attributes
+#define NVME_ASQ1  0x28  // Admin Submission Queue Base Address
+#define NVME_ASQ2  0x2C
+#define NVME_ACQ1  0x30  // Admin Completion Queue Base Address
+#define NVME_ACQ2  0x34
+
+// Queue IDs
+#define ADMIN_SUBQ 0x0   // Admin Submission Queue
+#define ADMIN_COMQ 0x1   // Admin Completion Queue
+
+// Admin Command Set
+#define A_RMIO_SUB 0x0   // Delete IO Submission Queue
+#define A_MKIO_SUB 0x1   // Create IO Submission Queue
+#define A_RMIO_COM 0x4   // Delete IO Completion Queue
+#define A_MKIO_COM 0x5   // Create IO Completion Queue
+#define A_IDENTIFY 0x6   // Identify
+#define A_ABORTCMD 0x8   // Abort Command
+#define A_SET_FEAT 0x9   // Set Features
+#define A_GET_FEAT 0xA   // Get Features
+
+// Admin Command Fields
+#define IDENT_NS   0x0   // Identify Namespace
+#define IDENT_CTRL 0x1   // Identify Controller
+#define IDENT_NSLS 0x2   // Identify Namespace List
+#define IDENT_NIDS 0x3   // Identify Namespace Descriptors
+#define FEAT_NQES  0x7   // Number of Queues feature
+
+// NVM Command Set
+#define NVM_FLUSH  0x0
+#define NVM_WRITE  0x1
+#define NVM_READ   0x2
+#define NVM_WRITEZ 0x8   // Write Zeroes
+#define NVM_DTSM   0x9   // Dataset Management
+
+// Completion Queue Status Codes
+#define SC_SUCCESS 0x0   // Successful Completion
+#define SC_BAD_OP  0x1   // Invalid Command Opcode
+#define SC_BAD_FIL 0x2   // Invalid Field in Command
+#define SC_DT_ERR  0x4   // Data Transfer Error
+#define SC_ABORT   0x7   // Command Abort Requested
+#define SC_SQ_DEL  0x8   // Command Aborted due to SQ Deletion
+#define SC_BAD_NS  0xB   // Invalid Namespace or Format
+#define SC_BAD_QI 0x101  // Invalid Queue ID
+#define SC_BAD_QS 0x102  // Invalid Queue Size
+
+// Configurable constants
+#define NVME_MQES 0xFFFF // Maximum Queue Entries Supported: 65536
+#define NVME_CQR   0x1   // Contiguous Queues Required
+#define NVME_TO    0xA   // Timeout: 5s
+#define NVME_DSTRD 0x0   // Doorbell Stride (0 means 2-bit shift)
+#define NVME_CSS   0x1   // Command Sets Supported (NVM Command Set)
+#define NVME_MPMAX 0x0   // Max page size: 4K
+#define NVME_V   0x10400 // NVMe v1.4
+#define NVME_IOQES 0x46  // IO Queue Entry Sizes (16b:64b)
+#define NVME_LBAS  0x9   // LBA Block Size Shift (512b blocks)
+#define NVME_MAXQ  0x12  // Max Queues: 18 (Admin + IO, Submission & Completion)
+
+#define NVME_PAGE_SIZE 0x1000ULL
+#define NVME_PAGE_MASK 0xFFFULL
+#define NVME_PRP2_END  0xFF8ULL
+
+typedef struct {
+    rvvm_addr_t addr;
+    spinlock_t lock;
+    uint32_t size;
+    uint32_t head;
+    uint32_t tail;
+} nvme_queue_t;
+
+typedef struct {
+    blkdev_t* blk;
+    pci_dev_t* pci_dev;
+    spinlock_t lock;
+    uint32_t threads;
+    uint32_t conf;
+    uint32_t irq_mask;
+    char serial[12];
+    nvme_queue_t queues[NVME_MAXQ];
+} nvme_dev_t;
+
+typedef struct {
+    rvvm_addr_t prp1;
+    rvvm_addr_t prp2;
+    uint8_t*    prp2_dma;
+    size_t      prp2_off;
+    size_t      size;
+    size_t      cur;
+} nvme_prp_ctx_t;
+
+typedef struct {
+    const uint8_t* ptr;
+    nvme_queue_t*  queue;
+    nvme_prp_ctx_t prp;
+    uint16_t cmd_id;
+    uint16_t sq_id;
+    uint16_t sq_head;
+    uint8_t  opcode;
+} nvme_cmd_t;
+
+static void nvme_shutdown(nvme_dev_t* nvme)
+{
+    while (atomic_load_uint32(&nvme->threads)) sleep_ms(1);
+    rvvm_addr_t asq = nvme->queues[ADMIN_SUBQ].addr;
+    rvvm_addr_t acq = nvme->queues[ADMIN_COMQ].addr;
+    uint32_t asqs = nvme->queues[ADMIN_SUBQ].size;
+    uint32_t acqs = nvme->queues[ADMIN_COMQ].size;
+    memset(nvme->queues, 0, sizeof(nvme->queues));
+    nvme->queues[ADMIN_SUBQ].addr = asq;
+    nvme->queues[ADMIN_COMQ].addr = acq;
+    nvme->queues[ADMIN_SUBQ].size = asqs;
+    nvme->queues[ADMIN_COMQ].size = acqs;
+}
+
+static void nvme_remove(rvvm_mmio_dev_t* dev)
+{
+    nvme_dev_t* nvme = (nvme_dev_t*)dev->data;
+    nvme_shutdown(nvme);
+    blk_close(nvme->blk);
+    free(nvme);
+}
+
+static rvvm_mmio_type_t nvme_type = {
+    .name = "nvme",
+    .remove = nvme_remove,
+};
+
+static void nvme_complete_cmd(nvme_dev_t* nvme, nvme_cmd_t* cmd, uint32_t sf)
+{
+    nvme_queue_t* queue = cmd->queue;
+    spin_lock(&queue->lock);
+    rvvm_addr_t addr = queue->addr + (queue->tail << 4);
+    if (queue->tail++ >= queue->size) queue->tail = 0;
+    spin_unlock(&queue->lock);
+
+    uint8_t* ptr = pci_get_dma_ptr(nvme->pci_dev, addr, 16);
+    if (ptr) {
+        uint8_t phase = (~read_uint16_le(ptr + 14)) & 1;
+        write_uint32_le(ptr,      sf >> 8);                  // Command Specific
+        write_uint32_le(ptr + 4,  0);                        // Reserved
+        write_uint16_le(ptr + 8,  cmd->sq_head);             // SQ Head Pointer
+        write_uint16_le(ptr + 10, cmd->sq_id);               // SQ Identifier
+        write_uint16_le(ptr + 12, cmd->cmd_id);              // Command Identifier
+        atomic_fence();
+        write_uint16_le(ptr + 14, (sf & 0xFF) << 1 | phase); // Phase Bit, Status Field
+    }
+    if (!(nvme->irq_mask & 1)) pci_send_irq(nvme->pci_dev, 0);
+}
+
+static size_t nvme_process_prp_chunk(nvme_dev_t* nvme, nvme_cmd_t* cmd)
+{
+    nvme_prp_ctx_t* prp = &cmd->prp;
+    rvvm_addr_t addr = prp->prp1;
+    size_t len = NVME_PAGE_SIZE;
+
+    if (prp->cur >= prp->size) {
+        // End of transfer
+        return 0;
+    }
+
+    if (prp->cur == 0) {
+        // Consume the first page, may be misaligned
+        len = NVME_PAGE_SIZE - (prp->prp1 & NVME_PAGE_MASK);
+        if (len < prp->size && prp->size <= NVME_PAGE_SIZE + len) {
+            // PRP2 encodes second page address directly
+            prp->prp1 = prp->prp2;
+            if (prp->prp1 == addr + len) len += NVME_PAGE_SIZE;
+            if (len >= prp->size) len = prp->size;
+            prp->cur = len;
+            return len;
+        }
+        if (len >= prp->size) {
+            prp->cur = prp->size;
+            return prp->size;
+        }
+    }
+
+    while ((prp->cur + len) < prp->size) {
+        // Process PRP2 entries until we reach end of transfer
+        if (prp->prp2_dma == NULL) {
+            prp->prp2_dma = pci_get_dma_ptr(nvme->pci_dev, prp->prp2, NVME_PAGE_SIZE);
+        }
+        if (prp->prp2_dma) {
+            prp->prp1 = read_uint64_le_m(prp->prp2_dma + prp->prp2_off);
+            prp->prp2_off += 8;
+            if (prp->prp2_off >= NVME_PRP2_END) {
+                prp->prp2 = read_uint64_le_m(prp->prp2_dma + NVME_PRP2_END);
+                prp->prp2_off = 0;
+                prp->prp2_dma = pci_get_dma_ptr(nvme->pci_dev, prp->prp2, NVME_PAGE_SIZE);
+            }
+        } else {
+            // DMA error
+            nvme_complete_cmd(nvme, cmd, SC_DT_ERR);
+            return 0;
+        }
+
+        // Non-continuous page, split the chunk
+        if (prp->prp1 != (addr + len)) break;
+        len += NVME_PAGE_SIZE;
+    }
+
+    if ((prp->cur + len) > prp->size) {
+        // Fixup length overrun
+        len = prp->size - prp->cur;
+    }
+
+    prp->cur += len;
+    return len;
+}
+
+static void* nvme_get_prp_chunk(nvme_dev_t* nvme, nvme_cmd_t* cmd, size_t* size)
+{
+    rvvm_addr_t addr = cmd->prp.prp1;
+    *size = nvme_process_prp_chunk(nvme, cmd);
+    if (*size == 0) return NULL;
+    void* ret = pci_get_dma_ptr(nvme->pci_dev, addr, *size);
+    if (ret == NULL) nvme_complete_cmd(nvme, cmd, SC_DT_ERR);
+    return ret;
+}
+
+static bool nvme_write_prp(nvme_dev_t* nvme, nvme_cmd_t* cmd, const void* data, size_t size)
+{
+    const uint8_t* src = data;
+    uint8_t* dest;
+    size_t tmp_size;
+    cmd->prp.size = size;
+    while (cmd->prp.cur < cmd->prp.size) {
+        dest = nvme_get_prp_chunk(nvme, cmd, &tmp_size);
+        if (!dest) return false;
+        memcpy(dest, src, tmp_size);
+        src += tmp_size;
+    }
+    return true;
+}
+
+static void nvme_admin_cmd(nvme_dev_t* nvme, nvme_cmd_t* cmd)
+{
+    switch (cmd->opcode) {
+        case A_IDENTIFY: {
+            uint8_t* ptr = safe_calloc(NVME_PAGE_SIZE, sizeof(uint8_t));
+            switch (cmd->ptr[40]) {
+                case IDENT_NS: {
+                    uint64_t lbas = blk_getsize(nvme->blk) >> NVME_LBAS;
+                    write_uint64_le(ptr,      lbas);
+                    write_uint64_le(ptr + 8,  lbas);
+                    write_uint64_le(ptr + 16, lbas);
+                    ptr[33] = 0x8; // Supports Deallocate bit in Write Zeros
+                    ptr[130] = NVME_LBAS;
+                    break;
+                }
+                case IDENT_CTRL: {
+                    write_uint16_le(ptr,     0x144d); // PCI Vendor ID
+                    write_uint16_le(ptr + 2, 0x144d);
+                    memcpy(ptr + 4,  nvme->serial, sizeof(nvme->serial)); // Serial Number
+                    rvvm_strlcpy((char*)ptr + 24, "NVMe Storage", 40);    // Model Number
+                    rvvm_strlcpy((char*)ptr + 64, "R947", 8);             // Firmware Revision
+                    write_uint32_le(ptr + 80, NVME_V); // Version
+                    ptr[111] = 1;    // Controller Type: I/O Controller
+                    ptr[512] = 0x66; // Submission Queue Max/Cur Entry Size
+                    ptr[513] = 0x44; // Completion Queue Max/Cur Entry Size
+                    ptr[516] = 1;    // Number of Namespaces
+                    ptr[520] = 0xC;  // Supports Write Zeroes, Dataset Management
+                    // NVMe Qualified Name (Includes serial to distinguish targets)
+                    size_t nqn_off = rvvm_strlcpy((char*)ptr + 768, "nqn.2022-04.lekkit:nvme:", 256);
+                    memcpy(ptr + 768 + nqn_off,  nvme->serial, sizeof(nvme->serial));
+                    break;
+                }
+                case IDENT_NSLS:
+                    write_uint32_le(ptr, 0x1); // Namespace #1
+                    break;
+                case IDENT_NIDS:
+                    ptr[0] = 3;  // Namespace UUID
+                    ptr[1] = 16; // UUID length
+                    break;
+                default:
+                    nvme_complete_cmd(nvme, cmd, SC_BAD_FIL);
+                    free(ptr);
+                    return;
+            }
+            if (nvme_write_prp(nvme, cmd, ptr, NVME_PAGE_SIZE)) {
+                nvme_complete_cmd(nvme, cmd, SC_SUCCESS);
+            }
+            free(ptr);
+            break;
+        }
+        case A_MKIO_SUB:
+        case A_MKIO_COM: {
+            size_t q_id = (read_uint16_le(cmd->ptr + 40) << 1) + (cmd->opcode == A_MKIO_COM);
+            uint16_t q_size = read_uint16_le(cmd->ptr + 42);
+            if (q_id <= ADMIN_COMQ || q_id >= NVME_MAXQ) {
+                nvme_complete_cmd(nvme, cmd, SC_BAD_QI);
+            } else if (q_size == 0) {
+                nvme_complete_cmd(nvme, cmd, SC_BAD_QS);
+            } else {
+                spin_lock(&nvme->queues[q_id].lock);
+                nvme->queues[q_id].addr = cmd->prp.prp1;
+                nvme->queues[q_id].size = q_size;
+                nvme->queues[q_id].head = 0;
+                nvme->queues[q_id].tail = 0;
+                spin_unlock(&nvme->queues[q_id].lock);
+                nvme_complete_cmd(nvme, cmd, SC_SUCCESS);
+            }
+            break;
+        }
+        case A_RMIO_SUB:
+        case A_RMIO_COM: {
+            size_t q_id = (read_uint16_le(cmd->ptr + 40) << 1) + (cmd->opcode == A_RMIO_COM);
+            if (q_id <= ADMIN_COMQ || q_id >= NVME_MAXQ) {
+                nvme_complete_cmd(nvme, cmd, SC_BAD_QI);
+            } else {
+                spin_lock(&nvme->queues[q_id].lock);
+                nvme->queues[q_id].addr = 0;
+                nvme->queues[q_id].size = 0;
+                nvme->queues[q_id].head = 0;
+                nvme->queues[q_id].tail = 0;
+                spin_unlock(&nvme->queues[q_id].lock);
+                nvme_complete_cmd(nvme, cmd, SC_SUCCESS);
+            }
+            break;
+        }
+        case A_SET_FEAT:
+        case A_GET_FEAT:
+            if (cmd->ptr[40] == FEAT_NQES) {
+                nvme_complete_cmd(nvme, cmd, SC_SUCCESS | (NVME_MAXQ << 8));
+            } else {
+                nvme_complete_cmd(nvme, cmd, SC_BAD_FIL);
+            }
+            break;
+        case A_ABORTCMD: // Ignored, all the commands could be already executing
+            nvme_complete_cmd(nvme, cmd, SC_SUCCESS);
+            break;
+        default:
+            //rvvm_info("NVMe unknown admin cmd %02x", cmd->opcode);
+            nvme_complete_cmd(nvme, cmd, SC_BAD_OP);
+            break;
+    }
+}
+
+static void nvme_io_cmd(nvme_dev_t* nvme, nvme_cmd_t* cmd)
+{
+    uint64_t pos = read_uint64_le(cmd->ptr + 40) << NVME_LBAS;
+    uint8_t* buffer;
+    size_t   size, tmp;
+
+    switch (cmd->opcode) {
+        case NVM_READ:
+        case NVM_WRITE:
+            while (cmd->prp.cur < cmd->prp.size) {
+                buffer = nvme_get_prp_chunk(nvme, cmd, &size);
+                if (buffer == NULL) return;
+                if (cmd->opcode == NVM_WRITE) {
+                    tmp = blk_write(nvme->blk, buffer, size, pos);
+                } else {
+                    tmp = blk_read(nvme->blk, buffer, size, pos);
+                }
+                if (tmp != size) {
+                    nvme_complete_cmd(nvme, cmd, SC_DT_ERR);
+                    return;
+                }
+                pos += size;
+            }
+            nvme_complete_cmd(nvme, cmd, SC_SUCCESS);
+            break;
+        case NVM_FLUSH:
+            blk_sync(nvme->blk);
+            nvme_complete_cmd(nvme, cmd, SC_SUCCESS);
+            break;
+        case NVM_WRITEZ:
+            blk_trim(nvme->blk, pos, cmd->prp.size);
+            nvme_complete_cmd(nvme, cmd, SC_SUCCESS);
+            break;
+        case NVM_DTSM:
+            if (cmd->ptr[44] & 0x4) {
+                // Deallocate (TRIM)
+                cmd->prp.size = (((size_t)cmd->ptr[40]) + 1) << 4;
+                while (cmd->prp.cur < cmd->prp.size) {
+                    buffer = nvme_get_prp_chunk(nvme, cmd, &size);
+                    if (!buffer) return;
+                    for (size_t i=0; i<size; i += 16) {
+                        uint64_t trim_len = ((uint64_t)read_uint32_le(buffer + i + 4)) << NVME_LBAS;
+                        uint64_t trim_pos = read_uint64_le(buffer + i + 8) << NVME_LBAS;
+                        blk_trim(nvme->blk, trim_pos, trim_len);
+                    }
+                }
+            }
+            nvme_complete_cmd(nvme, cmd, SC_SUCCESS);
+            break;
+        default:
+            //rvvm_info("NVMe unknown IO cmd %02x", cmd->opcode);
+            nvme_complete_cmd(nvme, cmd, SC_BAD_OP);
+            break;
+    }
+}
+
+static void* nvme_cmd_worker(void** data)
+{
+    nvme_dev_t* nvme = data[0];
+    size_t queue_id = (size_t)data[1];
+    nvme_queue_t* queue = &nvme->queues[queue_id];
+    nvme_cmd_t cmd = {
+        .queue = &nvme->queues[queue_id + 1],
+        .sq_id = queue_id >> 1,
+        .sq_head = (size_t)data[2],
+    };
+    cmd.ptr = pci_get_dma_ptr(nvme->pci_dev, queue->addr + (cmd.sq_head << 6), 64);
+    if (cmd.ptr) {
+        // Parse & process NVMe command
+        cmd.opcode = cmd.ptr[0];
+        cmd.cmd_id = read_uint16_le(cmd.ptr + 2);
+        cmd.prp.prp1 = read_uint64_le(cmd.ptr + 24);
+        cmd.prp.prp2 = read_uint64_le(cmd.ptr + 32);
+        cmd.prp.size = (((size_t)read_uint16_le(cmd.ptr + 48)) + 1) << NVME_LBAS;
+
+        if (queue_id == ADMIN_SUBQ) {
+            nvme_admin_cmd(nvme, &cmd);
+        } else {
+            nvme_io_cmd(nvme, &cmd);
+        }
+    }
+    atomic_sub_uint32(&nvme->threads, 1);
+    return NULL;
+}
+
+static void nvme_doorbell(nvme_dev_t* nvme, size_t queue_id, uint16_t val)
+{
+    nvme_queue_t* queue = &nvme->queues[queue_id];
+    
+    // Ignore attempts to overrun queue
+    if (val > queue->size) return;
+
+    spin_lock(&queue->lock);
+    if (queue_id & 1) {
+        // Update completion queue head
+        queue->head = val;
+        if (queue->tail == val) {
+            pci_clear_irq(nvme->pci_dev, 0);
+        }
+    } else {
+        queue->tail = val;
+        while (queue->head != queue->tail) {
+            void* args[3] = {nvme, (void*)queue_id, (void*)(size_t)queue->head};
+            atomic_add_uint32(&nvme->threads, 1);
+            thread_create_task_va(nvme_cmd_worker, args, 3);
+
+            if (queue->head++ >= queue->size) queue->head = 0;
+        }
+    }
+    spin_unlock(&queue->lock);
+}
+
+static bool nvme_pci_read(rvvm_mmio_dev_t* dev, void* data, size_t offset, uint8_t size)
+{
+    nvme_dev_t* nvme = dev->data;
+    spin_lock(&nvme->lock);
+    switch (offset) {
+        case NVME_CAP1:
+            write_uint32_le(data, NVME_MQES | (NVME_CQR << 16) | (NVME_TO << 24));
+            break;
+        case NVME_CAP2:
+            write_uint32_le(data, NVME_DSTRD | (NVME_CSS << 5) | (NVME_MPMAX << 20));
+            break;
+        case NVME_VS:
+            write_uint32_le(data, NVME_V);
+            break;
+        case NVME_INTMS:
+        case NVME_INTMC:
+            write_uint32_le(data, nvme->irq_mask);
+            break;
+        case NVME_CC:
+            write_uint32_le(data, (nvme->conf & 1) | (NVME_IOQES << 16));
+            break;
+        case NVME_CSTS:
+            // CC.EN  -> CSTS.EN
+            // CC.SHN -> CSTS.SHST
+            write_uint32_le(data, (nvme->conf & 1) | ((!!(nvme->conf & 0xC000)) << 3));
+            break;
+        case NVME_AQA:
+            write_uint32_le(data, nvme->queues[ADMIN_SUBQ].size | (nvme->queues[ADMIN_COMQ].size <<  16));
+            break;
+        case NVME_ASQ1:
+            write_uint32_le(data, nvme->queues[ADMIN_SUBQ].addr);
+            break;
+        case NVME_ASQ2:
+            write_uint32_le(data, nvme->queues[ADMIN_SUBQ].addr >> 32);
+            break;
+        case NVME_ACQ1:
+            write_uint32_le(data, nvme->queues[ADMIN_COMQ].addr);
+            break;
+        case NVME_ACQ2:
+            write_uint32_le(data, nvme->queues[ADMIN_COMQ].addr >> 32);
+            break;
+        default:
+            memset(data, 0, size);
+            break;
+    }
+    spin_unlock(&nvme->lock);
+    return true;
+}
+
+static bool nvme_pci_write(rvvm_mmio_dev_t* dev, void* data, size_t offset, uint8_t size)
+{
+    nvme_dev_t* nvme = dev->data;
+    UNUSED(size);
+    if (likely(offset >= 0x1000)) {
+        // Doorbell
+        size_t queue_id = (offset - 0x1000) >> (NVME_DSTRD + 2);
+        if (queue_id < NVME_MAXQ) nvme_doorbell(nvme, queue_id, read_uint16_le(data));
+        return true;
+    }
+    spin_lock(&nvme->lock);
+    switch (offset) {
+        case NVME_INTMS:
+            nvme->irq_mask |= read_uint32_le(data);
+            break;
+        case NVME_INTMC:
+            nvme->irq_mask &= ~read_uint32_le(data);
+            break;
+        case NVME_CC:
+            nvme->conf = read_uint32_le(data);
+            // Shutdown or reset the controller
+            if ((nvme->conf & 0xC000) || !(nvme->conf & 0x1))
+                nvme_shutdown(nvme);
+            break;
+        case NVME_AQA:
+            nvme->queues[ADMIN_SUBQ].size = bit_cut(read_uint32_le(data), 0, 12);
+            nvme->queues[ADMIN_COMQ].size = bit_cut(read_uint32_le(data), 16, 12);
+            break;
+        case NVME_ASQ1:
+            nvme->queues[ADMIN_SUBQ].addr = bit_replace(nvme->queues[ADMIN_SUBQ].addr, 12, 20, read_uint32_le(data) >> 12);
+            break;
+        case NVME_ASQ2:
+            nvme->queues[ADMIN_SUBQ].addr = bit_replace(nvme->queues[ADMIN_SUBQ].addr, 32, 32, read_uint32_le(data));
+            break;
+        case NVME_ACQ1:
+            nvme->queues[ADMIN_COMQ].addr = bit_replace(nvme->queues[ADMIN_COMQ].addr, 12, 20, read_uint32_le(data) >> 12);
+            break;
+        case NVME_ACQ2:
+            nvme->queues[ADMIN_COMQ].addr = bit_replace(nvme->queues[ADMIN_COMQ].addr, 32, 32, read_uint32_le(data));
+            break;
+    }
+    spin_unlock(&nvme->lock);
+    return true;
+}
+
+PUBLIC pci_dev_t* nvme_init_blk(pci_bus_t* pci_bus, void* blk_dev)
+{
+    nvme_dev_t* nvme = safe_new_obj(nvme_dev_t);
+    nvme->blk = blk_dev;
+    rvvm_randomserial(nvme->serial, sizeof(nvme->serial));
+
+    pci_dev_desc_t nvme_desc = {
+        .func[0] = {
+            .vendor_id = 0x144d,  // Samsung Electronics Co Ltd
+            .device_id = 0xa809,  // NVMe SSD Controller 980
+            .class_code = 0x0108, // Mass Storage, Non-Volatile memory controller
+            .prog_if = 0x02,      // NVMe
+            .irq_pin = PCI_IRQ_PIN_INTA,
+            .bar[0] = {
+                .addr = PCI_BAR_ADDR_64,
+                .size = 0x4000,
+                .min_op_size = 4,
+                .max_op_size = 4,
+                .read = nvme_pci_read,
+                .write = nvme_pci_write,
+                .data = nvme,
+                .type = &nvme_type,
+            }
+        }
+    };
+
+    pci_dev_t* pci_dev = pci_bus_add_device(pci_bus, &nvme_desc);
+    if (pci_dev) nvme->pci_dev = pci_dev;
+    return pci_dev;
+}
+
+PUBLIC pci_dev_t* nvme_init(pci_bus_t* pci_bus, const char* image_path, bool rw)
+{
+    blkdev_t* blk = blk_open(image_path, rw ? BLKDEV_RW : 0);
+    if (blk == NULL) return NULL;
+    return nvme_init_blk(pci_bus, blk);
+}
+
+PUBLIC pci_dev_t* nvme_init_auto(rvvm_machine_t* machine, const char* image_path, bool rw)
+{
+    return nvme_init(rvvm_get_pci_bus(machine), image_path, rw);
+}
diff --git a/app/src/main/java/libengine/RVVM/src/devices/nvme.h b/app/src/main/java/libengine/RVVM/src/devices/nvme.h
new file mode 100644
index 00000000..3522d0b6
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/nvme.h
@@ -0,0 +1,29 @@
+/*
+nvme.h - Non-Volatile Memory Express
+Copyright (C) 2022  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef NVME_H
+#define NVME_H
+
+#include "../rvvmlib.h"
+#include "pci-bus.h"
+
+PUBLIC pci_dev_t* nvme_init_blk(pci_bus_t* pci_bus, void* blk_dev);
+PUBLIC pci_dev_t* nvme_init(pci_bus_t* pci_bus, const char* image_path, bool rw);
+PUBLIC pci_dev_t* nvme_init_auto(rvvm_machine_t* machine, const char* image_path, bool rw);
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/devices/pci-bus.c b/app/src/main/java/libengine/RVVM/src/devices/pci-bus.c
new file mode 100644
index 00000000..a492de0b
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/pci-bus.c
@@ -0,0 +1,489 @@
+/*
+pci-bus.c - Peripheral Component Interconnect Bus
+Copyright (C) 2021  LekKit <github.com/LekKit>
+                    cerg2010cerg2010 <github.com/cerg2010cerg2010>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "pci-bus.h"
+#include "../fdtlib.h"
+#include "../utils.h"
+#include "../atomics.h"
+#include "../bit_ops.h"
+#include "../mem_ops.h"
+
+#define PCI_REG_DEV_VEN_ID    0x0
+#define PCI_REG_STATUS_CMD    0x4
+#define PCI_REG_CLASS_REV     0x8
+#define PCI_REG_BIST_HDR_LATENCY_CACHE 0xC
+
+#define PCI_REG_BAR0          0x10
+#define PCI_REG_BAR1          0x14
+#define PCI_REG_BAR2          0x18
+#define PCI_REG_BAR3          0x1C
+#define PCI_REG_BAR4          0x20
+#define PCI_REG_BAR5          0x24
+
+#define PCI_REG_SSID_SVID     0x2C
+
+#define PCI_REG_EXPANSION_ROM 0x30
+#define PCI_REG_CAP_PTR       0x34
+#define PCI_REG_IRQ_PIN_LINE  0x3c
+
+#define PCI_CMD_IO_SPACE      0x1  // Accessible through IO ports
+#define PCI_CMD_MEM_SPACE     0x2  // Accessible through MMIO
+#define PCI_CMD_BUS_MASTER    0x4  // May use DMA
+#define PCI_CMD_MWI_ENABLE    0x10 // May use Memory Write and Invalidate
+#define PCI_CMD_DEFAULT       0x17
+#define PCI_CMD_IRQ_DISABLE   0x400
+
+#define PCI_STATUS_IRQ        0x8
+
+typedef struct {
+    pci_dev_t* dev;
+    rvvm_mmio_dev_t* bar[PCI_FUNC_BARS];
+
+    // Atomic variables
+    uint32_t status;
+    uint32_t command;
+    uint32_t irq_line;
+
+    // RO attributes
+    uint16_t vendor_id;
+    uint16_t device_id;
+    uint16_t class_code;
+    uint8_t prog_if;
+    uint8_t rev;
+    uint8_t irq_pin;
+} pci_func_t;
+
+struct pci_device {
+    pci_bus_t* bus;
+    pci_func_t* func[PCI_DEV_FUNCS];
+    uint8_t dev_id;
+};
+
+struct pci_bus {
+    rvvm_machine_t* machine;
+    plic_ctx_t* plic;
+    uint32_t irq[PCI_BUS_IRQS];
+
+    struct pci_device* dev[PCI_BUS_DEVS];
+
+    rvvm_addr_t io_addr;
+    size_t      io_len;
+    rvvm_addr_t mem_addr;
+    size_t      mem_len;
+
+    uint8_t bus_shift; // 20 for ECAM (PCIe), 16 for regular CAM
+    uint8_t bus_id;
+};
+
+static pci_func_t* pci_get_func(pci_bus_t* bus, uint8_t bus_id, uint8_t dev_id, uint8_t fun_id)
+{
+    pci_dev_t* dev = bus->dev[dev_id];
+    if (bus_id != bus->bus_id || dev == NULL) {
+        return NULL;
+    }
+    return dev->func[fun_id];
+}
+
+static bool pci_bus_read(rvvm_mmio_dev_t* mmio_dev, void* data, size_t offset, uint8_t size)
+{
+    pci_bus_t* bus = mmio_dev->data;
+    uint8_t bus_id = offset >> bus->bus_shift;
+    uint8_t dev_id = bit_cut(offset, bus->bus_shift - 5, 5);
+    uint8_t fun_id = bit_cut(offset, bus->bus_shift - 8, 3);
+    uint8_t reg = bit_cut(offset, 0, bus->bus_shift - 8);
+    UNUSED(size);
+
+    pci_func_t* func = pci_get_func(bus, bus_id, dev_id, fun_id);
+    if (!func) {
+        // Nonexistent devices have all 0xFFFF in their conf space
+        write_uint32_le_m(data, 0xFFFFFFFF);
+        return true;
+    }
+
+    write_uint32_le_m(data, 0);
+    switch (reg) {
+        case PCI_REG_DEV_VEN_ID:
+            write_uint32_le_m(data, func->vendor_id | (uint32_t)func->device_id << 16);
+            break;
+        case PCI_REG_STATUS_CMD:
+            write_uint32_le_m(data, atomic_load_uint32(&func->status) << 16 | atomic_load_uint32(&func->command));
+            break;
+        case PCI_REG_CLASS_REV:
+            write_uint32_le_m(data, func->class_code << 16| (uint32_t)func->prog_if << 8 | func->rev);
+            break;
+        case PCI_REG_BIST_HDR_LATENCY_CACHE:
+            // Set (1 << 16) for PCI-PCI bridges (func->class_code == 0x0604)
+            write_uint32_le_m(data, 16);
+            break;
+        case PCI_REG_IRQ_PIN_LINE:
+            write_uint32_le_m(data, atomic_load_uint32(&func->irq_line) | ((uint32_t)func->irq_pin) << 8);
+            break;
+        case PCI_REG_BAR0:
+        case PCI_REG_BAR1:
+        case PCI_REG_BAR2:
+        case PCI_REG_BAR3:
+        case PCI_REG_BAR4:
+        case PCI_REG_BAR5: {
+            uint8_t bar_num = (reg - PCI_REG_BAR0) >> 2;
+            rvvm_mmio_dev_t* bar = func->bar[bar_num];
+            if (bar) {
+                write_uint32_le_m(data, bar->addr);
+            }
+            break;
+        }
+        case PCI_REG_SSID_SVID:
+            write_uint32_le_m(data, 0xeba110dc);
+            break;
+        case PCI_REG_EXPANSION_ROM: // Not needed for now, works as BAR
+        case PCI_REG_CAP_PTR:       // Currently no capabilities supported
+            break;
+    }
+
+    return true;
+}
+
+static bool pci_bus_write(rvvm_mmio_dev_t* mmio_dev, void* data, size_t offset, uint8_t size)
+{
+    pci_bus_t* bus = (pci_bus_t*)mmio_dev->data;
+    uint8_t bus_id = offset >> bus->bus_shift;
+    uint8_t dev_id = bit_cut(offset, bus->bus_shift - 5, 5);
+    uint8_t fun_id = bit_cut(offset, bus->bus_shift - 8, 3);
+    uint8_t reg = bit_cut(offset, 0, bus->bus_shift - 8);
+    UNUSED(size);
+
+    pci_func_t* func = pci_get_func(bus, bus_id, dev_id, fun_id);
+    if (!func) {
+        // No such device
+        return true;
+    }
+
+    switch (reg) {
+        case PCI_REG_STATUS_CMD:
+            atomic_store_uint32(&func->command, read_uint16_le_m(data));
+            break;
+        case PCI_REG_BAR0:
+        case PCI_REG_BAR1:
+        case PCI_REG_BAR2:
+        case PCI_REG_BAR3:
+        case PCI_REG_BAR4:
+        case PCI_REG_BAR5: {
+            uint8_t bar_num = (reg - PCI_REG_BAR0) >> 2;
+            rvvm_mmio_dev_t* bar = func->bar[bar_num];
+            if (bar) {
+                uint32_t addr = read_uint32_le_m(data) & ~(uint32_t)15;
+                if (~(uint32_t)0 - addr < bar->size) {
+                    addr = -bar->size;
+                }
+                // Should be atomic
+                bar->addr = addr;
+                atomic_fence();
+            }
+            break;
+        }
+        case PCI_REG_IRQ_PIN_LINE:
+            atomic_store_uint32(&func->irq_line, read_uint8(data));
+            break;
+        case PCI_REG_EXPANSION_ROM: // Not needed for now, works as BAR
+            break;
+    }
+
+    return true;
+}
+
+static void pci_free_dev(pci_dev_t* dev, bool remove_bar)
+{
+    if (dev == NULL) return;
+    for (size_t func_id = 0; func_id < PCI_DEV_FUNCS; ++func_id) {
+        pci_func_t* func = dev->func[func_id];
+        if (func && remove_bar) {
+            for (size_t bar_id = 0; bar_id < PCI_FUNC_BARS; ++bar_id) {
+                rvvm_remove_mmio(func->bar[bar_id]);
+            }
+        }
+        free(func);
+    }
+    dev->bus->dev[dev->dev_id] = NULL;
+    free(dev);
+}
+
+static void pci_bus_remove(rvvm_mmio_dev_t* mmio_dev)
+{
+    pci_bus_t* bus = mmio_dev->data;
+    for (size_t dev_id = 0; dev_id < PCI_BUS_DEVS; ++dev_id) {
+        pci_free_dev(bus->dev[dev_id], false);
+    }
+    free(bus);
+}
+
+static const rvvm_mmio_type_t pci_bus_type = {
+    .name = "pci_bus",
+    .remove = pci_bus_remove,
+};
+
+PUBLIC pci_bus_t* pci_bus_init(rvvm_machine_t* machine, plic_ctx_t* plic, uint32_t irq, bool ecam,
+                               rvvm_addr_t base_addr, size_t bus_count,
+                               rvvm_addr_t io_addr, size_t io_len,
+                               rvvm_addr_t mem_addr, size_t mem_len)
+{
+    size_t bus_shift = ecam ? 20 : 16;
+    pci_bus_t* bus = safe_new_obj(pci_bus_t);
+
+    bus->machine = machine;
+    bus->plic = plic;
+    for (size_t irq_pin = 0; irq_pin < PCI_BUS_IRQS; ++irq_pin) {
+        // Allocate INTX IRQs
+        bus->irq[irq_pin] = irq ? irq : plic_alloc_irq(plic);
+    }
+    bus->io_addr = io_addr;
+    bus->io_len = io_len;
+    bus->mem_addr = mem_addr;
+    bus->mem_len = mem_len;
+    bus->bus_id = 0;
+    bus->bus_shift = bus_shift;
+
+    rvvm_mmio_dev_t pci_bus_mmio = {
+        .addr = base_addr,
+        .size = (bus_count << bus_shift),
+        .data = bus,
+        .type = &pci_bus_type,
+        .read = pci_bus_read,
+        .write = pci_bus_write,
+        .min_op_size = 4,
+        .max_op_size = 4,
+    };
+
+    if (!rvvm_attach_mmio(machine, &pci_bus_mmio)) {
+        // Failed to attach the PCI bus
+        return NULL;
+    }
+
+    // Host Bridge: SiFive, Inc. FU740-C000 RISC-V SoC PCI Express x8
+    pci_dev_desc_t bridge_desc = { .func[0] = { .vendor_id = 0xF15E, .class_code = 0x0600 } };
+    pci_bus_add_device(bus, &bridge_desc);
+
+    rvvm_set_pci_bus(machine, bus);
+
+#ifdef USE_FDT
+    struct fdt_node* pci_node = fdt_node_create_reg("pci", base_addr);
+    fdt_node_add_prop_u32(pci_node, "#address-cells", 3);
+    fdt_node_add_prop_u32(pci_node, "#size-cells", 2);
+    fdt_node_add_prop_u32(pci_node, "#interrupt-cells", 1);
+    fdt_node_add_prop_str(pci_node, "device_type", "pci");
+    fdt_node_add_prop_reg(pci_node, "reg", base_addr, pci_bus_mmio.size);
+    fdt_node_add_prop_str(pci_node, "compatible", ecam ? "pci-host-ecam-generic" : "pci-host-cam-generic");
+    fdt_node_add_prop(pci_node, "dma-coherent", NULL, 0);
+
+    #define FDT_ADDR(addr) (((uint64_t)(addr)) >> 32), ((addr) & ~(uint32_t)0)
+
+    uint32_t bus_range[2] = { 0, bus_count - 1 };
+    fdt_node_add_prop_cells(pci_node, "bus-range", bus_range, 2);
+
+    // Range header: ((cacheable) << 30 | (space) << 24 | (bus) << 16 | (dev) << 11 | (fun) << 8 | (reg))
+    uint32_t ranges[14] = {
+        0x1000000, FDT_ADDR(0),        FDT_ADDR(io_addr),  FDT_ADDR(io_len),
+        0x2000000, FDT_ADDR(mem_addr), FDT_ADDR(mem_addr), FDT_ADDR(mem_len),
+    };
+    fdt_node_add_prop_cells(pci_node, "ranges", ranges + (io_len ? 0 : 7), io_len ? 14 : 7);
+
+    // Crossing-style IRQ routing for IRQ balancing
+    // INTA of dev 2 routes the same way as INTB of dev 1, etc
+    uint32_t plic_handle = plic_get_phandle(plic);
+    uint32_t interrupt_map[96] = {
+        0x0000, 0, 0, 1, plic_handle, bus->irq[0],
+        0x0000, 0, 0, 2, plic_handle, bus->irq[1],
+        0x0000, 0, 0, 3, plic_handle, bus->irq[2],
+        0x0000, 0, 0, 4, plic_handle, bus->irq[3],
+        0x0800, 0, 0, 1, plic_handle, bus->irq[1],
+        0x0800, 0, 0, 2, plic_handle, bus->irq[2],
+        0x0800, 0, 0, 3, plic_handle, bus->irq[3],
+        0x0800, 0, 0, 4, plic_handle, bus->irq[0],
+        0x1000, 0, 0, 1, plic_handle, bus->irq[2],
+        0x1000, 0, 0, 2, plic_handle, bus->irq[3],
+        0x1000, 0, 0, 3, plic_handle, bus->irq[0],
+        0x1000, 0, 0, 4, plic_handle, bus->irq[1],
+        0x1800, 0, 0, 1, plic_handle, bus->irq[3],
+        0x1800, 0, 0, 2, plic_handle, bus->irq[0],
+        0x1800, 0, 0, 3, plic_handle, bus->irq[2],
+        0x1800, 0, 0, 4, plic_handle, bus->irq[1],
+    };
+    fdt_node_add_prop_cells(pci_node, "interrupt-map", interrupt_map, 96);
+
+    uint32_t interrupt_mask[4] = { 0x1800, 0, 0, 7 };
+    fdt_node_add_prop_cells(pci_node, "interrupt-map-mask", interrupt_mask, 4);
+
+    fdt_node_add_child(rvvm_get_fdt_soc(machine), pci_node);
+#endif
+    return bus;
+}
+
+PUBLIC pci_bus_t* pci_bus_init_auto(rvvm_machine_t* machine)
+{
+    plic_ctx_t* plic = rvvm_get_plic(machine);
+    bool ecam = true;
+    size_t bus_count = 256; // TODO: Support more than 1 working bus
+    rvvm_addr_t addr = rvvm_mmio_zone_auto(machine, PCI_BASE_DEFAULT_MMIO, bus_count << (ecam ? 20 : 16));
+    return pci_bus_init(machine, plic, 0, ecam, addr, bus_count,
+                        PCI_IO_DEFAULT_ADDR, PCI_IO_DEFAULT_SIZE,
+                        PCI_MEM_DEFAULT_MMIO, PCI_MEM_DEFAULT_SIZE);
+}
+
+static inline size_t pci_func_irq_pin_id(pci_func_t* func)
+{
+    return (func->dev->dev_id + func->irq_pin + 3) & 3;
+}
+
+static pci_func_t* pci_init_func(pci_dev_t* dev, const pci_func_desc_t* func_desc)
+{
+    pci_bus_t* bus = dev->bus;
+    pci_func_t* func = safe_new_obj(pci_func_t);
+    func->dev = dev;
+    func->vendor_id  = func_desc->vendor_id;
+    func->device_id  = func_desc->device_id;
+    func->class_code = func_desc->class_code;
+    func->prog_if    = func_desc->prog_if;
+    func->rev        = func_desc->rev;
+    func->irq_pin    = func_desc->irq_pin;
+    func->command    = PCI_CMD_DEFAULT;
+    if (func->irq_pin) {
+        func->irq_line = bus->irq[pci_func_irq_pin_id(func)];
+    }
+
+    for (size_t bar_id = 0; bar_id < PCI_FUNC_BARS; ++bar_id) {
+        rvvm_mmio_dev_t bar = func_desc->bar[bar_id];
+        bar.size = align_size_up(bar.size, 16);
+        if (bar.size) {
+            // Align device BAR to it's size
+            bar.addr = bus->mem_addr + ((bar.size - bus->mem_addr) % bar.size);
+            bus->mem_len -= (bar.addr + bar.size) - bus->mem_addr;
+            bus->mem_addr = bar.addr + bar.size;
+
+            func->bar[bar_id] = rvvm_attach_mmio(bus->machine, &bar);
+            if (func->bar[bar_id] == NULL) {
+                // Failed to attach function BAR
+                free(func);
+                return NULL;
+            }
+        }
+    }
+
+    return func;
+}
+
+static void pci_free_desc(const pci_dev_desc_t* desc)
+{
+    for (size_t func_id = 0; func_id < PCI_DEV_FUNCS; ++func_id) {
+        const pci_func_desc_t* func_desc = &desc->func[func_id];
+        for (size_t bar_id = 0; bar_id < PCI_FUNC_BARS; ++bar_id) {
+            rvvm_cleanup_mmio_desc(&func_desc->bar[bar_id]);
+        }
+    }
+}
+
+PUBLIC pci_dev_t* pci_bus_add_device(pci_bus_t* bus, const pci_dev_desc_t* desc)
+{
+    if (bus == NULL) {
+        pci_free_desc(desc);
+        return NULL;
+    }
+
+    uint8_t dev_id = 0xFF;
+    for (size_t i = 0; i < PCI_BUS_DEVS; ++i) {
+        if (bus->dev[i] == NULL) {
+            dev_id = i;
+            break;
+        }
+    }
+    if (dev_id == 0xFF) {
+        rvvm_warn("Too much devices on a single PCI bus");
+        pci_free_desc(desc);
+        return NULL;
+    }
+
+    pci_dev_t* dev = safe_new_obj(pci_dev_t);
+    dev->bus = bus;
+    dev->dev_id = dev_id;
+
+    for (size_t func_id = 0; func_id < PCI_DEV_FUNCS; ++func_id) {
+        const pci_func_desc_t* func_desc = &desc->func[func_id];
+        if (func_desc->vendor_id != 0 || func_desc->device_id != 0) {
+            // Valid PCI function
+            pci_func_t* func = pci_init_func(dev, func_desc);
+            dev->func[func_id] = func;
+            if (!func) {
+                // Failed to attach function
+                pci_free_dev(dev, true);
+                return NULL;
+            }
+        }
+    }
+
+    // Pause the vCPUs and attach the device
+    bool was_running = rvvm_pause_machine(bus->machine);
+    bus->dev[dev->dev_id] = dev;
+    if (was_running) rvvm_start_machine(bus->machine);
+
+    return dev;
+}
+
+PUBLIC void pci_send_irq(pci_dev_t* dev, uint32_t func_id)
+{
+    if (dev == NULL || func_id >= PCI_DEV_FUNCS || dev->func[func_id] == NULL) {
+        return;
+    }
+    pci_func_t* func = dev->func[func_id];
+    pci_bus_t* bus = dev->bus;
+
+    // Check IRQs enabled
+    if (func->irq_pin && !(atomic_load_uint32(&func->command) & PCI_CMD_IRQ_DISABLE)) {
+        // Set interrupt status bit
+        atomic_or_uint32(&func->status, PCI_STATUS_IRQ);
+
+        // Send IRQ
+        uint32_t irq = bus->irq[pci_func_irq_pin_id(func)];
+        plic_send_irq(bus->plic, irq);
+    }
+}
+
+PUBLIC void pci_clear_irq(pci_dev_t* dev, uint32_t func_id)
+{
+    if (dev == NULL || func_id >= PCI_DEV_FUNCS || dev->func[func_id] == NULL) {
+        return;
+    }
+    pci_func_t* func = dev->func[func_id];
+
+    // Clear interrupt status bit
+    atomic_and_uint32(&func->status, ~PCI_STATUS_IRQ);
+}
+
+PUBLIC void* pci_get_dma_ptr(pci_dev_t* dev, rvvm_addr_t addr, size_t size)
+{
+    if (dev == NULL) return NULL;
+    return rvvm_get_dma_ptr(dev->bus->machine, addr, size);
+}
+
+PUBLIC void pci_remove_device(pci_dev_t* dev)
+{
+    if (dev == NULL) return;
+    pci_bus_t* bus = dev->bus;
+
+    // Pause the vCPUs and remove the device
+    bool was_running = rvvm_pause_machine(bus->machine);
+    pci_free_dev(dev, true);
+    if (was_running) rvvm_start_machine(bus->machine);
+}
diff --git a/app/src/main/java/libengine/RVVM/src/devices/pci-bus.h b/app/src/main/java/libengine/RVVM/src/devices/pci-bus.h
new file mode 100644
index 00000000..f6e2384b
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/pci-bus.h
@@ -0,0 +1,84 @@
+/*
+pci-bus.h - Peripheral Component Interconnect Bus
+Copyright (C) 2021  LekKit <github.com/LekKit>
+                    cerg2010cerg2010 <github.com/cerg2010cerg2010>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef PCI_BUS_H
+#define PCI_BUS_H
+
+#include "../rvvmlib.h"
+#include "plic.h"
+
+#define PCI_IRQ_PIN_INTA 1
+#define PCI_IRQ_PIN_INTB 2
+#define PCI_IRQ_PIN_INTC 3
+#define PCI_IRQ_PIN_INTD 4
+
+#define PCI_BUS_IRQS     4
+#define PCI_BUS_DEVS     32
+#define PCI_DEV_FUNCS    8
+#define PCI_FUNC_BARS    6
+
+// Pass in dev_desc->func[x].bar[y].addr to use 64-bit BAR
+#define PCI_BAR_ADDR_64  0x64646464
+
+// Default PCI bus settings
+#define PCI_BASE_DEFAULT_MMIO 0x30000000
+#define PCI_IO_DEFAULT_ADDR   0x03000000
+#define PCI_IO_DEFAULT_SIZE   0x00010000
+#define PCI_MEM_DEFAULT_MMIO  0x40000000
+#define PCI_MEM_DEFAULT_SIZE  0x40000000
+
+typedef struct {
+    uint16_t vendor_id;
+    uint16_t device_id;
+    uint16_t class_code;
+    uint8_t  prog_if;
+    uint8_t  rev;
+    uint8_t  irq_pin;
+    rvvm_mmio_dev_t bar[PCI_FUNC_BARS];
+} pci_func_desc_t;
+
+typedef struct {
+    pci_func_desc_t func[PCI_DEV_FUNCS];
+} pci_dev_desc_t;
+
+typedef struct pci_bus    pci_bus_t;
+typedef struct pci_device pci_dev_t;
+
+// Passing irq = 0 implies auto-allocation of 4 IRQ lanes
+PUBLIC pci_bus_t* pci_bus_init(rvvm_machine_t *machine, plic_ctx_t* plic,
+                               uint32_t irq, bool ecam,
+                               rvvm_addr_t base_addr, size_t bus_count,
+                               rvvm_addr_t io_addr, size_t io_len,
+                               rvvm_addr_t mem_addr, size_t mem_len);
+
+PUBLIC pci_bus_t* pci_bus_init_auto(rvvm_machine_t* machine);
+
+// Connect PCI device to the bus, use returned handle to send interrupts
+PUBLIC pci_dev_t* pci_bus_add_device(pci_bus_t* bus, const pci_dev_desc_t* desc);
+
+// Drives IRQ pin of the corresponding device function
+PUBLIC void       pci_send_irq(pci_dev_t* dev, uint32_t func_id);
+PUBLIC void       pci_clear_irq(pci_dev_t* dev, uint32_t func_id);
+
+// Directly access physical memory of the device bus host (returns non-NULL on success)
+PUBLIC void*      pci_get_dma_ptr(pci_dev_t* dev, rvvm_addr_t addr, size_t size);
+
+PUBLIC void       pci_remove_device(pci_dev_t* dev);
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/devices/pci-vfio.c b/app/src/main/java/libengine/RVVM/src/devices/pci-vfio.c
new file mode 100644
index 00000000..50c4f654
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/pci-vfio.c
@@ -0,0 +1,435 @@
+/*
+pci-vfio.c - VFIO PCI Passthrough
+Copyright (C) 2022  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+// Needed for pread()/pwrite()/readlink(), O_CLOEXEC when not passing -std=gnu..
+#define _GNU_SOURCE
+#define _BSD_SOURCE
+#define _DEFAULT_SOURCE
+
+#include "pci-vfio.h"
+#include "../compiler.h"
+#include "../threading.h"
+#include "../mem_ops.h"
+#include "../utils.h"
+
+// Check that <linux/vfio.h> include is available
+#if defined(__linux__) && defined(USE_VFIO) && !CHECK_INCLUDE(linux/vfio.h)
+#warning Disabling USE_VFIO as <linux/vfio.h> is unavailable
+#undef USE_VFIO
+#endif
+
+#if defined(__linux__) && defined(USE_VFIO)
+
+#include <string.h>
+#include <errno.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/types.h>
+#include <sys/eventfd.h>
+
+#include <linux/vfio.h>
+
+static size_t vfio_pci_sysfs_path(char* buffer, size_t size, const char* pci_id, const char* suffix)
+{
+    size_t len = rvvm_strlcpy(buffer, "/sys/bus/pci/devices/", size);
+    len += rvvm_strlcpy(buffer + len, pci_id, size - len);
+    return len + rvvm_strlcpy(buffer + len, suffix, size - len);
+}
+
+static size_t vfio_rw_file(const char* path, void* rdbuf, const void* wrbuf, size_t size)
+{
+    int fd = open(path, (rdbuf ? O_RDONLY : 0) | (wrbuf ? O_WRONLY : 0) | O_CLOEXEC);
+    size_t ret = fd >= 0;
+    if (wrbuf && ret) ret = (size_t)write(fd, wrbuf, size) == size;
+    if (rdbuf && ret) ret = read(fd, rdbuf, size);
+    if (fd >= 0) close(fd);
+    return ret;
+}
+
+static bool vfio_unbind_driver(const char* pci_id)
+{
+    char path[256] = {0};
+    vfio_pci_sysfs_path(path, sizeof(path), pci_id, "/driver/unbind");
+    return vfio_rw_file(path, NULL, pci_id, rvvm_strlen(pci_id));
+}
+
+static bool vfio_bind_vfio(const char* pci_id)
+{
+    char path[256] = {0};
+    char ven_dev[256] = {0};
+    vfio_pci_sysfs_path(path, sizeof(path), pci_id, "/vendor");
+    size_t len = vfio_rw_file(path, ven_dev, NULL, sizeof(ven_dev));
+    len += rvvm_strlcpy(ven_dev + len, " ", sizeof(ven_dev) - len);
+    vfio_pci_sysfs_path(path, sizeof(path), pci_id, "/device");
+    len += vfio_rw_file(path, ven_dev + len, NULL, sizeof(ven_dev) - len);
+    vfio_rw_file("/sys/bus/pci/drivers/vfio-pci/new_id", NULL, ven_dev, len);
+    return vfio_rw_file("/sys/bus/pci/drivers/vfio-pci/bind", NULL, pci_id, rvvm_strlen(pci_id));
+}
+
+static bool vfio_needs_rebind(const char* pci_id)
+{
+    char path[256] = {0};
+    char driver_path[256] = {0};
+    vfio_pci_sysfs_path(path, sizeof(path), pci_id, "/driver");
+    if (readlink(path, driver_path, sizeof(driver_path)) < 0) return true;
+    return !rvvm_strfind(driver_path, "vfio-pci");
+}
+
+static bool vfio_bind(const char* pci_id)
+{
+    if (vfio_needs_rebind(pci_id)) {
+        rvvm_info("Unbinding the device from it's original driver");
+        vfio_unbind_driver(pci_id);
+        vfio_bind_vfio(pci_id);
+    }
+    rvvm_info("Host PCI device %s should now be bound to vfio-pci", pci_id);
+    return !vfio_needs_rebind(pci_id);
+}
+
+static uint32_t vfio_get_iommu_group(const char* pci_id)
+{
+    char path[256] = {0};
+    char group_path[256] = {0};
+    vfio_pci_sysfs_path(path, sizeof(path), pci_id, "/iommu_group");
+    if (readlink(path, group_path, sizeof(group_path)) < 0) return -1;
+    const char* iommu_path = rvvm_strfind(group_path, "/kernel/iommu_groups/");
+    if (iommu_path) {
+        return str_to_int_dec(iommu_path + rvvm_strlen("/kernel/iommu_groups/"));
+    }
+    rvvm_error("Invalid VFIO IOMMU group path!");
+    return -1;
+}
+
+static int vfio_open_group(const char* pci_id)
+{
+    uint32_t group = vfio_get_iommu_group(pci_id);
+    char path[256] = "/dev/vfio/";
+    size_t len = rvvm_strlen(path);
+    int_to_str_dec(path + len, sizeof(path) - len, group);
+    int fd = open(path, O_RDWR | O_CLOEXEC);
+    return fd;
+}
+
+typedef struct {
+    pci_dev_desc_t pci_desc;
+    pci_dev_t*     pci_dev;
+    thread_ctx_t*  thread;
+    int container;
+    int group;
+    int device;
+    int eventfd;
+    bool running;
+} vfio_dev_t;
+
+static void vfio_unmask_irq(vfio_dev_t* vfio)
+{
+    struct vfio_irq_set irq_set = {
+        .argsz = sizeof(irq_set),
+        .flags = VFIO_IRQ_SET_DATA_NONE | VFIO_IRQ_SET_ACTION_UNMASK,
+        .index = VFIO_PCI_MSI_IRQ_INDEX,
+        .start = 0,
+        .count = 1,
+    };
+    ioctl(vfio->device, VFIO_DEVICE_SET_IRQS, &irq_set);
+}
+
+static void vfio_trigger_irq(vfio_dev_t* vfio)
+{
+    struct vfio_irq_set irq_set = {
+        .argsz = sizeof(irq_set),
+        .flags = VFIO_IRQ_SET_DATA_NONE | VFIO_IRQ_SET_ACTION_TRIGGER,
+        .index = VFIO_PCI_MSI_IRQ_INDEX,
+        .start = 0,
+        .count = 1,
+    };
+    if (vfio->device > 0) ioctl(vfio->device, VFIO_DEVICE_SET_IRQS, &irq_set);
+}
+
+static void* vfio_irq_thread(void* data)
+{
+    vfio_dev_t* vfio = data;
+    uint8_t buffer[8] = {0};
+    vfio_unmask_irq(vfio);
+    while (vfio->running) {
+        UNUSED(!read(vfio->eventfd, buffer, sizeof(buffer)));
+        pci_send_irq(vfio->pci_dev, 0);
+    }
+    return NULL;
+}
+
+static void vfio_bar_remove(rvvm_mmio_dev_t* dev)
+{
+    UNUSED(dev);
+}
+
+static rvvm_mmio_type_t vfio_bar_type = {
+    .name = "vfio_bar",
+    .remove = vfio_bar_remove,
+};
+
+static void vfio_dev_free(vfio_dev_t* vfio)
+{
+    for (size_t i=0; i<PCI_FUNC_BARS; ++i) {
+        void*  bar_ptr = vfio->pci_desc.func[0].bar[i].data;
+        size_t bar_size = vfio->pci_desc.func[0].bar[i].size;
+        if (bar_size) munmap(bar_ptr, bar_size);
+    }
+    vfio->running = false;
+    vfio_trigger_irq(vfio);
+    thread_join(vfio->thread);
+    if (vfio->eventfd > 0)   close(vfio->eventfd);
+    if (vfio->device > 0)    close(vfio->device);
+    if (vfio->group > 0)     close(vfio->group);
+    if (vfio->container > 0) close(vfio->container);
+    free(vfio);
+}
+
+static void vfio_dev_remove(rvvm_mmio_dev_t* dev)
+{
+    vfio_dev_t* vfio = dev->data;
+    vfio_dev_free(vfio);
+}
+
+static rvvm_mmio_type_t vfio_dev_type = {
+    .name = "vfio_pci_dev",
+    .remove = vfio_dev_remove,
+};
+
+static bool vfio_map_dma(vfio_dev_t* vfio, rvvm_machine_t* machine, rvvm_addr_t mem_base, size_t mem_size)
+{
+    struct vfio_iommu_type1_dma_map dma_map = {
+        .argsz = sizeof(struct vfio_iommu_type1_dma_map),
+        .flags = VFIO_DMA_MAP_FLAG_READ | VFIO_DMA_MAP_FLAG_WRITE,
+        .iova = mem_base,
+        .size = mem_size,
+        .vaddr = (size_t)rvvm_get_dma_ptr(machine, mem_base, mem_size),
+    };
+    return ioctl(vfio->container, VFIO_IOMMU_MAP_DMA, &dma_map) == 0;
+}
+
+static bool vfio_try_attach(vfio_dev_t* vfio, rvvm_machine_t* machine, const char* pci_id)
+{
+    vfio->container = open("/dev/vfio/vfio", O_RDWR | O_CLOEXEC);
+    if (vfio->container == -1) {
+        rvvm_error("Could not open /dev/vfio/vfio: %s", strerror(errno));
+        return false;
+    }
+    vfio->group = vfio_open_group(pci_id);
+    if (vfio->group == -1) {
+        rvvm_error("Failed to open VFIO group: %s", strerror(errno));
+        return false;
+    }
+    struct vfio_group_status group_status = { .argsz = sizeof(struct vfio_group_status), };
+    if (ioctl(vfio->group, VFIO_GROUP_GET_STATUS, &group_status) || !(group_status.flags & VFIO_GROUP_FLAGS_VIABLE)) {
+        rvvm_error("VFIO group not viable, are all group devices attached to vfio_pci module?");
+        return false;
+    }
+    if (ioctl(vfio->group, VFIO_GROUP_SET_CONTAINER, &vfio->container)) {
+        rvvm_error("Failed to set VFIO container group: %s", strerror(errno));
+        return false;
+    }
+    if (ioctl(vfio->container, VFIO_SET_IOMMU, VFIO_TYPE1_IOMMU)) {
+        rvvm_error("Failed to set up VFIO IOMMU: %s", strerror(errno));
+        return false;
+    }
+
+    // Set up DMA to guest RAM
+    rvvm_addr_t mem_base = rvvm_get_opt(machine, RVVM_OPT_MEM_BASE);
+    rvvm_addr_t mem_size = rvvm_get_opt(machine, RVVM_OPT_MEM_SIZE);
+    if (!vfio_map_dma(vfio, machine, mem_base, mem_size)) {
+        // This *kinda* works around a DMA conflict with x86 MSI IRQ vector reserved region
+        // More info: https://lore.kernel.org/linux-iommu/20191211082304.2d4fab45@x1.home/
+        // cat /sys/kernel/iommu_groups/[iommu group]/reserved_regions
+
+        // LAPIC MSI registers are usually placed on address 0xFEE00000, I/O APIC on address 0xFEС00000
+        const rvvm_addr_t msi_x86_low = 0xFEC00000;
+        const rvvm_addr_t msi_x86_end = 0xFEF00000;
+        rvvm_info("Workaround reserved x86 MSI IRQ vector by splitting DMA region");
+        if (mem_base < msi_x86_low) {
+            size_t low_size = EVAL_MIN(mem_size, msi_x86_low - mem_base);
+            if (!vfio_map_dma(vfio, machine, mem_base, low_size)) {
+                rvvm_error("Failed to set up VFIO DMA: %s", strerror(errno));
+                rvvm_error("This is likely caused by reserved mappings on your host overlapping guest RAM");
+                return false;
+            }
+        }
+        if (mem_base + mem_size > msi_x86_end) {
+            size_t high_size = (mem_base + mem_size) - msi_x86_end;
+            if (!vfio_map_dma(vfio, machine, msi_x86_end, high_size)) {
+                rvvm_error("Failed to set up VFIO DMA: %s", strerror(errno));
+                rvvm_error("This is likely caused by reserved mappings on your host overlapping guest RAM");
+                return false;
+            }
+        }
+    }
+
+    vfio->device = ioctl(vfio->group, VFIO_GROUP_GET_DEVICE_FD, pci_id);
+    if (vfio->device < 0) {
+        rvvm_error("Failed to get VFIO device fd: %s", strerror(errno));
+        return false;
+    }
+    struct vfio_device_info device_info = { .argsz = sizeof(struct vfio_device_info), };
+    if (ioctl(vfio->device, VFIO_DEVICE_GET_INFO, &device_info)) {
+        rvvm_error("Failed to get VFIO device info: %s", strerror(errno));
+        return false;
+    }
+
+    // Read PCI config space of the device
+    struct vfio_region_info pci_cfg_info = { .argsz = sizeof(struct vfio_region_info), .index = VFIO_PCI_CONFIG_REGION_INDEX, };
+    if (ioctl(vfio->device, VFIO_DEVICE_GET_REGION_INFO, &pci_cfg_info)) {
+        rvvm_error("Failed to get VFIO PCI config space info: %s", strerror(errno));
+        return false;
+    }
+    uint8_t pci_config[64];
+    if (pread(vfio->device, pci_config, 64, pci_cfg_info.offset) != 64) {
+        rvvm_error("Failed to read PCI config space: %s", strerror(errno));
+        return false;
+    }
+
+    vfio->pci_desc.func[0].vendor_id = read_uint16_le(pci_config);
+    vfio->pci_desc.func[0].device_id = read_uint16_le(pci_config + 0x2);
+    vfio->pci_desc.func[0].class_code = read_uint16_le(pci_config + 0xA);
+    vfio->pci_desc.func[0].prog_if = pci_config[0x9];
+    vfio->pci_desc.func[0].irq_pin = pci_config[0x3D];
+
+    // Enable interrupts, Bus-mastering, MMIO access, Write-inval
+    write_uint32_le(pci_config + 4, 0x16);
+    if (pwrite(vfio->device, pci_config + 4, 4, pci_cfg_info.offset + 4) != 4) {
+        rvvm_error("Failed to write PCI config space: %s", strerror(errno));
+        return false;
+    }
+
+    // Set up device BAR mappings
+    for (uint32_t i=0; i<device_info.num_regions && i<=VFIO_PCI_BAR5_REGION_INDEX; ++i) {
+        struct vfio_region_info region_info = { .argsz = sizeof(struct vfio_region_info), .index = i, };
+        if (ioctl(vfio->device, VFIO_DEVICE_GET_REGION_INFO, &region_info)) {
+            rvvm_error("Failed to get VFIO BAR info: %s", strerror(errno));
+            return false;
+        }
+        if (region_info.size && (region_info.flags & VFIO_REGION_INFO_FLAG_MMAP)) {
+            rvvm_info("VFIO PCI BAR %d: size 0x%lx, offset 0x%lx, flags 0x%x", i,
+                (unsigned long)region_info.size, (unsigned long)region_info.offset, (uint32_t)region_info.flags);
+            void* bar = mmap(NULL, region_info.size, PROT_READ | PROT_WRITE, MAP_SHARED, vfio->device, region_info.offset);
+            if (bar == MAP_FAILED) {
+                rvvm_error("VFIO BAR mmap() failed: %s", strerror(errno));
+                return false;
+            }
+            vfio->pci_desc.func[0].bar[i].mapping = bar;
+            vfio->pci_desc.func[0].bar[i].size = region_info.size;
+            vfio->pci_desc.func[0].bar[i].min_op_size = 1;
+            vfio->pci_desc.func[0].bar[i].max_op_size = 16;
+            vfio->pci_desc.func[0].bar[i].type = &vfio_bar_type;
+        }
+    }
+
+    // Check IRQ capabilities
+    if (device_info.num_irqs <= VFIO_PCI_MSI_IRQ_INDEX) {
+        rvvm_error("No support for VFIO INTx IRQ");
+        return false;
+    }
+    struct vfio_irq_info irq_info = { .argsz = sizeof(irq_info), .index = VFIO_PCI_MSI_IRQ_INDEX, };
+    if (ioctl(vfio->device, VFIO_DEVICE_GET_IRQ_INFO, &irq_info)) {
+        rvvm_error("Failed to get VFIO IRQ info: %s", strerror(errno));
+        return false;
+    }
+    if (!(irq_info.flags & VFIO_IRQ_INFO_EVENTFD)) {
+        rvvm_error("No support for VFIO IRQ eventfd");
+        return false;
+    }
+
+    // Set up device IRQs & IRQ eventfd
+    vfio->eventfd = eventfd(0, 0);
+    if (vfio->eventfd < 0) {
+        rvvm_error("Failed to create VFIO IRQ eventfd: %s", strerror(errno));
+        return false;
+    }
+    size_t irq_size = sizeof(struct vfio_irq_set) + sizeof(int);
+    struct vfio_irq_set* irq_set = safe_calloc(irq_size, 1);
+    irq_set->argsz = irq_size;
+    irq_set->flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_TRIGGER;
+    irq_set->index = VFIO_PCI_MSI_IRQ_INDEX;
+    irq_set->start = 0;
+    irq_set->count = 1;
+    *((int*)irq_set->data) = vfio->eventfd; // For MSI IRQs, this is an array of eventfds
+    if (ioctl(vfio->device, VFIO_DEVICE_SET_IRQS, irq_set)) {
+        rvvm_error("Failed to set VFIO IRQ eventfd: %s", strerror(errno));
+        free(irq_set);
+        return false;
+    }
+    free(irq_set);
+
+    // Graceful device reset, all OK
+    ioctl(vfio->device, VFIO_DEVICE_RESET);
+    return true;
+}
+
+PUBLIC bool pci_vfio_init_auto(rvvm_machine_t* machine, const char* pci_id)
+{
+    char long_pci_id[256] = "0000:";
+    if (rvvm_strlen(pci_id) < 12) {
+        // This is a shorthand pci id, like in lspci (00:01.0) - extend it to sysfs format
+        rvvm_strlcpy(long_pci_id + 5, pci_id, sizeof(long_pci_id) - 5);
+        pci_id = long_pci_id;
+    }
+
+    UNUSED(!system("modprobe vfio_pci")); // Just in case
+
+    if (vfio_bind(pci_id)) {
+        pci_bus_t* pci_bus = rvvm_get_pci_bus(machine);
+        vfio_dev_t* vfio = safe_new_obj(vfio_dev_t);
+        if (vfio_try_attach(vfio, machine, pci_id)) {
+            rvvm_mmio_dev_t vfio_dev_placeholder = {
+                .size = 0,
+                .type = &vfio_dev_type,
+                .data = vfio,
+                .read = rvvm_mmio_none,
+                .write = rvvm_mmio_none,
+            };
+            rvvm_mmio_dev_t* placeholder = rvvm_attach_mmio(machine, &vfio_dev_placeholder);
+            if (placeholder != NULL) {
+                vfio->pci_dev = pci_bus_add_device(pci_bus, &vfio->pci_desc);
+                if (vfio->pci_dev) {
+                    vfio->running = true;
+                    vfio->thread = thread_create(vfio_irq_thread, vfio);
+                    return true;
+                } else {
+                    // Failed to attach to guest PCI bus
+                    rvvm_remove_mmio(placeholder);
+                }
+            }
+        } else {
+            // Failed to attach to the host VFIO device
+            vfio_dev_free(vfio);
+        }
+    } else rvvm_error("Can't bind PCI device to vfio_pci kernel module");
+
+    return false;
+}
+
+#else
+
+PUBLIC bool pci_vfio_init_auto(rvvm_machine_t* machine, const char* pci_id)
+{
+    rvvm_error("VFIO isn't available");
+    UNUSED(machine); UNUSED(pci_id);
+    return false;
+}
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/devices/pci-vfio.h b/app/src/main/java/libengine/RVVM/src/devices/pci-vfio.h
new file mode 100644
index 00000000..2e15d82e
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/pci-vfio.h
@@ -0,0 +1,26 @@
+/*
+pci-vfio.h - VFIO PCI Passthrough
+Copyright (C) 2022  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef RVVM_PCI_VFIO_H
+#define RVVM_PCI_VFIO_H
+
+#include "pci-bus.h"
+
+PUBLIC bool pci_vfio_init_auto(rvvm_machine_t* machine, const char* pci_id);
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/devices/plic.c b/app/src/main/java/libengine/RVVM/src/devices/plic.c
new file mode 100644
index 00000000..d26436a2
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/plic.c
@@ -0,0 +1,466 @@
+/*
+plic.c - Platform-Level Interrupt Controller
+Copyright (C) 2023  LekKit <github.com/LekKit>
+              2021  cerg2010cerg2010 <github.com/cerg2010cerg2010>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "plic.h"
+#include "../riscv_hart.h"
+#include "../bit_ops.h"
+#include "../mem_ops.h"
+#include "../atomics.h"
+
+#define PLIC_CTXFLAG_THRESHOLD     0x0
+#define PLIC_CTXFLAG_CLAIMCOMPLETE 0x1
+
+#define PLIC_SOURCE_MAX 64 // Max 1024
+
+#define PLIC_SRC_REG_COUNT ((PLIC_SOURCE_MAX + 0x1F) >> 5)
+
+#define CTX_HARTID(ctx) ((ctx) >> 1)
+
+// In QEMU, those are reversed for whatever reason, but on most actual
+// boards it's done this way. Should we ever do 1:1 QEMU compat, swap those...
+#define CTX_IRQ_PRIO(ctx) (((ctx) & 1) ? INTERRUPT_SEXTERNAL : INTERRUPT_MEXTERNAL)
+
+struct plic {
+    rvvm_machine_t* machine;
+    uint32_t alloc_irq;
+    uint32_t phandle;
+    uint32_t prio[PLIC_SOURCE_MAX];
+    uint32_t pending[PLIC_SRC_REG_COUNT];
+    uint32_t raised[PLIC_SRC_REG_COUNT];
+    uint32_t** enable;    // [CTX][SRC_REG]
+    uint32_t*  threshold; // [CTX]
+};
+
+static inline uint32_t plic_ctx_count(plic_ctx_t* plic)
+{
+    return vector_size(plic->machine->harts) << 1;
+}
+
+// Check if the IRQ is pending
+static inline bool plic_irq_pending(plic_ctx_t* plic, uint32_t irq)
+{
+    return bit_check(atomic_load_uint32(&plic->pending[irq >> 5]), irq & 0x1F);
+}
+
+// Check if the IRQ is enabled for specific CTX
+static inline bool plic_irq_enabled(plic_ctx_t* plic, uint32_t ctx, uint32_t irq)
+{
+    return bit_check(atomic_load_uint32(&plic->enable[ctx][irq >> 5]), irq & 0x1F);
+}
+
+// Notify specific CTX about inbound IRQ
+static bool plic_notify_ctx_irq(plic_ctx_t* plic, uint32_t ctx, uint32_t irq)
+{
+    // Can we deliver this IRQ to this CTX?
+    if (!plic_irq_enabled(plic, ctx, irq)) return false;
+
+    if (atomic_load_uint32(&plic->prio[irq]) <= atomic_load_uint32(&plic->threshold[ctx])) {
+        // This IRQ priority isn't high enough
+        return false;
+    }
+
+    riscv_interrupt(vector_at(plic->machine->harts, CTX_HARTID(ctx)), CTX_IRQ_PRIO(ctx));
+    return true;
+}
+
+// Notify any hart responsible for this IRQ
+static void plic_notify_irq(plic_ctx_t* plic, uint32_t irq)
+{
+    for (size_t ctx=0; ctx<plic_ctx_count(plic); ++ctx) {
+        if (plic_notify_ctx_irq(plic, ctx, irq)) return;
+    }
+}
+
+// Update on IRQ prio change
+static void plic_update_irq(plic_ctx_t* plic, uint32_t irq)
+{
+    if (plic_irq_pending(plic, irq)) {
+        plic_notify_irq(plic, irq);
+    }
+}
+
+// Update on changes to IRQ enable register of CTX
+static void plic_update_ctx_irq_reg(plic_ctx_t* plic, uint32_t ctx, uint32_t reg)
+{
+    uint32_t irqs = atomic_load_uint32(&plic->pending[reg]) & atomic_load_uint32(&plic->enable[ctx][reg]);
+    if (irqs) {
+        for (size_t i=0; i<32; ++i) {
+            plic_update_irq(plic, (reg << 5) | i);
+        }
+    }
+}
+
+// Update a CTX (Also used for IRQ claim process)
+static uint32_t plic_update_ctx(plic_ctx_t* plic, uint32_t ctx, bool claim)
+{
+    uint32_t threshold = atomic_load_uint32(&plic->threshold[ctx]);
+    uint32_t notifying_irqs = 0;
+    uint32_t highest_prio_irq = 0;
+    uint32_t max_prio = 0;
+
+    riscv_interrupt_clear(vector_at(plic->machine->harts, CTX_HARTID(ctx)), CTX_IRQ_PRIO(ctx));
+
+    for (size_t i=0; i<PLIC_SRC_REG_COUNT; ++i) {
+        uint32_t irqs = atomic_load_uint32(&plic->pending[i]) & atomic_load_uint32(&plic->enable[ctx][i]);
+        if (irqs) {
+            for (size_t j=0; j<32; ++j) {
+                if (bit_check(irqs, j)) {
+                    uint32_t irq = (i << 5) | j;
+                    uint32_t prio = atomic_load_uint32(&plic->prio[irq]);
+                    if (prio > threshold) {
+                        // Count IRQs above CTX threshold
+                        notifying_irqs++;
+                    }
+                    if (prio > max_prio) {
+                        // Determine highest priority IRQ
+                        max_prio = prio;
+                        highest_prio_irq = irq;
+                    }
+                }
+            }
+        }
+    }
+
+    if (claim && max_prio > threshold) {
+        // Don't count the to-be-claimed IRQ as notifying
+        notifying_irqs--;
+    }
+
+    if (notifying_irqs) {
+        riscv_interrupt(vector_at(plic->machine->harts, CTX_HARTID(ctx)), CTX_IRQ_PRIO(ctx));
+    }
+
+    return highest_prio_irq;
+}
+
+/*
+ * Update PLIC state entirely
+ * Use after any operation that potentially causes an IRQ cease to signal
+ *
+ * Efforts are made so that this function is called in very rare cases,
+ * and usually it is replaced by a partial update for performance
+ */
+static void plic_full_update(plic_ctx_t* plic)
+{
+    for (size_t ctx=0; ctx<plic_ctx_count(plic); ++ctx) {
+        plic_update_ctx(plic, ctx, false);
+    }
+}
+
+static void plic_set_irq_prio(plic_ctx_t* plic, uint32_t irq, uint32_t prio)
+{
+    uint32_t old_prio = atomic_swap_uint32(&plic->prio[irq], prio);
+    if (prio < old_prio) {
+        if (plic_irq_pending(plic, irq)) {
+            // Pending IRQ priority was lowered - do a full PLIC state update
+            plic_full_update(plic);
+        }
+    } else if (prio > old_prio) {
+        // IRQ priority was raised - do a partial check
+        plic_update_irq(plic, irq);
+    }
+}
+
+static void plic_set_enable_bits(plic_ctx_t* plic, uint32_t ctx, uint32_t reg, uint32_t enable)
+{
+    uint32_t old_enable = atomic_swap_uint32(&plic->enable[ctx][reg], enable);
+    uint32_t irqs_disabled = old_enable & ~enable;
+    if (irqs_disabled) {
+        if (irqs_disabled & atomic_load_uint32(&plic->pending[reg])) {
+            // Some pending IRQs were disabled - do a full PLIC state update
+            plic_full_update(plic);
+        }
+    } else if (enable & ~old_enable) {
+        // Some IRQs were enabled - do a partial check
+        plic_update_ctx_irq_reg(plic, ctx, reg);
+    }
+}
+
+static void plic_set_ctx_threshold(plic_ctx_t* plic, uint32_t ctx, uint32_t threshold)
+{
+    uint32_t old_threshold = atomic_swap_uint32(&plic->threshold[ctx], threshold);
+    if (old_threshold != threshold) {
+        // CTX threshold changed - do a CTX update
+        plic_update_ctx(plic, ctx, false);
+    }
+}
+
+static uint32_t plic_claim_irq(plic_ctx_t* plic, uint32_t ctx)
+{
+    while (true) {
+        uint32_t irq = plic_update_ctx(plic, ctx, true);
+        if (irq) {
+            uint32_t mask = 1U << (irq & 0x1F);
+            if (!(atomic_and_uint32(&plic->pending[irq >> 5], ~mask) & mask)) {
+                // Someone stole our IRQ in the meantime, retry
+                continue;
+            }
+        }
+        return irq;
+    }
+}
+
+static void plic_complete_irq(plic_ctx_t* plic, uint32_t ctx, uint32_t irq)
+{
+    uint32_t raised = atomic_load_uint32(&plic->raised[irq >> 5]) & (1U << (irq & 0x1F));
+    if (raised) {
+        // Rearm raised interrupt as pending after completion
+        atomic_or_uint32(&plic->pending[irq >> 5], raised);
+        plic_notify_ctx_irq(plic, ctx, irq);
+    }
+}
+
+static bool plic_mmio_read(rvvm_mmio_dev_t* dev, void* data, size_t offset, uint8_t size)
+{
+    plic_ctx_t* plic = dev->data;
+    memset(data, 0, size);
+
+    if (offset < 0x1000) {
+        // Interrupt priority
+        uint32_t irq = offset >> 2;
+        if (irq > 0 && irq < PLIC_SOURCE_MAX) {
+            write_uint32_le(data, atomic_load_uint32(&plic->prio[irq]));
+        }
+    } else if (offset < 0x1080) {
+        // Interrupt pending
+        uint32_t reg = (offset - 0x1000) >> 2;
+        if (reg < PLIC_SRC_REG_COUNT) {
+            write_uint32_le(data, atomic_load_uint32(&plic->pending[reg]));
+        }
+    } else if (offset < 0x2000) {
+        // Reserved, ignore
+    } else if (offset < 0x1F2000) {
+        // Enable bits
+        uint32_t reg = ((offset - 0x2000) >> 2) & 0x1F;
+        uint32_t ctx = (offset - 0x2000) >> 7;
+        if (reg < PLIC_SRC_REG_COUNT && ctx < plic_ctx_count(plic)) {
+            write_uint32_le(data, atomic_load_uint32(&plic->enable[ctx][reg]));
+        }
+    } else if (offset < 0x200000) {
+        // Reserved, ignore
+    } else if (offset < 0x4000000) {
+        // Context flags - threshold and claim/complete
+        uint32_t flag = ((offset - 0x200000) >> 2) & 0x3FF;
+        uint32_t ctx = (offset - 0x200000) >> 12;
+        if (ctx < plic_ctx_count(plic)) {
+            if (flag == PLIC_CTXFLAG_CLAIMCOMPLETE) {
+                write_uint32_le(data, plic_claim_irq(plic, ctx));
+            } else if (flag == PLIC_CTXFLAG_THRESHOLD) {
+                write_uint32_le(data, atomic_load_uint32(&plic->threshold[ctx]));
+            }
+        }
+    }
+    return true;
+}
+
+static bool plic_mmio_write(rvvm_mmio_dev_t* dev, void* data, size_t offset, uint8_t size)
+{
+    plic_ctx_t* plic = dev->data;
+    UNUSED(size);
+
+    if (offset < 0x1000) {
+        // Interrupt priority
+        uint32_t irq = offset >> 2;
+        if (irq > 0 && irq < PLIC_SOURCE_MAX) {
+            plic_set_irq_prio(plic, irq, read_uint32_le_m(data));
+        }
+    } else if (offset < 0x1080) {
+        // R/O, do nothing. Pending bits are cleared by reading CLAIMCOMPLETE register
+    } else if (offset < 0x2000) {
+        // Reserved, ignore
+    } else if (offset < 0x1f2000) {
+        // Enable bits
+        uint32_t reg = ((offset - 0x2000) >> 2) & 0x1F;
+        uint32_t ctx = (offset - 0x2000) >> 7;
+        if (reg < PLIC_SRC_REG_COUNT && ctx < plic_ctx_count(plic)) {
+            plic_set_enable_bits(plic, ctx, reg, read_uint32_le_m(data));
+        }
+    } else if (offset < 0x200000) {
+        // Reserved, ignore
+    } else if (offset < 0x4000000) {
+        // Context flags - threshold and claim/complete
+        uint32_t flag = ((offset - 0x200000) >> 2) & 0x3FF;
+        uint32_t ctx = (offset - 0x200000) >> 12;
+        if (ctx < plic_ctx_count(plic)) {
+            if (flag == PLIC_CTXFLAG_CLAIMCOMPLETE) {
+                plic_complete_irq(plic, ctx, read_uint32_le_m(data));
+            } else if (flag == PLIC_CTXFLAG_THRESHOLD) {
+                plic_set_ctx_threshold(plic, ctx, read_uint32_le_m(data));
+            }
+        }
+    }
+
+    return true;
+}
+
+static void plic_remove(rvvm_mmio_dev_t* dev)
+{
+    plic_ctx_t* plic = dev->data;
+
+    for (size_t ctx=0; ctx<plic_ctx_count(plic); ++ctx){
+        free(plic->enable[ctx]);
+    }
+    free(plic->enable);
+    free(plic->threshold);
+    free(plic);
+}
+
+static void plic_reset(rvvm_mmio_dev_t* dev)
+{
+    plic_ctx_t* plic = dev->data;
+
+    for (size_t ctx=0; ctx<plic_ctx_count(plic); ++ctx){
+        riscv_interrupt_clear(vector_at(plic->machine->harts, CTX_HARTID(ctx)), CTX_IRQ_PRIO(ctx));
+        memset(plic->enable[ctx], 0, PLIC_SRC_REG_COUNT << 2);
+    }
+    memset(plic->prio, 0, sizeof(plic->prio));
+    memset(plic->pending, 0, sizeof(plic->pending));
+    memset(plic->raised, 0, sizeof(plic->raised));
+    memset(plic->threshold, 0, plic_ctx_count(plic) << 2);
+}
+
+static rvvm_mmio_type_t plic_dev_type = {
+    .name = "plic",
+    .remove = plic_remove,
+    .reset = plic_reset,
+};
+
+// Create PLIC device
+PUBLIC plic_ctx_t* plic_init(rvvm_machine_t* machine, rvvm_addr_t base_addr)
+{
+    plic_ctx_t* plic = safe_new_obj(plic_ctx_t);
+    plic->machine = machine;
+    plic->enable = safe_new_arr(uint32_t*, plic_ctx_count(plic));
+    for (size_t ctx=0; ctx<plic_ctx_count(plic); ++ctx){
+        plic->enable[ctx] = safe_new_arr(uint32_t, PLIC_SRC_REG_COUNT);
+    }
+    plic->threshold = safe_new_arr(uint32_t, plic_ctx_count(plic));
+
+    rvvm_mmio_dev_t plic_mmio = {
+        .addr = base_addr,
+        .size = 0x4000000,
+        .min_op_size = 4,
+        .max_op_size = 4,
+        .read = plic_mmio_read,
+        .write = plic_mmio_write,
+        .data = plic,
+        .type = &plic_dev_type,
+    };
+    if (!rvvm_attach_mmio(machine, &plic_mmio)) {
+        // Failed to attach PLIC
+        return NULL;
+    }
+
+    rvvm_set_plic(machine, plic);
+
+#ifdef USE_FDT
+    struct fdt_node* cpus = fdt_node_find(rvvm_get_fdt_root(machine), "cpus");
+    if (cpus == NULL) {
+        rvvm_warn("Missing /cpus node in FDT!");
+        return plic;
+    }
+
+    uint32_t* irq_ext = safe_new_arr(uint32_t, vector_size(machine->harts) * 4);
+    vector_foreach(machine->harts, i) {
+        struct fdt_node* cpu = fdt_node_find_reg(cpus, "cpu", i);
+        struct fdt_node* cpu_irq = fdt_node_find(cpu, "interrupt-controller");
+
+        uint32_t irq_phandle = fdt_node_get_phandle(cpu_irq);
+        irq_ext[(i * 4)] = irq_ext[(i * 4) + 2] = irq_phandle;
+        irq_ext[(i * 4) + 1] = CTX_IRQ_PRIO(0);
+        irq_ext[(i * 4) + 3] = CTX_IRQ_PRIO(1);
+    }
+
+    struct fdt_node* plic_node = fdt_node_create_reg("plic", base_addr);
+    fdt_node_add_prop_u32(plic_node, "#address-cells", 0);
+    fdt_node_add_prop_u32(plic_node, "#interrupt-cells", 1);
+    fdt_node_add_prop_reg(plic_node, "reg", base_addr, 0x4000000);
+    fdt_node_add_prop_str(plic_node, "compatible", "sifive,plic-1.0.0");
+    fdt_node_add_prop_u32(plic_node, "riscv,ndev", PLIC_SOURCE_MAX - 1);
+    fdt_node_add_prop(plic_node, "interrupt-controller", NULL, 0);
+    fdt_node_add_prop_cells(plic_node, "interrupts-extended", irq_ext, vector_size(machine->harts) * 4);
+    free(irq_ext);
+
+    fdt_node_add_child(rvvm_get_fdt_soc(machine), plic_node);
+
+    plic->phandle = fdt_node_get_phandle(plic_node);
+#endif
+    return plic;
+}
+
+PUBLIC plic_ctx_t* plic_init_auto(rvvm_machine_t* machine)
+{
+    rvvm_addr_t addr = rvvm_mmio_zone_auto(machine, PLIC_DEFAULT_MMIO, 0x4000000);
+    return plic_init(machine, addr);
+}
+
+// Allocate new IRQ
+PUBLIC uint32_t plic_alloc_irq(plic_ctx_t* plic)
+{
+    if (plic == NULL) return 0;
+    uint32_t irq = atomic_add_uint32(&plic->alloc_irq, 1) + 1;
+    if (irq >= PLIC_SOURCE_MAX) {
+        rvvm_warn("Ran out of PLIC interrupt IDs");
+        irq = 0;
+    }
+    return irq;
+}
+
+// Get FDT phandle of the PLIC
+PUBLIC uint32_t plic_get_phandle(plic_ctx_t* plic)
+{
+    if (plic == NULL) return 0;
+    return plic->phandle;
+}
+
+// Send IRQ through PLIC
+PUBLIC bool plic_send_irq(plic_ctx_t* plic, uint32_t irq)
+{
+    if (plic == NULL || irq == 0 || irq >= PLIC_SOURCE_MAX) {
+        return false;
+    }
+    // Mark the IRQ pending
+    uint32_t mask = 1U << (irq & 0x1F);
+    if (!(atomic_or_uint32(&plic->pending[irq >> 5], mask) & mask)) {
+        plic_notify_irq(plic, irq);
+    }
+    return true;
+}
+
+// Assert IRQ line level
+PUBLIC bool plic_raise_irq(plic_ctx_t* plic, uint32_t irq)
+{
+    if (plic == NULL || irq == 0 || irq >= PLIC_SOURCE_MAX) {
+        return false;
+    }
+    uint32_t mask = 1U << (irq & 0x1F);
+    if (!(atomic_or_uint32(&plic->raised[irq >> 5], mask) & mask)) {
+        plic_send_irq(plic, irq);
+    }
+    return true;
+}
+
+PUBLIC bool plic_lower_irq(plic_ctx_t* plic, uint32_t irq)
+{
+    if (plic == NULL || irq == 0 || irq >= PLIC_SOURCE_MAX) {
+        return false;
+    }
+    atomic_and_uint32(&plic->raised[irq >> 5], ~(1U << (irq & 0x1F)));
+    return true;
+}
diff --git a/app/src/main/java/libengine/RVVM/src/devices/plic.h b/app/src/main/java/libengine/RVVM/src/devices/plic.h
new file mode 100644
index 00000000..8fc2f6a2
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/plic.h
@@ -0,0 +1,43 @@
+/*
+plic.h - Platform-Level Interrupt Controller
+Copyright (C) 2023  LekKit <github.com/LekKit>
+              2021  cerg2010cerg2010 <github.com/cerg2010cerg2010>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef RVVM_PLIC_H
+#define RVVM_PLIC_H
+
+#include "../rvvmlib.h"
+
+#define PLIC_DEFAULT_MMIO 0xC000000
+
+PUBLIC plic_ctx_t* plic_init(rvvm_machine_t* machine, rvvm_addr_t base_addr);
+PUBLIC plic_ctx_t* plic_init_auto(rvvm_machine_t* machine);
+
+// Allocate new IRQ
+PUBLIC uint32_t plic_alloc_irq(plic_ctx_t* plic);
+
+// Get FDT phandle of the PLIC
+PUBLIC uint32_t plic_get_phandle(plic_ctx_t* plic);
+
+// Send IRQ through PLIC
+PUBLIC bool plic_send_irq(plic_ctx_t* plic, uint32_t irq);
+
+// Assert IRQ line level
+PUBLIC bool plic_raise_irq(plic_ctx_t* plic, uint32_t irq);
+PUBLIC bool plic_lower_irq(plic_ctx_t* plic, uint32_t irq);
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/devices/ps2-altera.c b/app/src/main/java/libengine/RVVM/src/devices/ps2-altera.c
new file mode 100644
index 00000000..ad6ad8cd
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/ps2-altera.c
@@ -0,0 +1,143 @@
+/*
+ps2-altera.c - Altera PS2 Controller
+Copyright (C) 2021  cerg2010cerg2010 <github.com/cerg2010cerg2010>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "ps2-altera.h"
+#include "../mem_ops.h"
+#include "../atomics.h"
+#include "../utils.h"
+#include "../fdtlib.h"
+
+#define ALTERA_REG_DATA 0x0
+#define ALTERA_REG_CTRL 0x4
+
+#define ALTERA_CTRL_RE 0x1   // IRQ Enabled
+#define ALTERA_CTRL_RI 0x100 // IRQ Pending
+#define ALTERA_CTRL_CE 0x400 // Controller Error
+
+#define ALTERA_DATA_RVALID 0x8000
+
+typedef struct {
+    chardev_t* chardev;
+
+    // IRQ data
+    plic_ctx_t* plic;
+    uint32_t irq;
+
+    // Controller registers
+    uint32_t ctrl;
+} altps2_dev_t;
+
+static void altps2_notify(void* io_dev, uint32_t flags)
+{
+    altps2_dev_t* ps2port = io_dev;
+    if ((flags & CHARDEV_RX)
+     && (atomic_or_uint32(&ps2port->ctrl, ALTERA_CTRL_RI) & ALTERA_CTRL_RE))  {
+        plic_send_irq(ps2port->plic, ps2port->irq);
+    }
+}
+
+static bool altps2_mmio_read(rvvm_mmio_dev_t* dev, void* data, size_t offset, uint8_t size)
+{
+    altps2_dev_t* ps2port = dev->data;
+    memset(data, 0, size);
+    switch (offset) {
+        case ALTERA_REG_DATA: {
+            uint8_t val = 0;
+            uint32_t avail = chardev_read(ps2port->chardev, &val, 1);
+            write_uint32_le(data, val | (avail ? ALTERA_DATA_RVALID : 0) | (avail << 16));
+            break;
+        }
+        case ALTERA_REG_CTRL:
+            write_uint32_le(data, atomic_load_uint32(&ps2port->ctrl));
+            break;
+    }
+    return true;
+}
+
+static bool altps2_mmio_write(rvvm_mmio_dev_t* dev, void* data, size_t offset, uint8_t size)
+{
+    altps2_dev_t* ps2port = dev->data;
+    uint32_t reg = read_uint32_le(data);
+    UNUSED(size);
+    switch (offset) {
+        case ALTERA_REG_DATA: {
+                uint8_t val = reg & 0xFF;
+                if (!chardev_write(ps2port->chardev, &val, 1)) {
+                    atomic_or_uint32(&ps2port->ctrl, ALTERA_CTRL_CE);
+                }
+            }
+            break;
+        case ALTERA_REG_CTRL:
+            atomic_or_uint32(&ps2port->ctrl, reg & ALTERA_CTRL_RE);
+            atomic_and_uint32(&ps2port->ctrl, ALTERA_CTRL_RI | (reg & (ALTERA_CTRL_RE | ALTERA_CTRL_CE)));
+            break;
+    }
+    return true;
+}
+
+static void altps2_update(rvvm_mmio_dev_t* dev)
+{
+    altps2_dev_t* ps2port = dev->data;
+    chardev_update(ps2port->chardev);
+}
+
+static void altps2_remove(rvvm_mmio_dev_t* dev)
+{
+    altps2_dev_t* ps2port = dev->data;
+    chardev_free(ps2port->chardev);
+    free(ps2port);
+}
+
+static rvvm_mmio_type_t altps2_dev_type = {
+    .name = "altera_ps2",
+    .update = altps2_update,
+    .remove = altps2_remove,
+};
+
+void altps2_init(rvvm_machine_t* machine, rvvm_addr_t base_addr, plic_ctx_t* plic, uint32_t irq, chardev_t* chardev)
+{
+    altps2_dev_t* ps2port = safe_new_obj(altps2_dev_t);
+    ps2port->chardev = chardev;
+    ps2port->plic = plic;
+    ps2port->irq = irq;
+
+    if (chardev) {
+        chardev->io_dev = ps2port;
+        chardev->notify = altps2_notify;
+    }
+
+    rvvm_mmio_dev_t altps2_mmio = {
+        .min_op_size = 4,
+        .max_op_size = 4,
+        .read = altps2_mmio_read,
+        .write = altps2_mmio_write,
+        .type = &altps2_dev_type,
+        .addr = base_addr,
+        .size = ALTPS2_MMIO_SIZE,
+        .data = ps2port,
+    };
+    rvvm_attach_mmio(machine, &altps2_mmio);
+#ifdef USE_FDT
+    struct fdt_node* ps2 = fdt_node_create_reg("ps2", base_addr);
+    fdt_node_add_prop_reg(ps2, "reg", base_addr, ALTPS2_MMIO_SIZE);
+    fdt_node_add_prop_str(ps2, "compatible", "altr,ps2-1.0");
+    fdt_node_add_prop_u32(ps2, "interrupt-parent", plic_get_phandle(plic));
+    fdt_node_add_prop_u32(ps2, "interrupts", irq);
+    fdt_node_add_child(rvvm_get_fdt_soc(machine), ps2);
+#endif
+}
diff --git a/app/src/main/java/libengine/RVVM/src/devices/ps2-altera.h b/app/src/main/java/libengine/RVVM/src/devices/ps2-altera.h
new file mode 100644
index 00000000..eaba76fd
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/ps2-altera.h
@@ -0,0 +1,30 @@
+/*
+ps2-altera.h - Altera PS2 Controller
+Copyright (C) 2021  cerg2010cerg2010 <github.com/cerg2010cerg2010>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef PS2_ALTERA_H
+#define PS2_ALTERA_H
+
+#include "../rvvmlib.h"
+#include "plic.h"
+#include "chardev.h"
+
+#define ALTPS2_MMIO_SIZE 0x8
+
+void altps2_init(rvvm_machine_t* machine, rvvm_addr_t base_addr, plic_ctx_t* plic, uint32_t irq, chardev_t* chardev);
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/devices/ps2-keyboard.c b/app/src/main/java/libengine/RVVM/src/devices/ps2-keyboard.c
new file mode 100644
index 00000000..0883b95d
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/ps2-keyboard.c
@@ -0,0 +1,484 @@
+/*
+ps2-keyboard.c - PS2 Keyboard
+Copyright (C) 2021  LekKit <github.com/LekKit>
+                    cerg2010cerg2010 <github.com/cerg2010cerg2010>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "ps2-altera.h"
+#include "hid_api.h"
+#include "../ringbuf.h"
+#include "../rvtimer.h"
+#include "../spinlock.h"
+#include "../mem_ops.h"
+#include "../utils.h"
+
+#define PS2_CMD_RESET 0xFF
+#define PS2_CMD_RESEND 0xFE
+#define PS2_CMD_SET_DEFAULTS 0xF6
+#define PS2_CMD_DISABLE_DATA_REPORTING 0xF5
+#define PS2_CMD_ENABLE_DATA_REPORTING 0xF4
+#define PS2_CMD_SET_SAMPLE_RATE 0xF3
+#define PS2_CMD_GET_DEV_ID 0xF2
+#define PS2_CMD_SET_SCAN_CODE_SET 0xF0
+#define PS2_CMD_ECHO 0xEE
+#define PS2_CMD_LEDS 0xED
+
+#define PS2_RSP_ACK 0xFA
+#define PS2_RSP_NAK 0xFE
+
+#define PS2_STATE_CMD               0x0
+#define PS2_STATE_SET_SAMPLE_RATE   0x1
+#define PS2_STATE_SET_SCAN_CODE_SET 0x2
+#define PS2_STATE_SET_LEDS          0x3
+
+struct hid_keyboard {
+    chardev_t chardev;
+    spinlock_t lock;
+    uint8_t key_state[32]; // State of all keys to prevent spurious repeat
+
+    uint8_t state;  // The keyboard is a state machine
+    uint8_t rate;   // Typematic rate in command encoding
+    uint8_t delay;  // Typematic delay in command encoding (0.25sec * (delay + 1))
+    bool reporting; // Data reporting enabled; needed for STATUS command
+
+    // Last key pressed, used for typematic input
+    const uint8_t* lastkey;
+    size_t lastkey_size;
+
+    // Used in IRQ handling for typematic (repeated) input
+    rvtimer_t sample_timer;
+    uint64_t sample_timecmp;
+
+    ringbuf_t cmdbuf;
+};
+
+static const uint8_t hid_to_ps2_byte_map[] = {
+    [HID_KEY_A] = 0x1C,
+    [HID_KEY_B] = 0x32,
+    [HID_KEY_C] = 0x21,
+    [HID_KEY_D] = 0x23,
+    [HID_KEY_E] = 0x24,
+    [HID_KEY_F] = 0x2B,
+    [HID_KEY_G] = 0x34,
+    [HID_KEY_H] = 0x33,
+    [HID_KEY_I] = 0x43,
+    [HID_KEY_J] = 0x3B,
+    [HID_KEY_K] = 0x42,
+    [HID_KEY_L] = 0x4B,
+    [HID_KEY_M] = 0x3A,
+    [HID_KEY_N] = 0x31,
+    [HID_KEY_O] = 0x44,
+    [HID_KEY_P] = 0x4D,
+    [HID_KEY_Q] = 0x15,
+    [HID_KEY_R] = 0x2D,
+    [HID_KEY_S] = 0x1B,
+    [HID_KEY_T] = 0x2C,
+    [HID_KEY_U] = 0x3C,
+    [HID_KEY_V] = 0x2A,
+    [HID_KEY_W] = 0x1D,
+    [HID_KEY_X] = 0x22,
+    [HID_KEY_Y] = 0x35,
+    [HID_KEY_Z] = 0x1A,
+
+    [HID_KEY_1] = 0x16,
+    [HID_KEY_2] = 0x1E,
+    [HID_KEY_3] = 0x26,
+    [HID_KEY_4] = 0x25,
+    [HID_KEY_5] = 0x2E,
+    [HID_KEY_6] = 0x36,
+    [HID_KEY_7] = 0x3D,
+    [HID_KEY_8] = 0x3E,
+    [HID_KEY_9] = 0x46,
+    [HID_KEY_0] = 0x45,
+
+    [HID_KEY_ENTER]      = 0x5A,
+    [HID_KEY_ESC]        = 0x76,
+    [HID_KEY_BACKSPACE]  = 0x66,
+    [HID_KEY_TAB]        = 0x0D,
+    [HID_KEY_SPACE]      = 0x29,
+    [HID_KEY_MINUS]      = 0x4E,
+    [HID_KEY_EQUAL]      = 0x55,
+    [HID_KEY_LEFTBRACE]  = 0x54,
+    [HID_KEY_RIGHTBRACE] = 0x5B,
+    [HID_KEY_BACKSLASH]  = 0x5D,
+    [HID_KEY_SEMICOLON]  = 0x4C,
+    [HID_KEY_APOSTROPHE] = 0x52,
+    [HID_KEY_GRAVE]      = 0x0E,
+    [HID_KEY_COMMA]      = 0x41,
+    [HID_KEY_DOT]        = 0x49,
+    [HID_KEY_SLASH]      = 0x4A,
+    [HID_KEY_CAPSLOCK]   = 0x58,
+
+    [HID_KEY_LEFTCTRL]   = 0x14,
+    [HID_KEY_LEFTSHIFT]  = 0x12,
+    [HID_KEY_LEFTALT]    = 0x11,
+    [HID_KEY_RIGHTSHIFT] = 0x59,
+
+    [HID_KEY_F1]  = 0x05,
+    [HID_KEY_F2]  = 0x06,
+    [HID_KEY_F3]  = 0x04,
+    [HID_KEY_F4]  = 0x0C,
+    [HID_KEY_F5]  = 0x03,
+    [HID_KEY_F6]  = 0x0B,
+    [HID_KEY_F7]  = 0x83,
+    [HID_KEY_F8]  = 0x0A,
+    [HID_KEY_F9]  = 0x01,
+    [HID_KEY_F10] = 0x09,
+    [HID_KEY_F11] = 0x78,
+    [HID_KEY_F12] = 0x07,
+
+    [HID_KEY_SCROLLLOCK] = 0x7E,
+
+    [HID_KEY_NUMLOCK]    = 0x77,
+    [HID_KEY_KPASTERISK] = 0x7C,
+    [HID_KEY_KPMINUS]    = 0x7B,
+    [HID_KEY_KPPLUS]     = 0x79,
+    [HID_KEY_KP1] = 0x69,
+    [HID_KEY_KP2] = 0x72,
+    [HID_KEY_KP3] = 0x7A,
+    [HID_KEY_KP4] = 0x6B,
+    [HID_KEY_KP5] = 0x73,
+    [HID_KEY_KP6] = 0x74,
+    [HID_KEY_KP7] = 0x6C,
+    [HID_KEY_KP8] = 0x75,
+    [HID_KEY_KP9] = 0x7D,
+    [HID_KEY_KP0] = 0x70,
+    [HID_KEY_KPDOT] = 0x71,
+};
+
+static void ps2_keyboard_set_rate(hid_keyboard_t* kb, uint8_t rate)
+{
+    kb->rate = rate & 0x1f;
+    kb->delay = rate & 3;
+
+    rvtimer_init(&kb->sample_timer, 1000);
+    kb->sample_timecmp = (kb->delay + 1) * 250;
+}
+
+static void ps2_keyboard_defaults(hid_keyboard_t* kb)
+{
+    memset(&kb->key_state, 0, sizeof(kb->key_state));
+    kb->state = PS2_STATE_CMD;
+    kb->rate = 20;
+    kb->delay = 1;
+}
+
+static bool ps2_keyboard_cmd(hid_keyboard_t* kb, uint8_t cmd)
+{
+    switch (cmd) {
+        case PS2_CMD_RESET:
+            ps2_keyboard_defaults(kb);
+            ringbuf_put_u8(&kb->cmdbuf, PS2_RSP_ACK);
+            ringbuf_put_u8(&kb->cmdbuf, 0xAA);
+            return true;
+        case PS2_CMD_RESEND:
+            // Unimplemented
+            return false;
+        case PS2_CMD_SET_DEFAULTS:
+            ps2_keyboard_defaults(kb);
+            ringbuf_put_u8(&kb->cmdbuf, PS2_RSP_ACK);
+            return true;
+        case PS2_CMD_DISABLE_DATA_REPORTING:
+            kb->reporting = false;
+            ps2_keyboard_defaults(kb);
+            ringbuf_put_u8(&kb->cmdbuf, PS2_RSP_ACK);
+            return true;
+        case PS2_CMD_ENABLE_DATA_REPORTING:
+            kb->reporting = true;
+            ringbuf_put_u8(&kb->cmdbuf, PS2_RSP_ACK);
+            return true;
+        case PS2_CMD_SET_SAMPLE_RATE:
+            kb->state = PS2_STATE_SET_SAMPLE_RATE;
+            ringbuf_put_u8(&kb->cmdbuf, PS2_RSP_ACK);
+            return true;
+        case PS2_CMD_GET_DEV_ID:
+            ringbuf_put_u8(&kb->cmdbuf, PS2_RSP_ACK);
+            ringbuf_put_u8(&kb->cmdbuf, 0xAB);
+            ringbuf_put_u8(&kb->cmdbuf, 0x83);
+            return true;
+        case PS2_CMD_SET_SCAN_CODE_SET:
+            kb->state = PS2_STATE_SET_SCAN_CODE_SET;
+            ringbuf_put_u8(&kb->cmdbuf, PS2_RSP_ACK);
+            return true;
+        case PS2_CMD_ECHO:
+            ringbuf_put_u8(&kb->cmdbuf, 0xEE);
+            return true;
+        case PS2_CMD_LEDS:
+            kb->state = PS2_STATE_SET_LEDS;
+            ringbuf_put_u8(&kb->cmdbuf, PS2_RSP_ACK);
+            return true;
+        default:
+            ringbuf_put_u8(&kb->cmdbuf, PS2_RSP_NAK);
+            return true;
+    }
+}
+
+static size_t ps2_keyboard_read(chardev_t* dev, void* buf, size_t size)
+{
+    hid_keyboard_t* kb = dev->data;
+    spin_lock(&kb->lock);
+    size_t ret = ringbuf_read(&kb->cmdbuf, buf, size);
+    spin_unlock(&kb->lock);
+    return ret;
+}
+
+static size_t ps2_keyboard_write(chardev_t* dev, const void* buf, size_t size)
+{
+    hid_keyboard_t* kb = dev->data;
+    spin_lock(&kb->lock);
+    for (size_t i=0; i<size; ++i) {
+        uint8_t val = ((const uint8_t*)buf)[i];
+
+        switch (kb->state) {
+            case PS2_STATE_CMD:
+                ps2_keyboard_cmd(kb, val);
+                break;
+            case PS2_STATE_SET_SAMPLE_RATE:
+                ps2_keyboard_set_rate(kb, val);
+                kb->state = PS2_STATE_CMD;
+                ringbuf_put_u8(&kb->cmdbuf, PS2_RSP_ACK);
+                break;
+            case PS2_STATE_SET_SCAN_CODE_SET:
+                if (val == 0) {
+                    ringbuf_put_u8(&kb->cmdbuf, PS2_RSP_ACK);
+                    ringbuf_put_u8(&kb->cmdbuf, 2);
+                } else if (val == 2) {
+                    ringbuf_put_u8(&kb->cmdbuf, PS2_RSP_ACK);
+                } else {
+                    ringbuf_put_u8(&kb->cmdbuf, PS2_RSP_NAK);
+                }
+                kb->state = PS2_STATE_CMD;
+                ringbuf_put_u8(&kb->cmdbuf, PS2_RSP_ACK);
+                break;
+            case PS2_STATE_SET_LEDS:
+                // leds are ignored
+                kb->state = PS2_STATE_CMD;
+                ringbuf_put_u8(&kb->cmdbuf, PS2_RSP_ACK);
+                break;
+        }
+    }
+    spin_unlock(&kb->lock);
+    chardev_notify(&kb->chardev, CHARDEV_RX);
+    return size;
+}
+
+static void ps2_keyboard_remove(chardev_t* dev)
+{
+    hid_keyboard_t* kb = dev->data;
+    ringbuf_destroy(&kb->cmdbuf);
+    free(kb);
+}
+
+static const uint16_t ps2kb_rate2realrate[32] = {
+    [0]  = 300,
+    [1]  = 267,
+    [2]  = 240,
+    [3]  = 218,
+    [4]  = 200,
+    [5]  = 185,
+    [6]  = 171,
+    [7]  = 160,
+    [8]  = 150,
+    [9]  = 133,
+    [10] = 120,
+    [11] = 109,
+    [12] = 100,
+    [13] = 92,
+    [14] = 86,
+    [15] = 80,
+    [16] = 75,
+    [17] = 67,
+    [18] = 60,
+    [19] = 55,
+    [20] = 50,
+    [21] = 46,
+    [22] = 43,
+    [23] = 40,
+    [24] = 37,
+    [25] = 33,
+    [26] = 30,
+    [27] = 28,
+    [28] = 25,
+    [29] = 23,
+    [30] = 21,
+    [31] = 20,
+};
+
+static void ps2_keyboard_update(chardev_t* dev)
+{
+    // Handle typematic
+    hid_keyboard_t* kb = dev->data;
+    spin_lock(&kb->lock);
+    if (kb->reporting && kb->lastkey_size && rvtimer_get(&kb->sample_timer) >= kb->sample_timecmp) {
+        rvtimer_init(&kb->sample_timer, ps2kb_rate2realrate[kb->rate]);
+        kb->sample_timecmp = 10;
+        ringbuf_put(&kb->cmdbuf, kb->lastkey, kb->lastkey_size);
+        chardev_notify(&kb->chardev, CHARDEV_RX);
+    }
+    spin_unlock(&kb->lock);
+}
+
+PUBLIC hid_keyboard_t* hid_keyboard_init_auto_ps2(rvvm_machine_t* machine)
+{
+    plic_ctx_t* plic = rvvm_get_plic(machine);
+    rvvm_addr_t addr = rvvm_mmio_zone_auto(machine, 0x20001000, ALTPS2_MMIO_SIZE);
+    hid_keyboard_t* kb = safe_new_obj(hid_keyboard_t);
+
+    kb->chardev.read = ps2_keyboard_read;
+    kb->chardev.write = ps2_keyboard_write;
+    kb->chardev.remove = ps2_keyboard_remove;
+    kb->chardev.update = ps2_keyboard_update;
+    kb->chardev.data = kb;
+
+    ringbuf_create(&kb->cmdbuf, 1024);
+    ringbuf_put_u8(&kb->cmdbuf, 0xAA);
+
+    altps2_init(machine, addr, plic, plic_alloc_irq(plic), &kb->chardev);
+    return kb;
+}
+
+static const uint8_t* hid_to_ps2_keycode(hid_key_t key, size_t* size)
+{
+    if (key < sizeof(hid_to_ps2_byte_map) && hid_to_ps2_byte_map[key]) {
+        // Convert small & common keycodes using a table, fallback to switch
+        *size = 1;
+        return &hid_to_ps2_byte_map[key];
+    } else {
+        switch (key) {
+            case HID_KEY_LEFTMETA:
+                *size = 2;
+                return (const uint8_t*)"\xE0\x1F";
+            case HID_KEY_RIGHTCTRL:
+                *size = 2;
+                return (const uint8_t*)"\xE0\x14";
+            case HID_KEY_RIGHTALT:
+                *size = 2;
+                return (const uint8_t*)"\xE0\x11";
+            case HID_KEY_RIGHTMETA:
+                *size = 2;
+                return (const uint8_t*)"\xE0\x27";
+            case HID_KEY_SYSRQ:
+                *size = 4;
+                return (const uint8_t*)"\xE0\x12\xE0\x7C";
+            case HID_KEY_PAUSE:
+                *size = 8;
+                return (const uint8_t*)"\xE1\x14\x77\xE1\xF0\x14\xF0\x77";
+            case HID_KEY_INSERT:
+                *size = 2;
+                return (const uint8_t*)"\xE0\x70";
+            case HID_KEY_HOME:
+                *size = 2;
+                return (const uint8_t*)"\xE0\x6C";
+            case HID_KEY_PAGEUP:
+                *size = 2;
+                return (const uint8_t*)"\xE0\x7D";
+            case HID_KEY_DELETE:
+                *size = 2;
+                return (const uint8_t*)"\xE0\x71";
+            case HID_KEY_END:
+                *size = 2;
+                return (const uint8_t*)"\xE0\x69";
+            case HID_KEY_PAGEDOWN:
+                *size = 2;
+                return (const uint8_t*)"\xE0\x7A";
+            case HID_KEY_RIGHT:
+                *size = 2;
+                return (const uint8_t*)"\xE0\x74";
+            case HID_KEY_LEFT:
+                *size = 2;
+                return (const uint8_t*)"\xE0\x6B";
+            case HID_KEY_DOWN:
+                *size = 2;
+                return (const uint8_t*)"\xE0\x72";
+            case HID_KEY_UP:
+                *size = 2;
+                return (const uint8_t*)"\xE0\x75";
+            case HID_KEY_MENU:
+                *size = 2;
+                return (const uint8_t*)"\xE0\x2F";
+            case HID_KEY_KPSLASH:
+                *size = 2;
+                return (const uint8_t*)"\xE0\x4A";
+            case HID_KEY_KPENTER:
+                *size = 2;
+                return (const uint8_t*)"\xE0\x5A";
+            default:
+                return NULL;
+        }
+    }
+}
+
+static void ps2_handle_keyboard(hid_keyboard_t* kb, hid_key_t key, bool pressed)
+{
+    spin_lock(&kb->lock);
+    // Ignore repeated press/release events
+    bool key_state = !!(kb->key_state[key >> 3] & (1 << (key & 0x7)));
+    if (key != HID_KEY_NONE && key_state != pressed && kb->reporting) {
+        size_t keycode_size = 0;
+        const uint8_t* keycode = hid_to_ps2_keycode(key, &keycode_size);
+
+        if (keycode) {
+            // Send key event to the guest
+            if (pressed) {
+                kb->key_state[key >> 3] |= (1 << (key & 0x7));
+                kb->lastkey = keycode;
+                kb->lastkey_size = keycode_size;
+
+                ringbuf_put(&kb->cmdbuf, keycode, keycode_size);
+                rvtimer_init(&kb->sample_timer, 1000);
+                kb->sample_timecmp = (kb->delay + 1) * 250;
+            } else {
+                uint8_t keycmd[8];
+                uint8_t keylen = 0;
+                kb->key_state[key >> 3] &= ~(1 << (key & 0x7));
+                if (kb->lastkey == keycode) kb->lastkey_size = 0;
+
+                if (keycode_size == 1) {
+                    keycmd[0] = 0xF0;
+                    keycmd[1] = keycode[0];
+                    keylen = 2;
+                } else if (keycode_size == 2 && keycode[0] == 0xE0) {
+                    keycmd[0] = 0xE0;
+                    keycmd[1] = 0xF0;
+                    keycmd[2] = keycode[1];
+                    keylen = 3;
+                } else if (keycode_size == 4 && keycode[0] == 0xE0 && keycode[2] == 0xE0) {
+                    // Print screen is special
+                    keycmd[0] = 0xE0;
+                    keycmd[1] = 0xF0;
+                    keycmd[2] = keycode[3];
+                    keycmd[3] = 0xE0;
+                    keycmd[4] = 0xF0;
+                    keycmd[5] = keycode[1];
+                    keylen = 6;
+                }
+                ringbuf_put(&kb->cmdbuf, keycmd, keylen);
+            }
+            chardev_notify(&kb->chardev, CHARDEV_RX);
+        }
+    }
+    spin_unlock(&kb->lock);
+}
+
+PUBLIC void hid_keyboard_press_ps2(hid_keyboard_t* kb, hid_key_t key)
+{
+    ps2_handle_keyboard(kb, key, true);
+}
+
+PUBLIC void hid_keyboard_release_ps2(hid_keyboard_t* kb, hid_key_t key)
+{
+    ps2_handle_keyboard(kb, key, false);
+}
diff --git a/app/src/main/java/libengine/RVVM/src/devices/ps2-mouse.c b/app/src/main/java/libengine/RVVM/src/devices/ps2-mouse.c
new file mode 100644
index 00000000..9067cf59
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/ps2-mouse.c
@@ -0,0 +1,381 @@
+/*
+ps2-mouse.c - PS2 Mouse
+Copyright (C) 2021  LekKit <github.com/LekKit>
+                    cerg2010cerg2010 <github.com/cerg2010cerg2010>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "ps2-altera.h"
+#include "hid_api.h"
+#include "../ringbuf.h"
+#include "../spinlock.h"
+#include "../utils.h"
+
+#define PS2_CMD_RESET 0xFF
+#define PS2_CMD_RESEND 0xFE
+#define PS2_CMD_SET_DEFAULTS 0xF6
+#define PS2_CMD_DISABLE_DATA_REPORTING 0xF5
+#define PS2_CMD_ENABLE_DATA_REPORTING 0xF4
+#define PS2_CMD_SET_SAMPLE_RATE 0xF3
+#define PS2_CMD_GET_DEV_ID 0xF2
+#define PS2_CMD_SET_REMOTE_MODE 0xF0
+#define PS2_CMD_SET_WRAP_MODE 0xEE
+#define PS2_CMD_RESET_WRAP_MODE 0xEC
+#define PS2_CMD_READ_DATA 0xEB
+#define PS2_CMD_SET_STREAM_MODE 0xEA
+#define PS2_CMD_STATUS_REQ 0xE9
+#define PS2_CMD_SET_RESOLUTION 0xE8
+#define PS2_CMD_SET_SCALING_2_1 0xE7
+#define PS2_CMD_SET_SCALING_1_1 0xE6
+
+#define PS2_RSP_ACK 0xFA
+#define PS2_RSP_NAK 0xFE
+
+#define PS2_STATE_CMD             0x0
+#define PS2_STATE_SET_SAMPLE_RATE 0x1
+#define PS2_STATE_WRAP            0x2
+#define PS2_STATE_SET_RESOLUTION  0x3
+
+#define PS2_MODE_STREAM 0x0
+#define PS2_MODE_REMOTE 0x1
+
+#define PS2_MOUSE_GENERIC 0x0
+#define PS2_MOUSE_WHEEL   0x3
+
+struct hid_mouse {
+    chardev_t chardev;
+    spinlock_t lock;
+    hid_btns_t btns; // Pressed buttons bitmask
+    bool res_init;   // Validate hid_mouse_resolution() was called
+    // Absolute position
+    int32_t x;
+    int32_t y;
+    // Movement counters - these are actually 9-bit
+    int16_t xctr;
+    int16_t yctr;
+    // Counters' overflow flags
+    bool xoverflow;
+    bool yoverflow;
+    
+    int32_t scroll;     // Scroll axis value
+    
+    uint8_t mode;
+    uint8_t state;      // The mouse is a state machine
+    uint8_t resolution; // In pow2, e.g. 2 means multiply by 4
+    uint8_t rate;       // In samples per second
+    uint8_t whl_detect; // Stage of detecting an Intellimouse extension
+    bool reporting;     // Data reporting enabled; needed for STATUS command
+
+    ringbuf_t cmdbuf;
+};
+
+static void ps2_mouse_defaults(hid_mouse_t* mice)
+{
+    mice->mode = PS2_MODE_STREAM;
+    mice->state = PS2_STATE_CMD;
+    mice->reporting = false;
+    mice->resolution = 2;
+}
+
+static void ps2_mouse_flush(hid_mouse_t* mice)
+{
+    mice->xctr = 0;
+    mice->yctr = 0;
+    mice->xoverflow = 0;
+    mice->yoverflow = 0;
+    mice->scroll = 0;
+}
+
+static void ps2_mouse_move_pkt(hid_mouse_t* mice)
+{
+    int8_t x   = mice->xctr & 0xff;
+    bool xsign = mice->xctr < 0;
+    int8_t y   = mice->yctr & 0xff;
+    bool ysign = mice->yctr < 0;
+
+    ringbuf_put_u8(&mice->cmdbuf, ((mice->btns & HID_BTN_LEFT) ? 1 : 0)
+                                | ((mice->btns & HID_BTN_RIGHT) ? 2 : 0)
+                                | ((mice->btns & HID_BTN_MIDDLE) ? 4 : 0)
+                                | 1 << 3
+                                | xsign << 4
+                                | ysign << 5
+                                | mice->xoverflow << 6
+                                | mice->yoverflow << 7);
+    ringbuf_put_u8(&mice->cmdbuf, x);
+    ringbuf_put_u8(&mice->cmdbuf, y);
+    
+    if (mice->whl_detect == 3) {
+        // Push scroll axis byte
+        ringbuf_put_u8(&mice->cmdbuf, mice->scroll);
+    }
+    
+    ps2_mouse_flush(mice);
+    chardev_notify(&mice->chardev, CHARDEV_RX);
+}
+
+static bool ps2_mouse_cmd(hid_mouse_t* mice, uint8_t cmd)
+{
+    switch (cmd) {
+        case PS2_CMD_RESET:
+            ps2_mouse_defaults(mice);
+            ringbuf_put_u8(&mice->cmdbuf, PS2_RSP_ACK);
+            ringbuf_put_u8(&mice->cmdbuf, 0xAA);
+            ringbuf_put_u8(&mice->cmdbuf, 0x00);
+            return true;
+        case PS2_CMD_RESEND:
+            // Unimplemented
+            return false;
+        case PS2_CMD_SET_DEFAULTS:
+            ps2_mouse_defaults(mice);
+            ringbuf_put_u8(&mice->cmdbuf, PS2_RSP_ACK);
+            return true;
+        case PS2_CMD_DISABLE_DATA_REPORTING:
+            mice->reporting = false;
+            ringbuf_put_u8(&mice->cmdbuf, PS2_RSP_ACK);
+            return true;
+        case PS2_CMD_ENABLE_DATA_REPORTING:
+            mice->reporting = true;
+            ringbuf_put_u8(&mice->cmdbuf, PS2_RSP_ACK);
+            return true;
+        case PS2_CMD_SET_SAMPLE_RATE:
+            mice->state = PS2_STATE_SET_SAMPLE_RATE;
+            ringbuf_put_u8(&mice->cmdbuf, PS2_RSP_ACK);
+            return true;
+        case PS2_CMD_GET_DEV_ID:
+            ringbuf_put_u8(&mice->cmdbuf, PS2_RSP_ACK);
+            if (mice->whl_detect == 3) {
+                ringbuf_put_u8(&mice->cmdbuf, PS2_MOUSE_WHEEL);
+            } else {
+                ringbuf_put_u8(&mice->cmdbuf, PS2_MOUSE_GENERIC);
+            }
+            return true;
+        case PS2_CMD_SET_REMOTE_MODE:
+            ps2_mouse_flush(mice);
+            mice->mode = PS2_MODE_REMOTE;
+            ringbuf_put_u8(&mice->cmdbuf, PS2_RSP_ACK);
+            return true;
+        case PS2_CMD_SET_WRAP_MODE:
+            ps2_mouse_flush(mice);
+            mice->state = PS2_STATE_WRAP;
+            ringbuf_put_u8(&mice->cmdbuf, PS2_RSP_ACK);
+            return true;
+        case PS2_CMD_RESET_WRAP_MODE:
+            ps2_mouse_flush(mice);
+            mice->state = PS2_STATE_CMD;
+            ringbuf_put_u8(&mice->cmdbuf, PS2_RSP_ACK);
+            return true;
+        case PS2_CMD_READ_DATA:
+            ringbuf_put_u8(&mice->cmdbuf, PS2_RSP_ACK);
+            ps2_mouse_move_pkt(mice);
+            return true;
+        case PS2_CMD_SET_STREAM_MODE:
+            ps2_mouse_flush(mice);
+            mice->mode = PS2_MODE_STREAM;
+            ringbuf_put_u8(&mice->cmdbuf, PS2_RSP_ACK);
+            return true;
+        case PS2_CMD_STATUS_REQ:
+            ringbuf_put_u8(&mice->cmdbuf, PS2_RSP_ACK);
+            ringbuf_put_u8(&mice->cmdbuf, ((mice->btns & HID_BTN_RIGHT) ? 0x1 : 0)
+                    | ((mice->btns & HID_BTN_MIDDLE) ? 0x2 : 0)
+                    | ((mice->btns & HID_BTN_LEFT) ? 0x4 : 0)
+                    | (mice->reporting ? 0x20 : 0)
+                    | ((mice->mode == PS2_MODE_REMOTE) ? 0x40 : 0));
+            ringbuf_put_u8(&mice->cmdbuf, mice->resolution);
+            ringbuf_put_u8(&mice->cmdbuf, mice->rate);
+            return true;
+        case PS2_CMD_SET_RESOLUTION:
+            mice->state = PS2_STATE_SET_RESOLUTION;
+            ringbuf_put_u8(&mice->cmdbuf, PS2_RSP_ACK);
+            return true;
+        case PS2_CMD_SET_SCALING_1_1:
+        case PS2_CMD_SET_SCALING_2_1:
+            // Ignored, we don't want acceleration of guest cursor
+            ringbuf_put_u8(&mice->cmdbuf, PS2_RSP_ACK);
+            return true;
+        default:
+            ringbuf_put_u8(&mice->cmdbuf, PS2_RSP_NAK);
+            return true;
+    }
+}
+
+static size_t ps2_mouse_read(chardev_t* dev, void* buf, size_t size)
+{
+    hid_mouse_t* mice = dev->data;
+    spin_lock(&mice->lock);
+    size_t ret = ringbuf_read(&mice->cmdbuf, buf, size);
+    spin_unlock(&mice->lock);
+    return ret;
+}
+
+static size_t ps2_mouse_write(chardev_t* dev, const void* buf, size_t size)
+{
+    hid_mouse_t* mice = dev->data;
+    spin_lock(&mice->lock);
+    for (size_t i=0; i<size; ++i) {
+        uint8_t val = ((const uint8_t*)buf)[i];
+
+        switch (mice->state) {
+            case PS2_STATE_CMD:
+                ps2_mouse_cmd(mice, val);
+                break;
+            case PS2_STATE_SET_SAMPLE_RATE:
+                mice->rate = val;
+                // Magical sequence for detecting Intellimouse extension
+                // See https://wiki.osdev.org/PS/2_Mouse
+                if (mice->whl_detect == 0 && mice->rate == 200) {
+                    mice->whl_detect = 1;
+                } else if (mice->whl_detect == 1 && mice->rate == 100) {
+                    mice->whl_detect = 2;
+                } else if (mice->whl_detect == 2 && mice->rate == 80) {
+                    mice->whl_detect = 3;
+                } else if (mice->whl_detect < 3) {
+                    mice->whl_detect = 0;
+                }
+                mice->state = PS2_STATE_CMD;
+                ringbuf_put_u8(&mice->cmdbuf, PS2_RSP_ACK);
+                break;
+            case PS2_STATE_WRAP:
+                if (val != PS2_CMD_RESET_WRAP_MODE && val != PS2_CMD_RESET) {
+                    ringbuf_put_u8(&mice->cmdbuf, val);
+                }
+                break;
+            case PS2_STATE_SET_RESOLUTION:
+                mice->resolution = val;
+                mice->state = PS2_STATE_CMD;
+                ringbuf_put_u8(&mice->cmdbuf, PS2_RSP_ACK);
+                break;
+        }
+    }
+    spin_unlock(&mice->lock);
+    chardev_notify(&mice->chardev, CHARDEV_RX);
+    return size;
+}
+
+static void ps2_mouse_remove(chardev_t* dev)
+{
+    hid_mouse_t* mice = dev->data;
+    ringbuf_destroy(&mice->cmdbuf);
+    free(mice);
+}
+
+PUBLIC hid_mouse_t* hid_mouse_init_auto_ps2(rvvm_machine_t* machine)
+{
+    plic_ctx_t* plic = rvvm_get_plic(machine);
+    rvvm_addr_t addr = rvvm_mmio_zone_auto(machine, 0x20000000, ALTPS2_MMIO_SIZE);
+    hid_mouse_t* mice = safe_new_obj(hid_mouse_t);
+
+    mice->chardev.read = ps2_mouse_read;
+    mice->chardev.write = ps2_mouse_write;
+    mice->chardev.remove = ps2_mouse_remove;
+    mice->chardev.data = mice;
+    
+    ps2_mouse_defaults(mice);
+    
+    ringbuf_create(&mice->cmdbuf, 1024);
+    ringbuf_put_u8(&mice->cmdbuf, 0xAA);
+    ringbuf_put_u8(&mice->cmdbuf, 0x00);
+    
+    altps2_init(machine, addr, plic, plic_alloc_irq(plic), &mice->chardev);
+    return mice;
+}
+
+PUBLIC void hid_mouse_press_ps2(hid_mouse_t* mouse, hid_btns_t btns)
+{
+    if (mouse == NULL) return;
+    spin_lock(&mouse->lock);
+    bool pressed = mouse->btns != (mouse->btns | btns);
+    mouse->btns |= btns;
+    if (pressed && mouse->mode == PS2_MODE_STREAM && mouse->reporting) {
+        ps2_mouse_move_pkt(mouse);
+    }
+    spin_unlock(&mouse->lock);
+}
+
+PUBLIC void hid_mouse_release_ps2(hid_mouse_t* mouse, hid_btns_t btns)
+{
+    if (mouse == NULL) return;
+    spin_lock(&mouse->lock);
+    bool released = mouse->btns != (mouse->btns & ~btns);
+    mouse->btns &= ~btns;
+    if (released && mouse->mode == PS2_MODE_STREAM && mouse->reporting) {
+        ps2_mouse_move_pkt(mouse);
+    }
+    spin_unlock(&mouse->lock);
+}
+
+PUBLIC void hid_mouse_scroll_ps2(hid_mouse_t* mouse, int32_t offset)
+{
+    if (mouse == NULL) return;
+    spin_lock(&mouse->lock);
+    mouse->scroll += offset;
+    if (mouse->mode == PS2_MODE_STREAM && mouse->reporting) {
+        ps2_mouse_move_pkt(mouse);
+    }
+    spin_unlock(&mouse->lock);
+}
+
+static void ps2_mouse_move(hid_mouse_t* mouse, int32_t x, int32_t y)
+{
+    int shift = 3 - mouse->resolution;
+    int32_t newx, newy;
+    mouse->x += x;
+    mouse->y += y;
+    if (shift >= 0) {
+        newx = mouse->xctr + (x >> shift);
+        newy = mouse->yctr - (y >> shift);
+    } else {
+        newx = mouse->xctr + (x << -shift);
+        newy = mouse->yctr - (y << -shift);
+    }
+    if (newx > 255 || newx < -512) {
+        mouse->xoverflow = true;
+        newx = (int8_t)newx;
+    }
+    if (newy > 255 || newy < -512) {
+        mouse->yoverflow = true;
+        newy = (int8_t)newy;
+    }
+
+    mouse->xctr = newx;
+    mouse->yctr = newy;
+    if (mouse->mode == PS2_MODE_STREAM && mouse->reporting) {
+        ps2_mouse_move_pkt(mouse);
+    }
+}
+
+PUBLIC void hid_mouse_resolution_ps2(hid_mouse_t* mouse, uint32_t x, uint32_t y)
+{
+    if (mouse == NULL) return;
+    spin_lock(&mouse->lock);
+    mouse->res_init = x != 0 && y != 0;
+    spin_unlock(&mouse->lock);
+}
+
+PUBLIC void hid_mouse_move_ps2(hid_mouse_t* mouse, int32_t x, int32_t y)
+{
+    if (mouse == NULL) return;
+    spin_lock(&mouse->lock);
+    ps2_mouse_move(mouse, x, y);
+    spin_unlock(&mouse->lock);
+}
+
+PUBLIC void hid_mouse_place_ps2(hid_mouse_t* mouse, int32_t x, int32_t y)
+{
+    if (mouse == NULL) return;
+    spin_lock(&mouse->lock);
+    if (!mouse->res_init) rvvm_warn("hid_mouse_resolution() was not called!");
+    ps2_mouse_move(mouse, x - mouse->x, y - mouse->y);
+    spin_unlock(&mouse->lock);
+}
diff --git a/app/src/main/java/libengine/RVVM/src/devices/rtc-ds1742.c b/app/src/main/java/libengine/RVVM/src/devices/rtc-ds1742.c
new file mode 100644
index 00000000..9506c0a2
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/rtc-ds1742.c
@@ -0,0 +1,120 @@
+/*
+rtc-ds7142.c - Dallas DS1742 Real-time Clock
+Copyright (C) 2023  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "rtc-ds1742.h"
+#include "../mem_ops.h"
+#include "../utils.h"
+#include "../fdtlib.h"
+#include <time.h>
+
+#define DS1742_REG_CTL_CENT 0x0 // Control, Century
+#define DS1742_REG_SECONDS  0x1 // Seconds [0, 59]
+#define DS1742_REG_MINUTES  0x2 // Minutes [0, 59]
+#define DS1742_REG_HOURS    0x3 // Hours [0, 23]
+#define DS1742_REG_DAY      0x4 // Day of week [1, 7]
+#define DS1742_REG_DATE     0x5 // Day of month [1, 31]
+#define DS1742_REG_MONTH    0x6 // Month [1, 12]
+#define DS1742_REG_YEAR     0x7 // Year [0, 99]
+
+#define DS1742_MMIO_SIZE 0x8
+
+#define DS1742_DAY_BATT 0x80 // Battery OK
+#define DS1742_CTL_READ 0x40 // Lock registers for read
+#define DS1742_CTL_MASK 0xC0 // Mask of control registers
+
+typedef struct {
+    uint8_t ctl;
+    uint8_t regs[DS1742_MMIO_SIZE];
+} ds1742_dev_t;
+
+static inline uint8_t bcd_conv_u8(uint8_t val)
+{
+    return (val % 10) | ((val / 10) << 4);
+}
+
+void rtc_ds1742_update_regs(ds1742_dev_t* rtc)
+{
+    time_t unix_time = time(NULL);
+    struct tm* calendar = gmtime(&unix_time);
+    rtc->regs[DS1742_REG_CTL_CENT] = bcd_conv_u8(calendar->tm_year / 100 + 19);
+    rtc->regs[DS1742_REG_SECONDS] = bcd_conv_u8(EVAL_MIN(calendar->tm_sec, 59));
+    rtc->regs[DS1742_REG_MINUTES] = bcd_conv_u8(calendar->tm_min);
+    rtc->regs[DS1742_REG_HOURS] = bcd_conv_u8(calendar->tm_hour);
+    rtc->regs[DS1742_REG_DATE] = bcd_conv_u8(calendar->tm_mday);
+    rtc->regs[DS1742_REG_DAY] = bcd_conv_u8(calendar->tm_wday + 1);
+    rtc->regs[DS1742_REG_MONTH] = bcd_conv_u8(calendar->tm_mon + 1);
+    rtc->regs[DS1742_REG_YEAR] = bcd_conv_u8(calendar->tm_year % 100);
+}
+
+static bool rtc_ds1742_mmio_read(rvvm_mmio_dev_t* dev, void* data, size_t offset, uint8_t size)
+{
+    ds1742_dev_t* rtc = dev->data;
+    uint8_t reg = rtc->regs[offset];
+    UNUSED(size);
+    if (offset == DS1742_REG_CTL_CENT) reg |= rtc->ctl;
+    if (offset == DS1742_REG_DAY) reg |= DS1742_DAY_BATT;
+    write_uint8(data, reg);
+    return true;
+}
+
+static bool rtc_ds1742_mmio_write(rvvm_mmio_dev_t* dev, void* data, size_t offset, uint8_t size)
+{
+    ds1742_dev_t* rtc = dev->data;
+    UNUSED(size);
+    if (offset == DS1742_REG_CTL_CENT) {
+        uint8_t ctl = read_uint8(data) & DS1742_CTL_MASK;
+        if (!(rtc->ctl & DS1742_CTL_READ) && (ctl & DS1742_CTL_READ)) rtc_ds1742_update_regs(rtc);
+        rtc->ctl = ctl;
+    }
+    return true;
+}
+
+static rvvm_mmio_type_t rtc_ds1742_dev_type = {
+    .name = "rtc_ds1742",
+};
+
+PUBLIC rvvm_mmio_dev_t* rtc_ds1742_init(rvvm_machine_t* machine, rvvm_addr_t base_addr)
+{
+    ds1742_dev_t* rtc = safe_new_obj(ds1742_dev_t);
+    rvvm_mmio_dev_t rtc_ds1742 = {
+        .addr = base_addr,
+        .size = DS1742_MMIO_SIZE,
+        .data = rtc,
+        .read = rtc_ds1742_mmio_read,
+        .write = rtc_ds1742_mmio_write,
+        .type = &rtc_ds1742_dev_type,
+        .min_op_size = 1,
+        .max_op_size = 1,
+    };
+    rtc_ds1742_update_regs(rtc);
+    rvvm_mmio_dev_t* mmio = rvvm_attach_mmio(machine, &rtc_ds1742);
+    if (mmio == NULL) return mmio;
+#ifdef USE_FDT
+    struct fdt_node* rtc_fdt = fdt_node_create_reg("rtc", base_addr);
+    fdt_node_add_prop_reg(rtc_fdt, "reg", base_addr, DS1742_MMIO_SIZE);
+    fdt_node_add_prop_str(rtc_fdt, "compatible", "maxim,ds1742");
+    fdt_node_add_child(rvvm_get_fdt_soc(machine), rtc_fdt);
+#endif
+    return mmio;
+}
+
+PUBLIC rvvm_mmio_dev_t* rtc_ds1742_init_auto(rvvm_machine_t* machine)
+{
+    rvvm_addr_t addr = rvvm_mmio_zone_auto(machine, RTC_DS1742_DEFAULT_MMIO, DS1742_MMIO_SIZE);
+    return rtc_ds1742_init(machine, addr);
+}
diff --git a/app/src/main/java/libengine/RVVM/src/devices/rtc-ds1742.h b/app/src/main/java/libengine/RVVM/src/devices/rtc-ds1742.h
new file mode 100644
index 00000000..45f2ed83
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/rtc-ds1742.h
@@ -0,0 +1,30 @@
+/*
+rtc-ds7142.h - Dallas DS1742 Real-time Clock
+Copyright (C) 2023  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef RVVM_RTC_DS1742_H
+#define RVVM_RTC_DS1742_H
+
+#include "../rvvmlib.h"
+
+#define RTC_DS1742_DEFAULT_MMIO 0x101000
+
+PUBLIC rvvm_mmio_dev_t* rtc_ds1742_init(rvvm_machine_t* machine, rvvm_addr_t base_addr);
+PUBLIC rvvm_mmio_dev_t* rtc_ds1742_init_auto(rvvm_machine_t* machine);
+
+#endif
+
diff --git a/app/src/main/java/libengine/RVVM/src/devices/rtc-goldfish.c b/app/src/main/java/libengine/RVVM/src/devices/rtc-goldfish.c
new file mode 100644
index 00000000..0ea8778d
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/rtc-goldfish.c
@@ -0,0 +1,144 @@
+/*
+rtc-goldfish.c - Goldfish Real-time Clock
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "rtc-goldfish.h"
+#include "../mem_ops.h"
+#include "../utils.h"
+#include "../fdtlib.h"
+#include <time.h>
+
+#define RTC_TIME_LOW     0x0
+#define RTC_TIME_HIGH    0x4
+#define RTC_ALARM_LOW    0x8
+#define RTC_ALARM_HIGH   0xC
+#define RTC_IRQ_ENABLED  0x10
+#define RTC_ALARM_CLEAR  0x14
+#define RTC_ALARM_STATUS 0x18
+#define RTC_IRQ_CLEAR    0x1C
+
+#define RTC_REG_SIZE     0x20
+
+struct rtc_goldfish_data {
+    plic_ctx_t* plic;
+    uint32_t irq;
+    uint32_t alarm_low;
+    uint32_t alarm_high;
+    bool irq_enabled;
+    bool alarm_enabled;
+};
+
+static bool rtc_goldfish_mmio_read(rvvm_mmio_dev_t* dev, void* data, size_t offset, uint8_t size)
+{
+    struct rtc_goldfish_data* rtc = dev->data;
+    uint64_t timer64 = time(NULL) * 1000000000ULL;
+    switch (offset) {
+        case RTC_TIME_LOW:
+            write_uint32_le(data, timer64);
+            break;
+        case RTC_TIME_HIGH:
+            write_uint32_le(data, timer64 >> 32);
+            break;
+        case RTC_ALARM_LOW:
+            write_uint32_le(data, rtc->alarm_low);
+            break;
+        case RTC_ALARM_HIGH:
+            write_uint32_le(data, rtc->alarm_high);
+            break;
+        case RTC_IRQ_ENABLED:
+            write_uint32_le(data, rtc->irq_enabled);
+            break;
+        case RTC_ALARM_STATUS:
+            write_uint32_le(data, rtc->alarm_enabled);
+            break;
+        default:
+            memset(data, 0, size);
+            break;
+    }
+    return true;
+}
+
+static bool rtc_goldfish_mmio_write(rvvm_mmio_dev_t* dev, void* data, size_t offset, uint8_t size)
+{
+    struct rtc_goldfish_data* rtc = dev->data;
+    uint64_t timer64 = time(NULL) * 1000000000ULL;
+    UNUSED(size);
+    switch (offset) {
+        case RTC_ALARM_LOW:
+            rtc->alarm_low = read_uint32_le(data);
+            break;
+        case RTC_ALARM_HIGH:
+            rtc->alarm_high = read_uint32_le(data);
+            break;
+        case RTC_IRQ_ENABLED:
+            rtc->irq_enabled = read_uint32_le(data);
+            break;
+        case RTC_ALARM_CLEAR:
+            rtc->alarm_enabled = false;
+            break;
+        default:
+            break;
+    }
+    uint64_t alarm64 = rtc->alarm_low | (((uint64_t)rtc->alarm_high) << 32);
+    if (rtc->alarm_enabled && rtc->irq_enabled && timer64 <= alarm64) {
+        if (rtc->plic) plic_send_irq(rtc->plic, rtc->irq);
+        rtc->alarm_enabled = false;
+    } else {
+        rtc->alarm_enabled = true;
+    }
+    return true;
+}
+
+static rvvm_mmio_type_t rtc_goldfish_dev_type = {
+    .name = "rtc_goldfish",
+};
+
+PUBLIC rvvm_mmio_dev_t* rtc_goldfish_init(rvvm_machine_t* machine, rvvm_addr_t base_addr, plic_ctx_t* plic, uint32_t irq)
+{
+    struct rtc_goldfish_data* ptr = safe_new_obj(struct rtc_goldfish_data);
+    ptr->plic = plic;
+    ptr->irq = irq;
+
+    rvvm_mmio_dev_t rtc_goldfish = {
+        .data = ptr,
+        .addr = base_addr,
+        .size = RTC_REG_SIZE,
+        .read = rtc_goldfish_mmio_read,
+        .write = rtc_goldfish_mmio_write,
+        .min_op_size = 4,
+        .max_op_size = 4,
+        .type = &rtc_goldfish_dev_type,
+    };
+    rvvm_mmio_dev_t* mmio = rvvm_attach_mmio(machine, &rtc_goldfish);
+    if (mmio == NULL) return mmio;
+#ifdef USE_FDT
+    struct fdt_node* rtc = fdt_node_create_reg("rtc", base_addr);
+    fdt_node_add_prop_reg(rtc, "reg", base_addr, RTC_REG_SIZE);
+    fdt_node_add_prop_str(rtc, "compatible", "google,goldfish-rtc");
+    fdt_node_add_prop_u32(rtc, "interrupt-parent", plic_get_phandle(plic));
+    fdt_node_add_prop_u32(rtc, "interrupts", irq);
+    fdt_node_add_child(rvvm_get_fdt_soc(machine), rtc);
+#endif
+    return mmio;
+}
+
+PUBLIC rvvm_mmio_dev_t* rtc_goldfish_init_auto(rvvm_machine_t* machine)
+{
+    plic_ctx_t* plic = rvvm_get_plic(machine);
+    rvvm_addr_t addr = rvvm_mmio_zone_auto(machine, RTC_GOLDFISH_DEFAULT_MMIO, RTC_REG_SIZE);
+    return rtc_goldfish_init(machine, addr, plic, plic_alloc_irq(plic));
+}
diff --git a/app/src/main/java/libengine/RVVM/src/devices/rtc-goldfish.h b/app/src/main/java/libengine/RVVM/src/devices/rtc-goldfish.h
new file mode 100644
index 00000000..63c15b25
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/rtc-goldfish.h
@@ -0,0 +1,32 @@
+/*
+rtc-goldfish.h - Goldfish Real-time Clock
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef RTC_GOLDFISH_H
+#define RTC_GOLDFISH_H
+
+#include "../rvvmlib.h"
+#include "plic.h"
+
+#define RTC_GOLDFISH_DEFAULT_MMIO 0x101000
+
+PUBLIC rvvm_mmio_dev_t* rtc_goldfish_init(rvvm_machine_t* machine, rvvm_addr_t base_addr,
+                                          plic_ctx_t* plic, uint32_t irq);
+PUBLIC rvvm_mmio_dev_t* rtc_goldfish_init_auto(rvvm_machine_t* machine);
+
+#endif
+
diff --git a/app/src/main/java/libengine/RVVM/src/devices/rtl8169.c b/app/src/main/java/libengine/RVVM/src/devices/rtl8169.c
new file mode 100644
index 00000000..a5176d40
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/rtl8169.c
@@ -0,0 +1,530 @@
+/*
+rtl8169.c - Realtek RTL8169 NIC
+Copyright (C) 2022  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifdef USE_NET
+
+#include "rtl8169.h"
+#include "tap_api.h"
+#include "pci-bus.h"
+#include "../mem_ops.h"
+#include "../bit_ops.h"
+#include "../spinlock.h"
+#include "../utils.h"
+
+#define RTL8169_REG_IDR0  0x0  // ID Register 0-3 (For MAC Address)
+#define RTL8169_REG_IDR4  0x4  // ID Register 4-5
+#define RTL8169_REG_MAR0  0x8  // Multicast Address Register 0-3
+#define RTL8169_REG_MAR4  0xC  // Multicast Address Register 4-7
+#define RTL8169_REG_DTCR1 0x10 // Dump Tally Counter Command Register (64-byte alignment)
+#define RTL8169_REG_DTCR2 0x14
+#define RTL8169_REG_TXDA1 0x20 // Transmit Descriptors Address (64-bit, 256-byte alignment)
+#define RTL8169_REG_TXDA2 0x24
+#define RTL8169_REG_TXHA1 0x28 // Transmit High Priority Descriptors Address (64-bit, 256-byte alignment)
+#define RTL8169_REG_TXHA2 0x2C
+#define RTL8169_REG_CR    0x37 // Command Register
+#define RTL8169_REG_TPOLL 0x38 // Transmit Priority Polling
+#define RTL8169_REG_IMR   0x3C // Interrupt Mask
+#define RTL8169_REG_ISR   0x3E // Interrupt Status
+#define RTL8169_REG_TCR   0x40 // Transmit Configuration Register
+#define RTL8169_REG_RCR   0x44 // Receive Configuration Register
+#define RTL8169_REG_TCTR  0x48 // Timer Counter Register
+#define RTL8169_REG_MPC   0x4C // Missed Packet Counter
+#define RTL8169_REG_9346  0x50 // 93C46 Command Register, CFG 0-2
+#define RTL8169_REG_CFG3  0x54 // Configuration Register 3-5
+#define RTL8169_REG_TINT  0x58 // Timer Interrupt Register
+#define RTL8169_REG_PHYAR 0x60 // PHY Access Register
+#define RTL8169_REG_TBIR0 0x64 // TBI Control and Status Register
+#define RTL8169_REG_TBANR 0x68 // TBI Auto-Negotiation Advertisement Register
+#define RTL8169_REG_PHYS  0x6C // PHY Status Register
+#define RTL8169_REG_RMS   0xDA // RX Packet Maximum Size
+#define RTL8169_REG_C_CR  0xE0 // C+ Command Register
+#define RTL8169_REG_RXDA1 0xE4 // Receive Descriptor Address (64-bit, 256-byte alignment)
+#define RTL8169_REG_RXDA2 0xE8
+#define RTL8169_REG_MTPS  0xEC // TX Packet Maximum Size
+
+#define RTL8169_CR_TE  0x04 // Transmitter Enable
+#define RTL8169_CR_RE  0x08 // Receiver Enable
+#define RTL8169_CR_RW  0x0C // R/W Register bits mask
+#define RTL8169_CR_RST 0x10 // Reset
+
+#define RTL8169_TPOLL_FSW 0x01 // Forced Software Interrupt
+#define RTL8169_TPOLL_NPQ 0x40 // Normal Priority Queue Polling
+#define RTL8169_TPOLL_HPQ 0x40 // High Priority Queue Polling
+
+#define RTL8169_IRQ_ROK 0x0  // Receive OK
+#define RTL8169_IRQ_RER 0x1  // Receiver Error
+#define RTL8169_IRQ_TOK 0x2  // Transmit OK
+#define RTL8169_IRQ_TER 0x3  // Transmitter Error
+#define RTL8169_IRQ_RDU 0x4  // RX Descriptor Unavailable
+#define RTL8169_IRQ_LCG 0x5  // Link Change
+#define RTL8169_IRQ_FOV 0x6  // RX FIFO Overflow
+#define RTL8169_IRQ_TDU 0x7  // TX Descriptor Unavailable
+#define RTL8169_IRQ_SWI 0x10 // Software Interrupt
+
+#define RTL8169_PHY_BMCR  0x0
+#define RTL8169_PHY_BMSR  0x1
+#define RTL8169_PHY_ID1   0x2
+#define RTL8169_PHY_ID2   0x3
+#define RTL8169_PHY_GBCR  0x9
+#define RTL8169_PHY_GBSR  0xA
+#define RTL8169_PHY_GBESR 0xF
+
+#define RTL8169_DESC_OWN 0x80000000
+#define RTL8169_DESC_EOR 0x40000000
+#define RTL8169_DESC_FS  0x20000000
+#define RTL8169_DESC_LS  0x10000000
+#define RTL8169_DESC_PAM 0x04000000
+#define RTL8169_DESC_GRX 0x34000000 // Generic RX packet flags
+
+#define RTL8169_EEPROM_DOU 0x01 // EEPROM Data out
+#define RTL8169_EEPROM_DIN 0x02 // EEPROM Data in
+#define RTL8169_EEPROM_CLK 0x04 // EEPROM Clock
+#define RTL8169_EEPROM_SEL 0x08 // EEPROM Chip select
+#define RTL8169_EEMODE_PRG 0x80 // EEPROM Programming mode
+
+#define RTL8169_MAX_FIFO_SIZE 1024
+#define RTL8169_MAC_SIZE 6
+#define RTL8169_MAX_PKT_SIZE 0x4000
+
+typedef struct {
+    rvvm_addr_t addr;
+    uint32_t index;
+} rtl8169_ring_t;
+
+// 93C56 16-bit word EEPROM emulation for reading MAC
+typedef struct {
+    uint8_t  pins;
+    uint8_t  addr;
+    uint16_t word;
+    bitcnt_t cur_bit;
+    bool     addr_ok;
+} at93c56_state_t;
+
+typedef struct {
+    pci_dev_t* pci_dev;
+    tap_dev_t* tap;
+    at93c56_state_t eeprom;
+    rtl8169_ring_t rx;
+    rtl8169_ring_t tx;
+    rtl8169_ring_t txp;
+    spinlock_t lock;
+    spinlock_t rx_lock;
+    uint32_t cr;
+    uint32_t phyar;
+    uint32_t imr;
+    uint32_t isr;
+    uint8_t  mac[RTL8169_MAC_SIZE];
+    // Descriptor segmentation reassembly buffer
+    uint8_t  seg_buff[RTL8169_MAX_PKT_SIZE];
+    size_t   seg_size;
+} rtl8169_dev_t;
+
+static void rtl8169_reset(rvvm_mmio_dev_t* dev)
+{
+    rtl8169_dev_t* rtl8169 = dev->data;
+    memset(&rtl8169->eeprom, 0, sizeof(at93c56_state_t));
+    memset(&rtl8169->rx, 0, sizeof(rtl8169_ring_t));
+    memset(&rtl8169->tx, 0, sizeof(rtl8169_ring_t));
+    memset(&rtl8169->txp, 0, sizeof(rtl8169_ring_t));
+    rtl8169->isr = 0;
+    rtl8169->imr = 0;
+    rtl8169->cr = 0;
+    rtl8169->phyar = 0;
+}
+
+static void rtl8169_interrupt(rtl8169_dev_t* rtl8169, size_t irq)
+{
+    uint32_t irqs = atomic_or_uint32(&rtl8169->isr, (1U << irq)) | (1U << irq);
+    if (irqs & atomic_load_uint32(&rtl8169->imr)) pci_send_irq(rtl8169->pci_dev, 0);
+}
+
+static uint32_t rtl8169_handle_phy(uint32_t cmd)
+{
+    uint32_t reg = (cmd >> 16) & 0x1F;
+    cmd &= 0xFFFF0000;
+    switch (reg) {
+        case RTL8169_PHY_BMCR:
+            cmd |= 0x0140; // Full-duplex 1Gbps
+            break;
+        case RTL8169_PHY_BMSR:
+            cmd |= 0x796D; // Link is up; Supports GBESR
+            break;
+        case RTL8169_PHY_ID1:
+            cmd |= 0x001C; // Realtek
+            break;
+        case RTL8169_PHY_ID2:
+            cmd |= 0xC800; // Generic 1 GBps PHY
+            break;
+        case RTL8169_PHY_GBCR:
+            cmd |= 0x0300; // Advertise 1000BASE-T Full/Half duplex
+            break;
+        case RTL8169_PHY_GBSR:
+            cmd |= 0x3C00; // Link partner is capable of 1000BASE-T Full/Half duplex
+            break;
+        case RTL8169_PHY_GBESR:
+            cmd |= 0x3000; // 1000BASE-T Full/Half duplex capable
+            break;
+        case 0x12:
+            cmd |= 0x0200; // Advertise a 10 Gbps link (Use 0x0400 for 1 Gbps)
+            break;
+    }
+    return cmd ^ 0x80000000;
+}
+
+static void rtl8169_93c56_read_word(rtl8169_dev_t* rtl8169)
+{
+    rtl8169->eeprom.word = 0;
+    switch (rtl8169->eeprom.addr) {
+        case 0x0: // Device ID
+            rtl8169->eeprom.word = 0x8129;
+            break;
+        case 0x7: // MAC words
+        case 0x8:
+        case 0x9:
+            tap_get_mac(rtl8169->tap, rtl8169->mac);
+            rtl8169->eeprom.word = read_uint16_le_m(rtl8169->mac + ((rtl8169->eeprom.addr - 7) << 1));
+            break;
+        default: // Unknown
+            rtl8169->eeprom.word = 0;
+            break;
+    }
+}
+
+static void rtl8169_93c56_pins_write(rtl8169_dev_t* rtl8169, uint8_t pins)
+{
+    if (pins & RTL8169_EEMODE_PRG) {
+        if ((pins & RTL8169_EEPROM_CLK) && !(rtl8169->eeprom.pins & RTL8169_EEPROM_CLK)) {
+            // Clock pulled high
+            if (rtl8169->eeprom.addr_ok) {
+                // Push data bits
+                if (rtl8169->eeprom.cur_bit == 0) rtl8169_93c56_read_word(rtl8169);
+                if (rtl8169->eeprom.word & (0x8000 >> rtl8169->eeprom.cur_bit)) {
+                    pins |= RTL8169_EEPROM_DOU;
+                } else {
+                    pins &= ~RTL8169_EEPROM_DOU;
+                }
+                if (rtl8169->eeprom.cur_bit++ >= 15) {
+                    rtl8169->eeprom.cur_bit = 0;
+                    rtl8169->eeprom.addr++;
+                }
+            } else {
+                // Get starting addr, ignore command (Act as readonly eeprom)
+                if (rtl8169->eeprom.cur_bit >= 3) {
+                    rtl8169->eeprom.addr <<= 1;
+                    if (pins & RTL8169_EEPROM_DIN) rtl8169->eeprom.addr |= 1;
+                }
+                if (rtl8169->eeprom.cur_bit++ >= 11) {
+                    rtl8169->eeprom.cur_bit = 0;
+                    rtl8169->eeprom.addr_ok = true;
+                }
+            }
+        }
+        if (!(pins & RTL8169_EEPROM_SEL)) {
+            // End of transfer, request addr next time
+            rtl8169->eeprom.addr_ok = false;
+            rtl8169->eeprom.addr = 0;
+            rtl8169->eeprom.cur_bit = 0;
+        }
+    }
+    rtl8169->eeprom.pins = pins;
+}
+
+static bool rtl8169_feed_rx(void* net_dev, const void* data, size_t size)
+{
+    rtl8169_dev_t* rtl8169 = net_dev;
+    // Receiver disabled
+    if (!(atomic_load_uint32(&rtl8169->cr) & RTL8169_CR_RE)) return false;
+
+    spin_lock(&rtl8169->rx_lock);
+    uint8_t* cmd = pci_get_dma_ptr(rtl8169->pci_dev, rtl8169->rx.addr + (rtl8169->rx.index << 4), 16);
+    // FIFO DMA error
+    if (cmd == NULL) {
+        spin_unlock(&rtl8169->rx_lock);
+        return false;
+    }
+
+    uint32_t flags = read_uint32_le(cmd);
+    // FIFO overflow
+    if (!(flags & RTL8169_DESC_OWN)) {
+        spin_unlock(&rtl8169->rx_lock);
+        rtl8169_interrupt(rtl8169, RTL8169_IRQ_FOV);
+        return false;
+    }
+
+    rvvm_addr_t packet_addr = read_uint64_le(cmd + 8);
+    size_t packet_size = flags & 0x3FFF;
+    uint8_t* packet_ptr = pci_get_dma_ptr(rtl8169->pci_dev, packet_addr, packet_size);
+    // Packet DMA error
+    if (packet_ptr == NULL || packet_size < size + 4) {
+        spin_unlock(&rtl8169->rx_lock);
+        rtl8169_interrupt(rtl8169, RTL8169_IRQ_RER);
+        return false;
+    }
+
+    memcpy(packet_ptr, data, size);
+    memset(packet_ptr + size, 0, 4); // Append fake CRC32
+
+    write_uint32_le(cmd, (flags & RTL8169_DESC_EOR) | RTL8169_DESC_GRX | (size + 4));
+    rtl8169->rx.index++;
+    if ((flags & RTL8169_DESC_EOR) || rtl8169->rx.index >= RTL8169_MAX_FIFO_SIZE) {
+        rtl8169->rx.index = 0;
+    }
+
+    spin_unlock(&rtl8169->rx_lock);
+    rtl8169_interrupt(rtl8169, RTL8169_IRQ_ROK);
+    return true;
+}
+
+static void rtl8169_handle_tx(rtl8169_dev_t* rtl8169, rtl8169_ring_t* ring)
+{
+    size_t tx_id = ring->index;
+    bool tx_irq = false;
+
+    if (rtl8169->cr & RTL8169_CR_TE) do {
+        uint8_t* cmd = pci_get_dma_ptr(rtl8169->pci_dev, ring->addr + (ring->index << 4), 16);
+        // FIFO DMA error
+        if (cmd == NULL) break;
+
+        uint32_t flags = read_uint32_le(cmd);
+        // Nothing to transmit
+        if (!(flags & RTL8169_DESC_OWN)) break;
+
+        rvvm_addr_t packet_addr = read_uint64_le(cmd + 8);
+        size_t packet_size = flags & 0x3FFF;
+        void* packet_ptr = pci_get_dma_ptr(rtl8169->pci_dev, packet_addr, packet_size);
+
+        if (packet_ptr) {
+            if ((flags & RTL8169_DESC_FS) && (flags & RTL8169_DESC_LS)) {
+                // This is a non-segmented packet, just send directly
+                tap_send(rtl8169->tap, packet_ptr, packet_size);
+            } else {
+                // Reassemble segmented packet from descriptors
+                if (flags & RTL8169_DESC_FS) rtl8169->seg_size = 0;
+                if (rtl8169->seg_size + packet_size <= RTL8169_MAX_PKT_SIZE) {
+                    memcpy(rtl8169->seg_buff + rtl8169->seg_size, packet_ptr, packet_size);
+                    rtl8169->seg_size += packet_size;
+                    if (flags & RTL8169_DESC_LS) {
+                        tap_send(rtl8169->tap, rtl8169->seg_buff, rtl8169->seg_size);
+                        rtl8169->seg_size = 0;
+                    }
+                } else rtl8169->seg_size = -1;
+            }
+        }
+
+        write_uint32_le(cmd, flags & ~RTL8169_DESC_OWN);
+        ring->index++;
+        if (!!(flags & RTL8169_DESC_EOR) || ring->index >= RTL8169_MAX_FIFO_SIZE) {
+            ring->index = 0;
+        }
+
+        tx_irq = true;
+    } while (tx_id != ring->index);
+    if (tx_irq) rtl8169_interrupt(rtl8169, RTL8169_IRQ_TOK);
+}
+
+static bool rtl8169_pci_read(rvvm_mmio_dev_t* dev, void* data, size_t offset, uint8_t size)
+{
+    rtl8169_dev_t* rtl8169 = dev->data;
+    uint8_t tmp[4] = {0};
+    spin_lock(&rtl8169->lock);
+    switch (offset & (~0x3)) {
+        case RTL8169_REG_IDR0:
+            tap_get_mac(rtl8169->tap, rtl8169->mac);
+            memcpy(tmp, rtl8169->mac, 4);
+            break;
+        case RTL8169_REG_IDR4:
+            tap_get_mac(rtl8169->tap, rtl8169->mac);
+            memcpy(tmp, rtl8169->mac + 4, 2);
+            break;
+        case RTL8169_REG_IMR:
+            write_uint16_le(tmp, atomic_load_uint32(&rtl8169->imr));
+            write_uint16_le(tmp + 2, atomic_load_uint32(&rtl8169->isr));
+            break;
+        case RTL8169_REG_CR - 3:
+            write_uint8(tmp + 3, atomic_load_uint32(&rtl8169->cr));
+            break;
+        case RTL8169_REG_TCR:
+            // XID decodes as (txconfig >> 20) & 0xfcf
+            write_uint32_le(tmp, 0x3010700 | (0x008 << 20)); // RTL8169S XID
+            break;
+        case RTL8169_REG_9346:
+            tmp[0] = rtl8169->eeprom.pins;
+            break;
+        case RTL8169_REG_PHYAR:
+            write_uint32_le(tmp, rtl8169->phyar);
+            break;
+        case RTL8169_REG_PHYS:
+            write_uint32_le(tmp, 0x73); // 1Gbps Full/Half
+            break;
+        case RTL8169_REG_TXDA1:
+            write_uint32_le(tmp, rtl8169->tx.addr);
+            break;
+        case RTL8169_REG_TXDA2:
+            write_uint32_le(tmp, rtl8169->tx.addr >> 32);
+            break;
+        case RTL8169_REG_TXHA1:
+            write_uint32_le(tmp, rtl8169->txp.addr);
+            break;
+        case RTL8169_REG_TXHA2:
+            write_uint32_le(tmp, rtl8169->txp.addr >> 32);
+            break;
+        case RTL8169_REG_RXDA1:
+            write_uint32_le(tmp, rtl8169->rx.addr);
+            break;
+        case RTL8169_REG_RXDA2:
+            write_uint32_le(tmp, rtl8169->rx.addr >> 32);
+            break;
+        case RTL8169_REG_RMS - 2:
+            write_uint32_le(tmp, 0x3FFF << 16);
+            break;
+        case RTL8169_REG_MTPS:
+            write_uint32_le(tmp, 0x3B);
+            break;
+    }
+    spin_unlock(&rtl8169->lock);
+    memcpy(data, tmp + (offset & 0x3), size);
+    //rvvm_warn("rtl8169 read  %08x from %08zx", read_uint32_le(tmp), offset & (~0x3));
+    return true;
+}
+
+static bool rtl8169_pci_write(rvvm_mmio_dev_t* dev, void* data, size_t offset, uint8_t size)
+{
+    rtl8169_dev_t* rtl8169 = dev->data;
+    //rvvm_warn("rtl8169 write %08x to   %08zx", read_uint32_le(data), offset);
+    spin_lock(&rtl8169->lock);
+    // I don't even know how to refactor this...
+    if (offset == RTL8169_REG_TPOLL) {
+        uint8_t flags = read_uint8(data);
+        if (flags & RTL8169_TPOLL_HPQ) rtl8169_handle_tx(rtl8169, &rtl8169->txp);
+        if (flags & RTL8169_TPOLL_NPQ) rtl8169_handle_tx(rtl8169, &rtl8169->tx);
+        if (flags & RTL8169_TPOLL_FSW) rtl8169_interrupt(rtl8169, RTL8169_IRQ_SWI);
+    } else if (offset == RTL8169_REG_CR) {
+        atomic_store_uint32(&rtl8169->cr, read_uint8(data) & RTL8169_CR_RW);
+        if (read_uint8(data) & RTL8169_CR_RST) rtl8169_reset(dev);
+    } else if (offset < RTL8169_MAC_SIZE) {
+        size_t size_clamp = (offset + size > RTL8169_MAC_SIZE)
+                        ? (RTL8169_MAC_SIZE - offset) : size;
+        memcpy(rtl8169->mac + offset, data, size_clamp);
+        tap_set_mac(rtl8169->tap, rtl8169->mac);
+    } else if (offset == RTL8169_REG_9346) rtl8169_93c56_pins_write(rtl8169, read_uint8(data));
+
+    if (size >= 2) {
+        switch (offset) {
+            case RTL8169_REG_IMR:
+                atomic_store_uint32(&rtl8169->imr, read_uint16_le(data));
+                if (atomic_load_uint32(&rtl8169->isr) & atomic_load_uint32(&rtl8169->imr)) {
+                    pci_send_irq(rtl8169->pci_dev, 0);
+                }
+                break;
+            case RTL8169_REG_ISR:
+                atomic_and_uint32(&rtl8169->isr, ~read_uint16_le(data));
+                break;
+        }
+    }
+    if (size >= 4) {
+        switch (offset) {
+            case RTL8169_REG_TXDA1:
+                rtl8169->tx.addr = bit_replace(rtl8169->tx.addr, 0, 32, read_uint32_le(data) & ~0xFFU);
+                break;
+            case RTL8169_REG_TXDA2:
+                rtl8169->tx.addr = bit_replace(rtl8169->tx.addr, 32, 32, read_uint32_le(data));
+                break;
+            case RTL8169_REG_TXHA1:
+                rtl8169->txp.addr = bit_replace(rtl8169->txp.addr, 0, 32, read_uint32_le(data) & ~0xFFU);
+                break;
+            case RTL8169_REG_TXHA2:
+                rtl8169->txp.addr = bit_replace(rtl8169->txp.addr, 32, 32, read_uint32_le(data));
+                break;
+            case RTL8169_REG_RXDA1:
+                rtl8169->rx.addr = bit_replace(rtl8169->rx.addr, 0, 32, read_uint32_le(data) & ~0xFFU);
+                break;
+            case RTL8169_REG_RXDA2:
+                rtl8169->rx.addr = bit_replace(rtl8169->rx.addr, 32, 32, read_uint32_le(data));
+                break;
+            case RTL8169_REG_PHYAR:
+                rtl8169->phyar = rtl8169_handle_phy(read_uint32_le(data));
+                break;
+        }
+    }
+    spin_unlock(&rtl8169->lock);
+    return true;
+}
+
+static void rtl8169_remove(rvvm_mmio_dev_t* dev)
+{
+    rtl8169_dev_t* rtl8169 = dev->data;
+    tap_close(rtl8169->tap);
+    free(rtl8169);
+}
+
+static rvvm_mmio_type_t rtl8169_type = {
+    .name = "rtl8169",
+    .remove = rtl8169_remove,
+    .reset = rtl8169_reset,
+};
+
+PUBLIC pci_dev_t* rtl8169_init(pci_bus_t* pci_bus, tap_dev_t* tap)
+{
+    rtl8169_dev_t* rtl8169 = safe_new_obj(rtl8169_dev_t);
+    tap_net_dev_t nic = {
+        .net_dev = rtl8169,
+        .feed_rx = rtl8169_feed_rx,
+    };
+
+    rtl8169->tap = tap;
+    tap_attach(tap, &nic);
+    if (rtl8169->tap == NULL) {
+        rvvm_error("Failed to create TAP device!");
+        free(rtl8169);
+        return NULL;
+    }
+
+    pci_dev_desc_t rtl8169_desc = {
+        .func[0] = {
+            .vendor_id = 0x10EC,  // Realtek
+            .device_id = 0x8169,  // RTL8169 Gigabit NIC
+            .class_code = 0x0200, // Ethernet
+            .irq_pin = PCI_IRQ_PIN_INTA,
+            .bar[1] = {
+                .size = 0x100,
+                .min_op_size = 1,
+                .max_op_size = 4,
+                .read = rtl8169_pci_read,
+                .write = rtl8169_pci_write,
+                .data = rtl8169,
+                .type = &rtl8169_type,
+            },
+        }
+    };
+
+    pci_dev_t* pci_dev = pci_bus_add_device(pci_bus, &rtl8169_desc);
+    if (pci_dev) rtl8169->pci_dev = pci_dev;
+    return pci_dev;
+}
+
+PUBLIC pci_dev_t* rtl8169_init_auto(rvvm_machine_t* machine)
+{
+    tap_dev_t* tap = tap_open();
+    if (tap == NULL) {
+        rvvm_error("Failed to create TAP device!");
+        return NULL;
+    }
+    return rtl8169_init(rvvm_get_pci_bus(machine), tap);
+}
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/devices/rtl8169.h b/app/src/main/java/libengine/RVVM/src/devices/rtl8169.h
new file mode 100644
index 00000000..ef726288
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/rtl8169.h
@@ -0,0 +1,28 @@
+/*
+rtl8169.h - Realtek RTL8169 NIC
+Copyright (C) 2022  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef RVVM_RTL8169_H
+#define RVVM_RTL8169_H
+
+#include "pci-bus.h"
+#include "tap_api.h"
+
+PUBLIC pci_dev_t* rtl8169_init(pci_bus_t* pci_bus, tap_dev_t* tap);
+PUBLIC pci_dev_t* rtl8169_init_auto(rvvm_machine_t* machine);
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/devices/sdl_window.c b/app/src/main/java/libengine/RVVM/src/devices/sdl_window.c
new file mode 100644
index 00000000..7400678c
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/sdl_window.c
@@ -0,0 +1,666 @@
+/*
+sdl_window.c - SDL RVVM Window
+Copyright (C) 2022  LekKit <github.com/LekKit>
+
+This Source Code Form is subject to the terms of the Mozilla Public
+License, v. 2.0. If a copy of the MPL was not distributed with this
+file, You can obtain one at https://mozilla.org/MPL/2.0/.
+
+Alternatively, the contents of this file may be used under the terms
+of the GNU General Public License as published by the Free Software
+Foundation, either version 3 of the License, or any later version.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "gui_window.h"
+#include "../dlib.h"
+#include "../vma_ops.h"
+#include "../utils.h"
+#include "../compiler.h"
+
+#if !defined(__EMSCRIPTEN__) && !defined(_MSC_VER)
+#define SDL_DYNAMIC_LOADING
+#endif
+
+// Resolve symbols at runtime
+#define SDL_DLIB_SYM(sym) static typeof(sym)* sym##_dlib = NULL;
+
+// Check for SDL1 header presence
+#if USE_SDL == 1 && !CHECK_INCLUDE(SDL/SDL.h)
+#undef USE_SDL
+#warning Disabling USE_SDL as <SDL/SDL.h> is unavailable
+#endif
+
+// Check for SDL2 header presence
+#if USE_SDL == 2 && !CHECK_INCLUDE(SDL2/SDL.h)
+#undef USE_SDL
+#warning Disabling USE_SDL as <SDL2/SDL.h> is unavailable
+#endif
+
+#ifdef USE_SDL
+
+
+#if USE_SDL == 2
+#include <SDL2/SDL.h>
+
+#define SDL_LIB_NAME "SDL2"
+
+#ifdef SDL_DYNAMIC_LOADING
+SDL_DLIB_SYM(SDL_UpdateWindowSurface)
+SDL_DLIB_SYM(SDL_UpdateTexture)
+SDL_DLIB_SYM(SDL_RenderCopy)
+SDL_DLIB_SYM(SDL_RenderPresent)
+SDL_DLIB_SYM(SDL_GetRelativeMouseState)
+SDL_DLIB_SYM(SDL_SetWindowGrab)
+SDL_DLIB_SYM(SDL_SetWindowKeyboardGrab)
+SDL_DLIB_SYM(SDL_SetRelativeMouseMode)
+SDL_DLIB_SYM(SDL_SetWindowTitle)
+SDL_DLIB_SYM(SDL_DestroyTexture)
+SDL_DLIB_SYM(SDL_DestroyRenderer)
+SDL_DLIB_SYM(SDL_DestroyWindow)
+SDL_DLIB_SYM(SDL_GetCurrentVideoDriver)
+SDL_DLIB_SYM(SDL_SetHint)
+SDL_DLIB_SYM(SDL_CreateWindow)
+SDL_DLIB_SYM(SDL_GetWindowSurface)
+SDL_DLIB_SYM(SDL_CreateRenderer)
+SDL_DLIB_SYM(SDL_CreateTexture)
+
+#define SDL_UpdateWindowSurface SDL_UpdateWindowSurface_dlib
+#define SDL_UpdateTexture SDL_UpdateTexture_dlib
+#define SDL_RenderCopy SDL_RenderCopy_dlib
+#define SDL_RenderPresent SDL_RenderPresent_dlib
+#define SDL_GetRelativeMouseState SDL_GetRelativeMouseState_dlib
+#define SDL_SetWindowGrab SDL_SetWindowGrab_dlib
+#define SDL_SetWindowKeyboardGrab SDL_SetWindowKeyboardGrab_dlib
+#define SDL_SetRelativeMouseMode SDL_SetRelativeMouseMode_dlib
+#define SDL_SetWindowTitle SDL_SetWindowTitle_dlib
+#define SDL_DestroyTexture SDL_DestroyTexture_dlib
+#define SDL_DestroyRenderer SDL_DestroyRenderer_dlib
+#define SDL_DestroyWindow SDL_DestroyWindow_dlib
+#define SDL_GetCurrentVideoDriver SDL_GetCurrentVideoDriver_dlib
+#define SDL_SetHint SDL_SetHint_dlib
+#define SDL_CreateWindow SDL_CreateWindow_dlib
+#define SDL_GetWindowSurface SDL_GetWindowSurface_dlib
+#define SDL_CreateRenderer SDL_CreateRenderer_dlib
+#define SDL_CreateTexture SDL_CreateTexture_dlib
+#endif
+
+static const hid_key_t sdl_key_to_hid_byte_map[] = {
+    [SDL_SCANCODE_A] = HID_KEY_A,
+    [SDL_SCANCODE_B] = HID_KEY_B,
+    [SDL_SCANCODE_C] = HID_KEY_C,
+    [SDL_SCANCODE_D] = HID_KEY_D,
+    [SDL_SCANCODE_E] = HID_KEY_E,
+    [SDL_SCANCODE_F] = HID_KEY_F,
+    [SDL_SCANCODE_G] = HID_KEY_G,
+    [SDL_SCANCODE_H] = HID_KEY_H,
+    [SDL_SCANCODE_I] = HID_KEY_I,
+    [SDL_SCANCODE_J] = HID_KEY_J,
+    [SDL_SCANCODE_K] = HID_KEY_K,
+    [SDL_SCANCODE_L] = HID_KEY_L,
+    [SDL_SCANCODE_M] = HID_KEY_M,
+    [SDL_SCANCODE_N] = HID_KEY_N,
+    [SDL_SCANCODE_O] = HID_KEY_O,
+    [SDL_SCANCODE_P] = HID_KEY_P,
+    [SDL_SCANCODE_Q] = HID_KEY_Q,
+    [SDL_SCANCODE_R] = HID_KEY_R,
+    [SDL_SCANCODE_S] = HID_KEY_S,
+    [SDL_SCANCODE_T] = HID_KEY_T,
+    [SDL_SCANCODE_U] = HID_KEY_U,
+    [SDL_SCANCODE_V] = HID_KEY_V,
+    [SDL_SCANCODE_W] = HID_KEY_W,
+    [SDL_SCANCODE_X] = HID_KEY_X,
+    [SDL_SCANCODE_Y] = HID_KEY_Y,
+    [SDL_SCANCODE_Z] = HID_KEY_Z,
+    [SDL_SCANCODE_0] = HID_KEY_0,
+    [SDL_SCANCODE_1] = HID_KEY_1,
+    [SDL_SCANCODE_2] = HID_KEY_2,
+    [SDL_SCANCODE_3] = HID_KEY_3,
+    [SDL_SCANCODE_4] = HID_KEY_4,
+    [SDL_SCANCODE_5] = HID_KEY_5,
+    [SDL_SCANCODE_6] = HID_KEY_6,
+    [SDL_SCANCODE_7] = HID_KEY_7,
+    [SDL_SCANCODE_8] = HID_KEY_8,
+    [SDL_SCANCODE_9] = HID_KEY_9,
+    [SDL_SCANCODE_RETURN] = HID_KEY_ENTER,
+    [SDL_SCANCODE_ESCAPE] = HID_KEY_ESC,
+    [SDL_SCANCODE_BACKSPACE] = HID_KEY_BACKSPACE,
+    [SDL_SCANCODE_TAB] = HID_KEY_TAB,
+    [SDL_SCANCODE_SPACE] = HID_KEY_SPACE,
+    [SDL_SCANCODE_MINUS] = HID_KEY_MINUS,
+    [SDL_SCANCODE_EQUALS] = HID_KEY_EQUAL,
+    [SDL_SCANCODE_LEFTBRACKET] = HID_KEY_LEFTBRACE,
+    [SDL_SCANCODE_RIGHTBRACKET] = HID_KEY_RIGHTBRACE,
+    [SDL_SCANCODE_BACKSLASH] = HID_KEY_BACKSLASH,
+    [SDL_SCANCODE_SEMICOLON] = HID_KEY_SEMICOLON,
+    [SDL_SCANCODE_APOSTROPHE] = HID_KEY_APOSTROPHE,
+    [SDL_SCANCODE_GRAVE] = HID_KEY_GRAVE,
+    [SDL_SCANCODE_COMMA] = HID_KEY_COMMA,
+    [SDL_SCANCODE_PERIOD] = HID_KEY_DOT,
+    [SDL_SCANCODE_SLASH] = HID_KEY_SLASH,
+    [SDL_SCANCODE_CAPSLOCK] = HID_KEY_CAPSLOCK,
+    [SDL_SCANCODE_F1] = HID_KEY_F1,
+    [SDL_SCANCODE_F2] = HID_KEY_F2,
+    [SDL_SCANCODE_F3] = HID_KEY_F3,
+    [SDL_SCANCODE_F4] = HID_KEY_F4,
+    [SDL_SCANCODE_F5] = HID_KEY_F5,
+    [SDL_SCANCODE_F6] = HID_KEY_F6,
+    [SDL_SCANCODE_F7] = HID_KEY_F7,
+    [SDL_SCANCODE_F8] = HID_KEY_F8,
+    [SDL_SCANCODE_F9] = HID_KEY_F9,
+    [SDL_SCANCODE_F10] = HID_KEY_F10,
+    [SDL_SCANCODE_F11] = HID_KEY_F11,
+    [SDL_SCANCODE_F12] = HID_KEY_F12,
+    [SDL_SCANCODE_SYSREQ] = HID_KEY_SYSRQ,
+    [SDL_SCANCODE_SCROLLLOCK] = HID_KEY_SCROLLLOCK,
+    [SDL_SCANCODE_PAUSE] = HID_KEY_PAUSE,
+    [SDL_SCANCODE_INSERT] = HID_KEY_INSERT,
+    [SDL_SCANCODE_HOME] = HID_KEY_HOME,
+    [SDL_SCANCODE_PAGEUP] = HID_KEY_PAGEUP,
+    [SDL_SCANCODE_DELETE] = HID_KEY_DELETE,
+    [SDL_SCANCODE_END] = HID_KEY_END,
+    [SDL_SCANCODE_PAGEDOWN] = HID_KEY_PAGEDOWN,
+    [SDL_SCANCODE_RIGHT] = HID_KEY_RIGHT,
+    [SDL_SCANCODE_LEFT] = HID_KEY_LEFT,
+    [SDL_SCANCODE_DOWN] = HID_KEY_DOWN,
+    [SDL_SCANCODE_UP] = HID_KEY_UP,
+    [SDL_SCANCODE_NUMLOCKCLEAR] = HID_KEY_NUMLOCK,
+    [SDL_SCANCODE_KP_DIVIDE] = HID_KEY_KPSLASH,
+    [SDL_SCANCODE_KP_MULTIPLY] = HID_KEY_KPASTERISK,
+    [SDL_SCANCODE_KP_MINUS] = HID_KEY_KPMINUS,
+    [SDL_SCANCODE_KP_PLUS] = HID_KEY_KPPLUS,
+    [SDL_SCANCODE_KP_ENTER] = HID_KEY_KPENTER,
+    [SDL_SCANCODE_KP_1] = HID_KEY_KP1,
+    [SDL_SCANCODE_KP_2] = HID_KEY_KP2,
+    [SDL_SCANCODE_KP_3] = HID_KEY_KP3,
+    [SDL_SCANCODE_KP_4] = HID_KEY_KP4,
+    [SDL_SCANCODE_KP_5] = HID_KEY_KP5,
+    [SDL_SCANCODE_KP_6] = HID_KEY_KP6,
+    [SDL_SCANCODE_KP_7] = HID_KEY_KP7,
+    [SDL_SCANCODE_KP_8] = HID_KEY_KP8,
+    [SDL_SCANCODE_KP_9] = HID_KEY_KP9,
+    [SDL_SCANCODE_KP_0] = HID_KEY_KP0,
+    [SDL_SCANCODE_KP_PERIOD] = HID_KEY_KPDOT,
+    [SDL_SCANCODE_APPLICATION] = HID_KEY_COMPOSE,
+    [SDL_SCANCODE_KP_EQUALS] = HID_KEY_KPEQUAL,
+    [SDL_SCANCODE_INTERNATIONAL1] = HID_KEY_RO,
+    [SDL_SCANCODE_INTERNATIONAL2] = HID_KEY_KATAKANAHIRAGANA,
+    [SDL_SCANCODE_INTERNATIONAL3] = HID_KEY_YEN,
+    [SDL_SCANCODE_INTERNATIONAL4] = HID_KEY_HENKAN,
+    [SDL_SCANCODE_INTERNATIONAL5] = HID_KEY_MUHENKAN,
+    [SDL_SCANCODE_INTERNATIONAL6] = HID_KEY_KPJPCOMMA,
+    [SDL_SCANCODE_LANG1] = HID_KEY_HANGEUL,
+    [SDL_SCANCODE_LANG2] = HID_KEY_HANJA,
+    [SDL_SCANCODE_LANG3] = HID_KEY_KATAKANA,
+    [SDL_SCANCODE_LANG4] = HID_KEY_HIRAGANA,
+    [SDL_SCANCODE_LANG5] = HID_KEY_ZENKAKUHANKAKU,
+    [SDL_SCANCODE_MENU] = HID_KEY_MENU,
+    [SDL_SCANCODE_LCTRL] = HID_KEY_LEFTCTRL,
+    [SDL_SCANCODE_LSHIFT] = HID_KEY_LEFTSHIFT,
+    [SDL_SCANCODE_LALT] = HID_KEY_LEFTALT,
+    [SDL_SCANCODE_LGUI] = HID_KEY_LEFTMETA,
+    [SDL_SCANCODE_RCTRL] = HID_KEY_RIGHTCTRL,
+    [SDL_SCANCODE_RSHIFT] = HID_KEY_RIGHTSHIFT,
+    [SDL_SCANCODE_RALT] = HID_KEY_RIGHTALT,
+    [SDL_SCANCODE_RGUI] = HID_KEY_RIGHTMETA,
+};
+
+#else
+#include <SDL/SDL.h>
+
+#define SDL_LIB_NAME "SDL"
+
+#ifdef SDL_DYNAMIC_LOADING
+SDL_DLIB_SYM(SDL_FreeSurface)
+SDL_DLIB_SYM(SDL_Flip)
+SDL_DLIB_SYM(SDL_WM_GrabInput)
+SDL_DLIB_SYM(SDL_WM_SetCaption)
+SDL_DLIB_SYM(SDL_SetVideoMode)
+
+#define SDL_FreeSurface SDL_FreeSurface_dlib
+#define SDL_Flip SDL_Flip_dlib
+#define SDL_WM_GrabInput SDL_WM_GrabInput_dlib
+#define SDL_WM_SetCaption SDL_WM_SetCaption_dlib
+#define SDL_SetVideoMode SDL_SetVideoMode_dlib
+#endif
+
+static const hid_key_t sdl_key_to_hid_byte_map[] = {
+    [SDLK_a] = HID_KEY_A,
+    [SDLK_b] = HID_KEY_B,
+    [SDLK_c] = HID_KEY_C,
+    [SDLK_d] = HID_KEY_D,
+    [SDLK_e] = HID_KEY_E,
+    [SDLK_f] = HID_KEY_F,
+    [SDLK_g] = HID_KEY_G,
+    [SDLK_h] = HID_KEY_H,
+    [SDLK_i] = HID_KEY_I,
+    [SDLK_j] = HID_KEY_J,
+    [SDLK_k] = HID_KEY_K,
+    [SDLK_l] = HID_KEY_L,
+    [SDLK_m] = HID_KEY_M,
+    [SDLK_n] = HID_KEY_N,
+    [SDLK_o] = HID_KEY_O,
+    [SDLK_p] = HID_KEY_P,
+    [SDLK_q] = HID_KEY_Q,
+    [SDLK_r] = HID_KEY_R,
+    [SDLK_s] = HID_KEY_S,
+    [SDLK_t] = HID_KEY_T,
+    [SDLK_u] = HID_KEY_U,
+    [SDLK_v] = HID_KEY_V,
+    [SDLK_w] = HID_KEY_W,
+    [SDLK_x] = HID_KEY_X,
+    [SDLK_y] = HID_KEY_Y,
+    [SDLK_z] = HID_KEY_Z,
+    [SDLK_0] = HID_KEY_0,
+    [SDLK_1] = HID_KEY_1,
+    [SDLK_2] = HID_KEY_2,
+    [SDLK_3] = HID_KEY_3,
+    [SDLK_4] = HID_KEY_4,
+    [SDLK_5] = HID_KEY_5,
+    [SDLK_6] = HID_KEY_6,
+    [SDLK_7] = HID_KEY_7,
+    [SDLK_8] = HID_KEY_8,
+    [SDLK_9] = HID_KEY_9,
+    [SDLK_RETURN] = HID_KEY_ENTER,
+    [SDLK_ESCAPE] = HID_KEY_ESC,
+    [SDLK_BACKSPACE] = HID_KEY_BACKSPACE,
+    [SDLK_TAB] = HID_KEY_TAB,
+    [SDLK_SPACE] = HID_KEY_SPACE,
+    [SDLK_MINUS] = HID_KEY_MINUS,
+    [SDLK_EQUALS] = HID_KEY_EQUAL,
+    [SDLK_LEFTBRACKET] = HID_KEY_LEFTBRACE,
+    [SDLK_RIGHTBRACKET] = HID_KEY_RIGHTBRACE,
+    [SDLK_BACKSLASH] = HID_KEY_BACKSLASH,
+    [SDLK_SEMICOLON] = HID_KEY_SEMICOLON,
+    [SDLK_QUOTE] = HID_KEY_APOSTROPHE,
+    [SDLK_BACKQUOTE] = HID_KEY_GRAVE,
+    [SDLK_COMMA] = HID_KEY_COMMA,
+    [SDLK_PERIOD] = HID_KEY_DOT,
+    [SDLK_SLASH] = HID_KEY_SLASH,
+    [SDLK_CAPSLOCK] = HID_KEY_CAPSLOCK,
+    [SDLK_LCTRL] = HID_KEY_LEFTCTRL,
+    [SDLK_LSHIFT] = HID_KEY_LEFTSHIFT,
+    [SDLK_LALT] = HID_KEY_LEFTALT,
+    [SDLK_LMETA] = HID_KEY_LEFTMETA,
+    [SDLK_RCTRL] = HID_KEY_RIGHTCTRL,
+    [SDLK_RSHIFT] = HID_KEY_RIGHTSHIFT,
+    [SDLK_RALT] = HID_KEY_RIGHTALT,
+    [SDLK_RMETA] = HID_KEY_RIGHTMETA,
+    [SDLK_F1] = HID_KEY_F1,
+    [SDLK_F2] = HID_KEY_F2,
+    [SDLK_F3] = HID_KEY_F3,
+    [SDLK_F4] = HID_KEY_F4,
+    [SDLK_F5] = HID_KEY_F5,
+    [SDLK_F6] = HID_KEY_F6,
+    [SDLK_F7] = HID_KEY_F7,
+    [SDLK_F8] = HID_KEY_F8,
+    [SDLK_F9] = HID_KEY_F9,
+    [SDLK_F10] = HID_KEY_F10,
+    [SDLK_F11] = HID_KEY_F11,
+    [SDLK_F12] = HID_KEY_F12,
+    [SDLK_SYSREQ] = HID_KEY_SYSRQ,
+    [SDLK_SCROLLOCK] = HID_KEY_SCROLLLOCK,
+    [SDLK_PAUSE] = HID_KEY_PAUSE,
+    [SDLK_INSERT] = HID_KEY_INSERT,
+    [SDLK_HOME] = HID_KEY_HOME,
+    [SDLK_PAGEUP] = HID_KEY_PAGEUP,
+    [SDLK_DELETE] = HID_KEY_DELETE,
+    [SDLK_END] = HID_KEY_END,
+    [SDLK_PAGEDOWN] = HID_KEY_PAGEDOWN,
+    [SDLK_RIGHT] = HID_KEY_RIGHT,
+    [SDLK_LEFT] = HID_KEY_LEFT,
+    [SDLK_DOWN] = HID_KEY_DOWN,
+    [SDLK_UP] = HID_KEY_UP,
+    [SDLK_NUMLOCK] = HID_KEY_NUMLOCK,
+    [SDLK_KP_DIVIDE] = HID_KEY_KPSLASH,
+    [SDLK_KP_MULTIPLY] = HID_KEY_KPASTERISK,
+    [SDLK_KP_MINUS] = HID_KEY_KPMINUS,
+    [SDLK_KP_PLUS] = HID_KEY_KPPLUS,
+    [SDLK_KP_ENTER] = HID_KEY_KPENTER,
+    [SDLK_KP1] = HID_KEY_KP1,
+    [SDLK_KP2] = HID_KEY_KP2,
+    [SDLK_KP3] = HID_KEY_KP3,
+    [SDLK_KP4] = HID_KEY_KP4,
+    [SDLK_KP5] = HID_KEY_KP5,
+    [SDLK_KP6] = HID_KEY_KP6,
+    [SDLK_KP7] = HID_KEY_KP7,
+    [SDLK_KP8] = HID_KEY_KP8,
+    [SDLK_KP9] = HID_KEY_KP9,
+    [SDLK_KP0] = HID_KEY_KP0,
+    [SDLK_KP_PERIOD] = HID_KEY_KPDOT,
+    [SDLK_MENU] = HID_KEY_MENU,
+#ifdef __EMSCRIPTEN__
+    // I dunno why, I don't want to know why,
+    // but some Emscripten SDL keycodes are plain wrong..
+    [0xbb] = HID_KEY_EQUAL,
+    [0xbd] = HID_KEY_MINUS,
+#endif
+};
+
+#endif
+
+#ifdef SDL_DYNAMIC_LOADING
+SDL_DLIB_SYM(SDL_QuitSubSystem)
+SDL_DLIB_SYM(SDL_LockSurface)
+SDL_DLIB_SYM(SDL_UnlockSurface)
+SDL_DLIB_SYM(SDL_PollEvent)
+SDL_DLIB_SYM(SDL_Init)
+SDL_DLIB_SYM(SDL_ShowCursor)
+
+#define SDL_QuitSubSystem SDL_QuitSubSystem_dlib
+#define SDL_LockSurface SDL_LockSurface_dlib
+#define SDL_UnlockSurface SDL_UnlockSurface_dlib
+#define SDL_PollEvent SDL_PollEvent_dlib
+#define SDL_Init SDL_Init_dlib
+#define SDL_ShowCursor SDL_ShowCursor_dlib
+#endif
+
+static hid_key_t sdl_key_to_hid(uint32_t sdl_key)
+{
+    if (sdl_key < sizeof(sdl_key_to_hid_byte_map)) {
+        return sdl_key_to_hid_byte_map[sdl_key];
+    }
+    rvvm_warn("Unknown SDL keycode %d!", sdl_key);
+    return HID_KEY_NONE;
+}
+
+static hid_key_t sdl_event_to_hid(const SDL_Event* event)
+{
+#if USE_SDL == 2
+    return sdl_key_to_hid(event->key.keysym.scancode);
+#else
+    return sdl_key_to_hid(event->key.keysym.sym);
+#endif
+}
+
+static rgb_fmt_t sdl_get_rgb_format(const SDL_PixelFormat* format)
+{
+    switch (format->BitsPerPixel) {
+        case 16: return RGB_FMT_R5G6B5;
+        case 24: return RGB_FMT_R8G8B8;
+        case 32:
+            if (format->Rmask & 0xFF) {
+                return RGB_FMT_A8B8G8R8;
+            } else {
+                return RGB_FMT_A8R8G8B8;
+            }
+    }
+    return RGB_FMT_INVALID;
+}
+
+#if USE_SDL == 2
+static SDL_Window* sdl_window = NULL;
+static SDL_Renderer* sdl_renderer = NULL;
+static SDL_Texture* sdl_texture = NULL;
+#endif
+static SDL_Surface* sdl_surface = NULL;
+static bool sdl_grabbed = false;
+
+static void sdl_window_draw(gui_window_t* win)
+{
+    if (sdl_surface && win->fb.buffer != sdl_surface->pixels) {
+        // Copy the framebuffer onto a locking surface
+        SDL_LockSurface(sdl_surface);
+        memcpy(sdl_surface->pixels, win->fb.buffer, framebuffer_size(&win->fb));
+        SDL_UnlockSurface(sdl_surface);
+    }
+#if USE_SDL == 2
+    if (sdl_surface) {
+        SDL_UpdateWindowSurface(sdl_window);
+    } else {
+        // Load the framebuffer into a texture and draw onto the screen
+        SDL_UpdateTexture(sdl_texture, NULL, win->fb.buffer, framebuffer_stride(&win->fb));
+        SDL_RenderCopy(sdl_renderer, sdl_texture, NULL, NULL);
+        SDL_RenderPresent(sdl_renderer);
+    }
+#else
+    SDL_Flip(sdl_surface);
+#endif
+}
+
+static void sdl_window_poll(gui_window_t* win)
+{
+    SDL_Event event = {0};
+    while (SDL_PollEvent(&event)) {
+        switch (event.type) {
+            case SDL_KEYDOWN:
+                win->on_key_press(win, sdl_event_to_hid(&event));
+                break;
+            case SDL_KEYUP:
+                win->on_key_release(win, sdl_event_to_hid(&event));
+                break;
+            case SDL_MOUSEMOTION:
+                if (sdl_grabbed) {
+                    win->on_mouse_move(win, event.motion.xrel, event.motion.yrel);
+                } else {
+                    win->on_mouse_place(win, event.motion.x, event.motion.y);
+                }
+                break;
+#if USE_SDL == 2
+            case SDL_MOUSEWHEEL:
+                win->on_mouse_scroll(win, event.wheel.y);
+                break;
+#endif
+            case SDL_MOUSEBUTTONDOWN:
+                if (event.button.button == SDL_BUTTON_LEFT) {
+                    win->on_mouse_press(win, HID_BTN_LEFT);
+                } else if (event.button.button == SDL_BUTTON_MIDDLE) {
+                    win->on_mouse_press(win, HID_BTN_MIDDLE);
+                } else if (event.button.button == SDL_BUTTON_RIGHT) {
+                    win->on_mouse_press(win, HID_BTN_RIGHT);
+#if USE_SDL == 1
+                } else if (event.button.button == SDL_BUTTON_WHEELUP) {
+                    win->on_mouse_scroll(win, HID_SCROLL_UP);
+                } else if (event.button.button == SDL_BUTTON_WHEELDOWN) {
+                    win->on_mouse_scroll(win, HID_SCROLL_DOWN);
+#endif
+                }
+                break;
+            case SDL_MOUSEBUTTONUP:
+                if (event.button.button == SDL_BUTTON_LEFT) {
+                    win->on_mouse_release(win, HID_BTN_LEFT);
+                } else if (event.button.button == SDL_BUTTON_MIDDLE) {
+                    win->on_mouse_release(win, HID_BTN_MIDDLE);
+                } else if (event.button.button == SDL_BUTTON_RIGHT) {
+                    win->on_mouse_release(win, HID_BTN_RIGHT);
+                }
+                break;
+            case SDL_QUIT:
+                win->on_close(win);
+                break;
+#if USE_SDL == 2
+            case SDL_WINDOWEVENT:
+                if (event.window.event == SDL_WINDOWEVENT_FOCUS_LOST) {
+                    win->on_focus_lost(win);
+                }
+                break;
+#else
+            case SDL_ACTIVEEVENT:
+                if (event.active.state == SDL_APPINPUTFOCUS && !event.active.gain) {
+                    win->on_focus_lost(win);
+                }
+                break;
+#endif
+        }
+    }
+}
+
+static void sdl_window_grab_input(gui_window_t* win, bool grab)
+{
+    UNUSED(win);
+    sdl_grabbed = grab;
+#if USE_SDL == 2
+    SDL_SetWindowGrab(sdl_window, grab);
+    SDL_SetWindowKeyboardGrab(sdl_window, grab);
+    SDL_SetRelativeMouseMode(grab);
+#else
+    SDL_WM_GrabInput(grab ? SDL_GRAB_ON : SDL_GRAB_OFF);
+#endif
+}
+
+static void sdl_window_set_title(gui_window_t* win, const char* title)
+{
+    UNUSED(win);
+#if USE_SDL == 2
+    SDL_SetWindowTitle(sdl_window, title);
+#else
+    SDL_WM_SetCaption(title, NULL);
+#endif
+}
+
+static void sdl_window_remove(gui_window_t* win)
+{
+    if (sdl_surface == NULL || win->fb.buffer != sdl_surface->pixels) {
+        vma_free(win->fb.buffer, framebuffer_size(&win->fb));
+    }
+    sdl_window_grab_input(win, false);
+#if USE_SDL == 2
+    if (sdl_texture) SDL_DestroyTexture(sdl_texture);
+    if (sdl_renderer) SDL_DestroyRenderer(sdl_renderer);
+    if (sdl_window) SDL_DestroyWindow(sdl_window);
+    sdl_window = NULL;
+    sdl_renderer = NULL;
+    sdl_texture = NULL;
+#else
+    SDL_FreeSurface(sdl_surface);
+#endif
+    SDL_QuitSubSystem(SDL_INIT_VIDEO);
+    sdl_surface = NULL;
+}
+
+#define SDL_DLIB_RESOLVE(lib, sym) \
+do { \
+    sym = dlib_resolve(lib, #sym);\
+    if (sym == NULL) return false; \
+} while (0)
+
+static bool sdl_init_libs(void)
+{
+#ifdef SDL_DYNAMIC_LOADING
+    dlib_ctx_t* libsdl = dlib_open(SDL_LIB_NAME, DLIB_NAME_PROBE);
+#if USE_SDL == 2
+    SDL_DLIB_RESOLVE(libsdl, SDL_UpdateWindowSurface);
+    SDL_DLIB_RESOLVE(libsdl, SDL_UpdateTexture);
+    SDL_DLIB_RESOLVE(libsdl, SDL_RenderCopy);
+    SDL_DLIB_RESOLVE(libsdl, SDL_RenderPresent);
+    SDL_DLIB_RESOLVE(libsdl, SDL_GetRelativeMouseState);
+    SDL_DLIB_RESOLVE(libsdl, SDL_SetWindowGrab);
+    SDL_DLIB_RESOLVE(libsdl, SDL_SetWindowKeyboardGrab);
+    SDL_DLIB_RESOLVE(libsdl, SDL_SetRelativeMouseMode);
+    SDL_DLIB_RESOLVE(libsdl, SDL_SetWindowTitle);
+    SDL_DLIB_RESOLVE(libsdl, SDL_DestroyTexture);
+    SDL_DLIB_RESOLVE(libsdl, SDL_DestroyRenderer);
+    SDL_DLIB_RESOLVE(libsdl, SDL_DestroyWindow);
+    SDL_DLIB_RESOLVE(libsdl, SDL_GetCurrentVideoDriver);
+    SDL_DLIB_RESOLVE(libsdl, SDL_SetHint);
+    SDL_DLIB_RESOLVE(libsdl, SDL_CreateWindow);
+    SDL_DLIB_RESOLVE(libsdl, SDL_GetWindowSurface);
+    SDL_DLIB_RESOLVE(libsdl, SDL_CreateRenderer);
+    SDL_DLIB_RESOLVE(libsdl, SDL_CreateTexture);
+#else
+    SDL_DLIB_RESOLVE(libsdl, SDL_FreeSurface);
+    SDL_DLIB_RESOLVE(libsdl, SDL_Flip);
+    SDL_DLIB_RESOLVE(libsdl, SDL_WM_GrabInput);
+    SDL_DLIB_RESOLVE(libsdl, SDL_WM_SetCaption);
+    SDL_DLIB_RESOLVE(libsdl, SDL_SetVideoMode);
+#endif
+    SDL_DLIB_RESOLVE(libsdl, SDL_QuitSubSystem);
+    SDL_DLIB_RESOLVE(libsdl, SDL_LockSurface);
+    SDL_DLIB_RESOLVE(libsdl, SDL_UnlockSurface);
+    SDL_DLIB_RESOLVE(libsdl, SDL_PollEvent);
+    SDL_DLIB_RESOLVE(libsdl, SDL_Init);
+    SDL_DLIB_RESOLVE(libsdl, SDL_ShowCursor);
+#endif
+    return true;
+}
+
+bool sdl_window_init(gui_window_t* win)
+{
+    static bool libsdl_avail = false;
+    DO_ONCE(libsdl_avail = sdl_init_libs());
+    if (!libsdl_avail) {
+        rvvm_info("Failed to load libSDL!");
+        return false;
+    }
+
+#ifndef _WIN32
+    DO_ONCE(setenv("SDL_DEBUG", "1", false));
+#endif
+
+    if (sdl_surface) {
+        // SDL_PollEvent is very inconvenient to use, SDL1 doesn't support multiwindow at all
+        rvvm_error("SDL doesn't support multiple windows");
+        return false;
+    }
+    if (SDL_Init(SDL_INIT_VIDEO) < 0) {
+        rvvm_error("Failed to initialize SDL");
+        return false;
+    }
+#if USE_SDL == 2
+    if (rvvm_strcmp(SDL_GetCurrentVideoDriver(), "x11")) {
+        // Prevent messing with the compositor
+        SDL_SetHint(SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR, "0");
+        // Force software flipping (Reduces idle CPU use, prevents issues on messy hosts)
+        SDL_SetHint(SDL_HINT_FRAMEBUFFER_ACCELERATION, "0");
+        SDL_SetHint(SDL_HINT_RENDER_DRIVER, "software");
+    }
+    sdl_window = SDL_CreateWindow("RVVM", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,
+                                  win->fb.width, win->fb.height, SDL_WINDOW_SHOWN);
+    if (sdl_window == NULL) {
+        rvvm_error("SDL_CreateWindow() failed!");
+        return false;
+    }
+    sdl_surface = SDL_GetWindowSurface(sdl_window);
+    if (sdl_surface == NULL) {
+        rvvm_info("No SDL framebuffer surface, using SDL renderer. Expect higher CPU use.");
+        sdl_renderer = SDL_CreateRenderer(sdl_window, -1, 0);
+        sdl_texture = SDL_CreateTexture(sdl_renderer, SDL_PIXELFORMAT_ARGB8888,
+                                        SDL_TEXTUREACCESS_STREAMING, win->fb.width, win->fb.height);
+        win->fb.buffer = vma_alloc(NULL, framebuffer_size(&win->fb), VMA_RDWR);
+    }
+#else
+    sdl_surface = SDL_SetVideoMode(win->fb.width, win->fb.height,
+                    rgb_format_bpp(win->fb.format), SDL_ANYFORMAT);
+    if (sdl_surface == NULL) {
+        rvvm_error("SDL_SetVideoMode() failed!");
+        return false;
+    }
+    SDL_WM_SetCaption("RVVM", NULL);
+#endif
+    SDL_ShowCursor(SDL_DISABLE);
+    if (sdl_surface) {
+        win->fb.format = sdl_get_rgb_format(sdl_surface->format);
+        if (SDL_MUSTLOCK(sdl_surface)) {
+            rvvm_info("SDL surface is locking. Expect higher CPU use.");
+            win->fb.buffer = vma_alloc(NULL, framebuffer_size(&win->fb), VMA_RDWR);
+#ifndef __EMSCRIPTEN__
+        } else if (((size_t)sdl_surface->pixels) & 0xFFF) {
+            rvvm_info("SDL surface is misaligned. Expect higher CPU use.");
+            win->fb.buffer = vma_alloc(NULL, framebuffer_size(&win->fb), VMA_RDWR);
+#endif
+        } else {
+            // Direct page-aligned framebuffer surface, like XShm
+            win->fb.buffer = sdl_surface->pixels;
+        }
+    }
+
+    win->draw = sdl_window_draw;
+    win->poll = sdl_window_poll;
+    win->remove = sdl_window_remove;
+    win->grab_input = sdl_window_grab_input;
+    win->set_title = sdl_window_set_title;
+
+    return true;
+}
+
+#else
+
+bool sdl_window_init(gui_window_t* win)
+{
+    UNUSED(win);
+    return false;
+}
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/devices/syscon.c b/app/src/main/java/libengine/RVVM/src/devices/syscon.c
new file mode 100644
index 00000000..3124fa6a
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/syscon.c
@@ -0,0 +1,86 @@
+/*
+syscon.c - Poweroff/reset syscon device
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "syscon.h"
+#include "../mem_ops.h"
+#include "../fdtlib.h"
+
+#define SYSCON_POWEROFF 0x5555
+#define SYSCON_RESET    0x7777
+
+static bool syscon_mmio_write(rvvm_mmio_dev_t* dev, void* data, size_t offset, uint8_t size)
+{
+    UNUSED(size);
+    if (offset == 0) {
+        switch(read_uint16_le_m(data)) {
+            case SYSCON_POWEROFF:
+            case SYSCON_RESET:
+                rvvm_reset_machine(dev->machine, read_uint16_le_m(data) == SYSCON_RESET);
+                break;
+            default:
+                break;
+        }
+    }
+    return true;
+}
+
+static rvvm_mmio_type_t syscon_dev_type = {
+    .name = "syscon",
+};
+
+PUBLIC rvvm_mmio_dev_t* syscon_init(rvvm_machine_t* machine, rvvm_addr_t base_addr)
+{
+    rvvm_mmio_dev_t syscon = {
+        .addr = base_addr,
+        .size = 0x1000,
+        .read = rvvm_mmio_none,
+        .write = syscon_mmio_write,
+        .min_op_size = 2,
+        .max_op_size = 2,
+        .type = &syscon_dev_type,
+    };
+    rvvm_mmio_dev_t* mmio = rvvm_attach_mmio(machine, &syscon);
+    if (mmio == NULL) return mmio;
+#ifdef USE_FDT
+    struct fdt_node* test = fdt_node_create_reg("test", base_addr);
+    fdt_node_add_prop_reg(test, "reg", base_addr, 0x1000);
+    fdt_node_add_prop(test, "compatible", "sifive,test1\0sifive,test0\0syscon\0", 33);
+    fdt_node_add_child(rvvm_get_fdt_soc(machine), test);
+
+    struct fdt_node* poweroff = fdt_node_create("poweroff");
+    fdt_node_add_prop_str(poweroff, "compatible", "syscon-poweroff");
+    fdt_node_add_prop_u32(poweroff, "value", SYSCON_POWEROFF);
+    fdt_node_add_prop_u32(poweroff, "offset", 0);
+    fdt_node_add_prop_u32(poweroff, "regmap", fdt_node_get_phandle(test));
+    fdt_node_add_child(rvvm_get_fdt_soc(machine), poweroff);
+
+    struct fdt_node* reboot = fdt_node_create("reboot");
+    fdt_node_add_prop_str(reboot, "compatible", "syscon-reboot");
+    fdt_node_add_prop_u32(reboot, "value", SYSCON_RESET);
+    fdt_node_add_prop_u32(reboot, "offset", 0);
+    fdt_node_add_prop_u32(reboot, "regmap", fdt_node_get_phandle(test));
+    fdt_node_add_child(rvvm_get_fdt_soc(machine), reboot);
+#endif
+    return mmio;
+}
+
+PUBLIC rvvm_mmio_dev_t* syscon_init_auto(rvvm_machine_t* machine)
+{
+    rvvm_addr_t addr = rvvm_mmio_zone_auto(machine, SYSCON_DEFAULT_MMIO, 0x1000);
+    return syscon_init(machine, addr);
+}
diff --git a/app/src/main/java/libengine/RVVM/src/devices/syscon.h b/app/src/main/java/libengine/RVVM/src/devices/syscon.h
new file mode 100644
index 00000000..662aaf36
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/syscon.h
@@ -0,0 +1,29 @@
+/*
+syscon.h - Poweroff/reset syscon device
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef RVVM_SYSCON_H
+#define RVVM_SYSCON_H
+
+#include "../rvvmlib.h"
+
+#define SYSCON_DEFAULT_MMIO 0x100000
+
+PUBLIC rvvm_mmio_dev_t* syscon_init(rvvm_machine_t* machine, rvvm_addr_t base_addr);
+PUBLIC rvvm_mmio_dev_t* syscon_init_auto(rvvm_machine_t* machine);
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/devices/tap_api.h b/app/src/main/java/libengine/RVVM/src/devices/tap_api.h
new file mode 100644
index 00000000..953d4dbe
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/tap_api.h
@@ -0,0 +1,60 @@
+/*
+tap_api.h - TAP Networking API
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef RVVM_TAP_H
+#define RVVM_TAP_H
+
+#include "../rvvmlib.h"
+
+// Maximum size for an Ethernet II header + payload
+#define TAP_FRAME_SIZE 1514
+
+typedef struct {
+    // Network card specific context
+    void* net_dev;
+    // Feed received Ethernet frame to the NIC (Without CRC)
+    bool (*feed_rx)(void* net_dev, const void* data, size_t size);
+} tap_net_dev_t;
+
+typedef struct tap_dev tap_dev_t;
+
+// Create TAP interface
+PUBLIC tap_dev_t* tap_open(void);
+
+// Attach to the NIC
+PUBLIC void tap_attach(tap_dev_t* tap, const tap_net_dev_t* net_dev);
+
+// Send Ethernet frame (Without CRC)
+PUBLIC bool tap_send(tap_dev_t* tap, const void* data, size_t size);
+
+// Set/get interface MAC address
+PUBLIC bool tap_get_mac(tap_dev_t* tap, uint8_t mac[6]);
+PUBLIC bool tap_set_mac(tap_dev_t* tap, const uint8_t mac[6]);
+
+// Forward ports from host address into guest network
+// By default forwards to guest DHCP address
+// Format: "tcp/2022=22"; "[::1]:2022=22"; "127.0.0.1:2022=192.168.0.101:22"
+PUBLIC bool tap_portfwd(tap_dev_t* tap, const char* fwd);
+
+// Set the host interface addr for this TAP interface
+PUBLIC bool tap_ifaddr(tap_dev_t* tap, const char* addr);
+
+// Shut down the interface
+PUBLIC void tap_close(tap_dev_t* tap);
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/devices/tap_linux.c b/app/src/main/java/libengine/RVVM/src/devices/tap_linux.c
new file mode 100644
index 00000000..f4faf7de
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/tap_linux.c
@@ -0,0 +1,183 @@
+/*
+tap_linux.c - Linux TUN/TAP Networking
+Copyright (C) 2021  LekKit <github.com/LekKit>
+                    cerg2010cerg2010 <github.com/cerg2010cerg2010>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "tap_api.h"
+#include "../threading.h"
+#include "../utils.h"
+
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <poll.h>
+#include <sys/poll.h>
+#include <sys/ioctl.h>
+#include <net/if.h>
+#include <net/if_arp.h>
+#include <linux/if_tun.h>
+
+/*
+ * Linux TUN/TAP networking manual by cerg2010cerg2010 (circa 2021)
+ * In the guest:
+    ip addr add 192.168.2.1/24 dev enp0s1
+    ip link set enp0s1 up
+    ip route add default dev enp0s1
+    ip route del default
+    ip route add default via 192.168.2.2
+    echo 'nameserver 1.1.1.1' > /etc/resolv.conf
+ * Workaround TX checksum failure:
+    ethtool -K enp0s1 tx off
+ * On the host (replace wlan0 with your host NIC ifname):
+    sudo sysctl net.ipv4.ip_forward=1
+    sudo iptables -t nat -A POSTROUTING -o wlan0 -j MASQUERADE
+    sudo ip addr add 192.168.2.2/24 dev tap0
+ */
+
+struct tap_dev {
+    tap_net_dev_t net;
+    thread_ctx_t* thread;
+    int           fd;
+    int           shut[2];
+    char          name[IFNAMSIZ];
+};
+
+static void* tap_thread(void* arg)
+{
+    tap_dev_t* tap = (tap_dev_t*)arg;
+    uint8_t buffer[TAP_FRAME_SIZE];
+    int ret = 0;
+    struct pollfd pfds[2] = {
+        {
+            .fd = tap->fd,
+            .events = POLLIN,
+        },
+        {
+            .fd = tap->shut[0],
+            .events = POLLIN | POLLHUP,
+        }
+    };
+    while (true) {
+        // Poll events
+        poll(pfds, 2, -1);
+        // Check for shutdown notification
+        if (pfds[1].revents) break;
+        // We received a packet
+        if (pfds[0].revents & POLLIN) {
+            ret = read(tap->fd, buffer, sizeof(buffer));
+            if (ret > 0) {
+                tap->net.feed_rx(tap->net.net_dev, buffer, ret);
+            }
+        }
+    }
+    return arg;
+}
+
+tap_dev_t* tap_open(void)
+{
+    tap_dev_t* tap = safe_new_obj(tap_dev_t);
+    // Open TUN
+    tap->fd = open("/dev/net/tun", O_RDWR);
+    if (tap->fd < 0) {
+        rvvm_error("Failed to open /dev/net/tun: %s", strerror(errno));
+        free(tap);
+        return NULL;
+    }
+    // Assign ifname, set TAP mode
+    struct ifreq ifr = {0};
+    rvvm_strlcpy(ifr.ifr_name, "tap0", sizeof(ifr.ifr_name));
+    ifr.ifr_flags = IFF_TAP | IFF_NO_PI;
+    if (ioctl(tap->fd, TUNSETIFF, &ifr) < 0) {
+        rvvm_error("ioctl(TUNSETIFF) failed: %s", strerror(errno));
+        close(tap->fd);
+        free(tap);
+        return NULL;
+    }
+    // TAP may be assigned a different name
+    rvvm_strlcpy(tap->name, ifr.ifr_name, sizeof(tap->name));
+
+    // Create shutdown pipe
+    if (pipe(tap->shut) < 0) {
+        rvvm_error("pipe() failed: %s", strerror(errno));
+        close(tap->fd);
+        free(tap);
+        return NULL;
+    }
+
+    // Set the interface up
+    int sock = socket(AF_INET, SOCK_DGRAM, 0);
+    ioctl(sock, SIOCGIFFLAGS, &ifr);
+    ifr.ifr_flags |= IFF_UP;
+    ioctl(sock, SIOCSIFFLAGS, &ifr);
+    close(sock);
+
+    return tap;
+}
+
+void tap_attach(tap_dev_t* tap, const tap_net_dev_t* net_dev)
+{
+    if (tap->net.feed_rx == NULL) {
+        tap->net = *net_dev;
+        // Run TAP thread
+        tap->thread = thread_create(tap_thread, tap);
+    }
+}
+
+bool tap_send(tap_dev_t* tap, const void* data, size_t size)
+{
+    return write(tap->fd, data, size) >= 0;
+}
+
+bool tap_get_mac(tap_dev_t* tap, uint8_t mac[6])
+{
+    struct ifreq ifr = {0};
+    rvvm_strlcpy(ifr.ifr_name, tap->name, sizeof(ifr.ifr_name));
+    if (ioctl(tap->fd, SIOCGIFHWADDR, &ifr) < 0) return false;
+    if (ifr.ifr_hwaddr.sa_family != ARPHRD_ETHER) {
+        return false;
+    }
+    memcpy(mac, ifr.ifr_hwaddr.sa_data, 6);
+    return true;
+}
+
+bool tap_set_mac(tap_dev_t* tap, const uint8_t mac[6])
+{
+    struct ifreq ifr = {0};
+    rvvm_strlcpy(ifr.ifr_name, tap->name, sizeof(ifr.ifr_name));
+    ifr.ifr_hwaddr.sa_family = ARPHRD_ETHER;
+    memcpy(ifr.ifr_hwaddr.sa_data, mac, 6);
+    return ioctl(tap->fd, SIOCSIFHWADDR, &ifr) >= 0;
+}
+
+bool tap_portfwd(tap_dev_t* tap, const char* fwd)
+{
+    UNUSED(tap); UNUSED(fwd);
+    return false;
+}
+
+void tap_close(tap_dev_t* tap)
+{
+    // Shut down the TAP thread
+    close(tap->shut[1]);
+    thread_join(tap->thread);
+
+    // Cleanup
+    close(tap->fd);
+    close(tap->shut[0]);
+    free(tap);
+}
diff --git a/app/src/main/java/libengine/RVVM/src/devices/tap_user.c b/app/src/main/java/libengine/RVVM/src/devices/tap_user.c
new file mode 100644
index 00000000..85725233
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/tap_user.c
@@ -0,0 +1,1158 @@
+/*
+tap_user.c - Userspace TAP Networking
+Copyright (C) 2021  LekKit <github.com/LekKit>
+                    0xCatPKG <github.com/PacketCat>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "tap_api.h"
+#include "../networking.h"
+#include "../threading.h"
+#include "../spinlock.h"
+#include "../rvtimer.h"
+#include "../hashmap.h"
+#include "../vector.h"
+#include "../mem_ops.h"
+#include "../utils.h"
+
+#define GATEWAY_MAC ((const uint8_t*)"\x00\x08\x97\xDE\xC0\xDE")
+#define GATEWAY_IP  ((const uint8_t*)"\xC0\xA8\x00\x01")
+
+#define CLIENT_IP   ((const uint8_t*)"\xC0\xA8\x00\x64")
+
+// EtherType for Ethernet Packets
+#define ETH2_IPv6       0x86DD
+#define ETH2_IPv4       0x0800
+#define ETH2_ARP        0x0806
+
+// Address types & sizes
+#define HTYPE_ETHER     0x1
+#define PTYPE_IPv4      ETH2_IPv4
+#define PTYPE_IPv6      ETH2_IPv6
+#define HLEN_ETHER      0x6
+#define PLEN_IPv4       0x4
+#define PLEN_IPv6       0x10
+
+// Header size for each protocol
+#define ETH2_HDR_SIZE   0xE
+#define IPv4_HDR_SIZE   0x14
+#define IPv6_HDR_SIZE   0x28
+#define ARPv4_HDR_SIZE  0x1C
+#define ARPv6_HDR_SIZE  0x34
+#define ICMP_HDR_SIZE   0x4
+#define UDP_HDR_SIZE    0x8
+#define TCP_HDR_SIZE    0x14
+
+// Protocols encapsulated in IP
+#define IP_PROTO_ICMP   0x1
+#define IP_PROTO_TCP    0x6
+#define IP_PROTO_UDP    0x11
+#define IP_PROTO_ENCv6  0x29 // IPv6 in IPv4 encapsulation
+#define IP_PROTO_ICMPv6 0x3A // IPv6 ICMP
+
+// OP field for ARP, DHCP
+#define OP_REQUEST      0x1
+#define OP_RESPONSE     0x2
+
+// ICMP Control Messages
+#define ICMP_ECHO_REQ   0x0800
+#define ICMP_ECHO_REP   0x0
+#define ICMPv6_ECHO_REQ 0x8000
+#define ICMPv6_ECHO_REP 0x8100
+
+// DHCP Options
+#define DHCP_SUBMASK    0x1
+#define DHCP_ROUTER     0x3
+#define DHCP_DNSERVERS  0x6
+#define DHCP_LEASETIME  0x33
+#define DHCP_MSG_TYPE   0x35
+#define DHCP_DHCPSERVER 0x36
+#define DHCP_ENDMARK    0xFF
+
+// DHCP Message Types
+#define DHCP_DISCOVER   0x1
+#define DHCP_OFFER      0x2
+#define DHCP_REQUEST    0x3
+#define DHCP_ACK        0x5
+
+// TCP Flags
+#define TCP_FLAG_FIN    0x1
+#define TCP_FLAG_SYN    0x2
+#define TCP_FLAG_RST    0x4
+#define TCP_FLAG_PSH    0x8
+#define TCP_FLAG_ACK    0x10
+
+typedef struct tcp_segment tcp_segment_t;
+struct tcp_segment {
+    tcp_segment_t* next;
+    size_t size;
+};
+
+typedef struct {
+    tcp_segment_t* head;
+    tcp_segment_t* tail;
+    uint32_t seq;
+    uint32_t ack;
+    uint32_t seq_ack;
+    uint16_t window;
+    uint8_t  state;
+    bool     win_full;
+} tcp_ctx_t;
+
+#define TCP_WRAP_SIZE (ETH2_HDR_SIZE + IPv4_HDR_SIZE + TCP_HDR_SIZE)
+
+#define TCP_STATE_CLOSED      0x00 // Awaiting cleanup
+#define TCP_STATE_LISTEN      0x01 // This is a listener socket
+#define TCP_STATE_ESTABLISHED 0x02 // This connection was established
+#define TCP_STATE_SEND_OPEN   0x04 // Guest sending side open
+#define TCP_STATE_RECV_OPEN   0x08 // Guest receiving side open
+
+// Connection actually established and not yet closing
+#define TCP_STATE_NORMAL (TCP_STATE_ESTABLISHED | TCP_STATE_SEND_OPEN | TCP_STATE_RECV_OPEN)
+
+#define BOUND_INF 0xFFFF // No UDP timeout
+
+typedef struct {
+    net_sock_t* sock;
+    tcp_ctx_t*  tcp;  // If NULL, this is a UDP socket
+    net_addr_t  addr; // Guest-side address
+    uint32_t    timeout;
+} tap_sock_t;
+
+typedef vector_t(tap_sock_t*) ts_vec_t;
+
+struct tap_dev {
+    spinlock_t    lock;
+    tap_net_dev_t net;
+    net_poll_t*   poll;
+    hashmap_t     udp_ports;
+    hashmap_t     tcp_map;
+    ts_vec_t      tcp_listeners;
+    thread_ctx_t* thread;
+    net_sock_t*   shut[2];
+    uint8_t       mac[6];
+
+    bool          filt_lan;
+};
+
+static inline bool eth_send(tap_dev_t* tap, const void* buffer, size_t size)
+{
+    return tap->net.feed_rx(tap->net.net_dev, buffer, size);
+}
+
+#if 0
+static inline uint16_t ip_checksum_combine(uint16_t csum1, uint16_t csum2)
+{
+    uint32_t sum = ((~csum1) & 0xFFFF) + ((~csum2) & 0xFFFF);
+    sum = (sum >> 16) + (sum & 0xFFFF);
+    return ~sum;
+}
+#endif
+
+static uint16_t ip_checksum(const void* data, size_t size, uint16_t initial)
+{
+    const uint8_t* buffer = (const uint8_t*)data;
+    uint32_t sum = (~initial) & 0xFFFF;
+    uint8_t tail = size & 1;
+    size -= tail;
+    for (size_t i = 0; i < size; i += 2) {
+        sum += read_uint16_be_m(buffer + i);
+    }
+    if (tail) {
+        sum += ((uint16_t)read_uint8(buffer + size)) << 8;
+    }
+    sum = (sum >> 16) + (sum & 0xFFFF);
+    sum += sum >> 16;
+    return ~sum;
+}
+
+static uint8_t* create_eth_frame(tap_dev_t* tap, uint8_t* frame, uint16_t ether_type)
+{
+    memcpy(frame, tap->mac, HLEN_ETHER);
+    memcpy(frame + HLEN_ETHER, GATEWAY_MAC, HLEN_ETHER);
+    write_uint16_be_m(frame + 12, ether_type);
+    return frame + ETH2_HDR_SIZE;
+}
+
+static void create_arp_frame(tap_dev_t* tap, uint8_t* frame, const void* req_ip)
+{
+    write_uint16_be_m(frame,     HTYPE_ETHER);
+    write_uint16_be_m(frame + 2, PTYPE_IPv4);
+    frame[4] = HLEN_ETHER;
+    frame[5] = PLEN_IPv4;
+    write_uint16_be_m(frame + 6, OP_RESPONSE);
+    memcpy(frame + 8,  GATEWAY_MAC, HLEN_ETHER);
+    memcpy(frame + 14, req_ip,      PLEN_IPv4);
+    memcpy(frame + 18, tap->mac,    HLEN_ETHER);
+    memcpy(frame + 24, req_ip,      PLEN_IPv4); // Сlient IP
+}
+
+static uint8_t* create_ipv4_frame(uint8_t* frame, size_t size, uint8_t proto, const void* dest_ip, const void* src_ip)
+{
+    frame[0] = 0x45; // Version 4, IHL 5
+    frame[1] = 0;    // DSCP, ECN
+    write_uint16_be_m(frame + 2, size + IPv4_HDR_SIZE);
+    write_uint16_be_m(frame + 4, 0);      // Identification
+    write_uint16_be_m(frame + 6, 0x4000); // Flags, Fragment Offset
+    frame[8] = 64;                        // TTL
+    frame[9] = proto;
+    write_uint16_be_m(frame + 10, 0); // Initial checksum is zero
+    memcpy(frame + 12, src_ip,  PLEN_IPv4);
+    memcpy(frame + 16, dest_ip, PLEN_IPv4);
+
+    // Header checksum calculation
+    write_uint16_be_m(frame + 10, ip_checksum(frame, IPv4_HDR_SIZE, 0));
+
+    return frame + IPv4_HDR_SIZE;
+}
+
+#if 0
+static uint8_t* create_ipv6_frame(uint8_t* frame, size_t size, uint8_t proto, const void* dest_ip, const void* src_ip)
+{
+    frame[0] = 0x60;                    // Version 6
+    frame[1] = 0;                       // Traffic class
+    write_uint16_be_m(frame + 2, 0);    // Flow label
+    write_uint16_be_m(frame + 4, size); // Payload Length
+    frame[6] = proto;                   // Next Header
+    frame[7] = 64;                      // Hop Limit (TTL)
+    memcpy(frame + 8,  src_ip,  PLEN_IPv6);
+    memcpy(frame + 24, dest_ip, PLEN_IPv6);
+    return frame + IPv6_HDR_SIZE;
+}
+#endif
+
+static uint8_t* create_udp_datagram(uint8_t* udp, size_t size, uint16_t dst_port, uint16_t src_port)
+{
+    write_uint16_be_m(udp,     src_port);
+    write_uint16_be_m(udp + 2, dst_port);
+    write_uint16_be_m(udp + 4, size + UDP_HDR_SIZE);
+    write_uint16_be_m(udp + 6, 0); // Initial checksum is zero
+    return udp + UDP_HDR_SIZE;
+}
+
+static void udp_ipv4_checksum(uint8_t* ipv4, size_t size)
+{
+    uint8_t* udp = ipv4 + IPv4_HDR_SIZE;
+    uint16_t csum = ip_checksum(ipv4 + 12, PLEN_IPv4 << 1, 0);
+    uint8_t phdr[4];
+    phdr[0] = 0;
+    phdr[1] = IP_PROTO_UDP;
+    write_uint16_be_m(phdr + 2, size + UDP_HDR_SIZE);
+    csum = ip_checksum(phdr, 4, csum);
+    csum = ip_checksum(udp, size + UDP_HDR_SIZE, csum);
+    write_uint16_be_m(udp + 6, csum);
+}
+
+static uint8_t* create_tcp_segment(uint8_t* tcp, uint8_t flags, uint32_t seq, uint32_t ack_sn, uint16_t dst_port, uint16_t src_port)
+{
+    write_uint16_be_m(tcp,     src_port);
+    write_uint16_be_m(tcp + 2, dst_port);
+    write_uint32_be_m(tcp + 4, seq);
+    write_uint32_be_m(tcp + 8, ack_sn);
+    tcp[12] = 0x50;                 // Data offset: 5 words
+    tcp[13] = flags;
+    write_uint16_be_m(tcp + 14, 0xFFFF); // Window size
+    write_uint16_be_m(tcp + 16, 0); // Initial checksum (zero)
+    write_uint16_be_m(tcp + 18, 0); // Urgent pointer
+    return tcp + TCP_HDR_SIZE;
+}
+
+static void tcp_ipv4_checksum(uint8_t* ipv4, size_t size)
+{
+    uint8_t* tcp = ipv4 + IPv4_HDR_SIZE;
+    uint16_t csum = ip_checksum(ipv4 + 12, PLEN_IPv4 << 1, 0);
+    uint8_t phdr[4];
+    phdr[0] = 0;
+    phdr[1] = IP_PROTO_TCP;
+    write_uint16_be_m(phdr + 2, size + TCP_HDR_SIZE);
+    csum = ip_checksum(phdr, 4, csum);
+    csum = ip_checksum(tcp, size + TCP_HDR_SIZE, csum);
+    write_uint16_be_m(tcp + 16, csum);
+}
+
+static void handle_icmp(tap_dev_t* tap, const uint8_t* buffer, size_t size, net_addr_t* dst, net_addr_t* src)
+{
+    if (size >= ICMP_HDR_SIZE && size < 1460 && read_uint16_be_m(buffer) == ICMP_ECHO_REQ) {
+        uint8_t frame[TAP_FRAME_SIZE];
+        uint8_t* ipv4 = create_eth_frame(tap, frame, ETH2_IPv4);
+        uint8_t* icmp = create_ipv4_frame(ipv4, size, IP_PROTO_ICMP, src->ip, dst->ip);
+        memcpy(icmp, buffer, size);
+        write_uint16_be_m(icmp, ICMP_ECHO_REP);
+        write_uint16_be_m(icmp + 2, 0); // Initial checksum is zero
+        write_uint16_be_m(icmp + 2, ip_checksum(icmp, size, 0));
+        eth_send(tap, frame, size + IPv4_HDR_SIZE + ETH2_HDR_SIZE);
+    }
+}
+
+static void handle_dhcp(tap_dev_t* tap, const uint8_t* buffer, size_t size, net_addr_t* dst, net_addr_t* src)
+{
+    if (unlikely(size < 240)) {
+        // Packet too small
+        return;
+    }
+
+    uint8_t msg_type = DHCP_ENDMARK;
+    for (size_t i = 240; i + 2 < size;) {
+        if (buffer[i] == DHCP_MSG_TYPE) {
+            msg_type = buffer[i+2];
+            break;
+        }
+        i += 2 + buffer[i + 1];
+    }
+    if (msg_type == DHCP_ENDMARK) {
+        // Lacking DHCP message type
+        return;
+    }
+
+    uint8_t frame[TAP_FRAME_SIZE];
+    uint8_t* ipv4 = create_eth_frame(tap, frame, ETH2_IPv4);
+    uint8_t* udp = create_ipv4_frame(ipv4, 277 + UDP_HDR_SIZE, IP_PROTO_UDP, (const uint8_t*)"\xFF\xFF\xFF\xFF", GATEWAY_IP);
+    uint8_t* dhcp = create_udp_datagram(udp, 277, src->port, dst->port);
+
+    dhcp[0] = OP_RESPONSE;
+    dhcp[1] = HTYPE_ETHER;
+    dhcp[2] = HLEN_ETHER;
+    dhcp[3] = 0;                              // Hop count
+    memcpy(dhcp + 4, buffer + 4, 4);          // Client ID
+    write_uint16_be_m(dhcp + 8,  0);          // Start time
+    write_uint16_be_m(dhcp + 10, 0);          // Flags
+    memcpy(dhcp + 12, src->ip,    PLEN_IPv4); // Client IP
+    memcpy(dhcp + 16, CLIENT_IP,  PLEN_IPv4); // Offered IP
+    memcpy(dhcp + 20, GATEWAY_IP, PLEN_IPv4); // Server address
+    memset(dhcp + 24, 0,          PLEN_IPv4); // Relay agent address
+    memcpy(dhcp + 28, buffer + 28, 16);       // Client hardware address
+
+    memset(dhcp + 44, 0, 192);                // BOOTP (legacy)
+    memcpy(dhcp + 44, "RVVM DHCP", 10);       // Server name
+
+    memcpy(dhcp + 236, buffer + 236, 4);      // Magic cookie
+
+    // DHCP Message type
+    dhcp[240] = DHCP_MSG_TYPE;
+    dhcp[241] = 1;
+    if (msg_type == DHCP_DISCOVER) {
+        dhcp[242] = DHCP_OFFER;
+    } else {
+        dhcp[242] = DHCP_ACK;
+    }
+    // Advertise /24 subnet
+    dhcp[243] = DHCP_SUBMASK;
+    dhcp[244] = 4;
+    write_uint32_be_m(dhcp + 245, 0xFFFFFF00);
+    // Advertise gateway IP
+    dhcp[249] = DHCP_ROUTER;
+    dhcp[250] = 4;
+    memcpy(dhcp + 251, GATEWAY_IP, PLEN_IPv4);
+    // Lease time: 1 day (renewable)
+    dhcp[255] = DHCP_LEASETIME;
+    dhcp[256] = 4;
+    write_uint32_be_m(dhcp + 257, 86400);
+    // Gateway acts as a DHCP server
+    dhcp[261] = DHCP_DHCPSERVER;
+    dhcp[262] = 4;
+    memcpy(dhcp + 263, GATEWAY_IP, PLEN_IPv4);
+    // Advertise usable DNS servers (1.1.1.1, 8.8.8.8)
+    dhcp[267] = DHCP_DNSERVERS;
+    dhcp[268] = 8;
+    write_uint32_be_m(dhcp + 269, 0x01010101);
+    write_uint32_be_m(dhcp + 273, 0x08080808);
+
+    eth_send(tap, frame, 277 + UDP_HDR_SIZE + IPv4_HDR_SIZE + ETH2_HDR_SIZE);
+}
+
+// Filter unwanted outbound traffic to special IPs
+static bool tap_addr_allowed(const tap_dev_t* tap, const net_addr_t* addr)
+{
+    if (addr->type == NET_TYPE_IPV4) {
+        // Filter attempts to reach host loopback from guest (127.x.x.x, 0.x.x.x)
+        if (addr->ip[0] == 127) return false;
+        if (addr->ip[0] == 0) return false;
+        // Filter multicast/broadcast addresses
+        if (addr->ip[0] >= 224 && addr->ip[0] <= 239) return false;
+        if (addr->ip[0] == 255 && addr->ip[1] == 255 && addr->ip[2] == 255 && addr->ip[3] == 255) return false;
+        if (tap->filt_lan) {
+            // Filter access to LAN if enabled
+            if (addr->ip[0] == 10) return false;
+            if (addr->ip[0] == 172 && addr->ip[1] >= 16 && addr->ip[1] < 32) return false;
+            if (addr->ip[0] == 192 && addr->ip[1] == 168) return false;
+            if (addr->ip[0] == 169 && addr->ip[1] == 254) return false; // Link-local range
+        }
+    }
+    return true;
+}
+
+// Route localhost traffic as gateway
+static void tap_addr_convert(net_addr_t* addr)
+{
+    if (addr->ip[0] == 127) memcpy(addr->ip, GATEWAY_IP, 4);
+}
+
+static void handle_udp(tap_dev_t* tap, const uint8_t* buffer, size_t size, net_addr_t* dst, net_addr_t* src)
+{
+    if (unlikely(size < UDP_HDR_SIZE)) {
+        // Packet too small
+        return;
+    }
+    src->port = read_uint16_be_m(buffer);
+    dst->port = read_uint16_be_m(buffer + 2);
+    uint16_t udp_size = read_uint16_be_m(buffer + 4);
+    const uint8_t* udb_buff = buffer + UDP_HDR_SIZE;
+    if (unlikely(udp_size > size)) {
+        // Encoded size exceeds frame size
+        return;
+    }
+    udp_size -= UDP_HDR_SIZE;
+
+    spin_lock(&tap->lock);
+    tap_sock_t* ts = (tap_sock_t*)hashmap_get(&tap->udp_ports, src->port);
+    if (ts == NULL) {
+        if (dst->port == 67 && (read_uint32_be_m(src->ip) == 0)) {
+            spin_unlock(&tap->lock);
+            handle_dhcp(tap, udb_buff, udp_size, dst, src);
+            return;
+        }
+
+        net_sock_t* sock = net_udp_bind(NET_IPV4_ANY);
+        net_sock_set_blocking(sock, false);
+        if (sock) {
+            ts = safe_new_obj(tap_sock_t);
+            ts->sock = sock;
+            ts->addr = *src;
+            hashmap_put(&tap->udp_ports, src->port, (size_t)ts);
+            net_event_t event = { .data = ts, .flags = NET_POLL_RECV, };
+            net_poll_add(tap->poll, ts->sock, &event);
+        } else {
+            // Couldn't bind UDP port
+            spin_unlock(&tap->lock);
+            return;
+        }
+    }
+    if (ts->timeout != BOUND_INF) ts->timeout = 0;
+    spin_unlock(&tap->lock);
+    if (tap_addr_allowed(tap, dst)) net_udp_send(ts->sock, udb_buff, udp_size, dst);
+}
+
+static inline uint8_t* tcp_seg_buffer(tcp_segment_t* seg)
+{
+    return ((uint8_t*)seg) + sizeof(tcp_segment_t);
+}
+
+static void tap_tcp_segment_gen(tap_dev_t* tap, tap_sock_t* ts, uint8_t flags, uint32_t seq_sub)
+{
+    uint8_t frame[ETH2_HDR_SIZE + IPv4_HDR_SIZE + TCP_HDR_SIZE + 4];
+    net_addr_t* dst = &ts->addr;
+    const net_addr_t* src = net_sock_addr(ts->sock);
+    uint8_t* ipv4 = create_eth_frame(tap, frame, ETH2_IPv4);
+    size_t opt_size = (flags & TCP_FLAG_SYN) ? 4 : 0;
+    uint8_t* tcp = create_ipv4_frame(ipv4, TCP_HDR_SIZE + opt_size, IP_PROTO_TCP, dst->ip, src->ip);
+    uint8_t* opt = create_tcp_segment(tcp, flags, ts->tcp->seq - seq_sub, ts->tcp->ack, dst->port, src->port);
+    if (flags & TCP_FLAG_SYN) {
+        // Change MSS to 1460
+        tcp[12] = 0x60;
+        opt[0] = 2;
+        opt[1] = 4;
+        write_uint16_be_m(opt + 2, 1460);
+    }
+    tcp_ipv4_checksum(ipv4, opt_size);
+    eth_send(tap, frame, ETH2_HDR_SIZE + IPv4_HDR_SIZE + TCP_HDR_SIZE + opt_size);
+}
+
+static void tap_tcp_segment(tap_dev_t* tap, tap_sock_t* ts, uint8_t flags)
+{
+    tap_tcp_segment_gen(tap, ts, flags, (flags & (TCP_FLAG_SYN | TCP_FLAG_FIN)) ? 1 : 0);
+}
+
+static inline bool tcp_window_avail(tcp_ctx_t* tcp)
+{
+    return tcp->seq - tcp->seq_ack < tcp->window;
+}
+
+static inline size_t tcp_ack_amount(tcp_ctx_t* tcp, uint32_t ack)
+{
+    size_t ret = ack - tcp->seq_ack;
+    return (ret < 0x80000000) ? ret : 0; // Care for wraparound
+}
+
+static inline size_t tcp_hash_tuple(const net_addr_t* remote, const net_addr_t* local)
+{
+    // Hash distribution happens in hashmap itself
+    size_t hash = (((uint32_t)remote->port) << 16) + local->port;
+    if (remote->type == NET_TYPE_IPV6) {
+        hash += read_uint64_le_m(remote->ip) + read_uint64_le_m(local->ip);
+        hash += read_uint64_le_m(remote->ip + 8) + read_uint64_le_m(local->ip + 8);
+    } else {
+        hash += read_uint32_le_m(remote->ip) + read_uint32_le_m(local->ip);
+    }
+    return hash;
+}
+
+static tap_sock_t* tap_tcp_lookup(tap_dev_t* tap, const net_addr_t* remote, const net_addr_t* local)
+{
+    size_t hash = tcp_hash_tuple(remote, local);
+    ts_vec_t* vec = (ts_vec_t*)hashmap_get(&tap->tcp_map, hash);
+    if (vec) {
+        vector_foreach(*vec, i) {
+            tap_sock_t* ts = vector_at(*vec, i);
+            if (!memcmp(&ts->addr,               local,  sizeof(net_addr_t))
+             && !memcmp(net_sock_addr(ts->sock), remote, sizeof(net_addr_t))) return ts;
+        }
+    }
+    return NULL;
+}
+
+static void tap_tcp_register(tap_dev_t* tap, tap_sock_t* ts)
+{
+    const net_addr_t* remote = net_sock_addr(ts->sock);
+    const net_addr_t* local = &ts->addr;
+    size_t hash = tcp_hash_tuple(remote, local);
+    ts_vec_t* vec = (ts_vec_t*)hashmap_get(&tap->tcp_map, hash);
+    if (vec == NULL) {
+        vec = safe_new_obj(ts_vec_t);
+        hashmap_put(&tap->tcp_map, hash, (size_t)vec);
+    }
+    vector_push_back(*vec, ts);
+}
+
+static void tap_tcp_remove(tap_dev_t* tap, tap_sock_t* ts)
+{
+    const net_addr_t* remote = net_sock_addr(ts->sock);
+    const net_addr_t* local = &ts->addr;
+    size_t hash = tcp_hash_tuple(remote, local);
+    ts_vec_t* vec = (ts_vec_t*)hashmap_get(&tap->tcp_map, hash);
+    if (vec) {
+        vector_foreach_back(*vec, i) {
+            if (vector_at(*vec, i) == ts) {
+                vector_erase(*vec, i);
+                if (!vector_size(*vec)) {
+                    vector_free(*vec);
+                    free(vec);
+                    hashmap_remove(&tap->tcp_map, hash);
+                }
+                return;
+            }
+        }
+    }
+}
+
+static void tap_tcp_close(tap_dev_t* tap, tap_sock_t* ts)
+{
+    // Unmap if tap != NULL
+    if (tap) tap_tcp_remove(tap, ts);
+
+    net_sock_close(ts->sock);
+    while (ts->tcp && ts->tcp->head) {
+        tcp_segment_t* seg = ts->tcp->head;
+        ts->tcp->head = seg->next;
+        free(seg);
+    }
+    free(ts->tcp);
+    free(ts);
+}
+
+static bool tap_tcp_arm_poll(tap_dev_t* tap, tap_sock_t* ts)
+{
+    // Rearm the socket to the eventloop
+    net_event_t event = { .data = ts, .flags = NET_POLL_RECV, };
+    if (!net_poll_add(tap->poll, ts->sock, &event)) {
+        DO_ONCE(rvvm_warn("net_poll_add() failed!"));
+        return false;
+    }
+    return true;
+}
+
+static void handle_tcp(tap_dev_t* tap, const uint8_t* buffer, size_t size, net_addr_t* dst, net_addr_t* src)
+{
+    src->port         = read_uint16_be_m(buffer);
+    dst->port         = read_uint16_be_m(buffer + 2);
+    uint32_t seq      = read_uint32_be_m(buffer + 4);
+    uint32_t ack      = read_uint32_be_m(buffer + 8);
+    size_t   data_off = (buffer[12] >> 4) << 2;
+    uint8_t  flags    = buffer[13];
+    uint16_t window   = read_uint16_be_m(buffer + 14);
+
+    spin_lock(&tap->lock);
+    tap_sock_t* ts = tap_tcp_lookup(tap, dst, src);
+    if (ts) {
+        tcp_ctx_t* tcp = ts->tcp;
+        bool reset = !!(flags & TCP_FLAG_RST);
+        bool resp_ack = seq != tcp->ack; // Respond with ACK on keepalive
+        bool cleanup = false;
+        tcp->window = window; // Scale the window
+        ts->timeout = 1; // Allow TCP retransmit, but reset keepalive
+        if (flags & TCP_FLAG_ACK) {
+            while (tcp->head && tcp_ack_amount(tcp, ack) >= tcp->head->size) {
+                // Free ACKed segments
+                tcp_segment_t* seg = tcp->head;
+                tcp->seq_ack += seg->size;
+                tcp->head = seg->next;
+                free(seg);
+                ts->timeout = 0;
+            }
+            if (tcp->win_full && (tcp->state & TCP_STATE_RECV_OPEN) && tcp_window_avail(tcp)) {
+                // Window became available
+                if (!tap_tcp_arm_poll(tap, ts)) reset = true;
+                tcp->win_full = false;
+            }
+            if (tcp->seq == tcp->seq_ack + 1 && ack == tcp->seq) {
+                if ((tcp->state & TCP_STATE_ESTABLISHED) && !(tcp->state & TCP_STATE_RECV_OPEN)) {
+                    // Guest ACKed inbound FIN
+                    tcp->seq_ack++;
+
+                    if (tcp->state == TCP_STATE_ESTABLISHED) {
+                        // Closed completely
+                        cleanup = true;
+                    }
+                }
+                if (tcp->state == (TCP_STATE_SEND_OPEN | TCP_STATE_RECV_OPEN)) {
+                    // Guest ACKed inbound SYN ACK
+                    if (tap_tcp_arm_poll(tap, ts)) {
+                        tcp->state |= TCP_STATE_ESTABLISHED;
+                        tcp->seq_ack++;
+                    } else reset = true;
+                }
+                if (tcp->state == TCP_STATE_RECV_OPEN && (flags & TCP_FLAG_SYN)) {
+                    // Guest SYN ACKed an inbound connection
+                    if (tap_tcp_arm_poll(tap, ts)) {
+                        tcp->state |= TCP_STATE_SEND_OPEN | TCP_STATE_ESTABLISHED;
+                        tcp->ack = seq + 1;
+                        tcp->seq_ack++;
+                        resp_ack = true;
+                    } else reset = true;
+                }
+            }
+        }
+        if ((tcp->state & TCP_STATE_ESTABLISHED) && (tcp->state & TCP_STATE_SEND_OPEN)) {
+            // The guest sending side is open
+            if (data_off >= TCP_HDR_SIZE && data_off < size) {
+                // Send data segment
+                size_t send_len = size - data_off;
+                size_t seq_off = tcp->ack - seq;
+                if (send_len > seq_off) {
+                    int32_t result = net_tcp_send(ts->sock, buffer + data_off + seq_off, send_len - seq_off);
+                    if (result >= 0) {
+                        tcp->ack += result;
+                    } else if (result != NET_ERR_BLOCK) {
+                        // Connection is reset
+                        reset = true;
+                    }
+                }
+                // Acknowledge the bytes actually sent
+                // TODO: Reduce amount of response ACKs
+                resp_ack = true;
+            }
+        }
+        if ((flags & TCP_FLAG_FIN) && seq + (size - data_off) == tcp->ack) {
+            // Close guest sending side
+            if (tcp->state & TCP_STATE_SEND_OPEN) {
+                net_tcp_shutdown(ts->sock);
+                tcp->state &= ~TCP_STATE_SEND_OPEN;
+                tcp->ack++;
+            }
+            if (tcp->state == TCP_STATE_ESTABLISHED) {
+                // Closed completely
+                cleanup = true;
+            }
+            resp_ack = true;
+        }
+        if (reset) {
+            // Reset the connection
+            if (!(flags & TCP_FLAG_RST)) tap_tcp_segment(tap, ts, TCP_FLAG_RST);
+            if (!!(tcp->state & TCP_STATE_ESTABLISHED) != !!(tcp->state & TCP_STATE_RECV_OPEN)) {
+                // Closed completely
+                cleanup = true;
+            }
+            tcp->state = TCP_STATE_CLOSED;
+        } else if (resp_ack) {
+            // Handle keepalive, ACKs
+            tap_tcp_segment(tap, ts, TCP_FLAG_ACK);
+        }
+        if (cleanup) {
+            // It's safe to clean up here,
+            // since net_poll can't reference tap socket anymore
+            tap_tcp_close(tap, ts);
+        }
+    } else if (flags == TCP_FLAG_SYN) {
+        // Initiate new async connection
+        net_sock_t* sock = net_tcp_connect(dst, NULL, false);
+        if (sock) {
+            ts = safe_new_obj(tap_sock_t);
+            ts->sock = sock;
+            ts->addr = *src;
+            ts->tcp = safe_new_obj(tcp_ctx_t);
+            ts->tcp->state = TCP_STATE_SEND_OPEN;
+            ts->tcp->ack = seq + 1;
+            ts->tcp->window = window;
+            rvvm_randombytes(&ts->tcp->seq, sizeof(ts->tcp->seq));
+            ts->tcp->seq_ack = ts->tcp->seq;
+
+            tap_tcp_register(tap, ts);
+            net_event_t event = { .data = ts, .flags = NET_POLL_SEND, };
+            net_poll_add(tap->poll, ts->sock, &event);
+        } else {
+            DO_ONCE(rvvm_warn("net_tcp_connect() failed!"));
+        }
+    }
+    spin_unlock(&tap->lock);
+}
+
+static void handle_ipv4(tap_dev_t* tap, const uint8_t* buffer, size_t size)
+{
+    net_addr_t dst = { .type = NET_TYPE_IPV4, };
+    net_addr_t src = { .type = NET_TYPE_IPV4, };
+    if (unlikely(size < IPv4_HDR_SIZE)) {
+        // Packet too small
+        return;
+    }
+    size_t total_length = read_uint16_be_m(buffer + 2);
+    size_t header_length = (buffer[0] & 0xF) << 2;
+    uint16_t frag_flags = read_uint16_be_m(buffer + 6);
+    if (unlikely(frag_flags & 0x3FFF)) {
+        // This is a fragmented frame
+        return;
+    }
+    if (unlikely(size < total_length)) {
+        // Encoded size exceeds frame size
+        return;
+    }
+
+    memcpy(src.ip, buffer + 12, PLEN_IPv4);
+    memcpy(dst.ip, buffer + 16, PLEN_IPv4);
+    uint8_t proto = buffer[9];
+    switch (proto) {
+        case IP_PROTO_TCP:
+            handle_tcp(tap, buffer + header_length, total_length - header_length, &dst, &src);
+            break;
+        case IP_PROTO_UDP:
+            handle_udp(tap, buffer + header_length, total_length - header_length, &dst, &src);
+            break;
+        case IP_PROTO_ICMP:
+            handle_icmp(tap, buffer + header_length, total_length - header_length, &dst, &src);
+            break;
+    }
+}
+
+static void handle_ipv6(tap_dev_t* tap, const uint8_t* buffer, size_t size)
+{
+    net_addr_t dst = { .type = NET_TYPE_IPV6, };
+    net_addr_t src = { .type = NET_TYPE_IPV6, };
+    if (unlikely(size < IPv6_HDR_SIZE)) {
+        // Packet too small
+        return;
+    }
+    size_t payload_length = read_uint16_be_m(buffer + 4);
+    if (unlikely(size < (payload_length + IPv6_HDR_SIZE))) {
+        // Encoded size exceeds frame size
+        return;
+    }
+
+    memcpy(src.ip,  buffer + 8, PLEN_IPv6);
+    memcpy(dst.ip, buffer + 24, PLEN_IPv6);
+    uint8_t proto = buffer[6];
+    UNUSED(tap);
+    UNUSED(proto);
+    /*switch (proto) {
+        case IP_PROTO_TCP:
+            handle_tcp(tap, buffer, total_length);
+            break;
+        case IP_PROTO_UDP:
+            handle_udp(tap, buffer, total_length);
+            break;
+        case IP_PROTO_ICMPv6:
+            handle_icmpv6(tap, buffer + IPv6_HDR_SIZE, payload_length, &dst, &src);
+            break;
+    }*/
+}
+
+static void handle_arp(tap_dev_t* tap, const uint8_t* buffer, size_t size)
+{
+    if (size < ARPv4_HDR_SIZE) {
+        // Packet too small
+        return;
+    }
+    uint8_t frame[ARPv4_HDR_SIZE + ETH2_HDR_SIZE];
+    uint16_t ptype = read_uint16_be_m(buffer + 2);
+    uint16_t oper  = read_uint16_be_m(buffer + 6);
+    if (oper == OP_REQUEST && ptype == ETH2_IPv4 && memcmp(buffer + 14, buffer + 24, 4)) {
+        uint8_t* arp = create_eth_frame(tap, frame, ETH2_ARP);
+        create_arp_frame(tap, arp, buffer + 24);
+        eth_send(tap, frame, ARPv4_HDR_SIZE + ETH2_HDR_SIZE);
+    }
+}
+
+bool tap_send(tap_dev_t* tap, const void* data, size_t size)
+{
+    if (unlikely(size < ETH2_HDR_SIZE)) {
+        // Packet too small
+        return true;
+    }
+    const uint8_t* buffer = (const uint8_t*)data;
+    uint16_t ether_type = read_uint16_be_m(buffer + 12);
+    switch (ether_type) {
+        case ETH2_IPv4:
+            handle_ipv4(tap, buffer + 14, size - ETH2_HDR_SIZE);
+            break;
+        case ETH2_IPv6:
+            handle_ipv6(tap, buffer + 14, size - ETH2_HDR_SIZE);
+            break;
+        case ETH2_ARP:
+            handle_arp(tap, buffer + 14, size - ETH2_HDR_SIZE);
+            break;
+    }
+    return true;
+}
+
+bool tap_get_mac(tap_dev_t* tap, uint8_t mac[6])
+{
+    memcpy(mac, tap->mac, 6);
+    return true;
+}
+
+bool tap_set_mac(tap_dev_t* tap, const uint8_t mac[6])
+{
+    memcpy(tap->mac, mac, 6);
+    return true;
+}
+
+static bool bind_port(tap_dev_t* tap, const net_addr_t* internal, const net_addr_t* external, bool tcp)
+{
+    net_sock_t* sock = NULL;
+    if (tcp) {
+        sock = net_tcp_listen(external);
+    } else {
+        sock = net_udp_bind(external);
+    }
+    net_sock_set_blocking(sock, false);
+    if (sock) {
+        tap_sock_t* ts = safe_new_obj(tap_sock_t);
+        ts->sock = sock;
+        ts->addr = *internal;
+        spin_lock(&tap->lock);
+        if (tcp) {
+            ts->tcp = safe_new_obj(tcp_ctx_t);
+            ts->tcp->state = TCP_STATE_LISTEN;
+            vector_push_back(tap->tcp_listeners, ts);
+        } else {
+            ts->timeout = BOUND_INF;
+            hashmap_put(&tap->udp_ports, internal->port, (size_t)ts);
+        }
+        spin_unlock(&tap->lock);
+        net_event_t event = { .data = ts, .flags = NET_POLL_RECV, };
+        net_poll_add(tap->poll, ts->sock, &event);
+    }
+    return sock;
+}
+
+static void tap_udp_recv(tap_dev_t* tap, tap_sock_t* ts)
+{
+    uint8_t buffer[TAP_FRAME_SIZE];
+    net_addr_t addr;
+    size_t offset = ETH2_HDR_SIZE + IPv4_HDR_SIZE + UDP_HDR_SIZE;
+    size_t size = sizeof(buffer) - offset;
+
+    if (ts->timeout != BOUND_INF) ts->timeout = 0;
+    int32_t result = net_udp_recv(ts->sock, buffer + offset, size, &addr);
+    if (result >= 0) {
+        size = result;
+        tap_addr_convert(&addr);
+        uint8_t* ipv4 = create_eth_frame(tap, buffer, ETH2_IPv4);
+        uint8_t* udp  = create_ipv4_frame(ipv4, size + UDP_HDR_SIZE, IP_PROTO_UDP, ts->addr.ip, addr.ip);
+        create_udp_datagram(udp, size, ts->addr.port, addr.port);
+        udp_ipv4_checksum(ipv4, size);
+        eth_send(tap, buffer, size + UDP_HDR_SIZE + IPv4_HDR_SIZE + ETH2_HDR_SIZE);
+    }
+}
+
+static void tap_tcp_recv(tap_dev_t* tap, tap_sock_t* ts)
+{
+    if (!tcp_window_avail(ts->tcp)) {
+        // The window is full, back off and wait for ACK
+        net_poll_remove(tap->poll, ts->sock);
+        ts->tcp->win_full = true;
+        return;
+    }
+
+    tcp_segment_t* seg = safe_malloc(sizeof(tcp_segment_t) + TAP_FRAME_SIZE);
+    size_t size = TAP_FRAME_SIZE - TCP_WRAP_SIZE;
+    int32_t result = net_tcp_recv(ts->sock, tcp_seg_buffer(seg) + TCP_WRAP_SIZE, size);
+    if (result > 0) {
+        // Push a segment and buffer it for retransmit
+        seg->size = result;
+        seg->next = NULL;
+        uint8_t* ipv4 = create_eth_frame(tap, tcp_seg_buffer(seg), ETH2_IPv4);
+        uint8_t* tcp  = create_ipv4_frame(ipv4, seg->size + TCP_HDR_SIZE, IP_PROTO_TCP, ts->addr.ip, net_sock_addr(ts->sock)->ip);
+        create_tcp_segment(tcp, TCP_FLAG_PSH | TCP_FLAG_ACK, ts->tcp->seq, ts->tcp->ack, ts->addr.port, net_sock_addr(ts->sock)->port);
+        tcp_ipv4_checksum(ipv4, seg->size);
+        eth_send(tap, tcp_seg_buffer(seg), seg->size + TCP_WRAP_SIZE);
+
+        ts->tcp->seq += seg->size;
+
+        // Shrink the retransmit segment
+        seg = safe_realloc(seg, sizeof(tcp_segment_t) + result + TCP_WRAP_SIZE);
+        if (!ts->tcp->head) {
+            ts->tcp->head = seg;
+            ts->tcp->tail = seg;
+        } else {
+            ts->tcp->tail->next = seg;
+            ts->tcp->tail = seg;
+        }
+    } else {
+        free(seg);
+        if (result == NET_ERR_DISCONNECT) {
+            // Receiving side closed
+            ts->tcp->state &= ~TCP_STATE_RECV_OPEN;
+            ts->tcp->seq++;
+            tap_tcp_segment(tap, ts, TCP_FLAG_FIN | TCP_FLAG_ACK);
+
+            net_poll_remove(tap->poll, ts->sock);
+        } else if (result != NET_ERR_BLOCK) {
+            // Connection reset
+            tap_tcp_segment(tap, ts, TCP_FLAG_RST);
+
+            tap_tcp_close(tap, ts);
+        }
+    }
+}
+
+static void tap_tcp_accept(tap_dev_t* tap, tap_sock_t* listener)
+{
+    net_sock_t* sock = net_tcp_accept(listener->sock);
+    if (sock) {
+        tap_addr_convert(net_sock_addr(sock));
+        tap_sock_t* ts = safe_new_obj(tap_sock_t);
+        ts->sock = sock;
+        ts->addr = listener->addr;
+        ts->tcp = safe_new_obj(tcp_ctx_t);
+        rvvm_randombytes(&ts->tcp->seq, sizeof(ts->tcp->seq));
+        ts->tcp->seq_ack = ts->tcp->seq - 1;
+        ts->tcp->state = TCP_STATE_RECV_OPEN;
+
+        tap_tcp_register(tap, ts);
+        tap_tcp_segment(tap, ts, TCP_FLAG_SYN);
+    }
+}
+
+static void tap_tcp_periodic(tap_dev_t* tap, tap_sock_t* ts)
+{
+    tcp_ctx_t* tcp = ts->tcp;
+
+    if (unlikely(tcp->state != TCP_STATE_NORMAL)) {
+        if (tcp->state == TCP_STATE_CLOSED) {
+            // Clean up the closed socket
+            tap_tcp_close(tap, ts);
+            return;
+        }
+        if (tcp->seq != tcp->seq_ack) {
+            switch (tcp->state) {
+                case TCP_STATE_RECV_OPEN:
+                    // Retry SYN
+                    tap_tcp_segment(tap, ts, TCP_FLAG_SYN);
+                    break;
+                case TCP_STATE_RECV_OPEN | TCP_STATE_SEND_OPEN:
+                    // Retry SYN+ACK
+                    tap_tcp_segment(tap, ts, TCP_FLAG_SYN | TCP_FLAG_ACK);
+                    break;
+                case TCP_STATE_ESTABLISHED:
+                case TCP_STATE_ESTABLISHED | TCP_STATE_SEND_OPEN:
+                    // Retry FIN
+                    tap_tcp_segment(tap, ts, TCP_FLAG_FIN | TCP_FLAG_ACK);
+                    break;
+            }
+        }
+    }
+
+    if (ts->timeout++) {
+        // Upon ACK timeout, retransmit the whole window
+        tcp_segment_t* seg = tcp->head;
+        uint32_t seq = tcp->seq_ack;
+        while (seg && seq - tcp->seq_ack < tcp->window) {
+            eth_send(tap, tcp_seg_buffer(seg), seg->size + TCP_WRAP_SIZE);
+            seq += seg->size;
+            seg = seg->next;
+        }
+    }
+    if (ts->timeout > 50) {
+        if (tcp->state & TCP_STATE_ESTABLISHED) {
+            // Each 10s, send keepalive packet (seq = last seq - 1)
+            tap_tcp_segment_gen(tap, ts, TCP_FLAG_ACK, 1);
+        }
+        if (ts->timeout > 300 || !(tcp->state & TCP_STATE_ESTABLISHED)) {
+            // Connection is assumed dead after a minute
+            // Incoming connection has 10s to be accepted
+            tap_tcp_close(tap, ts);
+        }
+    }
+}
+
+static void tap_net_periodic(tap_dev_t* tap)
+{
+    hashmap_foreach(&tap->tcp_map, hash, ts_val) {
+        ts_vec_t* vec = (ts_vec_t*)ts_val;
+        UNUSED(hash);
+        vector_foreach_back(*vec, i) {
+            tap_tcp_periodic(tap, vector_at(*vec, i));
+        }
+    }
+
+    hashmap_foreach(&tap->udp_ports, port, ts_val) {
+        tap_sock_t* ts = (tap_sock_t*)ts_val;
+        if (ts->timeout != BOUND_INF && ts->timeout++ >= 300) {
+            // UDP timeouts after 60 seconds
+            hashmap_remove(&tap->udp_ports, port);
+            net_sock_close(ts->sock);
+            free(ts);
+            break;
+        }
+    }
+}
+
+static void* tap_thread(void* arg)
+{
+    tap_dev_t* tap = arg;
+    rvtimer_t timer;
+
+    net_event_t events[64];
+    rvtimer_init(&timer, 1000);
+    while (true) {
+        size_t size = net_poll_wait(tap->poll, events, 64, 200);
+        spin_lock(&tap->lock);
+        for (size_t i=0; i<size; ++i) {
+            if (events[i].data == NULL) {
+                // Shutdown notification
+                spin_unlock(&tap->lock);
+                return NULL;
+            }
+            tap_sock_t* ts = events[i].data;
+            if (ts->tcp) {
+                // TCP socket
+                if (events[i].flags & NET_POLL_SEND) {
+                    if (net_tcp_status(ts->sock)) {
+                        // Connection succeeded
+                        net_poll_remove(tap->poll, ts->sock);
+                        ts->tcp->state |= TCP_STATE_RECV_OPEN;
+                        ts->tcp->seq++;
+                        tap_tcp_segment(tap, ts, TCP_FLAG_SYN | TCP_FLAG_ACK);
+                    } else {
+                        // Connection refused or timeout
+                        tap_tcp_close(tap, ts);
+                    }
+                } else if (ts->tcp->state == TCP_STATE_LISTEN) {
+                    tap_tcp_accept(tap, ts);
+                } else {
+                    tap_tcp_recv(tap, ts);
+                }
+            } else {
+                // UDP
+                tap_udp_recv(tap, ts);
+            }
+        }
+
+        if (rvtimer_get(&timer) >= 200) {
+            tap_net_periodic(tap);
+            rvtimer_init(&timer, 1000);
+        }
+        spin_unlock(&tap->lock);
+    }
+    return NULL;
+}
+
+tap_dev_t* tap_open(void)
+{
+    tap_dev_t* tap = safe_new_obj(tap_dev_t);
+    // Generate a random local unicast MAC
+    rvvm_randombytes(tap->mac, 6);
+    tap->mac[0] = (tap->mac[0] & 0xFE) | 0x2;
+
+    tap->poll = net_poll_create();
+
+    // Create shutdown sockpair & watch for it
+    net_tcp_sockpair(tap->shut);
+    net_event_t event = { .data = NULL, };
+    net_poll_add(tap->poll, tap->shut[0], &event);
+
+    hashmap_init(&tap->udp_ports, 16);
+    hashmap_init(&tap->tcp_map, 16);
+
+    return tap;
+}
+
+void tap_attach(tap_dev_t* tap, const tap_net_dev_t* net_dev)
+{
+    if (tap->net.feed_rx == NULL) {
+        tap->net = *net_dev;
+        tap->thread = thread_create(tap_thread, tap);
+    }
+}
+
+bool tap_portfwd(tap_dev_t* tap, const char* fwd)
+{
+    net_addr_t host, guest;
+    char host_str[256];
+    const char* tcp_prefix = rvvm_strfind(fwd, "tcp/");
+    const char* udp_prefix = rvvm_strfind(fwd, "udp/");
+    if (tcp_prefix || udp_prefix) fwd += 4;
+    const char* delim = rvvm_strfind(fwd, "=");
+    if (!delim) return false;
+    rvvm_strlcpy(host_str, fwd, EVAL_MIN((size_t)(delim - fwd + 1), sizeof(host_str)));
+    if (!net_parse_addr(&host, host_str) || !net_parse_addr(&guest, delim + 1)) {
+        return false;
+    }
+    // Accomodate addr types (If only port is passed at either side, etc)
+    if (guest.type == NET_TYPE_IPV4) guest.type = host.type;
+    if (host.type == NET_TYPE_IPV4) host.type = guest.type;
+    if (guest.type == NET_TYPE_IPV4 && memcmp(guest.ip, net_ipv4_any_addr.ip, PLEN_IPv4) == 0) {
+        memcpy(guest.ip, CLIENT_IP, PLEN_IPv4);
+    }
+    bool ret = true;
+    if (tcp_prefix || !udp_prefix) ret = bind_port(tap, &guest, &host, true);
+    if (ret && (udp_prefix || !tcp_prefix)) ret = bind_port(tap, &guest, &host, false);
+    if (!ret) {
+        rvvm_error("Failed to bind %s", host_str);
+        if (host.port && host.port < 1024) rvvm_error("Binding ports below 1024 requires root/admin privilege");
+    }
+    return ret;
+}
+
+void tap_close(tap_dev_t* tap)
+{
+    // Shut down the TAP thread
+    net_sock_close(tap->shut[1]);
+    thread_join(tap->thread);
+
+    // Cleanup
+    hashmap_foreach(&tap->tcp_map, hash, ts_val) {
+        ts_vec_t* vec = (ts_vec_t*)ts_val;
+        UNUSED(hash);
+        vector_foreach_back(*vec, i) {
+            tap_tcp_close(NULL, vector_at(*vec, i));
+        }
+        vector_free(*vec);
+        free(vec);
+    }
+    hashmap_foreach(&tap->udp_ports, port, ts_val) {
+        UNUSED(port);
+        tap_sock_t* ts = (tap_sock_t*)ts_val;
+        net_sock_close(ts->sock);
+        free(ts);
+    }
+    vector_foreach(tap->tcp_listeners, i) {
+        tap_tcp_close(NULL, vector_at(tap->tcp_listeners, i));
+    }
+    vector_free(tap->tcp_listeners);
+    hashmap_destroy(&tap->udp_ports);
+    hashmap_destroy(&tap->tcp_map);
+    net_sock_close(tap->shut[0]);
+    net_poll_close(tap->poll);
+    free(tap);
+}
diff --git a/app/src/main/java/libengine/RVVM/src/devices/win32window.c b/app/src/main/java/libengine/RVVM/src/devices/win32window.c
new file mode 100644
index 00000000..04810d22
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/win32window.c
@@ -0,0 +1,313 @@
+/*
+win32window.c - Win32 RVVM Window
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef UNICODE
+#define UNICODE
+#endif
+
+#include "gui_window.h"
+#include "../utils.h"
+#include "../vma_ops.h"
+
+#include <windows.h>
+
+typedef struct {
+    HWND hwnd;
+    HDC  hdc;
+} win32_data_t;
+
+static ATOM winclass_atom = 0;
+
+static const hid_key_t win32_key_to_hid_byte_map[] = {
+    [0x41] = HID_KEY_A,
+    [0x42] = HID_KEY_B,
+    [0x43] = HID_KEY_C,
+    [0x44] = HID_KEY_D,
+    [0x45] = HID_KEY_E,
+    [0x46] = HID_KEY_F,
+    [0x47] = HID_KEY_G,
+    [0x48] = HID_KEY_H,
+    [0x49] = HID_KEY_I,
+    [0x4A] = HID_KEY_J,
+    [0x4B] = HID_KEY_K,
+    [0x4C] = HID_KEY_L,
+    [0x4D] = HID_KEY_M,
+    [0x4E] = HID_KEY_N,
+    [0x4F] = HID_KEY_O,
+    [0x50] = HID_KEY_P,
+    [0x51] = HID_KEY_Q,
+    [0x52] = HID_KEY_R,
+    [0x53] = HID_KEY_S,
+    [0x54] = HID_KEY_T,
+    [0x55] = HID_KEY_U,
+    [0x56] = HID_KEY_V,
+    [0x57] = HID_KEY_W,
+    [0x58] = HID_KEY_X,
+    [0x59] = HID_KEY_Y,
+    [0x5A] = HID_KEY_Z,
+    [0x30] = HID_KEY_0,
+    [0x31] = HID_KEY_1,
+    [0x32] = HID_KEY_2,
+    [0x33] = HID_KEY_3,
+    [0x34] = HID_KEY_4,
+    [0x35] = HID_KEY_5,
+    [0x36] = HID_KEY_6,
+    [0x37] = HID_KEY_7,
+    [0x38] = HID_KEY_8,
+    [0x39] = HID_KEY_9,
+    [0x0D] = HID_KEY_ENTER,
+    [0x1B] = HID_KEY_ESC,
+    [0x08] = HID_KEY_BACKSPACE,
+    [0x09] = HID_KEY_TAB,
+    [0x20] = HID_KEY_SPACE,
+    [0xBD] = HID_KEY_MINUS,
+    [0xBB] = HID_KEY_EQUAL,
+    [0xDB] = HID_KEY_LEFTBRACE,
+    [0xDD] = HID_KEY_RIGHTBRACE,
+    [0xDC] = HID_KEY_BACKSLASH,
+    [0xBA] = HID_KEY_SEMICOLON,
+    [0xDE] = HID_KEY_APOSTROPHE,
+    [0xC0] = HID_KEY_GRAVE,
+    [0xBC] = HID_KEY_COMMA,
+    [0xBE] = HID_KEY_DOT,
+    [0xBF] = HID_KEY_SLASH,
+    [0x14] = HID_KEY_CAPSLOCK,
+    [0x70] = HID_KEY_F1,
+    [0x71] = HID_KEY_F2,
+    [0x72] = HID_KEY_F3,
+    [0x73] = HID_KEY_F4,
+    [0x74] = HID_KEY_F5,
+    [0x75] = HID_KEY_F6,
+    [0x76] = HID_KEY_F7,
+    [0x77] = HID_KEY_F8,
+    [0x78] = HID_KEY_F9,
+    [0x79] = HID_KEY_F10,
+    [0x7A] = HID_KEY_F11,
+    [0x7B] = HID_KEY_F12,
+    [0x2C] = HID_KEY_SYSRQ,
+    [0x91] = HID_KEY_SCROLLLOCK,
+    [0x13] = HID_KEY_PAUSE,
+    [0x2D] = HID_KEY_INSERT,
+    [0x24] = HID_KEY_HOME,
+    [0x21] = HID_KEY_PAGEUP,
+    [0x2E] = HID_KEY_DELETE,
+    [0x23] = HID_KEY_END,
+    [0x22] = HID_KEY_PAGEDOWN,
+    [0x27] = HID_KEY_RIGHT,
+    [0x25] = HID_KEY_LEFT,
+    [0x28] = HID_KEY_DOWN,
+    [0x26] = HID_KEY_UP,
+    [0x90] = HID_KEY_NUMLOCK,
+    [0x6F] = HID_KEY_KPSLASH,
+    [0x6A] = HID_KEY_KPASTERISK,
+    [0x6D] = HID_KEY_KPMINUS,
+    [0x6B] = HID_KEY_KPPLUS,
+    [0x6C] = HID_KEY_KPENTER,
+    [0x61] = HID_KEY_KP1,
+    [0x62] = HID_KEY_KP2,
+    [0x63] = HID_KEY_KP3,
+    [0x64] = HID_KEY_KP4,
+    [0x65] = HID_KEY_KP5,
+    [0x66] = HID_KEY_KP6,
+    [0x67] = HID_KEY_KP7,
+    [0x68] = HID_KEY_KP8,
+    [0x69] = HID_KEY_KP9,
+    [0x60] = HID_KEY_KP0,
+    [0x6E] = HID_KEY_KPDOT,
+    [0x5D] = HID_KEY_MENU,
+    [0xE2] = HID_KEY_RO, // It's HID_KEY_102ND on German keyboards (I have one),
+                         // but Windows has no way to distinguish their VK keycodes
+    [0xF2] = HID_KEY_KATAKANAHIRAGANA,
+    [0x1C] = HID_KEY_HENKAN,
+    [0x1D] = HID_KEY_MUHENKAN,
+    [0x15] = HID_KEY_HANGEUL, // Actually KANA on Japanese NEC PC-9800
+    [0x19] = HID_KEY_HANJA,
+    [0x11] = HID_KEY_LEFTCTRL,
+    [0x10] = HID_KEY_LEFTSHIFT,
+    [0x12] = HID_KEY_LEFTALT,
+    [0x5B] = HID_KEY_LEFTMETA,
+    [0xA3] = HID_KEY_RIGHTCTRL,
+    [0xA1] = HID_KEY_RIGHTSHIFT,
+    [0xA5] = HID_KEY_RIGHTALT,
+    [0x5C] = HID_KEY_RIGHTMETA,
+};
+
+static hid_key_t win32_key_to_hid(uint32_t win32_key)
+{
+    if (win32_key < sizeof(win32_key_to_hid_byte_map)) {
+        return win32_key_to_hid_byte_map[win32_key];
+    }
+    return HID_KEY_NONE;
+}
+
+static LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
+{
+    switch (uMsg) {
+        case WM_CLOSE:
+            PostMessage(hwnd, WM_QUIT, wParam, lParam);
+            return 0;
+        case WM_KILLFOCUS:
+            // This is an ugly fucking way to handle WM_KILLFOCUS via PeekMessage()
+            PostMessage(hwnd, uMsg, wParam, lParam);
+            return 0;
+    }
+
+    if (uMsg == WM_SETCURSOR && LOWORD(lParam) == HTCLIENT) SetCursor(NULL);
+    return DefWindowProc(hwnd, uMsg, wParam, lParam);
+}
+
+static void win32_window_remove(gui_window_t* win)
+{
+    win32_data_t* data = win->win_data;
+    if (data->hwnd) {
+        ReleaseDC(data->hwnd, data->hdc);
+        DestroyWindow(data->hwnd);
+    }
+    vma_free(win->fb.buffer, framebuffer_size(&win->fb));
+    free(data);
+}
+
+static void win32_window_draw(gui_window_t* win)
+{
+    win32_data_t* data = win->win_data;
+    BITMAPINFO bmi = {
+        .bmiHeader = {
+            .biSize = sizeof(BITMAPINFOHEADER),
+            .biWidth = win->fb.width,
+            .biHeight = -win->fb.height,
+            .biPlanes = 1,
+            .biBitCount = 32,
+        },
+    };
+    StretchDIBits(data->hdc, 0, 0, win->fb.width, win->fb.height,
+                             0, 0, win->fb.width, win->fb.height,
+                             win->fb.buffer, &bmi, 0, SRCCOPY);
+}
+
+static void win32_window_poll(gui_window_t* win)
+{
+    win32_data_t* data = win->win_data;
+    MSG Msg = {0};
+    while (PeekMessage(&Msg, data->hwnd, 0, 0, PM_REMOVE)) {
+        switch (Msg.message) {
+            case WM_MOUSEMOVE: {
+                POINTS cur = MAKEPOINTS(Msg.lParam);
+                win->on_mouse_place(win, cur.x, cur.y);
+                break;
+            }
+            case WM_KEYDOWN:
+            case WM_SYSKEYDOWN: // For handling F10
+                // Disable autorepeat keypresses
+                if ((Msg.lParam & KF_REPEAT) == 0) {
+                    win->on_key_press(win, win32_key_to_hid(Msg.wParam));
+                }
+                break;
+            case WM_KEYUP:
+            case WM_SYSKEYUP:
+                if ((Msg.lParam & KF_REPEAT) == 0) {
+                    win->on_key_release(win, win32_key_to_hid(Msg.wParam));
+                }
+                break;
+            case WM_LBUTTONDOWN:
+                win->on_mouse_press(win, HID_BTN_LEFT);
+                break;
+            case WM_LBUTTONUP:
+                win->on_mouse_release(win, HID_BTN_LEFT);
+                break;
+            case WM_RBUTTONDOWN:
+                win->on_mouse_press(win, HID_BTN_RIGHT);
+                break;
+            case WM_RBUTTONUP:
+                win->on_mouse_release(win, HID_BTN_RIGHT);
+                break;
+            case WM_MBUTTONDOWN:
+                win->on_mouse_press(win, HID_BTN_MIDDLE);
+                break;
+            case WM_MBUTTONUP:
+                win->on_mouse_release(win, HID_BTN_MIDDLE);
+                break;
+            case WM_MOUSEWHEEL:
+                win->on_mouse_scroll(win, -GET_WHEEL_DELTA_WPARAM(Msg.wParam) / WHEEL_DELTA);
+                break;
+            case WM_QUIT:
+                win->on_close(win);
+                break;
+            case WM_KILLFOCUS:
+                win->on_focus_lost(win);
+                break;
+            default:
+                DispatchMessage(&Msg);
+                break;
+        }
+    }
+}
+
+bool win32_window_init(gui_window_t* win)
+{
+    DO_ONCE({
+        // Initialize window atom
+        WNDCLASSW wc = {0};
+        wc.lpfnWndProc   = WindowProc;
+        wc.hInstance     = GetModuleHandle(NULL);
+        wc.lpszClassName = L"RVVM_window";
+        winclass_atom = RegisterClassW(&wc);
+        if (winclass_atom == 0) {
+            rvvm_error("Failed to register window class!");
+            return false;
+        }
+    });
+
+    // Adjust window size
+    RECT rect = {
+        .right = win->fb.width,
+        .bottom = win->fb.height,
+    };
+    AdjustWindowRectEx(&rect, WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX, false, 0);
+
+    // Create window
+    HWND hwnd = CreateWindowW(L"RVVM_window", L"RVVM",
+        WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX | WS_VISIBLE,
+        CW_USEDEFAULT, CW_USEDEFAULT, (rect.right - rect.left), (rect.bottom - rect.top),
+        NULL, NULL, GetModuleHandle(NULL), NULL);
+    if (hwnd == NULL) {
+        rvvm_error("Failed to create window!");
+        return false;
+    }
+
+    // Initialize structures
+    win32_data_t* data = safe_new_obj(win32_data_t);
+    data->hwnd = hwnd;
+    data->hdc = GetDC(hwnd);
+
+    win->win_data = data;
+    win->fb.format = RGB_FMT_A8R8G8B8;
+    win->fb.buffer = vma_alloc(NULL, framebuffer_size(&win->fb), VMA_RDWR);
+
+    // Initialize callbacks
+    win->draw = win32_window_draw;
+    win->poll = win32_window_poll;
+    win->remove = win32_window_remove;
+    // TODO: win32_window_grab_input, win32_window_set_title, relative mouse mode
+
+#ifndef UNDER_CE
+    // Set smooth scaling on HiDPI
+    SetStretchBltMode(data->hdc, STRETCH_HALFTONE);
+#endif
+
+    return true;
+}
diff --git a/app/src/main/java/libengine/RVVM/src/devices/x11window_xlib.c b/app/src/main/java/libengine/RVVM/src/devices/x11window_xlib.c
new file mode 100644
index 00000000..4609ccd2
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/devices/x11window_xlib.c
@@ -0,0 +1,772 @@
+/*
+x11window.c - X11 RVVM Window, Xlib backend
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "gui_window.h"
+#include "../dlib.h"
+#include "../vma_ops.h"
+#include "../utils.h"
+#include "../compiler.h"
+
+#define X11_DYNAMIC_LOADING
+
+// Resolve symbols at runtime
+#define X11_DLIB_SYM(sym) static typeof(sym)* sym##_dlib = NULL;
+
+// Check for X11 headers presence
+#if defined(USE_X11) && !(CHECK_INCLUDE(X11/Xlib.h) && CHECK_INCLUDE(X11/Xutil.h) && CHECK_INCLUDE(X11/keysym.h))
+#undef USE_X11
+#warning Disabling X11 support as <X11/Xlib.h> is unavailable
+#endif
+
+// Check for XShm header presence
+#if CHECK_INCLUDE(X11/extensions/XShm.h) && CHECK_INCLUDE(sys/ipc.h) && CHECK_INCLUDE(sys/shm.h)
+#define USE_XSHM
+#else
+#warning Disabling XShm support as <X11/extensions/XShm.h> is unavailable
+#endif
+
+#ifdef USE_X11
+
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+#include <X11/keysym.h>
+
+#ifdef USE_XSHM
+#include <X11/extensions/XShm.h>
+#include <sys/ipc.h>
+#include <sys/shm.h>
+
+#ifdef X11_DYNAMIC_LOADING
+X11_DLIB_SYM(XShmQueryExtension)
+X11_DLIB_SYM(XShmDetach)
+X11_DLIB_SYM(XShmCreateImage)
+X11_DLIB_SYM(XShmAttach)
+X11_DLIB_SYM(XShmPutImage)
+
+#define XShmQueryExtension XShmQueryExtension_dlib
+#define XShmDetach XShmDetach_dlib
+#define XShmCreateImage XShmCreateImage_dlib
+#define XShmAttach XShmAttach_dlib
+#define XShmPutImage XShmPutImage_dlib
+#endif
+
+#endif
+
+#ifdef X11_DYNAMIC_LOADING
+X11_DLIB_SYM(XGetKeyboardMapping)
+X11_DLIB_SYM(XFree)
+X11_DLIB_SYM(XListPixmapFormats)
+X11_DLIB_SYM(XSetErrorHandler)
+X11_DLIB_SYM(XSync)
+X11_DLIB_SYM(XPutImage)
+X11_DLIB_SYM(XWarpPointer)
+X11_DLIB_SYM(XFlush)
+X11_DLIB_SYM(XPending)
+X11_DLIB_SYM(XNextEvent)
+X11_DLIB_SYM(XPeekEvent)
+X11_DLIB_SYM(XGrabKeyboard)
+X11_DLIB_SYM(XGrabPointer)
+X11_DLIB_SYM(XQueryPointer)
+X11_DLIB_SYM(XUngrabKeyboard)
+X11_DLIB_SYM(XUngrabPointer)
+X11_DLIB_SYM(XStoreName)
+X11_DLIB_SYM(XFreeGC)
+X11_DLIB_SYM(XDestroyWindow)
+X11_DLIB_SYM(XCloseDisplay)
+X11_DLIB_SYM(XDisplayKeycodes)
+X11_DLIB_SYM(XSetWMNormalHints)
+X11_DLIB_SYM(XSetWMProtocols)
+X11_DLIB_SYM(XCreateBitmapFromData)
+X11_DLIB_SYM(XCreatePixmapCursor)
+X11_DLIB_SYM(XDefineCursor)
+X11_DLIB_SYM(XFreeCursor)
+X11_DLIB_SYM(XFreePixmap)
+X11_DLIB_SYM(XMapWindow)
+X11_DLIB_SYM(XCreateGC)
+X11_DLIB_SYM(XCreateImage)
+X11_DLIB_SYM(XOpenDisplay)
+X11_DLIB_SYM(XInternAtom)
+X11_DLIB_SYM(XCreateWindow)
+
+#define XGetKeyboardMapping XGetKeyboardMapping_dlib
+#define XFree XFree_dlib
+#define XListPixmapFormats XListPixmapFormats_dlib
+#define XSetErrorHandler XSetErrorHandler_dlib
+#define XSync XSync_dlib
+#define XPutImage XPutImage_dlib
+#define XWarpPointer XWarpPointer_dlib
+#define XFlush XFlush_dlib
+#define XPending XPending_dlib
+#define XNextEvent XNextEvent_dlib
+#define XPeekEvent XPeekEvent_dlib
+#define XGrabKeyboard XGrabKeyboard_dlib
+#define XGrabPointer XGrabPointer_dlib
+#define XQueryPointer XQueryPointer_dlib
+#define XUngrabKeyboard XUngrabKeyboard_dlib
+#define XUngrabPointer XUngrabPointer_dlib
+#define XStoreName XStoreName_dlib
+#define XFreeGC XFreeGC_dlib
+#define XDestroyWindow XDestroyWindow_dlib
+#define XCloseDisplay XCloseDisplay_dlib
+#define XDisplayKeycodes XDisplayKeycodes_dlib
+#define XSetWMNormalHints XSetWMNormalHints_dlib
+#define XSetWMProtocols XSetWMProtocols_dlib
+#define XCreateBitmapFromData XCreateBitmapFromData_dlib
+#define XCreatePixmapCursor XCreatePixmapCursor_dlib
+#define XDefineCursor XDefineCursor_dlib
+#define XFreeCursor XFreeCursor_dlib
+#define XFreePixmap XFreePixmap_dlib
+#define XMapWindow XMapWindow_dlib
+#define XCreateGC XCreateGC_dlib
+#define XCreateImage XCreateImage_dlib
+#define XOpenDisplay XOpenDisplay_dlib
+#define XInternAtom XInternAtom_dlib
+#define XCreateWindow XCreateWindow_dlib
+#endif
+
+typedef struct {
+    Display* display;
+    Window window;
+    GC gc;
+    XImage* ximage;
+    void* image_buffer;
+
+#ifdef USE_XSHM
+    XShmSegmentInfo seginfo;
+#endif
+
+    // Keycode stuff
+    KeySym* keycodemap;
+    int min_keycode;
+    int max_keycode;
+    int keysyms_per_keycode;
+
+    // Handle window closing
+    Atom wm_delete;
+
+    bool grabbed;
+
+    // These are used to restore the original pointer position
+    Window grab_root;
+    int grab_pointer_x;
+    int grab_pointer_y;
+} x11_data_t;
+
+static hid_key_t x11_keysym_to_hid(KeySym keysym)
+{
+    // XK_ definitions are huge numbers, don't use a table
+    switch (keysym) {
+        case XK_a:            return HID_KEY_A;
+        case XK_b:            return HID_KEY_B;
+        case XK_c:            return HID_KEY_C;
+        case XK_d:            return HID_KEY_D;
+        case XK_e:            return HID_KEY_E;
+        case XK_f:            return HID_KEY_F;
+        case XK_g:            return HID_KEY_G;
+        case XK_h:            return HID_KEY_H;
+        case XK_i:            return HID_KEY_I;
+        case XK_j:            return HID_KEY_J;
+        case XK_k:            return HID_KEY_K;
+        case XK_l:            return HID_KEY_L;
+        case XK_m:            return HID_KEY_M;
+        case XK_n:            return HID_KEY_N;
+        case XK_o:            return HID_KEY_O;
+        case XK_p:            return HID_KEY_P;
+        case XK_q:            return HID_KEY_Q;
+        case XK_r:            return HID_KEY_R;
+        case XK_s:            return HID_KEY_S;
+        case XK_t:            return HID_KEY_T;
+        case XK_u:            return HID_KEY_U;
+        case XK_v:            return HID_KEY_V;
+        case XK_w:            return HID_KEY_W;
+        case XK_x:            return HID_KEY_X;
+        case XK_y:            return HID_KEY_Y;
+        case XK_z:            return HID_KEY_Z;
+        case XK_0:            return HID_KEY_0;
+        case XK_1:            return HID_KEY_1;
+        case XK_2:            return HID_KEY_2;
+        case XK_3:            return HID_KEY_3;
+        case XK_4:            return HID_KEY_4;
+        case XK_5:            return HID_KEY_5;
+        case XK_6:            return HID_KEY_6;
+        case XK_7:            return HID_KEY_7;
+        case XK_8:            return HID_KEY_8;
+        case XK_9:            return HID_KEY_9;
+        case XK_Return:       return HID_KEY_ENTER;
+        case XK_Escape:       return HID_KEY_ESC;
+        case XK_BackSpace:    return HID_KEY_BACKSPACE;
+        case XK_Tab:          return HID_KEY_TAB;
+        case XK_space:        return HID_KEY_SPACE;
+        case XK_minus:        return HID_KEY_MINUS;
+        case XK_equal:        return HID_KEY_EQUAL;
+        case XK_bracketleft:  return HID_KEY_LEFTBRACE;
+        case XK_bracketright: return HID_KEY_RIGHTBRACE;
+        case XK_backslash:    return HID_KEY_BACKSLASH;
+        case XK_semicolon:    return HID_KEY_SEMICOLON;
+        case XK_apostrophe:   return HID_KEY_APOSTROPHE;
+        case XK_grave:        return HID_KEY_GRAVE;
+        case XK_comma:        return HID_KEY_COMMA;
+        case XK_period:       return HID_KEY_DOT;
+        case XK_slash:        return HID_KEY_SLASH;
+        case XK_Caps_Lock:    return HID_KEY_CAPSLOCK;
+        case XK_F1:           return HID_KEY_F1;
+        case XK_F2:           return HID_KEY_F2;
+        case XK_F3:           return HID_KEY_F3;
+        case XK_F4:           return HID_KEY_F4;
+        case XK_F5:           return HID_KEY_F5;
+        case XK_F6:           return HID_KEY_F6;
+        case XK_F7:           return HID_KEY_F7;
+        case XK_F8:           return HID_KEY_F8;
+        case XK_F9:           return HID_KEY_F9;
+        case XK_F10:          return HID_KEY_F10;
+        case XK_F11:          return HID_KEY_F11;
+        case XK_F12:          return HID_KEY_F12;
+        case XK_Print:        return HID_KEY_SYSRQ;
+        case XK_Scroll_Lock:  return HID_KEY_SCROLLLOCK;
+        case XK_Pause:        return HID_KEY_PAUSE;
+        case XK_Insert:       return HID_KEY_INSERT;
+        case XK_Home:         return HID_KEY_HOME;
+        case XK_Prior:        return HID_KEY_PAGEUP; // ?
+        case XK_Delete:       return HID_KEY_DELETE;
+        case XK_End:          return HID_KEY_END;
+        case XK_Next:         return HID_KEY_PAGEDOWN; // ?
+        case XK_Right:        return HID_KEY_RIGHT;
+        case XK_Left:         return HID_KEY_LEFT;
+        case XK_Down:         return HID_KEY_DOWN;
+        case XK_Up:           return HID_KEY_UP;
+        case XK_Num_Lock:     return HID_KEY_NUMLOCK;
+        case XK_KP_Divide:    return HID_KEY_KPSLASH;
+        case XK_KP_Multiply:  return HID_KEY_KPASTERISK;
+        case XK_KP_Subtract:  return HID_KEY_KPMINUS;
+        case XK_KP_Add:       return HID_KEY_KPPLUS;
+        case XK_KP_Enter:     return HID_KEY_KPENTER;
+        case XK_KP_End:       return HID_KEY_KP1;
+        case XK_KP_Down:      return HID_KEY_KP2;
+        case XK_KP_Page_Down: return HID_KEY_KP3;
+        case XK_KP_Left:      return HID_KEY_KP4;
+        case XK_KP_Begin:     return HID_KEY_KP5;
+        case XK_KP_Right:     return HID_KEY_KP6;
+        case XK_KP_Home:      return HID_KEY_KP7;
+        case XK_KP_Up:        return HID_KEY_KP8;
+        case XK_KP_Page_Up:   return HID_KEY_KP9;
+        case XK_KP_Insert:    return HID_KEY_KP0;
+        case XK_KP_Delete:    return HID_KEY_KPDOT;
+        case XK_less:         return HID_KEY_102ND;
+        case XK_Multi_key:    return HID_KEY_COMPOSE;
+        case XK_KP_Equal:     return HID_KEY_KPEQUAL;
+        case XK_KP_Separator: return HID_KEY_KPCOMMA;
+        case 0x04db:          return HID_KEY_RO;
+        case 0xff27:          return HID_KEY_KATAKANAHIRAGANA;
+        case XK_yen:          return HID_KEY_YEN;
+        case 0xff23:          return HID_KEY_HENKAN;
+        case 0xff22:          return HID_KEY_MUHENKAN;
+        case 0x04a4:          return HID_KEY_KPJPCOMMA;
+        case 0xff31:          return HID_KEY_HANGEUL;
+        case 0xff34:          return HID_KEY_HANJA;
+        case 0xff26:          return HID_KEY_KATAKANA;
+        case 0xff25:          return HID_KEY_HIRAGANA;
+        case 0xff2a:          return HID_KEY_ZENKAKUHANKAKU;
+        case XK_Menu:         return HID_KEY_MENU;
+        case XK_Control_L:    return HID_KEY_LEFTCTRL;
+        case XK_Shift_L:      return HID_KEY_LEFTSHIFT;
+        case XK_Alt_L:        return HID_KEY_LEFTALT;
+        case XK_Super_L:      return HID_KEY_LEFTMETA;
+        case XK_Control_R:    return HID_KEY_RIGHTCTRL;
+        case XK_Shift_R:      return HID_KEY_RIGHTSHIFT;
+        case XK_Alt_R:        return HID_KEY_RIGHTALT;
+        case XK_Super_R:      return HID_KEY_RIGHTMETA;
+    }
+    return HID_KEY_NONE;
+}
+
+static hid_key_t x11_event_key_to_hid(x11_data_t* x11, int keycode)
+{
+    if (x11->keycodemap == NULL) {
+        rvvm_warn("XKeycodemap not initialized!");
+        return HID_KEY_NONE;
+    } else if (keycode < x11->min_keycode || keycode > x11->max_keycode) {
+        rvvm_warn("XEvent keycode out of keycodemap range!");
+        return HID_KEY_NONE;
+    } else {
+        uint32_t entry = (keycode - x11->min_keycode) * x11->keysyms_per_keycode;
+        return x11_keysym_to_hid(x11->keycodemap[entry]);
+    }
+}
+
+static void x11_update_keymap(x11_data_t* x11)
+{
+    KeySym* keycodemap = XGetKeyboardMapping(x11->display,
+                            x11->min_keycode, x11->max_keycode - x11->min_keycode + 1,
+                            &x11->keysyms_per_keycode);
+    if (keycodemap) {
+        if (x11->keycodemap) {
+            XFree(x11->keycodemap);
+        }
+        x11->keycodemap = keycodemap;
+    } else {
+        rvvm_warn("XGetKeyboardMapping() failed!");
+    }
+}
+
+static rgb_fmt_t x11_get_rgb_format(Display* display)
+{
+    rgb_fmt_t format = RGB_FMT_INVALID;
+    int nfmts = 0;
+    XPixmapFormatValues* fmts = XListPixmapFormats(display, &nfmts);
+    if (fmts) {
+        for (int i = 0; i < nfmts; ++i) {
+            if (fmts[i].depth == DefaultDepth(display, DefaultScreen(display))) {
+                format = rgb_format_from_bpp(fmts[i].bits_per_pixel);
+                break;
+            }
+        }
+        XFree(fmts);
+    }
+    return format;
+}
+
+#ifdef USE_XSHM
+
+static bool xshm_error = false;
+static int x11_dummy_error_handler(Display* display, XErrorEvent* error)
+{
+    UNUSED(display);
+    UNUSED(error);
+    xshm_error = true;
+    return 0;
+}
+
+static void x11_free_xshm(x11_data_t* x11)
+{
+    if (x11->seginfo.shmaddr) {
+        XShmDetach(x11->display, &x11->seginfo);
+        shmdt(x11->seginfo.shmaddr);
+    }
+    x11->seginfo.shmaddr = NULL;
+}
+
+static void* x11_xshm_init(gui_window_t* win)
+{
+    x11_data_t* x11 = win->win_data;
+    Display* dsp = x11->display;
+
+    if (!XShmQueryExtension(dsp)) {
+        rvvm_info("XShm extension not supported");
+        return NULL;
+    }
+
+    x11->ximage = XShmCreateImage(dsp,
+                        DefaultVisual(dsp, DefaultScreen(dsp)),
+                        DefaultDepth(dsp, DefaultScreen(dsp)),
+                        ZPixmap, NULL, &x11->seginfo,
+                        win->fb.width, win->fb.height);
+    if (!x11->ximage) {
+        rvvm_error("XShmCreateImage() failed!");
+        return NULL;
+    }
+
+    x11->seginfo.shmid = shmget(IPC_PRIVATE, framebuffer_size(&win->fb), IPC_CREAT | 0777);
+    if (x11->seginfo.shmid < 0) {
+        rvvm_error("XShm shmget() failed!");
+        return NULL;
+    }
+
+    x11->seginfo.shmaddr = shmat(x11->seginfo.shmid, NULL, 0);
+    shmctl(x11->seginfo.shmid, IPC_RMID, NULL);
+    if (x11->seginfo.shmaddr == (void*)-1 || x11->seginfo.shmaddr == NULL) {
+        rvvm_error("XShm shmget() failed!");
+        return NULL;
+    }
+
+    x11->ximage->data = x11->seginfo.shmaddr;
+    if (!XShmAttach(dsp, &x11->seginfo)) {
+        rvvm_error("XShmAttach() failed!");
+        return NULL;
+    }
+
+    return x11->seginfo.shmaddr;
+}
+
+static void* x11_xshm_attach(gui_window_t* win)
+{
+    x11_data_t* x11 = win->win_data;
+    void* old_handler = XSetErrorHandler(x11_dummy_error_handler);
+    void* xshm = x11_xshm_init(win);
+
+    // Process errors, if any
+    XSync(x11->display, False);
+
+    // Cleanup on error
+    if (xshm == NULL || xshm_error) {
+        rvvm_info("XShm failed to initialize");
+        x11_free_xshm(x11);
+        if (x11->ximage) {
+            XDestroyImage(x11->ximage);
+            x11->ximage = NULL;
+        }
+        xshm = NULL;
+    }
+
+    XSync(x11->display, False);
+    XSetErrorHandler(old_handler);
+    return xshm;
+}
+
+#endif
+
+static void x11_window_draw(gui_window_t* win)
+{
+    x11_data_t* x11 = win->win_data;
+    Display* dsp = x11->display;
+#ifdef USE_XSHM
+    if (x11->seginfo.shmaddr != NULL) {
+        XShmPutImage(dsp,
+                     x11->window,
+                     x11->gc,
+                     x11->ximage,
+                     0, 0, 0, 0, // src, dst x & y
+                     x11->ximage->width,
+                     x11->ximage->height,
+                     False /* send_event */);
+        return;
+    }
+#endif
+    XPutImage(dsp,
+              x11->window,
+              x11->gc,
+              x11->ximage,
+              0, 0, 0, 0, // src, dst x & y
+              x11->ximage->width,
+              x11->ximage->height);
+}
+
+static void x11_handle_mouse_motion(gui_window_t* win, XMotionEvent* xmotion)
+{
+    x11_data_t* x11 = win->win_data;
+    Display* dsp = x11->display;
+
+    if (x11->grabbed) {
+        int center_x = win->fb.width / 2;
+        int center_y = win->fb.height / 2;
+        int dx = xmotion->x - center_x;
+        int dy = xmotion->y - center_y;
+        if (dx || dy) {
+            XWarpPointer(dsp, None, x11->window, 0, 0, 0, 0, center_x, center_y);
+            XFlush(dsp);
+            win->on_mouse_move(win, dx, dy);
+        }
+    } else {
+        win->on_mouse_place(win, xmotion->x, xmotion->y);
+    }
+}
+
+static void x11_window_poll(gui_window_t* win)
+{
+    x11_data_t* x11 = win->win_data;
+    Display* dsp = x11->display;
+    size_t pending = 0;
+
+    XSync(dsp, False);
+    while ((pending = XPending(dsp))) {
+        XEvent ev = {0};
+        XNextEvent(dsp, &ev);
+        switch (ev.type) {
+            case ButtonPress:
+                if (ev.xbutton.button == Button1) {
+                    win->on_mouse_press(win, HID_BTN_LEFT);
+                } else if (ev.xbutton.button == Button2) {
+                    win->on_mouse_press(win, HID_BTN_MIDDLE);
+                } else if (ev.xbutton.button == Button3) {
+                    win->on_mouse_press(win, HID_BTN_RIGHT);
+                } else if (ev.xbutton.button == Button4) {
+                    win->on_mouse_scroll(win, HID_SCROLL_UP);
+                } else if (ev.xbutton.button == Button5) {
+                    win->on_mouse_scroll(win, HID_SCROLL_DOWN);
+                }
+                break;
+            case ButtonRelease:
+                if (ev.xbutton.button == Button1) {
+                    win->on_mouse_release(win, HID_BTN_LEFT);
+                } else if (ev.xbutton.button == Button2) {
+                    win->on_mouse_release(win, HID_BTN_MIDDLE);
+                } else if (ev.xbutton.button == Button3) {
+                    win->on_mouse_release(win, HID_BTN_RIGHT);
+                }
+                break;
+            case MotionNotify:
+                x11_handle_mouse_motion(win, &ev.xmotion);
+                break;
+            case KeyPress:
+                win->on_key_press(win, x11_event_key_to_hid(x11, ev.xkey.keycode));
+                break;
+            case KeyRelease:
+                if (pending > 1) {
+                    XEvent tmp = {0};
+                    XPeekEvent(dsp, &tmp);
+                    if (tmp.type == KeyPress && tmp.xkey.time == ev.xkey.time && tmp.xkey.keycode == ev.xkey.keycode) {
+                        // Skip the repeated key release event, repeated presses are filtered by hid_keyboard
+                        break;
+                    }
+                }
+                win->on_key_release(win, x11_event_key_to_hid(x11, ev.xkey.keycode));
+                break;
+            case MappingNotify:
+                if (ev.xmapping.request == MappingKeyboard) {
+                    x11->min_keycode = ev.xmapping.first_keycode;
+                    x11->max_keycode = ev.xmapping.first_keycode + ev.xmapping.count - 1;
+                    x11_update_keymap(x11);
+                }
+                break;
+            case ClientMessage:
+                if (((Atom)ev.xclient.data.l[0]) == x11->wm_delete) {
+                    // Attempted to close window
+                    win->on_close(win);
+                }
+                break;
+            case FocusOut:
+                if (ev.xfocus.mode == NotifyNormal) {
+                    win->on_focus_lost(win);
+                }
+                break;
+        }
+    }
+}
+
+static void x11_window_grab_input(gui_window_t* win, bool grab)
+{
+    x11_data_t* x11 = win->win_data;
+    Display* dsp = x11->display;
+
+    if (x11->grabbed != grab) {
+        x11->grabbed = grab;
+        if (x11->grabbed) {
+            // Grab the input
+            XGrabKeyboard(dsp, x11->window, True, GrabModeAsync, GrabModeAsync, CurrentTime);
+            XGrabPointer(dsp, x11->window, True,
+                    ButtonPressMask | ButtonReleaseMask | PointerMotionMask,
+                    GrabModeAsync, GrabModeAsync, None, None, CurrentTime);
+
+            // Save the original cursor position
+            Window child = None;
+            int win_x = 0, win_y = 0;
+            unsigned int mask = 0;
+            x11->grab_root = None;
+            XQueryPointer(dsp, x11->window, &x11->grab_root,
+                    &child, &x11->grab_pointer_x, &x11->grab_pointer_y,
+                    &win_x, &win_y, &mask);
+            XWarpPointer(dsp, None, x11->window, 0, 0, 0, 0,
+                    win->fb.width / 2, win->fb.height / 2);
+        } else {
+            // Ungrab
+            XUngrabKeyboard(dsp, CurrentTime);
+            XUngrabPointer(dsp, CurrentTime);
+
+            // Restore the original cursor position
+            if (x11->grab_root) {
+                XWarpPointer(x11->display, None, x11->grab_root, 0, 0, 0, 0,
+                            x11->grab_pointer_x, x11->grab_pointer_y);
+                x11->grab_root = None;
+            }
+        }
+    }
+}
+
+static void x11_window_set_title(gui_window_t* win, const char* title)
+{
+    x11_data_t* x11 = win->win_data;
+    Display* dsp = x11->display;
+
+    XStoreName(dsp, x11->window, title);
+}
+
+static void x11_window_remove(gui_window_t* win)
+{
+    x11_data_t* x11 = win->win_data;
+    Display* dsp = x11->display;
+
+    // Restore input
+    x11_window_grab_input(win, false);
+#ifdef USE_XSHM
+    x11_free_xshm(x11);
+#endif
+    if (x11->image_buffer) {
+        // Free framebuffer VMA
+        vma_free(x11->image_buffer, framebuffer_size(&win->fb));
+        x11->ximage->data = NULL;
+    }
+    XDestroyImage(x11->ximage);
+    XFreeGC(dsp, x11->gc);
+    XDestroyWindow(dsp, x11->window);
+    XFree(x11->keycodemap);
+    XCloseDisplay(dsp);
+
+    free(x11);
+}
+
+#define X11_DLIB_RESOLVE(lib, sym) \
+do { \
+    sym = dlib_resolve(lib, #sym);\
+    if (sym == NULL) return false; \
+} while (0)
+
+static bool x11_init_libs(void)
+{
+#ifdef X11_DYNAMIC_LOADING
+    dlib_ctx_t* libx11 = dlib_open("X11", DLIB_NAME_PROBE);
+
+    X11_DLIB_RESOLVE(libx11, XGetKeyboardMapping);
+    X11_DLIB_RESOLVE(libx11, XFree);
+    X11_DLIB_RESOLVE(libx11, XListPixmapFormats);
+    X11_DLIB_RESOLVE(libx11, XSetErrorHandler);
+    X11_DLIB_RESOLVE(libx11, XSync);
+    X11_DLIB_RESOLVE(libx11, XPutImage);
+    X11_DLIB_RESOLVE(libx11, XWarpPointer);
+    X11_DLIB_RESOLVE(libx11, XFlush);
+    X11_DLIB_RESOLVE(libx11, XPending);
+    X11_DLIB_RESOLVE(libx11, XNextEvent);
+    X11_DLIB_RESOLVE(libx11, XPeekEvent);
+    X11_DLIB_RESOLVE(libx11, XGrabKeyboard);
+    X11_DLIB_RESOLVE(libx11, XGrabPointer);
+    X11_DLIB_RESOLVE(libx11, XQueryPointer);
+    X11_DLIB_RESOLVE(libx11, XUngrabKeyboard);
+    X11_DLIB_RESOLVE(libx11, XUngrabPointer);
+    X11_DLIB_RESOLVE(libx11, XStoreName);
+    X11_DLIB_RESOLVE(libx11, XFreeGC);
+    X11_DLIB_RESOLVE(libx11, XDestroyWindow);
+    X11_DLIB_RESOLVE(libx11, XCloseDisplay);
+    X11_DLIB_RESOLVE(libx11, XDisplayKeycodes);
+    X11_DLIB_RESOLVE(libx11, XSetWMNormalHints);
+    X11_DLIB_RESOLVE(libx11, XSetWMProtocols);
+    X11_DLIB_RESOLVE(libx11, XCreateBitmapFromData);
+    X11_DLIB_RESOLVE(libx11, XCreatePixmapCursor);
+    X11_DLIB_RESOLVE(libx11, XDefineCursor);
+    X11_DLIB_RESOLVE(libx11, XFreeCursor);
+    X11_DLIB_RESOLVE(libx11, XFreePixmap);
+    X11_DLIB_RESOLVE(libx11, XMapWindow);
+    X11_DLIB_RESOLVE(libx11, XCreateGC);
+    X11_DLIB_RESOLVE(libx11, XCreateImage);
+    X11_DLIB_RESOLVE(libx11, XOpenDisplay);
+    X11_DLIB_RESOLVE(libx11, XInternAtom);
+    X11_DLIB_RESOLVE(libx11, XCreateWindow);
+
+    dlib_close(libx11);
+#ifdef USE_XSHM
+    dlib_ctx_t* libxext = dlib_open("Xext", DLIB_NAME_PROBE);
+
+    X11_DLIB_RESOLVE(libxext, XShmQueryExtension);
+    X11_DLIB_RESOLVE(libxext, XShmDetach);
+    X11_DLIB_RESOLVE(libxext, XShmCreateImage);
+    X11_DLIB_RESOLVE(libxext, XShmAttach);
+    X11_DLIB_RESOLVE(libxext, XShmPutImage);
+
+    dlib_close(libxext);
+#endif
+#endif
+    return true;
+}
+
+bool x11_window_init(gui_window_t* win)
+{
+    static bool libx11_avail = false;
+    DO_ONCE(libx11_avail = x11_init_libs());
+    if (!libx11_avail) {
+        rvvm_info("Failed to load libX11!");
+        return false;
+    }
+
+    Display* dsp = XOpenDisplay(NULL);
+    if (dsp == NULL) {
+        rvvm_info("Could not open a connection to the X server!");
+        return false;
+    }
+
+    x11_data_t* x11 = safe_new_obj(x11_data_t);
+    x11->display = dsp;
+
+    // Initialize callbacks
+    win->win_data = x11;
+
+    win->draw = x11_window_draw;
+    win->poll = x11_window_poll;
+    win->remove = x11_window_remove;
+    win->grab_input = x11_window_grab_input;
+    win->set_title = x11_window_set_title;
+
+    XDisplayKeycodes(dsp, &x11->min_keycode, &x11->max_keycode);
+    x11_update_keymap(x11);
+
+    XSetWindowAttributes attributes = {
+        .event_mask = KeyPressMask | KeyReleaseMask | ButtonPressMask | ButtonReleaseMask | PointerMotionMask | FocusChangeMask,
+    };
+    x11->window = XCreateWindow(dsp, DefaultRootWindow(dsp),
+                                0, 0, win->fb.width, win->fb.height, 0,
+                                DefaultDepth(dsp, DefaultScreen(dsp)),
+                                InputOutput, CopyFromParent, CWEventMask, &attributes);
+
+    XSizeHints hints = {
+        .flags = PMinSize | PMaxSize,
+        .min_width = win->fb.width, .min_height = win->fb.height,
+        .max_width = win->fb.width, .max_height = win->fb.height,
+    };
+    XSetWMNormalHints(dsp, x11->window, &hints);
+    XStoreName(dsp, x11->window, "RVVM");
+
+    // Handle window close
+    x11->wm_delete = XInternAtom(dsp, "WM_DELETE_WINDOW", False);
+    XSetWMProtocols(dsp, x11->window, &x11->wm_delete, 1);
+
+    // Hide cursor
+    XColor color = {0};
+    const char pixels[8] = {0};
+    Pixmap pixmap = XCreateBitmapFromData(dsp, x11->window, pixels, 8, 8);
+    Cursor cursor = XCreatePixmapCursor(dsp, pixmap, pixmap, &color, &color, 0, 0);
+    XDefineCursor(dsp, x11->window, cursor);
+    XFreeCursor(dsp, cursor);
+    XFreePixmap(dsp, pixmap);
+
+    // Show window
+    XMapWindow(dsp, x11->window);
+
+    x11->gc = XCreateGC(dsp, x11->window, 0, NULL);
+
+    win->fb.format = x11_get_rgb_format(dsp);
+#ifdef USE_XSHM
+    win->fb.buffer = x11_xshm_attach(win);
+#endif
+    if (win->fb.buffer == NULL) {
+        x11->ximage = XCreateImage(dsp, DefaultVisual(dsp, DefaultScreen(dsp)),
+                                   DefaultDepth(dsp, DefaultScreen(dsp)), ZPixmap, 0,
+                                   NULL, win->fb.width, win->fb.height, 8, 0);
+        x11->image_buffer = vma_alloc(NULL, framebuffer_size(&win->fb), VMA_RDWR);
+        x11->ximage->data = x11->image_buffer;
+        win->fb.buffer = x11->image_buffer;
+    }
+
+    XSync(dsp, False);
+    return true;
+}
+
+#else
+
+bool x11_window_init(gui_window_t* win)
+{
+    UNUSED(win);
+    return false;
+}
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/dlib.c b/app/src/main/java/libengine/RVVM/src/dlib.c
new file mode 100644
index 00000000..c6518cd8
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/dlib.c
@@ -0,0 +1,153 @@
+/*
+dlib.c - Dynamic library loader
+Copyright (C) 2023 0xCatPKG <github.com/0xCatPKG>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "dlib.h"
+
+#ifndef DLIB_DISABLED
+
+#if defined(_WIN32) && !defined(UNDER_CE)
+#include <windows.h>
+#define DLIB_WIN32_IMPL
+#define DLIB_FILE_EXT ".dll"
+
+#elif (defined(__unix__) || defined(__APPLE__) || defined(__HAIKU__)) && !defined(__EMSCRIPTEN__)
+#include <dlfcn.h>
+#define DLIB_POSIX_IMPL
+#ifdef __APPLE__
+#define DLIB_FILE_EXT ".dylib"
+#else
+#define DLIB_FILE_EXT ".so"
+#endif
+#endif
+
+#endif
+
+#ifndef DLIB_FILE_EXT
+#define DLIB_FILE_EXT ""
+#endif
+
+// RVVM internal headers come after system headers because of safe_free()
+#include "utils.h"
+
+struct dlib_ctx {
+#if defined(DLIB_WIN32_IMPL)
+    HMODULE handle;
+#elif defined(DLIB_POSIX_IMPL)
+    void* handle;
+#endif
+    uint32_t flags;
+};
+
+static dlib_ctx_t* dlib_open_internal(const char* lib_name, uint32_t flags)
+{
+#if defined(DLIB_WIN32_IMPL)
+    size_t name_len = rvvm_strlen(lib_name) + 1;
+    wchar_t* u16_name = safe_new_arr(wchar_t, name_len);
+
+    // Try to get module from already loaded modules
+    MultiByteToWideChar(CP_UTF8, 0, lib_name, -1, u16_name, name_len);
+    HMODULE handle = GetModuleHandleW(u16_name);
+    if (handle) {
+        // Prevent unloading an existing module
+        flags &= ~DLIB_MAY_UNLOAD;
+    } else {
+        handle = LoadLibraryExW(u16_name, NULL, 0);
+    }
+    free(u16_name);
+    if (handle == NULL) return NULL;
+    dlib_ctx_t* lib = safe_new_obj(dlib_ctx_t);
+    lib->handle = handle;
+    lib->flags = flags;
+    return lib;
+#elif defined(DLIB_POSIX_IMPL)
+    void* handle = dlopen(lib_name, RTLD_LAZY | RTLD_GLOBAL);
+    if (handle == NULL) return NULL;
+    dlib_ctx_t* lib = safe_new_obj(dlib_ctx_t);
+    lib->handle = handle;
+    lib->flags = flags;
+    return lib;
+#else
+    UNUSED(lib_name);
+    UNUSED(flags);
+    return NULL;
+#endif
+}
+
+static dlib_ctx_t* dlib_open_named(const char* prefix, const char* lib_name, const char* suffix, uint32_t flags)
+{
+    char name[256] = {0};
+    size_t off = rvvm_strlcpy(name, prefix, sizeof(name));
+    off += rvvm_strlcpy(name + off, lib_name, sizeof(name) - off);
+    rvvm_strlcpy(name + off, suffix, sizeof(name) - off);
+    return dlib_open_internal(name, flags);
+}
+
+dlib_ctx_t* dlib_open(const char* lib_name, uint32_t flags)
+{
+    if ((flags & DLIB_NAME_PROBE) && !rvvm_strfind(lib_name, "/")) {
+        dlib_ctx_t* lib = dlib_open_named("lib", lib_name, DLIB_FILE_EXT, flags);
+        if (lib) return lib;
+        lib = dlib_open_named("", lib_name, DLIB_FILE_EXT, flags);
+        if (lib) return lib;
+    }
+    return dlib_open_internal(lib_name, flags);
+}
+
+void dlib_close(dlib_ctx_t* lib)
+{
+    // Silently ignore load error
+    if (lib && (lib->flags & DLIB_MAY_UNLOAD)) {
+        rvvm_info("Unloading a library");
+#if defined(DLIB_WIN32_IMPL)
+        FreeLibrary(lib->handle);
+#elif defined(DLIB_POSIX_IMPL)
+        dlclose(lib->handle);
+#endif
+    }
+    free(lib);
+}
+
+void* dlib_resolve(dlib_ctx_t* lib, const char* symbol_name)
+{
+    // Silently propagate load error
+    if (lib == NULL) return NULL;
+    void* ret = NULL;
+#if defined(DLIB_WIN32_IMPL)
+    ret = (void*)GetProcAddress(lib->handle, symbol_name);
+#elif defined(DLIB_POSIX_IMPL)
+    ret = dlsym(lib->handle, symbol_name);
+#else
+    UNUSED(symbol_name);
+#endif
+    return ret;
+}
+
+void* dlib_get_symbol(const char* lib_name, const char* symbol_name)
+{
+    dlib_ctx_t* lib = dlib_open(lib_name, 0);
+    void* symbol = dlib_resolve(lib, symbol_name);
+    dlib_close(lib);
+    return symbol;
+}
+
+bool dlib_load_weak(const char* lib_name)
+{
+    dlib_ctx_t* lib = dlib_open(lib_name, DLIB_NAME_PROBE);
+    dlib_close(lib);
+    return lib != NULL;
+}
diff --git a/app/src/main/java/libengine/RVVM/src/dlib.h b/app/src/main/java/libengine/RVVM/src/dlib.h
new file mode 100644
index 00000000..ca1eeba1
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/dlib.h
@@ -0,0 +1,45 @@
+/*
+dlib.h - Dynamic library loader
+Copyright (C) 2023 0xCatPKG <github.com/0xCatPKG>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef RVVM_DLIB_H
+#define RVVM_DLIB_H
+
+#include <stdint.h>
+#include <stdbool.h>
+
+#define DLIB_NAME_PROBE 0x1 // Probe various A.so, libA.so variations
+#define DLIB_MAY_UNLOAD 0x2 // Allow dlib_close() to actually unload the library
+
+typedef struct dlib_ctx dlib_ctx_t;
+
+// Load a library by name
+dlib_ctx_t* dlib_open(const char* lib_name, uint32_t flags);
+
+// Drop the library handle. unload the library if DLIB_MAY_UNLOAD was set
+void dlib_close(dlib_ctx_t* lib);
+
+// Resolve public library symbols
+void* dlib_resolve(dlib_ctx_t* lib, const char* symbol_name);
+
+// Get symbol from an explicitly named lib
+void* dlib_get_symbol(const char* lib_name, const char* symbol_name);
+
+// Resolve weak symbols provided by a lib (With name probing)
+bool dlib_load_weak(const char* lib_name);
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/elf_load.c b/app/src/main/java/libengine/RVVM/src/elf_load.c
new file mode 100644
index 00000000..3f22ab1c
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/elf_load.c
@@ -0,0 +1,151 @@
+/*
+elf_load.c - ELF Loader
+Copyright (C) 2023  LekKit <github.com/LekKit>
+              2021  cerg2010cerg2010 <github.com/cerg2010cerg2010>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "elf_load.h"
+#include "mem_ops.h"
+#include "utils.h"
+#include "vma_ops.h"
+
+#define ELF_ET_NONE 0x0
+#define ELF_ET_REL  0x1
+#define ELF_ET_EXEC 0x2
+#define ELF_ET_DYN  0x3
+
+#define ELF_PT_NULL    0x0
+#define ELF_PT_LOAD    0x1
+#define ELF_PT_DYNAMIC 0x2
+#define ELF_PT_INTERP  0x3
+#define ELF_PT_NOTE    0x4
+#define ELF_PT_SHLIB   0x5
+#define ELF_PT_PHDR    0x6
+#define ELF_PT_TLS     0x7
+
+#define ELF_PF_X 0x1
+#define ELF_PF_W 0x2
+#define ELF_PF_R 0x4
+
+// TODO: Handling >64k PHENTs
+#define ELF_PN_XNUM 0xFFFF
+
+#define WRAP_ERR(cond, error) \
+    if (!(cond)) { \
+        rvvm_error(error); \
+        return false; \
+    }
+
+bool elf_load_file(rvfile_t* file, elf_desc_t* elf)
+{
+    uint8_t tmp[64] = {0};
+    WRAP_ERR(file && elf, "Invalid arguments to elf_load_file()");
+    WRAP_ERR(rvread(file, tmp, 64, 0) == 64, "Failed to read ELF header");
+    WRAP_ERR(read_uint32_le_m(tmp) == 0x464c457F, "Not an ELF file");
+    WRAP_ERR(tmp[4] == 1 || tmp[4] == 2, "Invalid ELF class");
+    WRAP_ERR(tmp[5] == 1, "Not a little-endian ELF");
+
+    // Parse ELF header
+    bool objcopy = !!elf->base;
+    bool class64 = (tmp[4] == 2);
+    uint16_t elf_type = read_uint16_le_m(tmp + 16);
+    uint64_t elf_entry = class64 ? read_uint64_le_m(tmp + 24) : read_uint32_le_m(tmp + 24);
+    uint64_t elf_phoff = class64 ? read_uint64_le_m(tmp + 32) : read_uint32_le_m(tmp + 28);
+    //uint64_t elf_shoff = class64 ? read_uint64_le_m(tmp + 40) : read_uint32_le_m(tmp + 32);
+    size_t   elf_phnsz = class64 ? 56 : 32;
+    size_t   elf_phnum = read_uint16_le_m(tmp + (class64 ? 56 : 44));
+
+    elf->entry = elf_entry;
+    elf->interp_path = NULL;
+    elf->phdr = 0;
+    elf->phnum = elf_phnum;
+
+    // Determine lowest / highest virtual address, PHDR address
+    uint64_t elf_loaddr = (uint64_t)-1;
+    uint64_t elf_hiaddr = 0;
+    for (size_t i=0; i<elf_phnum; ++i) {
+        uint64_t elf_phent_off = elf_phoff + (elf_phnsz * i);
+        WRAP_ERR(rvread(file, tmp, elf_phnsz, elf_phent_off) == elf_phnsz, "Failed to read ELF phent");
+        uint32_t p_type = read_uint32_le_m(tmp);
+        uint64_t p_vaddr = class64 ? read_uint64_le_m(tmp + 16) : read_uint32_le_m(tmp + 8);
+        uint64_t p_memsz = class64 ? read_uint64_le_m(tmp + 40) : read_uint32_le_m(tmp + 20);
+        if (p_type == ELF_PT_LOAD || p_type == ELF_PT_PHDR) {
+            if (p_vaddr < elf_loaddr) elf_loaddr = p_vaddr;
+            if (p_vaddr + p_memsz > elf_hiaddr) elf_hiaddr = p_vaddr + p_memsz;
+        }
+        if (p_type == ELF_PT_PHDR) elf->phdr = p_vaddr;
+    }
+    if (elf_loaddr == (uint64_t)-1) elf_loaddr = 0; // No ELF segments
+
+    // Relocate pointers
+    if (objcopy) {
+        if (elf->entry) elf->entry -= elf_loaddr;
+        if (elf->phdr)  elf->phdr  -= elf_loaddr;
+    } else {
+        // Userland ELF loading
+        elf->buf_size = elf_hiaddr - elf_loaddr;
+        if (elf_type == ELF_ET_DYN) {
+            // Dynamic (PIC) ELF, relocate it
+            elf->base = vma_alloc(NULL, elf->buf_size, VMA_RDWR);
+            WRAP_ERR(elf->base, "Failed to allocate dynamic ELF VMA");
+        } else {
+            // Non-relocatable ELF at fixed address
+            elf->base = vma_alloc((void*)(size_t)elf_loaddr, elf->buf_size, VMA_RDWR | VMA_FIXED);
+            WRAP_ERR(elf->base, "Failed to map fixed ELF VMA, address collision?");
+        }
+        if (elf->entry) elf->entry += (size_t)elf->base - elf_loaddr;
+        if (elf->phdr)  elf->phdr  += (size_t)elf->base - elf_loaddr;
+    }
+
+    for (size_t i=0; i<elf_phnum; ++i) {
+        uint64_t elf_phent_off = elf_phoff + (elf_phnsz * i);
+        WRAP_ERR(rvread(file, tmp, elf_phnsz, elf_phent_off) == elf_phnsz, "Failed to read ELF phent");
+        uint32_t p_type = read_uint32_le_m(tmp);
+        uint64_t p_offset = class64 ? read_uint64_le_m(tmp + 8) : read_uint32_le_m(tmp + 4);
+        uint64_t p_vaddr = class64 ? read_uint64_le_m(tmp + 16) : read_uint32_le_m(tmp + 8);
+        uint64_t p_fsize = class64 ? read_uint64_le_m(tmp + 32) : read_uint32_le_m(tmp + 16);
+        uint64_t p_memsz = class64 ? read_uint64_le_m(tmp + 40) : read_uint32_le_m(tmp + 20);
+        //uint32_t p_flags = class64 ? read_uint32_le_m(tmp + 4) : read_uint32_le_m(tmp + 24);
+
+        if (p_type == ELF_PT_LOAD || p_type == ELF_PT_PHDR) {
+            // Load ELF program segment or PHDR segment
+            void* vaddr = ((uint8_t*)elf->base) + p_vaddr - elf_loaddr;
+            WRAP_ERR(p_vaddr + p_memsz <= elf_loaddr + elf->buf_size, "ELF segment does not fit in memory");
+            WRAP_ERR(rvread(file, vaddr, p_fsize, p_offset) == p_fsize, "Failed to read ELF segment");
+        }
+        if (p_type == ELF_PT_INTERP && !objcopy && !elf->interp_path) {
+            // Get ELF interpreter path
+            WRAP_ERR(p_fsize < 1024, "ELF interpreter path is too long");
+            elf->interp_path = safe_new_arr(char, p_fsize + 1);
+            WRAP_ERR(rvread(file, elf->interp_path, p_fsize, p_offset) == p_fsize, "Failed to read ELF interp_path");
+        }
+    }
+
+    return true;
+}
+
+bool bin_objcopy(rvfile_t* file, void* buffer, size_t size, bool try_elf)
+{
+    uint8_t mag[4] = {0};
+    if (try_elf && rvread(file, mag, 4, 0) == 4 && read_uint32_le_m(mag) == 0x464c457F) {
+        elf_desc_t elf = {
+            .base = buffer,
+            .buf_size = size,
+        };
+        if (elf_load_file(file, &elf)) return true;
+    }
+    return rvread(file, buffer, size, 0);
+}
diff --git a/app/src/main/java/libengine/RVVM/src/elf_load.h b/app/src/main/java/libengine/RVVM/src/elf_load.h
new file mode 100644
index 00000000..6f387f20
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/elf_load.h
@@ -0,0 +1,43 @@
+/*
+elf_load.h - ELF Loader
+Copyright (C) 2023  LekKit <github.com/LekKit>
+              2021  cerg2010cerg2010 <github.com/cerg2010cerg2010>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef ELF_LOAD_H
+#define ELF_LOAD_H
+
+#include "blk_io.h"
+
+typedef struct {
+    // Pass a buffer for objcopy, NULL for userland loading
+    // Receive base ELF address for userland
+    void*  base;
+    // Objcopy buffer size
+    size_t buf_size;
+
+    // Various loaded ELF info
+    size_t entry;
+    char*  interp_path;
+    size_t phdr;
+    size_t phnum;
+} elf_desc_t;
+
+bool elf_load_file(rvfile_t* file, elf_desc_t* elf);
+
+bool bin_objcopy(rvfile_t* file, void* buffer, size_t size, bool allow_elf);
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/fdtlib.c b/app/src/main/java/libengine/RVVM/src/fdtlib.c
new file mode 100644
index 00000000..763d93bd
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/fdtlib.c
@@ -0,0 +1,375 @@
+/*
+fdtlib.c - Flattened Device Tree Library
+Copyright (C) 2021  cerg2010cerg2010 <github.com/cerg2010cerg2010>
+                    LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "fdtlib.h"
+#include "utils.h"
+#include "vector.h"
+#include "mem_ops.h"
+
+#define FDT_MAGIC        0xD00DFEED
+#define FDT_VERSION      17
+#define FDT_COMP_VERSION 16
+
+#define FDT_BEGIN_NODE 1
+#define FDT_END_NODE   2
+#define FDT_PROP       3
+#define FDT_NOP        4
+#define FDT_END        9
+
+#define FDT_HDR_SIZE 40
+#define FDT_RSV_SIZE 16
+
+struct fdt_prop {
+    char* name;
+    void* data;
+    uint32_t len;
+};
+
+struct fdt_node {
+    char* name;
+    struct fdt_node* parent;
+    // Used as last_phandle in root node (parent = NULL)
+    uint32_t phandle;
+
+    vector_t(struct fdt_prop) props;
+    vector_t(struct fdt_node*) nodes;
+};
+
+static void* heap_duplicate(const void* data, size_t size)
+{
+    if (size) {
+        void* buffer = safe_malloc(size);
+        memcpy(buffer, data, size);
+        return buffer;
+    }
+    return NULL;
+}
+
+static char* str_duplicate(const char* str)
+{
+    return heap_duplicate(str, rvvm_strlen(str) + 1);
+}
+
+static void fdt_prop_free(struct fdt_prop* prop)
+{
+    free(prop->name);
+    free(prop->data);
+}
+
+static size_t fdt_name_with_addr(char* buffer, size_t size, const char* name, uint64_t addr)
+{
+    size_t len = rvvm_strlcpy(buffer, name, size);
+    len += rvvm_strlcpy(buffer + len, "@", size - len);
+    len += uint_to_str_base(buffer + len, size, addr, 16);
+    return len;
+}
+
+struct fdt_node* fdt_node_create(const char* name)
+{
+    struct fdt_node* node = safe_new_obj(struct fdt_node);
+    node->name = name ? str_duplicate(name) : NULL;
+    return node;
+}
+
+struct fdt_node* fdt_node_create_reg(const char* name, uint64_t addr)
+{
+    char buffer[256];
+    fdt_name_with_addr(buffer, sizeof(buffer), name, addr);
+    return fdt_node_create(buffer);
+}
+
+void fdt_node_add_child(struct fdt_node* node, struct fdt_node* child)
+{
+    if (node == NULL || child == NULL) return;
+    child->parent = node;
+    vector_push_back(node->nodes, child);
+}
+
+struct fdt_node* fdt_node_find(struct fdt_node* node, const char* name)
+{
+    if (node) vector_foreach_back(node->nodes, i) {
+        struct fdt_node* child = vector_at(node->nodes, i);
+        if (rvvm_strcmp(child->name, name)) return child;
+    }
+    return NULL;
+}
+
+struct fdt_node* fdt_node_find_reg(struct fdt_node* node, const char* name, uint64_t addr)
+{
+    char buffer[256];
+    fdt_name_with_addr(buffer, sizeof(buffer), name, addr);
+    return fdt_node_find(node, buffer);
+}
+
+struct fdt_node* fdt_node_find_reg_any(struct fdt_node* node, const char* name)
+{
+    char buffer[256] = {0};
+    size_t len = rvvm_strlcpy(buffer, name, sizeof(buffer));
+    rvvm_strlcpy(buffer + len, "@", sizeof(buffer) - len);
+    if (node) vector_foreach_back(node->nodes, i) {
+        struct fdt_node* child = vector_at(node->nodes, i);
+        if (rvvm_strfind(child->name, buffer) == child->name) return child;
+    }
+    return NULL;
+}
+
+static inline bool fdt_is_illegal_phandle(uint32_t phandle)
+{
+    return phandle == 0 || phandle == 0xffffffff;
+}
+
+static uint32_t fdt_get_new_phandle(struct fdt_node* node)
+{
+    // Trace to root node
+    const char* orig_node_name = node->name;
+    while (node->parent) node = node->parent;
+    if (node->name) rvvm_warn("fdt_node_get_phandle(%s): Invalid hierarchy", orig_node_name);
+    node->phandle++;
+    return node->phandle;
+}
+
+uint32_t fdt_node_get_phandle(struct fdt_node* node)
+{
+    if (node == NULL || node->name == NULL) {
+        // This is a root node, no handle needed
+        return 0;
+    }
+    if (fdt_is_illegal_phandle(node->phandle)) {
+        // Allocate new phandle
+        node->phandle = fdt_get_new_phandle(node);
+        fdt_node_add_prop_u32(node, "phandle", node->phandle);
+    }
+    return node->phandle;
+}
+
+void fdt_node_add_prop(struct fdt_node* node, const char* name, const void* data, uint32_t len)
+{
+    if (node) {
+        // Replace old prop if present
+        vector_foreach(node->props, i) {
+            struct fdt_prop* repl_prop = &vector_at(node->props, i);
+            if (rvvm_strcmp(repl_prop->name, name)) {
+                free(repl_prop->data);
+                repl_prop->data = heap_duplicate(data, len);
+                repl_prop->len = len;
+                return;
+            }
+        }
+
+        // Put a new prop
+        struct fdt_prop prop = {
+            .name = str_duplicate(name),
+            .data = heap_duplicate(data, len),
+            .len = len,
+        };
+        vector_push_back(node->props, prop);
+    }
+}
+
+void fdt_node_add_prop_u32(struct fdt_node* node, const char* name, uint32_t val)
+{
+    write_uint32_be_m(&val, val);
+    fdt_node_add_prop(node, name, &val, sizeof(val));
+}
+
+void fdt_node_add_prop_u64(struct fdt_node *node, const char* name, uint64_t val)
+{
+    write_uint64_be_m(&val, val);
+    fdt_node_add_prop(node, name, &val, sizeof(val));
+}
+
+void fdt_node_add_prop_cells(struct fdt_node* node, const char* name, uint32_t* cells, uint32_t count)
+{
+    uint32_t* buffer = safe_new_arr(uint32_t, count);
+    for (uint32_t i=0; i<count; ++i) {
+        write_uint32_be_m(&buffer[i], cells[i]);
+    }
+    fdt_node_add_prop(node, name, buffer, count * sizeof(uint32_t));
+    free(buffer);
+}
+
+void fdt_node_add_prop_str(struct fdt_node* node, const char* name, const char* val)
+{
+    fdt_node_add_prop(node, name, val, rvvm_strlen(val) + 1);
+}
+
+void fdt_node_add_prop_reg(struct fdt_node *node, const char *name, uint64_t begin, uint64_t size)
+{
+    uint64_t arr[2] = {0};
+    write_uint64_be_m(&arr[0], begin);
+    write_uint64_be_m(&arr[1], size);
+    fdt_node_add_prop(node, name, arr, sizeof(arr));
+}
+
+bool fdt_node_del_prop(struct fdt_node* node, const char* name)
+{
+    vector_foreach_back(node->props, i) {
+        struct fdt_prop* prop = &vector_at(node->props, i);
+        if (rvvm_strcmp(prop->name, name)) {
+            fdt_prop_free(prop);
+            vector_erase(node->props, i);
+            return true;
+        }
+    }
+    return false;
+}
+
+void fdt_node_free(struct fdt_node* node)
+{
+    if (node) {
+        vector_foreach_back(node->props, i) {
+            fdt_prop_free(&vector_at(node->props, i));
+        }
+        vector_foreach_back(node->nodes, i) {
+            fdt_node_free(vector_at(node->nodes, i));
+        }
+        vector_free(node->props);
+        vector_free(node->nodes);
+        free(node->name);
+        free(node);
+    }
+}
+
+struct fdt_size_desc {
+    uint32_t struct_size;
+    uint32_t string_size;
+};
+
+static void fdt_get_tree_size(struct fdt_node* node, struct fdt_size_desc* desc)
+{
+    size_t name_len = align_size_up(node->name ? rvvm_strlen(node->name) + 1 : 1, sizeof(uint32_t));
+    desc->struct_size += sizeof(uint32_t) + name_len; // FDT_BEGIN_NODE, name
+
+    vector_foreach(node->props, i) {
+        struct fdt_prop* prop = &vector_at(node->props, i);
+        desc->struct_size += sizeof(uint32_t) * 3; // FDT_PROP, struct fdt_prop_desc
+        desc->struct_size += align_size_up(prop->len, sizeof(uint32_t));
+        desc->string_size += align_size_up(rvvm_strlen(prop->name) + 1, sizeof(uint32_t));
+    }
+
+    vector_foreach(node->nodes, i) {
+        struct fdt_node* child = vector_at(node->nodes, i);
+        fdt_get_tree_size(child, desc);
+    }
+
+    desc->struct_size += sizeof(uint32_t); // FDT_END_NODE
+}
+
+struct fdt_serializer_ctx {
+    char* buf;
+    uint32_t struct_off;
+    uint32_t strings_begin;
+    uint32_t strings_off;
+    uint32_t reserve_off;
+};
+
+static void fdt_serialize_u32(struct fdt_serializer_ctx* ctx, uint32_t value)
+{
+    write_uint32_be_m(ctx->buf + ctx->struct_off, value);
+    ctx->struct_off += sizeof(uint32_t);
+}
+
+static void fdt_serialize_string(struct fdt_serializer_ctx* ctx, const char* str)
+{
+    if (!str) str = "";
+    rvvm_strlcpy(ctx->buf + ctx->struct_off, str, -1);
+    ctx->struct_off = align_size_up(ctx->struct_off + rvvm_strlen(str) + 1, sizeof(uint32_t));
+}
+
+static void fdt_serialize_data(struct fdt_serializer_ctx* ctx, const char* data, uint32_t len)
+{
+    memcpy(ctx->buf + ctx->struct_off, data, len);
+    ctx->struct_off = align_size_up(ctx->struct_off + len, sizeof(uint32_t));
+}
+
+static void fdt_serialize_name(struct fdt_serializer_ctx* ctx, const char* str)
+{
+    if (!str) str = "";
+    rvvm_strlcpy(ctx->buf + ctx->strings_off, str, -1);
+    ctx->strings_off = align_size_up(ctx->strings_off + rvvm_strlen(str) + 1, sizeof(uint32_t));
+}
+
+static void fdt_serialize_tree(struct fdt_serializer_ctx *ctx, struct fdt_node *node)
+{
+    fdt_serialize_u32(ctx, FDT_BEGIN_NODE);
+    fdt_serialize_string(ctx, node->name);
+
+    vector_foreach(node->props, i) {
+        struct fdt_prop* prop = &vector_at(node->props, i);
+        fdt_serialize_u32(ctx, FDT_PROP);
+
+        // struct fdt_prop_desc
+        fdt_serialize_u32(ctx, prop->len);
+        fdt_serialize_u32(ctx, ctx->strings_off - ctx->strings_begin);
+
+        fdt_serialize_data(ctx, prop->data, prop->len);
+
+        fdt_serialize_name(ctx, prop->name);
+    }
+
+    vector_foreach(node->nodes, i) {
+        struct fdt_node* child = vector_at(node->nodes, i);
+        fdt_serialize_tree(ctx, child);
+    }
+
+    fdt_serialize_u32(ctx, FDT_END_NODE);
+}
+
+size_t fdt_size(struct fdt_node* node)
+{
+    return fdt_serialize(node, NULL, 0, 0);
+}
+
+size_t fdt_serialize(struct fdt_node* node, void* buffer, size_t size, uint32_t boot_cpuid)
+{
+    if (node == NULL) return 0;
+    struct fdt_size_desc size_desc = {0};
+    fdt_get_tree_size(node, &size_desc);
+    size_desc.struct_size += sizeof(uint32_t); // FDT_END
+
+    struct fdt_serializer_ctx ctx = {0};
+    uint32_t buf_size = FDT_HDR_SIZE + FDT_RSV_SIZE + size_desc.struct_size;
+    ctx.reserve_off = FDT_HDR_SIZE;
+    ctx.struct_off = FDT_HDR_SIZE + FDT_RSV_SIZE;
+    ctx.strings_begin = buf_size;
+    ctx.strings_off = ctx.strings_begin;
+    buf_size += size_desc.string_size;
+
+    if (buffer) {
+        if (buf_size > size) return 0;
+
+        memset(buffer, 0, buf_size);
+        ctx.buf = buffer;
+        write_uint32_be_m(ctx.buf, FDT_MAGIC);
+        write_uint32_be_m(ctx.buf + 4,  buf_size);
+        write_uint32_be_m(ctx.buf + 8,  ctx.struct_off);
+        write_uint32_be_m(ctx.buf + 12, ctx.strings_off);
+        write_uint32_be_m(ctx.buf + 16, ctx.reserve_off);
+        write_uint32_be_m(ctx.buf + 20, FDT_VERSION);
+        write_uint32_be_m(ctx.buf + 24, FDT_COMP_VERSION);
+        write_uint32_be_m(ctx.buf + 28, boot_cpuid);
+        write_uint32_be_m(ctx.buf + 32, size_desc.string_size);
+        write_uint32_be_m(ctx.buf + 36, size_desc.struct_size);
+
+        fdt_serialize_tree(&ctx, node);
+        fdt_serialize_u32(&ctx, FDT_END);
+    }
+
+    return buf_size;
+}
diff --git a/app/src/main/java/libengine/RVVM/src/fdtlib.h b/app/src/main/java/libengine/RVVM/src/fdtlib.h
new file mode 100644
index 00000000..c741fe0b
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/fdtlib.h
@@ -0,0 +1,91 @@
+/*
+fdtlib.h - Flattened Device Tree Library
+Copyright (C) 2021  cerg2010cerg2010 <github.com/cerg2010cerg2010>
+                    LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef RVVM_FDTLIB_H
+#define RVVM_FDTLIB_H
+
+#include "rvvmlib.h"
+
+struct fdt_node;
+
+/*
+ * Node handling
+ */
+
+// Create a fdt node, root node should have name = NULL
+PUBLIC struct fdt_node* fdt_node_create(const char* name);
+
+// Create a fdt node with address, like device@10000
+PUBLIC struct fdt_node* fdt_node_create_reg(const char* name, uint64_t addr);
+
+// Attach child node
+PUBLIC void fdt_node_add_child(struct fdt_node* node, struct fdt_node* child);
+
+// Lookup for child node by name (returns NULL on failure)
+PUBLIC struct fdt_node* fdt_node_find(struct fdt_node* node, const char* name);
+
+// Lookup for child node by name + addr, like device@10000 (returns NULL on failure)
+PUBLIC struct fdt_node* fdt_node_find_reg(struct fdt_node* node, const char* name, uint64_t addr);
+
+// Lookup for any reg child node by name, like device@* (returns NULL on failure)
+PUBLIC struct fdt_node* fdt_node_find_reg_any(struct fdt_node* node, const char *name);
+
+// Get child node phandle. Allocates phandles transparently, all node hierarchy should be attached!
+PUBLIC uint32_t fdt_node_get_phandle(struct fdt_node* node);
+
+/*
+ * Property handling
+ */
+
+// Add arbitary byte buffer property
+PUBLIC void fdt_node_add_prop(struct fdt_node* node, const char* name, const void* data, uint32_t len);
+
+// Add single-cell property
+PUBLIC void fdt_node_add_prop_u32(struct fdt_node* node, const char* name, uint32_t val);
+
+// Add double-cell property
+PUBLIC void fdt_node_add_prop_u64(struct fdt_node* node, const char* name, uint64_t val);
+
+// Add multi-cell property
+PUBLIC void fdt_node_add_prop_cells(struct fdt_node* node, const char* name, uint32_t* cells, uint32_t count);
+
+// Add string property
+PUBLIC void fdt_node_add_prop_str(struct fdt_node* node, const char* name, const char* val);
+
+// Add register range property (addr cells: 2, size cells: 2)
+PUBLIC void fdt_node_add_prop_reg(struct fdt_node* node, const char* name, uint64_t begin, uint64_t size);
+
+// Delete property
+PUBLIC bool fdt_node_del_prop(struct fdt_node* node, const char* name);
+
+/*
+ * Serialization, cleanup
+ */
+
+// Recursively free a node and it's child nodes
+PUBLIC void fdt_node_free(struct fdt_node* node);
+
+// Returns required buffer size for serializing
+PUBLIC size_t fdt_size(struct fdt_node* node);
+
+// Serialize DTB into buffer, returns 0 when there's insufficient space
+// Returns required buffer size when buffer == NULL
+PUBLIC size_t fdt_serialize(struct fdt_node* node, void* buffer, size_t size, uint32_t boot_cpuid);
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/fpu_ops.h b/app/src/main/java/libengine/RVVM/src/fpu_ops.h
new file mode 100644
index 00000000..d5cd5b0b
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/fpu_ops.h
@@ -0,0 +1,95 @@
+/*
+fpu_ops.h - FPU Rounding/Exceptions manipulation
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef RVVM_FPU_OPS_H
+#define RVVM_FPU_OPS_H
+
+#include "compiler.h"
+
+// Fix rounding modes even when -frounding-math is not present
+#if CLANG_CHECK_VER(12, 0)
+#pragma STDC FENV_ACCESS ON
+#elif defined(_MSC_VER)
+#pragma fenv_access (on)
+#endif
+
+#include <fenv.h>
+
+#ifndef FE_ALL_EXCEPT
+// Some targets (Emscripten, Windows CE) explicitly lack
+// the ability to manipulate host FPU modes.
+// These shims are provided to build & run on these targets.
+#define HOST_NO_FENV
+#endif
+
+#ifndef FE_DIVBYZERO
+#define FE_DIVBYZERO 0
+#endif
+#ifndef FE_INEXACT
+#define FE_INEXACT 0
+#endif
+#ifndef FE_INVALID
+#define FE_INVALID 0
+#endif
+#ifndef FE_OVERFLOW
+#define FE_OVERFLOW 0
+#endif
+#ifndef FE_UNDERFLOW
+#define FE_UNDERFLOW 0
+#endif
+#ifndef FE_ALL_EXCEPT
+#define FE_ALL_EXCEPT 0
+#endif
+#ifndef FE_DOWNWARD
+#define FE_DOWNWARD 0
+#endif
+#ifndef FE_TONEAREST
+#define FE_TONEAREST 0
+#endif
+#ifndef FE_TOWARDZERO
+#define FE_TOWARDZERO 0
+#endif
+#ifndef FE_UPWARD
+#define FE_UPWARD 0
+#endif
+#ifndef FE_DFL_ENV
+#define FE_DFL_ENV 0
+#endif
+
+static inline int fenv_bogus_op(void)
+{
+    return 0;
+}
+
+#ifdef HOST_NO_FENV
+#define feclearexcept(x) fenv_bogus_op()
+#define fegetexceptflag(f, x) fenv_bogus_op()
+#define feraiseexcept(x) fenv_bogus_op()
+#define fesetexceptflag(f, x) fenv_bogus_op()
+#define fetestexcept(x) fenv_bogus_op()
+
+#define fegetround() fenv_bogus_op()
+#define fesetround(r) fenv_bogus_op()
+
+#define fegetenv(x) fenv_bogus_op()
+#define feholdexcept(f, x) fenv_bogus_op()
+#define fesetenv(x) fenv_bogus_op()
+#define feupdateenv(x) fenv_bogus_op()
+#endif
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/gd32.c b/app/src/main/java/libengine/RVVM/src/gd32.c
new file mode 100644
index 00000000..2a2877a0
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/gd32.c
@@ -0,0 +1,204 @@
+/*
+gd32.c - Giga Device RISC-V microcontroller
+Copyright (C) 2021  Mr0maks <mr.maks0443@gmail.com>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#if 0
+#include <assert.h>
+#include <stdbool.h>
+#include <stdio.h>
+
+#include "riscv.h"
+#include "riscv32.h"
+
+void flash_emulate(rvvm_hart_t *vm, uint32_t operation, uint32_t addr, uint32_t *data)
+{
+        printf("%u %u %u\n", operation, addr, *data);
+}
+
+static memory_map_t map[] =
+{
+        {0xA0000000, 0xA0000FFF, "EXMC_SWREG", NULL},
+/*
+        0x90000000 -0x9FFFFFFF Reserved
+        0x70000000 -0x8FFFFFFF Reserved
+*/
+        {0x60000000, 0x6FFFFFFF, "EXMC -NOR/PSRAM/SRAM", NULL},
+        {0x50000000, 0x5003FFFF, "USBFS", NULL},
+/*
+        0x40080000 -0x4FFFFFFF Reserved
+        0x40040000 -0x4007FFFF Reserved
+        0x4002BC00 -0x4003FFFF Reserved
+        0x4002B000 -0x4002BBFF Reserved
+        0x4002A000 -0x4002AFFF Reserved
+        0x40028000 -0x40029FFF Reserved
+        0x40026800 -0x40027FFF Reserved
+        0x40026400 -0x400267FF Reserved
+        0x40026000 -0x400263FF Reserved
+        0x40025000 -0x40025FFF Reserved
+        0x40024000 -0x40024FFF Reserved
+        0x40023C00 -0x40023FFF Reserved
+        0x40023800 -0x40023BFF Reserved
+        0x40023400 -0x400237FF Reserved
+*/
+        {0x40023000, 0x400233FF, "CRC", NULL},
+/*
+        0x40022C00 - 0x40022FFF Reserved
+        0x40022800 - 0x40022BFF Reserved
+        0x40022400 - 0x400227FF Reserved
+*/
+        {0x40022000, 0x400223FF, "FMC", NULL},
+/*
+        0x40021C00 - 0x40021FFF Reserved
+        0x40021800 - 0x40021BFF Reserved
+        0x40021400 - 0x400217FF Reserved
+*/
+        {0x40021000, 0x400213FF, "RCU", NULL},
+/*
+        0x40020C00 - 0x40020FFF Reserved
+        0x40020800 - 0x40020BFF Reserved
+*/
+        {0x40020400, 0x400207FF, "DMA1", NULL},
+        {0x40020000, 0x400203FF, "DMA0", NULL},
+/*
+        0x40018400 - 0x4001FFFF Reserved
+        0x40018000 - 0x400183FF Reserved
+*/
+/*
+        0x40017C00 - 0x40017FFF Reserved
+        0x40017800 - 0x40017BFF Reserved
+        0x40017400 - 0x400177FF Reserved
+        0x40017000 - 0x400173FF Reserved
+        0x40016C00 - 0x40016FFF Reserved
+        0x40016800 - 0x40016BFF Reserved
+        0x40015C00 - 0x400167FF Reserved
+        0x40015800 - 0x40015BFF Reserved
+        0x40015400 - 0x400157FF Reserved
+        0x40015000 - 0x400153FF Reserved
+        0x40014C00 - 0x40014FFF Reserved
+        0x40014800 - 0x40014BFF Reserved
+        0x40014400 - 0x400147FF Reserved
+        0x40014000 - 0x400143FF Reserved
+        0x40013C00 - 0x40013FFF Reserved
+*/
+        {0x40013800, 0x40013BFF, "USART0", NULL},
+/*
+        0x40013400 - 0x400137FF Reserved
+*/
+        {0x40013000, 0x400133FF, "SPI0", NULL},
+
+        {0x40012C00, 0x40012FFF, "TIMER0", NULL},
+        {0x40012800, 0x40012BFF, "ADC1", NULL},
+        {0x40012400, 0x400127FF, "ADC0", NULL},
+/*
+        0x40012000 - 0x400123FF Reserved
+        0x40011C00 - 0x40011FFF Reserved
+*/
+        {0x40011800, 0x40011BFF, "GPIOE", NULL},
+        {0x40011400, 0x400117FF, "GPIOD", NULL},
+        {0x40011000, 0x400113FF, "GPIOC", NULL},
+        {0x40010C00, 0x40010FFF, "GPIOB", NULL},
+        {0x40010800, 0x40010BFF, "GPIOA", NULL},
+        {0x40010400, 0x400107FF, "EXTI", NULL},
+        {0x40010000, 0x400103FF, "AFIO", NULL},
+/*
+        0x4000CC00 - 0x4000FFFF Reserved
+        0x4000C800 - 0x4000CBFF Reserved
+        0x4000C400 - 0x4000C7FF Reserved
+        0x4000C000 - 0x4000C3FF Reserved
+        0x40008000 - 0x4000BFFF Reserved
+        0x40007C00 - 0x40007FFF Reserved
+        0x40007800 - 0x40007BFF Reserved
+*/
+        {0x40007400, 0x400077FF, "DAC", NULL},
+        {0x40007000, 0x400073FF, "PMU", NULL},
+        {0x40006C00, 0x40006FFF, "BKP", NULL},
+
+        {0x40006800, 0x40006BFF, "CAN1", NULL},
+        {0x40006400, 0x400067FF, "CAN0", NULL},
+        {0x40006000, 0x400063FF, "Shared USB/CAN SRAM 512bytes", NULL},
+        {0x40005C00, 0x40005FFF, "USB device FS registers", NULL},
+        {0x40005800, 0x40005BFF, "I2C1", NULL},
+        {0x40005400, 0x400057FF, "I2C0", NULL},
+        {0x40005000, 0x400053FF, "UART4", NULL},
+        {0x40004C00, 0x40004FFF, "UART3", NULL},
+        {0x40004800, 0x40004BFF, "USART2", NULL},
+        {0x40004400, 0x400047FF, "USART1", NULL},
+/*
+        0x40004000 - 0x400043FF Reserved
+*/
+        {0x40003C00, 0x40003FFF, "SPI2/I2S2", NULL},
+        {0x40003800, 0x40003BFF, "SPI1/I2S1", NULL},
+/*
+        0x40003400 - 0x400037FF Reserved
+*/
+        {0x40003000, 0x400033FF, "FWDGT", NULL},
+        {0x40002C00, 0x40002FFF, "WWDGT", NULL},
+        {0x40002800, 0x40002BFF, "RTC", NULL},
+/*
+        0x40002400 - 0x400027FF Reserved
+        0x40002000 - 0x400023FF Reserved
+        0x40001C00 - 0x40001FFF Reserved
+        0x40001800 - 0x40001BFF Reserved
+*/
+        {0x40001400, 0x400017FF, "TIMER6", NULL},
+        {0x40001000, 0x400013FF, "TIMER5", NULL},
+        {0x40000C00, 0x40000FFF, "TIMER4", NULL},
+        {0x40000800, 0x40000BFF, "TIMER3", NULL},
+        {0x40000400, 0x400007FF, "TIMER2", NULL},
+        {0x40000000, 0x400003FF, "TIMER1", NULL},
+/*
+        0x20070000 - 0x3FFFFFFF Reserved
+        0x20060000 - 0x2006FFFF Reserved
+        0x20030000 - 0x2005FFFF Reserved
+        0x20020000 - 0x2002FFFF Reserved
+        0x2001C000 - 0x2001FFFF Reserved
+        0x20018000 - 0x2001BFFF Reserved
+*/
+        {0x20000000, 0x20017FFF, "SRAM", NULL},
+/*
+        0x1FFFF810 - 0x1FFFFFFF Reserved
+*/
+        {0x1FFFF800, 0x1FFFF80F, "Option Bytes", NULL},
+        {0x1FFFB000, 0x1FFFF7FF, "Bootloader", NULL},
+/*
+         0x1FFF7A10 - 0x1FFFAFFF Reserved
+         0x1FFF7800 - 0x1FFF7A0F Reserved
+         0x1FFF0000 - 0x1FFF77FF Reserved
+         0x1FFEC010 - 0x1FFEFFFF Reserved
+         0x1FFEC000 - 0x1FFEC00F Reserved
+         0x10010000 - 0x1FFEBFFF Reserved
+         0x10000000 - 0x1000FFFF Reserved
+         0x083C0000 - 0x0FFFFFFF Reserved
+         0x08300000 - 0x083BFFFF Reserved
+         0x08020000 - 0x082FFFFF Reserved
+*/
+        // Main Flash or bootloader
+        {0x08000000, 0x0801FFFF, "Flash", NULL},
+/*
+        0x00300000 - 0x07FFFFFF Reserved
+*/
+        {0x00000000, 0x002FFFFF, "Flash", NULL},
+        {0xDEADBEEF, 0xDEADF00D, NULL, NULL}
+};
+
+
+void gd32_prepare_memory_map(rvvm_hart_t *vm)
+{
+    vm->memory_map = map;
+}
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/hashmap.c b/app/src/main/java/libengine/RVVM/src/hashmap.c
new file mode 100644
index 00000000..2f64cba9
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/hashmap.c
@@ -0,0 +1,98 @@
+/*
+hashmap.c - Open-addressing hashmap implementation
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "hashmap.h"
+#include "utils.h"
+#include "bit_ops.h"
+#include <string.h>
+
+void hashmap_init(hashmap_t* map, size_t size)
+{
+    if (!size) size = 16;
+    map->entries = 0;
+    map->entry_balance = 0;
+    map->size = bit_next_pow2(size) - 1;
+    map->buckets = safe_new_arr(hashmap_bucket_t, map->size + 1);
+}
+
+void hashmap_destroy(hashmap_t* map)
+{
+    free(map->buckets);
+    memset(map, 0, sizeof(hashmap_t));
+}
+
+void hashmap_resize(hashmap_t* map, size_t size)
+{
+    hashmap_t tmp;
+    hashmap_init(&tmp, size);
+    hashmap_foreach(map, k, v)
+        hashmap_put(&tmp, k, v);
+    free(map->buckets);
+    map->buckets = tmp.buckets;
+    map->size = tmp.size;
+    map->entry_balance = map->entries;
+}
+
+void hashmap_grow(hashmap_t* map, size_t key, size_t val)
+{
+    hashmap_resize(map, (map->size + 1) << 1);
+    hashmap_put(map, key, val);
+}
+
+static size_t hashmap_calc_shrink(hashmap_t* map)
+{
+    if (unlikely(map->entries && map->entry_balance > map->entries)) {
+        return map->size / (map->entry_balance / map->entries);
+    }
+    return map->size;
+}
+
+void hashmap_shrink(hashmap_t* map)
+{
+    size_t size = hashmap_calc_shrink(map);
+    if (unlikely(size < map->size)) {
+        hashmap_resize(map, size);
+    }
+}
+
+void hashmap_clear(hashmap_t* map)
+{
+    size_t size = bit_next_pow2(hashmap_calc_shrink(map)) - 1;
+    if (size < map->size) {
+        map->size = size;
+        map->buckets = safe_realloc(map->buckets, (map->size + 1) * sizeof(hashmap_bucket_t));
+        map->entry_balance = map->entries;
+    }
+    memset(map->buckets, 0, (map->size + 1) * sizeof(hashmap_bucket_t));
+    map->entries = 0;
+}
+
+void hashmap_rebalance(hashmap_t* map, size_t index)
+{
+    size_t j = index, k;
+    while (true) {
+        map->buckets[index].val = 0;
+        do {
+            j = (j + 1) & map->size;
+            if (!map->buckets[j].val) return;
+            k = hashmap_hash(map->buckets[j].key) & map->size;
+        } while ((index <= j) ? (index < k && k <= j) : (index < k || k <= j));
+        map->buckets[index] = map->buckets[j];
+        index = j;
+    }
+}
diff --git a/app/src/main/java/libengine/RVVM/src/hashmap.h b/app/src/main/java/libengine/RVVM/src/hashmap.h
new file mode 100644
index 00000000..22571d15
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/hashmap.h
@@ -0,0 +1,135 @@
+/*
+hashmap.h - Open-addressing hashmap implementation
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef HASHMAP_H
+#define HASHMAP_H
+
+#include <stdint.h>
+#include <stddef.h>
+
+/*
+ * This is the worst-case scenario lookup complexity,
+ * only 1/256 of entries may reach this point at all.
+ * Setting the value lower may improve worst-case scenario
+ * by a slight margin, but increases memory consumption
+ * by orders of magnitude.
+ */
+#define HASHMAP_MAX_PROBES 256
+// ((map->size >> 1) & 255)
+
+typedef struct {
+    size_t key;
+    size_t val;
+} hashmap_bucket_t;
+
+/*
+* val=0 is treated as unused bucket to reduce memory usage
+* (no additional flag), size is actually a bitmask holding
+* lowest 1s to represent encoding space
+*/
+typedef struct {
+    hashmap_bucket_t* buckets;
+    size_t size;
+    size_t entries;
+    size_t entry_balance;
+} hashmap_t;
+
+// Hint the expected amount of entries on map creation
+void hashmap_init(hashmap_t* map, size_t size);
+
+void hashmap_destroy(hashmap_t* map);
+void hashmap_resize(hashmap_t* map, size_t size);
+void hashmap_grow(hashmap_t* map, size_t key, size_t val);
+void hashmap_shrink(hashmap_t* map);
+void hashmap_clear(hashmap_t* map);
+
+static inline size_t hashmap_used_mem(hashmap_t* map)
+{
+    return (map->size + 1) * sizeof(hashmap_bucket_t);
+}
+
+#define hashmap_foreach(map, k, v) \
+    for (size_t _i=0, k, v; k=(map)->buckets[_i & (map)->size].key, v=(map)->buckets[_i & (map)->size].val, _i<=(map)->size; ++_i) if (v)
+
+static inline size_t hashmap_hash(size_t k)
+{
+    k ^= k << 21;
+    k ^= k >> 17;
+#if (SIZE_MAX > 0xFFFFFFFF)
+    k ^= k >> 35;
+    k ^= k >> 51;
+#endif
+    return k;
+}
+
+void hashmap_rebalance(hashmap_t* map, size_t index);
+
+static inline void hashmap_put(hashmap_t* map, size_t key, size_t val)
+{
+    size_t hash = hashmap_hash(key);
+    size_t index;
+    for (size_t i=0; i<HASHMAP_MAX_PROBES; ++i) {
+        index = (hash + i) & map->size;
+
+        if (map->buckets[index].key == key) {
+            // The key is already used, change value
+            map->buckets[index].val = val;
+
+            if (!val) {
+                // Value = 0 means we can clear a bucket
+                // Rebalance colliding trailing entries
+                hashmap_rebalance(map, index);
+                map->entries--;
+            }
+            return;
+        } else if (!map->buckets[index].val && val) {
+            // Empty bucket found, the key is unused
+            map->entries++;
+            map->buckets[index].key = key;
+            map->buckets[index].val = val;
+            return;
+        }
+    }
+    // Near-key space is polluted with colliding entries, reallocate and rehash
+    // Puts the new entry as well to simplify the inlined function
+    if (val) hashmap_grow(map, key, val);
+}
+
+static inline size_t hashmap_get(const hashmap_t* map, size_t key)
+{
+    size_t hash = hashmap_hash(key);
+    size_t index;
+    for (size_t i=0; i<HASHMAP_MAX_PROBES; ++i) {
+        index = (hash + i) & map->size;
+        if (map->buckets[index].key == key || !map->buckets[index].val) {
+            return map->buckets[index].val;
+        }
+    }
+    return 0;
+}
+
+static inline void hashmap_remove(hashmap_t* map, size_t key)
+{
+    // Treat value zero as removed key
+    hashmap_put(map, key, 0);
+    if (map->entries < map->entry_balance && map->entries > 256) {
+        hashmap_shrink(map);
+    }
+}
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/main.c b/app/src/main/java/libengine/RVVM/src/main.c
new file mode 100644
index 00000000..7cbe4071
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/main.c
@@ -0,0 +1,318 @@
+/*
+main.c - RVVM CLI, API usage example
+Copyright (C) 2021  LekKit <github.com/LekKit>
+                    cerg2010cerg2010 <github.com/cerg2010cerg2010>
+                    Mr0maks <mr.maks0443@gmail.com>
+                    KotB <github.com/0xCatPKG>
+                    fish4terrisa-MSDSM <fish4terrisa@fishinix.eu.org>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "rvvmlib.h"
+#include "rvvm_user.h"
+#include "rvvm_isolation.h"
+#include "utils.h"
+#include "dlib.h"
+
+#include "devices/clint.h"
+#include "devices/plic.h"
+#include "devices/ns16550a.h"
+#include "devices/gui_window.h"
+#include "devices/syscon.h"
+#include "devices/rtc-goldfish.h"
+#include "devices/pci-bus.h"
+#include "devices/pci-vfio.h"
+#include "devices/nvme.h"
+#include "devices/ata.h"
+#include "devices/eth-oc.h"
+#include "devices/rtl8169.h"
+#include "devices/i2c-oc.h"
+
+#include <stdio.h>
+#include <inttypes.h>
+
+#ifdef _WIN32
+// For unicode args/console
+#include <windows.h>
+#endif
+
+static void print_help(void)
+{
+#if defined(_WIN32) && !defined(UNDER_CE)
+    const wchar_t* help = L"\n"
+#else
+    printf("\n"
+#endif
+           "  ██▀███   ██▒   █▓ ██▒   █▓ ███▄ ▄███▓\n"
+           " ▓██ ▒ ██▒▓██░   █▒▓██░   █▒▓██▒▀█▀ ██▒\n"
+           " ▓██ ░▄█ ▒ ▓██  █▒░ ▓██  █▒░▓██    ▓██░\n"
+           " ▒██▀▀█▄    ▒██ █░░  ▒██ █░░▒██    ▒██ \n"
+           " ░██▓ ▒██▒   ▒▀█░     ▒▀█░  ▒██▒   ░██▒\n"
+           " ░ ▒▓ ░▒▓░   ░ ▐░     ░ ▐░  ░ ▒░   ░  ░\n"
+           "   ░▒ ░ ▒░   ░ ░░     ░ ░░  ░  ░      ░\n"
+           "   ░░   ░      ░░       ░░  ░      ░   \n"
+           "    ░           ░        ░         ░   \n"
+           "               ░        ░              \n"
+           "\n"
+           "https://github.com/LekKit/RVVM (v"RVVM_VERSION")\n"
+           "\n"
+           "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\n"
+           "This is free software: you are free to change and redistribute it.\n"
+           "There is NO WARRANTY, to the extent permitted by law.\n"
+           "\n"
+           "Usage: rvvm [bootrom] [-m 256M] [-k kernel] [-i drive.img] ...\n"
+           "\n"
+           "    [bootrom]        Machine bootrom (OpenSBI, BBL, etc)\n"
+           "    -m, -mem 1G      Memory amount, default: 256M\n"
+           "    -s, -smp 4       Cores count, default: 1\n"
+#ifdef USE_RV64
+           "    -rv32            Enable 32-bit RISC-V, 64-bit by default\n"
+#endif
+           "    -k, -kernel ...  Load S-mode kernel payload (Linux, U-Boot, etc)\n"
+           "    -i, -image  ...  Attach NVMe storage image (For compatibility reasons)\n"
+           "    -cmdline    ...  Override default kernel command line\n"
+           "    -append     ...  Modify kernel command line\n"
+           "    -nvme       ...  Explicitly attach storage image as NVMe device\n"
+           "    -ata        ...  Explicitly attach storage image as ATA (IDE) device\n"
+           "    -serial     ...  Add more serial ports\n"
+#ifdef USE_FB
+           "    -res 1280x720    Change framebuffer resoulution\n"
+           "    -nogui           Disable framebuffer GUI\n"
+#endif
+           "    -dtb ...         Pass custom DTB to the machine\n"
+#ifdef USE_FDT
+           "    -dumpdtb ...     Dump autogenerated DTB to file\n"
+#endif
+#ifdef USE_JIT
+           "    -jitcache 16M    Per-core JIT cache size\n"
+           "    -nojit           Disable RVJIT\n"
+#endif
+           "    -v, -verbose     Enable verbose logging\n"
+           "    -h, -help        Show this help message\n"
+#if defined(_WIN32) && !defined(UNDER_CE)
+           "\n";
+    WriteConsoleW(GetStdHandle(STD_OUTPUT_HANDLE), help, wcslen(help), NULL, NULL);
+#else
+           "\n");
+#endif
+}
+
+static size_t get_arg(const char** argv, const char** arg_name, const char** arg_val)
+{
+    if (argv[0][0] == '-') {
+        size_t offset = (argv[0][1] == '-') ? 2 : 1;
+        *arg_name = &argv[0][offset];
+        for (size_t i=0; argv[0][offset + i] != 0; ++i) {
+            if (argv[0][offset + i] == '=') {
+                // Argument format -arg=val
+                *arg_val = &argv[0][offset + i + 1];
+                return 1;
+            }
+        }
+
+        if (argv[1] == NULL || argv[1][0] == '-') {
+            // Argument format -arg
+            *arg_val = "";
+            return 1;
+        } else {
+            // Argument format -arg val
+            *arg_val = argv[1];
+            return 2;
+        }
+    } else {
+        *arg_name = "bootrom";
+        *arg_val = argv[0];
+        return 1;
+    }
+}
+
+static bool cmp_arg(const char* arg, const char* name)
+{
+    while (*arg && *arg == *name) {
+        arg++;
+        name++;
+    }
+    return *name == 0 && (*arg == '=' || *arg == 0);
+}
+
+static bool rvvm_cli_configure(rvvm_machine_t* machine, int argc, const char** argv,
+                               const char* bootrom, tap_dev_t* tap)
+{
+    const char* arg_name = "";
+    const char* arg_val = "";
+    size_t      arg_size = 0;
+    UNUSED(tap);
+    rvvm_append_cmdline(machine, "root=/dev/nvme0n1 rootflags=discard rw");
+    if (rvvm_getarg("cmdline")) rvvm_set_cmdline(machine, rvvm_getarg("cmdline"));
+    if (rvvm_getarg("append")) rvvm_append_cmdline(machine, rvvm_getarg("append"));
+
+    if (!rvvm_load_bootrom(machine, bootrom)) return false;
+    if (rvvm_getarg("k") && !rvvm_load_kernel(machine, rvvm_getarg("k"))) return false;
+    if (rvvm_getarg("kernel") && !rvvm_load_kernel(machine, rvvm_getarg("kernel"))) return false;
+    if (rvvm_getarg("dtb") && !rvvm_load_dtb(machine, rvvm_getarg("dtb"))) return false;
+
+    for (int i=1; i<argc; i+=arg_size) {
+        arg_size = get_arg(argv + i, &arg_name, &arg_val);
+        if (cmp_arg(arg_name, "i") || cmp_arg(arg_name, "image") || cmp_arg(arg_name, "nvme")) {
+            if (!nvme_init_auto(machine, arg_val, true)) {
+                rvvm_error("Failed to attach image \"%s\"", arg_val);
+                return false;
+            }
+        } else if (cmp_arg(arg_name, "ata")) {
+            if (!ata_init_auto(machine, arg_val, true)) {
+                rvvm_error("Failed to attach image \"%s\"", arg_val);
+                return false;
+            }
+        } else if (cmp_arg(arg_name, "serial")) {
+            chardev_t* chardev = chardev_pty_create(arg_val);
+            if (chardev == NULL && !rvvm_strcmp(arg_val, "null")) return false;
+            ns16550a_init_auto(machine, chardev);
+        } else if (cmp_arg(arg_name, "res")) {
+            size_t len = 0;
+            uint32_t fb_x = str_to_uint_base(arg_val, &len, 10);
+            uint32_t fb_y = str_to_uint_base(arg_val + len + 1, NULL, 10);
+            if (arg_val[len] != 'x') fb_y = 0;
+            if (fb_x < 100 || fb_y < 100) {
+                rvvm_error("Invalid resoulution: %s, expects 640x480", arg_val);
+                return false;
+            }
+            gui_window_init_auto(machine, fb_x, fb_y);
+        } else if (cmp_arg(arg_name, "portfwd")) {
+#ifdef USE_NET
+            if (!tap_portfwd(tap, arg_val)) return false;
+#endif
+        } else if (cmp_arg(arg_name, "vfio_pci")) {
+            if (!pci_vfio_init_auto(machine, arg_val)) return false;
+        }
+    }
+    if (rvvm_getarg("dumpdtb")) rvvm_dump_dtb(machine, rvvm_getarg("dumpdtb"));
+    return true;
+}
+
+static int rvvm_cli_main(int argc, const char** argv)
+{
+    const char* arg_name = "";
+    const char* arg_val = "";
+    size_t      arg_size = 0;
+
+    // Default params: 1 core, 256M ram, riscv64, 640x480 screen
+    const char* bootrom = NULL;
+    size_t mem = 256 << 20;
+    size_t smp = 1;
+    bool   rv64 = true;
+    tap_dev_t* tap = NULL;
+
+    // Set up global argparser
+    rvvm_set_args(argc, argv);
+    if (rvvm_has_arg("h") || rvvm_has_arg("help") || rvvm_has_arg("H")) {
+        print_help();
+        return 0;
+    }
+
+    // Parse initial machine options
+    if (rvvm_getarg_size("m"))   mem = rvvm_getarg_size("m");
+    if (rvvm_getarg_size("mem")) mem = rvvm_getarg_size("mem");
+    if (rvvm_getarg_int("s"))    smp = rvvm_getarg_int("s");
+    if (rvvm_getarg_int("smp"))  smp = rvvm_getarg_int("smp");
+    rv64 = !rvvm_has_arg("rv32");
+
+    for (int i=1; i<argc; i+=arg_size) {
+        arg_size = get_arg(argv + i, &arg_name, &arg_val);
+        if (cmp_arg(arg_name, "bootrom") || cmp_arg(arg_name, "bios")) {
+            bootrom = arg_val;
+        }
+    }
+    if (bootrom == NULL) {
+        printf("Usage: rvvm [bootrom] [-mem 256M] [-k kernel] [-help] ...\n");
+        return -1;
+    }
+
+    // Create & configure machine
+    rvvm_machine_t* machine = rvvm_create_machine(RVVM_DEFAULT_MEMBASE, mem, smp, rv64);
+    if (machine == NULL) {
+        rvvm_error("Failed to create VM");
+        return -1;
+    }
+    clint_init_auto(machine);
+    plic_init_auto(machine);
+    pci_bus_init_auto(machine);
+    i2c_oc_init_auto(machine);
+
+    rtc_goldfish_init_auto(machine);
+    syscon_init_auto(machine);
+    if (!rvvm_has_arg("serial")) ns16550a_init_term_auto(machine);
+    if (!rvvm_has_arg("nogui") && !rvvm_has_arg("res")) gui_window_init_auto(machine, 640, 480);
+#ifdef USE_NET
+    if (!rvvm_has_arg("nonet")) {
+        tap = tap_open();
+        tap_portfwd(tap, "tcp/127.0.0.1:2022=22");
+        rtl8169_init(rvvm_get_pci_bus(machine), tap);
+    }
+#endif
+
+    if (rvvm_cli_configure(machine, argc, argv, bootrom, tap)) {
+        rvvm_start_machine(machine);
+
+        if (!rvvm_has_arg("noisolation")) {
+            // Preparations are done, isolate the process as much as possible
+            rvvm_restrict_process();
+        }
+
+        // Returns on machine shutdown
+        rvvm_run_eventloop();
+    } else {
+        rvvm_error("Failed to initialize VM");
+    }
+    rvvm_free_machine(machine);
+    return 0;
+}
+
+static int rvvm_main(int argc, char** argv)
+{
+    if (argc >= 3 && rvvm_strcmp(argv[1], "-user")) {
+        return rvvm_user_linux(argc - 2, argv + 2, NULL);
+    }
+    return rvvm_cli_main(argc, (const char**)argv);
+}
+
+int main(int argc, char** argv)
+{
+#if defined(_WIN32) && !defined(UNDER_CE)
+    HWND (__stdcall *get_console_window)(void) = dlib_get_symbol("kernel32.dll", "GetConsoleWindow");
+    if (get_console_window) {
+        HWND console = get_console_window();
+        DWORD pid = 0;
+        GetWindowThreadProcessId(console, &pid);
+        if (GetCurrentProcessId() == pid) {
+            // If we don't have a parent terminal, destroy our console
+            FreeConsole();
+        }
+    }
+    // Use UTF-8 arguments
+    LPWSTR* argv_u16 = CommandLineToArgvW(GetCommandLineW(), &argc);
+    argv = safe_calloc(sizeof(char*), argc + 1);
+    for (int i=0; i<argc; ++i) {
+        size_t arg_len = WideCharToMultiByte(CP_UTF8, 0, argv_u16[i], -1, NULL, 0, NULL, NULL);
+        argv[i] = safe_calloc(sizeof(char), arg_len);
+        WideCharToMultiByte(CP_UTF8, 0, argv_u16[i], -1, argv[i], arg_len, NULL, NULL);
+    }
+#endif
+    int ret = rvvm_main(argc, argv);
+#if defined(_WIN32) && !defined(UNDER_CE)
+    for (int i=0; i<argc; ++i) free(argv[i]);
+    free(argv);
+#endif
+    return ret;
+}
diff --git a/app/src/main/java/libengine/RVVM/src/mem_ops.h b/app/src/main/java/libengine/RVVM/src/mem_ops.h
new file mode 100644
index 00000000..2a48a970
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/mem_ops.h
@@ -0,0 +1,298 @@
+/*
+mem_ops.h - memory operations functions
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef RISCV_MEM_OPS_H
+#define RISCV_MEM_OPS_H
+
+#include "compiler.h"
+#include <stdint.h>
+#include <memory.h>
+
+/*
+ * Simple memory operations (write, read integers) for internal usage,
+ * and load/store instructions.
+ */
+
+/*
+ * Handle misaligned operaions properly, to prevent
+ * crashes on old ARM CPUs, etc
+ */
+
+static inline uint64_t read_uint64_le_m(const void* addr) {
+    const uint8_t* arr = (const uint8_t*)addr;
+    return (uint64_t)arr[0] | ((uint64_t)arr[1] << 8)
+    | ((uint64_t)arr[2] << 16) | ((uint64_t)arr[3] << 24)
+    | ((uint64_t)arr[4] << 32) | ((uint64_t)arr[5] << 40)
+    | ((uint64_t)arr[6] << 48) | ((uint64_t)arr[7] << 56);
+}
+
+static inline void write_uint64_le_m(void* addr, uint64_t val) {
+    uint8_t* arr = (uint8_t*)addr;
+    arr[0] = val & 0xFF;
+    arr[1] = (val >> 8) & 0xFF;
+    arr[2] = (val >> 16) & 0xFF;
+    arr[3] = (val >> 24) & 0xFF;
+    arr[4] = (val >> 32) & 0xFF;
+    arr[5] = (val >> 40) & 0xFF;
+    arr[6] = (val >> 48) & 0xFF;
+    arr[7] = (val >> 56) & 0xFF;
+}
+
+static inline uint32_t read_uint32_le_m(const void* addr) {
+    const uint8_t* arr = (const uint8_t*)addr;
+    return (uint32_t)arr[0] | ((uint32_t)arr[1] << 8)
+    | ((uint32_t)arr[2] << 16) | ((uint32_t)arr[3] << 24);
+}
+
+static inline void write_uint32_le_m(void* addr, uint32_t val) {
+    uint8_t* arr = (uint8_t*)addr;
+    arr[0] = val & 0xFF;
+    arr[1] = (val >> 8) & 0xFF;
+    arr[2] = (val >> 16) & 0xFF;
+    arr[3] = (val >> 24) & 0xFF;
+}
+
+static inline uint16_t read_uint16_le_m(const void* addr) {
+    const uint8_t* arr = (const uint8_t*)addr;
+    return (uint16_t)arr[0] | ((uint16_t)arr[1] << 8);
+}
+
+static inline void write_uint16_le_m(void* addr, uint16_t val) {
+    uint8_t* arr = (uint8_t*)addr;
+    arr[0] = val & 0xFF;
+    arr[1] = (val >> 8) & 0xFF;
+}
+
+/*
+ * Big-endian operations
+ */
+
+static inline uint64_t read_uint64_be_m(const void* addr) {
+    const uint8_t* arr = (const uint8_t*)addr;
+    return (uint64_t)arr[7] | ((uint64_t)arr[6] << 8)
+    | ((uint64_t)arr[5] << 16) | ((uint64_t)arr[4] << 24)
+    | ((uint64_t)arr[3] << 32) | ((uint64_t)arr[2] << 40)
+    | ((uint64_t)arr[1] << 48) | ((uint64_t)arr[0] << 56);
+}
+
+static inline void write_uint64_be_m(void* addr, uint64_t val) {
+    uint8_t* arr = (uint8_t*)addr;
+    arr[7] = val & 0xFF;
+    arr[6] = (val >> 8) & 0xFF;
+    arr[5] = (val >> 16) & 0xFF;
+    arr[4] = (val >> 24) & 0xFF;
+    arr[3] = (val >> 32) & 0xFF;
+    arr[2] = (val >> 40) & 0xFF;
+    arr[1] = (val >> 48) & 0xFF;
+    arr[0] = (val >> 56) & 0xFF;
+}
+
+static inline uint32_t read_uint32_be_m(const void* addr) {
+    const uint8_t* arr = (const uint8_t*)addr;
+    return (uint32_t)arr[3] | ((uint32_t)arr[2] << 8)
+    | ((uint32_t)arr[1] << 16) | ((uint32_t)arr[0] << 24);
+}
+
+static inline void write_uint32_be_m(void* addr, uint32_t val) {
+    uint8_t* arr = (uint8_t*)addr;
+    arr[3] = val & 0xFF;
+    arr[2] = (val >> 8) & 0xFF;
+    arr[1] = (val >> 16) & 0xFF;
+    arr[0] = (val >> 24) & 0xFF;
+}
+
+static inline uint16_t read_uint16_be_m(const void* addr) {
+    const uint8_t* arr = (const uint8_t*)addr;
+    return (uint16_t)arr[1] | ((uint16_t)arr[0] << 8);
+}
+
+static inline void write_uint16_be_m(void* addr, uint16_t val) {
+    uint8_t* arr = (uint8_t*)addr;
+    arr[1] = val & 0xFF;
+    arr[0] = (val >> 8) & 0xFF;
+}
+
+/*
+ * Strictly aligned access for performace
+ * Falls back to byte-bang operations on big-endian systems
+ */
+
+TSAN_SUPPRESS static forceinline uint64_t read_uint64_le(const void* addr) {
+#ifdef HOST_LITTLE_ENDIAN
+    return *(const uint64_t*)addr;
+#else
+    return read_uint64_le_m(addr);
+#endif
+}
+
+TSAN_SUPPRESS static forceinline void write_uint64_le(void* addr, uint64_t val) {
+#ifdef HOST_LITTLE_ENDIAN
+    *(uint64_t*)addr = val;
+#else
+    write_uint64_le_m(addr, val);
+#endif
+}
+
+TSAN_SUPPRESS static forceinline uint32_t read_uint32_le(const void* addr) {
+#ifdef HOST_LITTLE_ENDIAN
+    return *(const uint32_t*)addr;
+#else
+    return read_uint32_le_m(addr);
+#endif
+}
+
+TSAN_SUPPRESS static forceinline void write_uint32_le(void* addr, uint32_t val) {
+#ifdef HOST_LITTLE_ENDIAN
+    *(uint32_t*)addr = val;
+#else
+    write_uint32_le_m(addr, val);
+#endif
+}
+
+TSAN_SUPPRESS static forceinline uint16_t read_uint16_le(const void* addr) {
+#ifdef HOST_LITTLE_ENDIAN
+    return *(const uint16_t*)addr;
+#else
+    return read_uint16_le_m(addr);
+#endif
+}
+
+TSAN_SUPPRESS static forceinline void write_uint16_le(void* addr, uint16_t val) {
+#ifdef HOST_LITTLE_ENDIAN
+    *(uint16_t*)addr = val;
+#else
+    write_uint16_le_m(addr, val);
+#endif
+}
+
+TSAN_SUPPRESS static forceinline uint8_t read_uint8(const void* addr) {
+    return *(const uint8_t*)addr;
+}
+
+TSAN_SUPPRESS static forceinline void write_uint8(void* addr, uint8_t val) {
+    *(uint8_t*)addr = val;
+}
+
+/*
+ * Floating-point memory operations (misaligned)
+ */
+
+static inline float read_float_le_m(const void *addr) {
+    uint32_t i_v = read_uint32_le_m(addr);
+    float ret;
+    memcpy(&ret, &i_v, sizeof(float));
+    return ret;
+}
+
+static inline double read_double_le_m(const void *addr) {
+    uint64_t i_v = read_uint64_le_m(addr);
+    double ret;
+    memcpy(&ret, &i_v, sizeof(double));
+    return ret;
+}
+
+static inline void write_float_le_m(void* addr, float val) {
+    uint32_t i_v;
+    memcpy(&i_v, &val, sizeof(i_v));
+    write_uint32_le_m(addr, i_v);
+}
+
+static inline void write_double_le_m(void* addr, double val) {
+    uint64_t i_v;
+    memcpy(&i_v, &val, sizeof(i_v));
+    write_uint64_le_m(addr, i_v);
+}
+
+/*
+ * Floating-point memory operations (aligned)
+ */
+
+TSAN_SUPPRESS static forceinline float read_float_le(const void *addr) {
+#ifdef HOST_LITTLE_ENDIAN
+    return *(const float*)addr;
+#else
+    return read_float_le_m(addr);
+#endif
+}
+
+TSAN_SUPPRESS static forceinline double read_double_le(const void *addr) {
+#ifdef HOST_LITTLE_ENDIAN
+    return *(const double*)addr;
+#else
+    return read_double_le_m(addr);
+#endif
+}
+
+TSAN_SUPPRESS static forceinline void write_float_le(void *addr, float val) {
+#ifdef HOST_LITTLE_ENDIAN
+    *(float*)addr = val;
+#else
+    write_float_le_m(addr, val);
+#endif
+}
+
+TSAN_SUPPRESS static forceinline void write_double_le(void *addr, double val) {
+#ifdef HOST_LITTLE_ENDIAN
+    *(double*)addr = val;
+#else
+    write_double_le_m(addr, val);
+#endif
+}
+
+// Writes a host-endian double consisting of float + nan-boxing as in RISC-V spec
+static forceinline void write_float_nanbox(void* addr, float val) {
+#ifdef HOST_LITTLE_ENDIAN
+    ((float*)addr)[0] = val;
+    ((uint32_t*)addr)[1] = 0xFFFFFFFF;
+#else
+    ((uint32_t*)addr)[0] = 0xFFFFFFFF;
+    ((float*)addr)[1] = val;
+#endif
+}
+
+// Reads a host-endian double as a nan-boxed float
+static forceinline float read_float_nanbox(const void* addr) {
+#ifdef HOST_LITTLE_ENDIAN
+    return ((const float*)addr)[0];
+#else
+    return ((const float*)addr)[1];
+#endif
+}
+
+// Reads a host-endian nan-boxed float, normalizes invalid values to NaN
+static inline float read_float_normalize(const void* addr) {
+#ifdef HOST_LITTLE_ENDIAN
+    if (unlikely(((const uint32_t*)addr)[1] != 0xFFFFFFFF)) {
+        float ret;
+        uint32_t val = 0x7fc00000;
+        memcpy(&ret, &val, sizeof(ret));
+        return ret;
+    }
+    return ((const float*)addr)[0];
+#else
+    if (unlikely(((const uint32_t*)addr)[0] != 0xFFFFFFFF)) {
+        float ret;
+        uint32_t val = 0x7fc00000;
+        memcpy(&ret, &val, sizeof(ret));
+        return ret;
+    }
+    return ((const float*)addr)[1];
+#endif
+}
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/networking.c b/app/src/main/java/libengine/RVVM/src/networking.c
new file mode 100644
index 00000000..984f5f0f
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/networking.c
@@ -0,0 +1,945 @@
+/*
+networking.c - Network sockets (IPv4/IPv6), Event polling
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifdef _WIN32
+
+// Override maximum amount of sockets for select()
+#define FD_SETSIZE 1024
+#include <winsock2.h>
+#include <ws2tcpip.h> // For IPv6
+
+typedef SOCKET net_handle_t;
+typedef int net_addrlen_t;
+#define NET_HANDLE_INVALID INVALID_SOCKET
+
+#else
+
+#define _GNU_SOURCE
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/select.h>
+#include <sys/ioctl.h>
+#include <netinet/in.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <signal.h>
+#include <errno.h>
+
+typedef int net_handle_t;
+typedef socklen_t net_addrlen_t;
+#define NET_HANDLE_INVALID -1
+
+#if defined(__linux__) || defined(__illumos__)
+// Use epoll() for net_poll on Linux & Illumos
+#include <sys/epoll.h>
+#include <sys/resource.h>
+#define EPOLL_NET_IMPL
+#elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__) \
+   || defined(__OpenBSD__) || defined(__NetBSD__) || defined(__DragonFly__) \
+   || (defined(__APPLE__) && __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ >= 1060)
+// Use BSD kqueue() for net_poll
+#include <sys/event.h>
+#include <sys/resource.h>
+#define KQUEUE_NET_IMPL
+#endif
+
+#endif
+
+#if !(defined(EPOLL_NET_IMPL) || defined(KQUEUE_NET_IMPL))
+// Use select() for net_poll
+// Scales poorly, but it's a fairly portable fallback.
+// Thread safety & other epoll-like features are well emulated.
+#define SELECT_NET_IMPL
+#endif
+
+#ifdef AF_INET6
+// Compile IPv6 support on systems where it's actually exposed
+#define IPV6_NET_IMPL
+#endif
+
+// RVVM internal headers come after system headers because of safe_free() and winsock
+#include "networking.h"
+#include "utils.h"
+#include "mem_ops.h"
+#include "vector.h"
+#include "hashmap.h"
+#include "threading.h"
+#include "spinlock.h"
+
+#if defined(SELECT_NET_IMPL)
+typedef struct {
+    net_sock_t* sock;
+    void*       data;
+    uint32_t    flags;
+} net_monitor_t;
+#endif
+
+struct net_sock {
+#if defined(SELECT_NET_IMPL)
+    vector_t(net_poll_t*) watchers;
+#endif
+    net_handle_t fd;
+    net_addr_t   addr;
+};
+
+struct net_poll {
+#if defined(EPOLL_NET_IMPL) || defined(KQUEUE_NET_IMPL)
+    net_handle_t fd;
+#else
+    spinlock_t lock;
+    vector_t(net_monitor_t) events;
+    fd_set r_set,   w_set;
+    fd_set r_ready, w_ready;
+    int    max_fd;
+    size_t consumed;
+#endif
+};
+
+const net_addr_t net_ipv4_any_addr   = { .type = NET_TYPE_IPV4, };
+const net_addr_t net_ipv4_local_addr = { .type = NET_TYPE_IPV4, .ip[0] = 127, .ip[3] = 1, };
+const net_addr_t net_ipv6_any_addr   = { .type = NET_TYPE_IPV6, };
+const net_addr_t net_ipv6_local_addr = { .type = NET_TYPE_IPV6, .ip[15] = 1, };
+
+static bool net_init_once(void)
+{
+#ifdef _WIN32
+    WSADATA wsaData = {0};
+    WSAStartup(MAKEWORD(2, 2), &wsaData);
+    if (LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) != 2) {
+        rvvm_warn("Failed to initialize WinSock");
+        return false;
+    }
+#elif defined(SIGPIPE)
+    // Ignore SIGPIPE (Do not crash on writes to closed socket)
+    void* handler = signal(SIGPIPE, SIG_IGN);
+    if (handler != (void*)SIG_DFL && handler != (void*)SIG_IGN) {
+        // Revert handler set by someone else
+        signal(SIGPIPE, handler);
+    }
+#endif
+#if defined(EPOLL_NET_IMPL) || defined(KQUEUE_NET_IMPL)
+    struct rlimit rlim = {0};
+    if (getrlimit(RLIMIT_NOFILE, &rlim) == 0) {
+        if (rlim.rlim_cur < rlim.rlim_max && rlim.rlim_max > 1024) {
+            rlim.rlim_cur = rlim.rlim_max;
+            if (setrlimit(RLIMIT_NOFILE, &rlim) == 0) {
+                rvvm_info("Raising RLIMIT_NOFILE to %u", (uint32_t)rlim.rlim_cur);
+            }
+        }
+    }
+#endif
+    return true;
+}
+
+// Initialize networking automatically
+static bool net_init(void)
+{
+    static bool init = false;
+    DO_ONCE(init = net_init_once());
+    return init;
+}
+
+// Address types conversion (net_addr_t <-> sockaddr_in/sockaddr_in6)
+static void net_sockaddr_from_addr(struct sockaddr_in* sock_addr, const net_addr_t* addr)
+{
+    memset(sock_addr, 0, sizeof(struct sockaddr_in));
+    sock_addr->sin_family = AF_INET;
+    if (addr) {
+        write_uint16_be_m(&sock_addr->sin_port, addr->port);
+        memcpy(&sock_addr->sin_addr.s_addr, addr->ip, 4);
+    }
+}
+
+static void net_addr_from_sockaddr(net_addr_t* addr, const struct sockaddr_in* sock_addr)
+{
+    memset(addr, 0, sizeof(net_addr_t));
+    addr->type = NET_TYPE_IPV4;
+    addr->port = read_uint16_be_m(&sock_addr->sin_port);
+    memcpy(addr->ip, &sock_addr->sin_addr.s_addr, 4);
+}
+
+#if defined(IPV6_NET_IMPL)
+static void net_sockaddr6_from_addr(struct sockaddr_in6* sock_addr, const net_addr_t* addr)
+{
+    memset(sock_addr, 0, sizeof(struct sockaddr_in6));
+    sock_addr->sin6_family = AF_INET6;
+    write_uint16_be_m(&sock_addr->sin6_port, addr->port);
+    memcpy(&sock_addr->sin6_addr.s6_addr, addr->ip, 16);
+}
+
+static void net_addr_from_sockaddr6(net_addr_t* addr, const struct sockaddr_in6* sock_addr)
+{
+    memset(addr, 0, sizeof(net_addr_t));
+    addr->type = NET_TYPE_IPV6;
+    addr->port = read_uint16_be_m(&sock_addr->sin6_port);
+    memcpy(addr->ip, &sock_addr->sin6_addr.s6_addr, 16);
+}
+#endif
+
+// Wrappers for generic operations on socket handles
+static void net_close_handle(net_handle_t fd)
+{
+#ifdef _WIN32
+    closesocket(fd);
+#else
+    close(fd);
+#endif
+}
+
+static bool net_handle_set_blocking(net_handle_t fd, bool block)
+{
+#ifdef _WIN32
+    u_long nb = block ? 0 : 1;
+    return ioctlsocket(fd, FIONBIO, &nb) == 0;
+#elif defined(FIONBIO)
+    // Use a single syscall instead of fcntl implementation
+    int nb = block ? 0 : 1;
+    return ioctl(fd, FIONBIO, &nb) == 0;
+#elif defined(F_SETFL) && defined(O_NONBLOCK)
+    int flags = fcntl(fd, F_GETFL, 0);
+    if (flags == -1) return false;
+    flags = block ? (flags & ~O_NONBLOCK) : (flags | O_NONBLOCK);
+    return fcntl(fd, F_SETFL, flags) == 0;
+#else
+    UNUSED(fd);
+    if (!block) rvvm_warn("Non-blocking sockets are not supported on this OS");
+    return false;
+#endif
+}
+
+static void net_handle_set_cloexec(net_handle_t fd)
+{
+#if defined(_WIN32) && !defined(UNDER_CE)
+    SetHandleInformation((HANDLE)fd, HANDLE_FLAG_INHERIT, 0);
+#elif defined(F_SETFD) && defined(FD_CLOEXEC)
+    fcntl(fd, F_SETFD, FD_CLOEXEC);
+#else
+    UNUSED(fd);
+#endif
+}
+
+// Set CLOEXEC flag on created sockets to prevent handle leaking
+// Optimize nonblocking connects on modern Linux and *BSD
+static net_handle_t net_socket_create_ex(int domain, int type, bool nonblock)
+{
+    net_handle_t fd = NET_HANDLE_INVALID;
+#if defined(_WIN32) && !defined(UNDER_CE) && defined(WSA_FLAG_NO_HANDLE_INHERIT)
+    fd = WSASocketW(domain, type, 0, NULL, 0, WSA_FLAG_OVERLAPPED | WSA_FLAG_NO_HANDLE_INHERIT);
+#elif defined(SOCK_CLOEXEC) && defined(SOCK_NONBLOCK)
+    fd = socket(domain, type | SOCK_CLOEXEC | (nonblock ? SOCK_NONBLOCK : 0), 0);
+    if (fd != NET_HANDLE_INVALID) return fd;
+#endif
+    if (fd == NET_HANDLE_INVALID) {
+        fd = socket(domain, type, 0);
+        if (fd != NET_HANDLE_INVALID) net_handle_set_cloexec(fd);
+    }
+    if (nonblock && fd != NET_HANDLE_INVALID) net_handle_set_blocking(fd, false);
+    return fd;
+}
+
+// Set CLOEXEC flag on accepted sockets, propagate blocking mode as on BSD stack
+static net_handle_t net_accept_ex(net_handle_t listener, void* sock_addr, net_addrlen_t* addr_len)
+{
+    net_handle_t fd = NET_HANDLE_INVALID;
+#ifdef __linux__
+    // Linux accept(2) does not inherit nonblocking flag on created socket
+    bool nonblock = !!(fcntl(listener, F_GETFL, 0) & O_NONBLOCK);
+#if defined(SOCK_CLOEXEC) && defined(SOCK_NONBLOCK) && defined(__USE_GNU)
+    fd = accept4(listener, sock_addr, addr_len, SOCK_CLOEXEC | (nonblock ? SOCK_NONBLOCK : 0));
+#endif
+#endif
+    if (fd == NET_HANDLE_INVALID) {
+        fd = accept(listener, sock_addr, addr_len);
+        if (fd != NET_HANDLE_INVALID) {
+            net_handle_set_cloexec(fd);
+#ifdef __linux__
+            if (nonblock) net_handle_set_blocking(fd, false);
+#endif
+        }
+    }
+    return fd;
+}
+
+static net_handle_t net_create_handle(int type, const net_addr_t* addr, bool nonblock)
+{
+    net_handle_t fd = NET_HANDLE_INVALID;
+    if (!net_init()) return fd;
+    if (addr == NULL || addr->type == NET_TYPE_IPV4) {
+        fd = net_socket_create_ex(AF_INET, type, nonblock);
+#if defined(IPV6_NET_IMPL)
+    } else if (addr->type == NET_TYPE_IPV6) {
+        fd = net_socket_create_ex(AF_INET6, type, nonblock);
+#endif
+    }
+#if defined(IPPROTO_TCP) && defined(TCP_NODELAY)
+    if (type == SOCK_STREAM && fd != NET_HANDLE_INVALID) {
+        // Disable transmit buffering to improve latency, inherited in accept()
+        int nodelay = 1;
+        setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, (const void*)&nodelay, sizeof(nodelay));
+    }
+#endif
+    return fd;
+}
+
+static bool net_bind_handle(net_handle_t fd, const net_addr_t* addr)
+{
+    if (addr == NULL || addr->type == NET_TYPE_IPV4) {
+        struct sockaddr_in sock_addr;
+        net_sockaddr_from_addr(&sock_addr, addr);
+        return bind(fd, (struct sockaddr*)&sock_addr, sizeof(sock_addr)) == 0;
+#if defined(IPV6_NET_IMPL)
+    } else if (addr->type == NET_TYPE_IPV6) {
+#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)
+        // Disable dual-stack explicitly (may be configurable in future)
+        int v6only = 1;
+        setsockopt(fd, SOL_IPV6, IPV6_V6ONLY, (const void*)&v6only, sizeof(v6only));
+#endif
+        struct sockaddr_in6 sock_addr;
+        net_sockaddr6_from_addr(&sock_addr, addr);
+        return bind(fd, (struct sockaddr*)&sock_addr, sizeof(sock_addr)) == 0;
+#endif
+    }
+    return false;
+}
+
+static inline bool net_conn_initiated(void)
+{
+#ifdef _WIN32
+    return WSAGetLastError() == WSAEWOULDBLOCK;
+#else
+    return errno == EINPROGRESS;
+#endif
+}
+
+static bool net_connect_handle(net_handle_t fd, const net_addr_t* addr)
+{
+    if (addr == NULL || addr->type == NET_TYPE_IPV4) {
+        struct sockaddr_in sock_addr;
+        net_sockaddr_from_addr(&sock_addr, addr);
+        return connect(fd, (struct sockaddr*)&sock_addr, sizeof(sock_addr)) == 0
+            || net_conn_initiated();
+#if defined(IPV6_NET_IMPL)
+    } else if (addr->type == NET_TYPE_IPV6) {
+        struct sockaddr_in6 sock_addr;
+        net_sockaddr6_from_addr(&sock_addr, addr);
+        return connect(fd, (struct sockaddr*)&sock_addr, sizeof(sock_addr)) == 0
+            || net_conn_initiated();
+#endif
+    }
+    return false;
+}
+
+// Wrap native handles in net_sock_t
+static net_sock_t* net_wrap_handle(net_handle_t fd)
+{
+    if (fd == NET_HANDLE_INVALID) return NULL;
+    net_sock_t* sock = safe_new_obj(net_sock_t);
+    sock->fd = fd;
+    return sock;
+}
+
+// Wrap assigned local address after net_bind_handle()
+static net_sock_t* net_init_localaddr(net_sock_t* sock, const net_addr_t* addr)
+{
+    if (sock) {
+        if (addr == NULL || addr->type == NET_TYPE_IPV4) {
+            struct sockaddr_in sock_addr;
+            net_addrlen_t addr_len = sizeof(struct sockaddr_in);
+            // Win32 getsockname may not set sin_family/sin_addr...
+            net_sockaddr_from_addr(&sock_addr, addr);
+            getsockname(sock->fd, (struct sockaddr*)&sock_addr, &addr_len);
+            net_addr_from_sockaddr(&sock->addr, &sock_addr);
+#if defined(IPV6_NET_IMPL)
+        } else if (addr->type == NET_TYPE_IPV6) {
+            struct sockaddr_in6 sock_addr;
+            net_addrlen_t addr_len = sizeof(struct sockaddr_in6);
+            net_sockaddr6_from_addr(&sock_addr, addr);
+            getsockname(sock->fd, (struct sockaddr*)&sock_addr, &addr_len);
+            net_addr_from_sockaddr6(&sock->addr, &sock_addr);
+#endif
+        }
+    }
+    return sock;
+}
+
+static int32_t net_last_error(void)
+{
+#ifdef _WIN32
+    int err = WSAGetLastError();
+    if (err == WSAEWOULDBLOCK || err == WSAEINTR) return NET_ERR_BLOCK;
+    if (err == WSAECONNRESET) return NET_ERR_RESET;
+    return NET_ERR_UNKNOWN;
+#else
+    int err = errno;
+    if (err == EAGAIN || err == EWOULDBLOCK || err == EINTR) return NET_ERR_BLOCK;
+    if (err == ECONNRESET) return NET_ERR_RESET;
+    return NET_ERR_UNKNOWN;
+#endif
+}
+
+// Public socket API
+
+bool net_parse_addr(net_addr_t* addr, const char* str)
+{
+    net_addr_t result = {0};
+    const char* parse = str;
+    const char* colon = rvvm_strfind(parse, ":");
+    bool ipv6 = colon && rvvm_strfind(colon + 1, ":"); // More than a single :
+    bool ipv4 = rvvm_strfind(parse, ".");
+    bool parse_port = !ipv4 && !ipv6 && !rvvm_strfind(parse, "localhost");
+    size_t len = 0;
+    if (ipv6) {
+        bool bracket = parse[0] == '[';
+        bool skip_colon = false;
+        const char* colon_pair = rvvm_strfind(parse, "::");
+        size_t bytes = 0;
+        size_t right_start = 0;
+        if (bracket) parse++;
+        for (; bytes < 16; bytes += 2) {
+            if (parse == colon_pair) {
+                // Record location of encountered ::, skip it like a group
+                parse += 2;
+                right_start = bytes;
+                skip_colon = false;
+                continue;
+            } else if (skip_colon && parse[0] == ':') {
+                // If we are beyond first hex group, skip prepending :
+                parse++;
+            } else if (parse[0] == 0 || (bracket && parse[0] == ']')) break;
+            // Parse hex group
+            uint16_t hex = str_to_uint_base(parse, &len, 16);
+            if (!len || len > 4) return false; // Hex parsing failed or too long
+            write_uint16_be_m(result.ip + bytes, hex);
+            parse += len;
+            skip_colon = true;
+        }
+        if (bracket) {
+            if (parse[0] != ']') return false; // Missing closing ]
+            parse++;
+        }
+        if (!bracket && parse[0] != 0) return false; // Trailing garbage without []
+        if (colon_pair) {
+            // Align fields at the right of colon pair to end of IPv6, zero hole
+            memmove(result.ip + 16 - (bytes - right_start), result.ip + right_start, bytes - right_start);
+            memset(result.ip + right_start, 0, 16 - bytes);
+        } else if (bytes != 16) return false; // Not enough hex groups and no colon pair
+        result.type = NET_TYPE_IPV6;
+    } else if (ipv4) {
+        for (size_t i=0; i<4; ++i) {
+            result.ip[i] = str_to_uint_base(parse, &len, 10);
+            if (!len) return false; // Integer parsing failed
+            parse += len;
+            if (i < 3 && parse[0] == '.') parse++;
+        }
+    } else if (rvvm_strfind(parse, "localhost") == parse) {
+        result = net_ipv4_local_addr;
+        parse += 9;
+    }
+    if (parse[0] == ':') {
+        parse_port = true;
+        parse++;
+    }
+    if (parse_port) {
+        result.port = str_to_uint_base(parse, &len, 10);
+        if (!len) return false; // Integer parsing failed
+        parse += len;
+    }
+    if (parse[0] != 0) return false; // Trailing garbage
+
+    memcpy(addr, &result, sizeof(result));
+    return true;
+}
+
+net_sock_t* net_tcp_listen(const net_addr_t* addr)
+{
+    net_handle_t fd = net_create_handle(SOCK_STREAM, addr, false);
+    if (fd == NET_HANDLE_INVALID) return NULL;
+#if defined(SOL_SOCKET) && defined(SO_REUSEADDR)
+    // Prevent bind errors due to TIME_WAIT
+    int reuse = 1;
+    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (const void*)&reuse, sizeof(reuse));
+#endif
+    if (!net_bind_handle(fd, addr) || listen(fd, SOMAXCONN)) {
+        net_close_handle(fd);
+        return NULL;
+    }
+
+    return net_init_localaddr(net_wrap_handle(fd), addr);
+}
+
+net_sock_t* net_tcp_accept(net_sock_t* listener)
+{
+    net_sock_t* sock = NULL;
+    if (listener == NULL) return NULL;
+    if (listener->addr.type == NET_TYPE_IPV4) {
+        struct sockaddr_in sock_addr = {0};
+        net_addrlen_t addr_len = sizeof(struct sockaddr_in);
+        sock = net_wrap_handle(net_accept_ex(listener->fd, &sock_addr, &addr_len));
+        if (sock) net_addr_from_sockaddr(&sock->addr, &sock_addr);
+#if defined(IPV6_NET_IMPL)
+    } else if (listener->addr.type == NET_TYPE_IPV6) {
+        struct sockaddr_in6 sock_addr = {0};
+        net_addrlen_t addr_len = sizeof(struct sockaddr_in6);
+        sock = net_wrap_handle(net_accept_ex(listener->fd, &sock_addr, &addr_len));
+        if (sock) net_addr_from_sockaddr6(&sock->addr, &sock_addr);
+#endif
+    }
+    return sock;
+}
+
+net_sock_t* net_tcp_connect(const net_addr_t* dst, const net_addr_t* src, bool block)
+{
+    if (dst == NULL) return NULL;
+    // Create a nonblocking socket if needed
+    net_handle_t fd = net_create_handle(SOCK_STREAM, dst, !block);
+    if (fd == NET_HANDLE_INVALID) return NULL;
+    // Bind to local address if needed
+    if (src) {
+#if defined(SOL_SOCKET) && defined(IP_BIND_ADDRESS_NO_PORT)
+        if (src->port == 0) {
+            // Prevent bind errors due to ephemeral port exhaustion
+            // Kernel now knows we won't listen() and allows local 2-tuple reuse
+            int noport = 1;
+            setsockopt(fd, SOL_SOCKET, IP_BIND_ADDRESS_NO_PORT, (const void*)&noport, sizeof(noport));
+        }
+#endif
+#if defined(SOL_SOCKET) && defined(SO_REUSEADDR)
+        if (src->port) {
+            // Allow connecting to different destinations from a single local port
+            int reuse = 1;
+            setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (const void*)&reuse, sizeof(reuse));
+        }
+#endif
+        if (!net_bind_handle(fd, src)) {
+            net_close_handle(fd);
+            return NULL;
+        }
+    }
+
+    if (!net_connect_handle(fd, dst)) {
+        net_close_handle(fd);
+        return NULL;
+    }
+
+    net_sock_t* sock = net_wrap_handle(fd);
+    if (sock) sock->addr = *dst;
+
+    return sock;
+}
+
+bool net_tcp_sockpair(net_sock_t* pair[2])
+{
+    net_sock_t* listener = net_tcp_listen(NET_IPV4_LOCAL);
+    pair[0] = net_tcp_connect(net_sock_addr(listener), NULL, false);
+    pair[1] = net_tcp_accept(listener);
+    net_sock_close(listener);
+    if (!net_tcp_status(pair[0]) || !net_tcp_status(pair[1])) {
+        net_sock_close(pair[0]);
+        net_sock_close(pair[1]);
+        return false;
+    }
+    return true;
+}
+
+bool net_tcp_status(net_sock_t* sock)
+{
+    if (sock == NULL) return false;
+    if (sock->addr.type == NET_TYPE_IPV4) {
+        struct sockaddr_in sock_addr = {0};
+        net_addrlen_t addr_len = sizeof(struct sockaddr_in);
+        return getpeername(sock->fd, (struct sockaddr*)&sock_addr, &addr_len) == 0;
+#if defined(IPV6_NET_IMPL)
+    } else if (sock->addr.type == NET_TYPE_IPV6) {
+        struct sockaddr_in6 sock_addr = {0};
+        net_addrlen_t addr_len = sizeof(struct sockaddr_in6);
+        return getpeername(sock->fd, (struct sockaddr*)&sock_addr, &addr_len) == 0;
+#endif
+    }
+    return false;
+}
+
+bool net_tcp_shutdown(net_sock_t* sock)
+{
+    return sock && shutdown(sock->fd, 1) == 0;
+}
+
+int32_t net_tcp_send(net_sock_t* sock, const void* buffer, size_t size)
+{
+    if (sock == NULL) return NET_ERR_RESET;
+    int ret = send(sock->fd, buffer, size, 0);
+    if (ret < 0) return net_last_error();
+    return ret;
+}
+
+int32_t net_tcp_recv(net_sock_t* sock, void* buffer, size_t size)
+{
+    if (sock == NULL) return NET_ERR_RESET;
+    int ret = recv(sock->fd, buffer, size, 0);
+    if (ret > 0) return ret;
+    if (ret == 0) return NET_ERR_DISCONNECT;
+    return net_last_error();
+}
+
+net_sock_t* net_udp_bind(const net_addr_t* addr)
+{
+    net_handle_t fd = net_create_handle(SOCK_DGRAM, addr, false);
+    if (fd == NET_HANDLE_INVALID) return NULL;
+
+    if (!net_bind_handle(fd, addr)) {
+        net_close_handle(fd);
+        return NULL;
+    }
+
+    return net_init_localaddr(net_wrap_handle(fd), addr);
+}
+
+size_t net_udp_send(net_sock_t* sock, const void* buffer, size_t size, const net_addr_t* addr)
+{
+    int ret = 0;
+    if (sock == NULL) return 0;
+    if (sock->addr.type == NET_TYPE_IPV4) {
+        struct sockaddr_in sock_addr;
+        net_sockaddr_from_addr(&sock_addr, addr);
+        ret = sendto(sock->fd, buffer, size, 0, (struct sockaddr*)&sock_addr, sizeof(sock_addr));
+#if defined(IPV6_NET_IMPL)
+    } else if (sock->addr.type == NET_TYPE_IPV6) {
+        struct sockaddr_in6 sock_addr;
+        net_sockaddr6_from_addr(&sock_addr, addr);
+        ret = sendto(sock->fd, buffer, size, 0, (struct sockaddr*)&sock_addr, sizeof(sock_addr));
+#endif
+    }
+    return ret > 0 ? ret : 0;
+}
+
+int32_t net_udp_recv(net_sock_t* sock, void* buffer, size_t size, net_addr_t* addr)
+{
+    int ret = 0;
+    if (sock == NULL) return NET_ERR_RESET;
+    if (sock->addr.type == NET_TYPE_IPV4) {
+        struct sockaddr_in sock_addr = {0};
+        net_addrlen_t addr_len = sizeof(struct sockaddr_in);
+        ret = recvfrom(sock->fd, buffer, size, 0, (struct sockaddr*)&sock_addr, &addr_len);
+        net_addr_from_sockaddr(addr, &sock_addr);
+#if defined(IPV6_NET_IMPL)
+    } else if (sock->addr.type == NET_TYPE_IPV6) {
+        struct sockaddr_in6 sock_addr = {0};
+        net_addrlen_t addr_len = sizeof(struct sockaddr_in6);
+        ret = recvfrom(sock->fd, buffer, size, 0, (struct sockaddr*)&sock_addr, &addr_len);
+        net_addr_from_sockaddr6(addr, &sock_addr);
+#endif
+    }
+    if (ret < 0) return net_last_error();
+    return ret;
+}
+
+// Generic socket operations
+
+net_addr_t* net_sock_addr(net_sock_t* sock)
+{
+    return sock ? &sock->addr : NULL;
+}
+
+uint16_t net_sock_port(net_sock_t* sock)
+{
+    return sock ? sock->addr.port : 0;
+}
+
+bool net_sock_set_blocking(net_sock_t* sock, bool block)
+{
+    return sock && net_handle_set_blocking(sock->fd, block);
+}
+
+void net_sock_close(net_sock_t* sock)
+{
+    if (sock == NULL) return;
+#if defined(SELECT_NET_IMPL)
+    vector_foreach_back(sock->watchers, i) {
+        net_poll_remove(vector_at(sock->watchers, i), sock);
+    }
+    vector_free(sock->watchers);
+#endif
+    net_close_handle(sock->fd);
+    free(sock);
+}
+
+// Event polling
+
+net_poll_t* net_poll_create(void)
+{
+    if (!net_init()) return NULL;
+    net_poll_t* poll = safe_new_obj(net_poll_t);
+#if defined(EPOLL_NET_IMPL)
+    poll->fd = epoll_create(16);
+    if (poll->fd < 0) {
+        free(poll);
+        return NULL;
+    }
+    net_handle_set_cloexec(poll->fd);
+#elif defined(KQUEUE_NET_IMPL)
+    poll->fd = kqueue();
+    if (poll->fd < 0) {
+        free(poll);
+        return NULL;
+    }
+    net_handle_set_cloexec(poll->fd);
+#else
+    vector_init(poll->events);
+    FD_ZERO(&poll->r_set);
+    FD_ZERO(&poll->w_set);
+    poll->max_fd = 1;
+#endif
+    return poll;
+}
+
+bool net_poll_add(net_poll_t* poll, net_sock_t* sock, const net_event_t* event)
+{
+    if (poll == NULL || sock == NULL) return false;
+    bool poll_wr = !!(event->flags & NET_POLL_SEND);
+#if defined(EPOLL_NET_IMPL)
+    struct epoll_event ev = {
+        .events = EPOLLIN | (poll_wr ? EPOLLOUT : 0),
+        .data.ptr = event->data,
+    };
+    return epoll_ctl(poll->fd, EPOLL_CTL_ADD, sock->fd, &ev) == 0;
+#elif defined(KQUEUE_NET_IMPL)
+    struct kevent ev[2];
+    EV_SET(&ev[0], sock->fd, EVFILT_READ, EV_ADD, 0, 0, event->data);
+    EV_SET(&ev[1], sock->fd, EVFILT_WRITE, poll_wr ? EV_ADD : EV_DELETE, 0, 0, event->data);
+    return kevent(poll->fd, ev, 2, NULL, 0, NULL) != -1 || errno == ENOENT;
+#else
+    net_monitor_t monitor = {
+        .sock = sock,
+        .data = event->data,
+        .flags = event->flags | NET_POLL_RECV,
+    };
+    spin_lock(&poll->lock);
+    if (FD_ISSET(sock->fd, &poll->r_set) || FD_ISSET(sock->fd, &poll->w_set)) {
+        // Socket already monitored
+        spin_unlock(&poll->lock);
+        return false;
+    }
+#ifdef _WIN32
+    if (vector_size(poll->events) >= FD_SETSIZE)
+#else
+    if (sock->fd >= FD_SETSIZE)
+#endif
+    {
+        rvvm_warn("select(): ignoring sockets above FD_SETSIZE (%d)", (uint32_t)FD_SETSIZE);
+        spin_unlock(&poll->lock);
+        return false;
+    }
+#ifndef _WIN32
+    if (poll->max_fd < sock->fd) poll->max_fd = sock->fd;
+#endif
+    // Monitor for requested events
+    FD_SET(sock->fd, &poll->r_set);
+    if (poll_wr) FD_SET(sock->fd, &poll->w_set);
+    vector_push_back(poll->events, monitor);
+    // Link the socket to the watcher to remove() it on close()
+    vector_push_back(sock->watchers, poll);
+    spin_unlock(&poll->lock);
+    return true;
+#endif
+}
+
+bool net_poll_mod(net_poll_t* poll, net_sock_t* sock, const net_event_t* event)
+{
+    if (poll == NULL || sock == NULL) return false;
+    bool poll_wr = !!(event->flags & NET_POLL_SEND);
+#if defined(EPOLL_NET_IMPL)
+    struct epoll_event ev = {
+        .events = EPOLLIN | (poll_wr ? EPOLLOUT : 0),
+        .data.ptr = event->data,
+    };
+    return epoll_ctl(poll->fd, EPOLL_CTL_MOD, sock->fd, &ev) == 0;
+#elif defined(KQUEUE_NET_IMPL)
+    struct kevent ev[2];
+    EV_SET(&ev[0], sock->fd, EVFILT_READ, EV_ADD, 0, 0, event->data);
+    EV_SET(&ev[1], sock->fd, EVFILT_WRITE, poll_wr ? EV_ADD : EV_DELETE, 0, 0, event->data);
+    return kevent(poll->fd, ev, 2, NULL, 0, NULL) != -1 || errno == ENOENT;
+#else
+    spin_lock(&poll->lock);
+    vector_foreach(poll->events, i) {
+        net_monitor_t* monitor = &vector_at(poll->events, i);
+        if (monitor->sock == sock) {
+            monitor->data = event->data;
+            monitor->flags = NET_POLL_RECV | (poll_wr ? NET_POLL_SEND : 0);
+            if (poll_wr) {
+                FD_SET(sock->fd, &poll->w_set);
+            } else {
+                FD_CLR(sock->fd, &poll->w_set);
+            }
+            spin_unlock(&poll->lock);
+            return true;
+        }
+    }
+    spin_unlock(&poll->lock);
+    return false;
+#endif
+}
+
+bool net_poll_remove(net_poll_t* poll, net_sock_t* sock)
+{
+    if (poll == NULL || sock == NULL) return false;
+#if defined(EPOLL_NET_IMPL)
+    struct epoll_event ev = {0};
+    return epoll_ctl(poll->fd, EPOLL_CTL_DEL, sock->fd, &ev) == 0;
+#elif defined(KQUEUE_NET_IMPL)
+    struct kevent ev[2];
+    EV_SET(&ev[0], sock->fd, EVFILT_READ,  EV_DELETE, 0, 0, NULL);
+    EV_SET(&ev[1], sock->fd, EVFILT_WRITE, EV_DELETE, 0, 0, NULL);
+    return kevent(poll->fd, ev, 2, NULL, 0, NULL) != -1 || errno == ENOENT;
+#else
+    spin_lock(&poll->lock);
+    vector_foreach(poll->events, i) {
+        if (vector_at(poll->events, i).sock == sock) {
+            vector_erase(poll->events, i);
+            FD_CLR(sock->fd, &poll->r_set);
+            FD_CLR(sock->fd, &poll->w_set);
+            // Skip this socket in events buffer
+            if (poll->consumed > i) poll->consumed--;
+            // Unlink watcher from the socket
+            vector_foreach(sock->watchers, j) {
+                if (vector_at(sock->watchers, j) == poll) {
+                    vector_erase(sock->watchers, j);
+                    spin_unlock(&poll->lock);
+                    return true;
+                }
+            }
+            rvvm_warn("Corrupted socket watcher list!");
+            break;
+        }
+    }
+    spin_unlock(&poll->lock);
+    return false;
+#endif
+}
+
+#define NET_POLL_MAX_EVENTS 64
+
+size_t net_poll_wait(net_poll_t* poll, net_event_t* events, size_t size, uint32_t wait_ms)
+{
+    if (poll == NULL || size == 0) return 0;
+#if defined(EPOLL_NET_IMPL)
+    struct epoll_event ev[NET_POLL_MAX_EVENTS];
+    if (size > NET_POLL_MAX_EVENTS) size = NET_POLL_MAX_EVENTS;
+    int ret = epoll_wait(poll->fd, ev, size, wait_ms);
+    if (ret < 0) ret = 0;
+    for (int i=0; i<ret; ++i) {
+        events[i].data = ev[i].data.ptr;
+        events[i].flags = ((ev[i].events & ~EPOLLOUT) ? NET_POLL_RECV : 0)
+                        | ((ev[i].events & EPOLLOUT) ? NET_POLL_SEND : 0);
+    }
+#elif defined(KQUEUE_NET_IMPL)
+    size_t ret = 0;
+    struct kevent ev[NET_POLL_MAX_EVENTS];
+    struct timespec ts = {
+        .tv_sec = wait_ms / 1000,
+        .tv_nsec = (wait_ms % 1000) * 1000000,
+    };
+    if (size > NET_POLL_MAX_EVENTS) size = NET_POLL_MAX_EVENTS;
+    int cnt = kevent(poll->fd, NULL, 0, ev, size, (wait_ms == NET_POLL_INF) ? NULL : &ts);
+    for (int i=0; i<cnt; ++i) if (ev[i].filter == EVFILT_READ) {
+        events[ret].data = (void*)ev[i].udata;
+        events[ret++].flags = NET_POLL_RECV;
+    }
+    // Coalesce NET_POLL_SEND flags onto associated event entry
+    for (int i=0; i<cnt; ++i) if (ev[i].filter == EVFILT_WRITE) {
+        bool coalesce = false;
+        for (size_t j=0; j<ret; ++j) if (events[j].data == (void*)ev[i].udata) {
+            events[j].flags |= NET_POLL_SEND;
+            coalesce = true;
+            break;
+        }
+        if (!coalesce) {
+            events[ret].data = (void*)ev[i].udata;
+            events[ret++].flags = NET_POLL_SEND;
+        }
+    }
+#else
+    size_t ret = 0;
+
+    spin_lock(&poll->lock);
+    do {
+        bool has_events = poll->consumed;
+        if (!has_events) {
+            // No available buffered events to consume
+            // Wait for small intervals, allowing to modify polled events
+            int nfds = poll->max_fd + 1;
+            struct timeval tv = {
+                .tv_usec = (wait_ms < 10) ? wait_ms : 10,
+            };
+            if (wait_ms != NET_POLL_INF) wait_ms -= tv.tv_usec;
+            tv.tv_usec *= 1000;
+
+            poll->r_ready = poll->r_set;
+            poll->w_ready = poll->w_set;
+            spin_unlock(&poll->lock);
+            has_events = select(nfds, &poll->r_ready, &poll->w_ready, NULL, &tv) > 0;
+            spin_lock(&poll->lock);
+        }
+
+        // Loop over buffered socket state
+        if (has_events) for (size_t i=poll->consumed; i<vector_size(poll->events); ++i) {
+            net_monitor_t* monitor = &vector_at(poll->events, i);
+            uint32_t flags = 0;
+            if (monitor->flags & NET_POLL_RECV) {
+                if (FD_ISSET(monitor->sock->fd, &poll->r_ready)) flags |= NET_POLL_RECV;
+            }
+            if (monitor->flags & NET_POLL_SEND) {
+                if (FD_ISSET(monitor->sock->fd, &poll->w_ready)) flags |= NET_POLL_SEND;
+            }
+            if (flags) {
+                events[ret].data = monitor->data;
+                events[ret].flags = flags;
+                if (++ret >= size) {
+                    // We filled caller event buffer, leave trailing buffered events
+                    poll->consumed = i + 1;
+                    spin_unlock(&poll->lock);
+                    return ret;
+                }
+            }
+        }
+        // All events consumed, call select() next time
+        poll->consumed = 0;
+    } while (wait_ms && ret == 0);
+    spin_unlock(&poll->lock);
+#endif
+    return ret;
+}
+
+void net_poll_close(net_poll_t* poll)
+{
+    if (poll == NULL) return;
+#if defined(EPOLL_NET_IMPL) || defined(KQUEUE_NET_IMPL)
+    net_close_handle(poll->fd);
+#else
+    // Unlink watcher from related sockets
+    vector_foreach(poll->events, i) {
+        net_sock_t* sock = vector_at(poll->events, i).sock;
+        vector_foreach(sock->watchers, j) {
+            if (vector_at(sock->watchers, j) == poll) {
+                vector_erase(sock->watchers, j);
+                break;
+            }
+        }
+    }
+    vector_free(poll->events);
+#endif
+    free(poll);
+}
diff --git a/app/src/main/java/libengine/RVVM/src/networking.h b/app/src/main/java/libengine/RVVM/src/networking.h
new file mode 100644
index 00000000..6077545b
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/networking.h
@@ -0,0 +1,118 @@
+/*
+networking.h - Network sockets (IPv4/IPv6), Event polling
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef NETWORKING_H
+#define NETWORKING_H
+
+#include <stdbool.h>
+#include <stdint.h>
+#include <stddef.h>
+
+typedef struct net_sock net_sock_t;
+
+typedef struct {
+    // Address family (IPv4/IPv6)
+    uint16_t type;
+
+    // Port (In host byte order)
+    uint16_t port;
+
+    // For IPv4: ip[0].ip[1].ip[2].ip[3]
+    uint8_t  ip[16];
+} net_addr_t;
+
+#define NET_TYPE_IPV4 0
+#define NET_TYPE_IPV6 1
+#define NET_PORT_ANY  0
+
+extern const net_addr_t net_ipv4_any_addr;
+extern const net_addr_t net_ipv6_any_addr;
+extern const net_addr_t net_ipv4_local_addr;
+extern const net_addr_t net_ipv6_local_addr;
+
+// Passed to listen/bind as a shorthand (Picks any free port)
+#define NET_IPV4_ANY   (&net_ipv4_any_addr)
+#define NET_IPV4_LOCAL (&net_ipv4_local_addr)
+#define NET_IPV6_ANY   (&net_ipv6_any_addr)
+#define NET_IPV6_LOCAL (&net_ipv6_local_addr)
+
+#define NET_ERR_NONE       0
+#define NET_ERR_UNKNOWN    (-1)
+#define NET_ERR_BLOCK      (-2)
+#define NET_ERR_DISCONNECT (-3)
+#define NET_ERR_RESET      (-4)
+
+// Parses "[port]"; "0.0.0.0:[port]"; "[::1]:[port]"; "localhost"; etc
+bool        net_parse_addr(net_addr_t* addr, const char* str);
+
+// TCP Sockets
+
+net_sock_t* net_tcp_listen(const net_addr_t* addr);
+net_sock_t* net_tcp_accept(net_sock_t* listener);
+net_sock_t* net_tcp_connect(const net_addr_t* dst, const net_addr_t* src, bool block);
+bool        net_tcp_sockpair(net_sock_t* pair[2]);
+bool        net_tcp_status(net_sock_t* sock);   // Connected & not yet closed on both sides
+bool        net_tcp_shutdown(net_sock_t* sock); // Send EOF (FIN), only recv() works afterwards
+
+int32_t     net_tcp_send(net_sock_t* sock, const void* buffer, size_t size);
+int32_t     net_tcp_recv(net_sock_t* sock, void* buffer, size_t size);
+
+// UDP Sockets
+
+net_sock_t* net_udp_bind(const net_addr_t* addr);
+
+size_t      net_udp_send(net_sock_t* sock, const void* buffer, size_t size, const net_addr_t* addr);
+int32_t     net_udp_recv(net_sock_t* sock, void* buffer, size_t size, net_addr_t* addr);
+
+// Generic socket operations
+
+net_addr_t* net_sock_addr(net_sock_t* sock);
+uint16_t    net_sock_port(net_sock_t* sock);
+bool        net_sock_set_blocking(net_sock_t* sock, bool block);
+void        net_sock_close(net_sock_t* sock);
+
+// Socket event polling
+
+typedef struct net_poll net_poll_t;
+
+typedef struct {
+    uint32_t flags;
+    void*    data;
+} net_event_t;
+
+// Incoming connection, data received or peer disconnected
+// Implicitly polled for all watched sockets
+#define NET_POLL_RECV 1
+
+// Transmission is possible or outbound connect finished
+// Check connection success with net_tcp_status() afterwards
+#define NET_POLL_SEND 2
+
+#define NET_POLL_INF ((uint32_t)-1)
+
+net_poll_t* net_poll_create(void);
+
+bool        net_poll_add(net_poll_t* poll, net_sock_t* sock, const net_event_t* event);
+bool        net_poll_mod(net_poll_t* poll, net_sock_t* sock, const net_event_t* event);
+bool        net_poll_remove(net_poll_t* poll, net_sock_t* sock);
+
+size_t      net_poll_wait(net_poll_t* poll, net_event_t* events, size_t size, uint32_t wait_ms);
+
+void        net_poll_close(net_poll_t* poll);
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/ringbuf.c b/app/src/main/java/libengine/RVVM/src/ringbuf.c
new file mode 100644
index 00000000..44539e72
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/ringbuf.c
@@ -0,0 +1,118 @@
+/*
+ringbuf.с - FIFO Ring buffer
+Copyright (C) 2021  cerg2010cerg2010 <github.com/cerg2010cerg2010>
+                    LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "ringbuf.h"
+#include "utils.h"
+#include "mem_ops.h"
+
+void ringbuf_create(ringbuf_t* rb, size_t size)
+{
+    rb->data = safe_new_arr(uint8_t, size);
+    rb->size = size;
+    rb->start = 0;
+    rb->consumed = 0;
+}
+
+void ringbuf_destroy(ringbuf_t* rb)
+{
+    rb->size = 0;
+    rb->start = 0;
+    rb->consumed = 0;
+    free(rb->data);
+}
+
+size_t ringbuf_space(ringbuf_t* rb)
+{
+    return rb->size - rb->consumed;
+}
+
+size_t ringbuf_avail(ringbuf_t* rb)
+{
+    return rb->consumed;
+}
+
+size_t ringbuf_skip(ringbuf_t* rb, size_t len)
+{
+    size_t skip = EVAL_MIN(len, rb->consumed);
+    rb->consumed -= skip;
+    return skip;
+}
+
+static inline size_t ringbuf_get_read_start(ringbuf_t* rb)
+{
+    return rb->consumed > rb->start
+        ? (rb->size - rb->consumed + rb->start)
+        : (rb->start - rb->consumed);
+}
+
+size_t ringbuf_peek(ringbuf_t* rb, void* data, size_t len)
+{
+    size_t start = ringbuf_get_read_start(rb);
+    size_t ret = EVAL_MIN(rb->consumed, len);
+    size_t lhalf_len = EVAL_MIN(rb->size - start, ret);
+    memcpy(data, ((uint8_t*)rb->data) + start, lhalf_len);
+    if (ret > lhalf_len) {
+        size_t rhalf_len = ret - lhalf_len;
+        memcpy(((uint8_t*)data) + lhalf_len, rb->data, rhalf_len);
+    }
+    return ret;
+}
+
+size_t ringbuf_read(ringbuf_t* rb, void* data, size_t len)
+{
+    size_t ret = ringbuf_peek(rb, data, len);
+    ringbuf_skip(rb, ret);
+    return ret;
+}
+
+size_t ringbuf_write(ringbuf_t* rb, const void* data, size_t len)
+{
+    size_t ret = EVAL_MIN(rb->size - rb->consumed, len);
+    size_t lhalf_len = EVAL_MIN(rb->size - rb->start, ret);
+    memcpy(((uint8_t*)rb->data) + rb->start, data, lhalf_len);
+    if (ret > lhalf_len) {
+        size_t rhalf_len = ret - lhalf_len;
+        memcpy(rb->data, ((const uint8_t*)data) + lhalf_len, rhalf_len);
+        rb->start = rhalf_len;
+    } else {
+        rb->start += ret;
+    }
+    rb->consumed += ret;
+    return ret;
+}
+
+bool ringbuf_get(ringbuf_t* rb, void* data, size_t len)
+{
+    if (len <= ringbuf_avail(rb)) {
+        ringbuf_read(rb, data, len);
+        return true;
+    }
+    return false;
+}
+
+bool ringbuf_put(ringbuf_t* rb, const void* data, size_t len)
+{
+    if (len <= ringbuf_space(rb)) {
+        ringbuf_write(rb, data, len);
+        return true;
+    }
+    DO_ONCE(rvvm_info("Overflow in ring %p! (size: %u, consumed: %u, len: %u)",
+              (void*)rb, (uint32_t)rb->size, (uint32_t)rb->consumed, (uint32_t)len));
+    return false;
+}
diff --git a/app/src/main/java/libengine/RVVM/src/ringbuf.h b/app/src/main/java/libengine/RVVM/src/ringbuf.h
new file mode 100644
index 00000000..4ec48e9a
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/ringbuf.h
@@ -0,0 +1,60 @@
+/*
+ringbuf.h - FIFO Ring buffer
+Copyright (C) 2021  cerg2010cerg2010 <github.com/cerg2010cerg2010>
+                    LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef RVVM_RINGBUF_H
+#define RVVM_RINGBUF_H
+
+#include <stddef.h>
+#include <stdint.h>
+#include <stdbool.h>
+
+typedef struct ringbuf {
+    void*  data;
+    size_t size;
+    size_t start;
+    size_t consumed;
+} ringbuf_t;
+
+void ringbuf_create(ringbuf_t* rb, size_t size);
+void ringbuf_destroy(ringbuf_t* rb);
+
+size_t ringbuf_space(ringbuf_t* rb);
+size_t ringbuf_avail(ringbuf_t* rb);
+
+// Serial operation (Returns actual amount of read/written bytes)
+size_t ringbuf_read(ringbuf_t* rb, void* data, size_t len);
+size_t ringbuf_peek(ringbuf_t* rb, void* data, size_t len);
+size_t ringbuf_skip(ringbuf_t* rb, size_t len);
+size_t ringbuf_write(ringbuf_t* rb, const void* data, size_t len);
+
+// Error out instead of partial operation
+bool ringbuf_get(ringbuf_t* rb, void* data, size_t len);
+bool ringbuf_put(ringbuf_t* rb, const void* data, size_t len);
+
+static inline bool ringbuf_put_u8(ringbuf_t* rb, uint8_t x) { return ringbuf_put(rb, &x, sizeof(x)); }
+static inline bool ringbuf_put_u16(ringbuf_t* rb, uint16_t x) { return ringbuf_put(rb, &x, sizeof(x)); }
+static inline bool ringbuf_put_u32(ringbuf_t* rb, uint32_t x) { return ringbuf_put(rb, &x, sizeof(x)); }
+static inline bool ringbuf_put_u64(ringbuf_t* rb, uint64_t x) { return ringbuf_put(rb, &x, sizeof(x)); }
+
+static inline bool ringbuf_get_u8(ringbuf_t* rb, uint8_t* x) { return ringbuf_get(rb, x, sizeof(*x)); }
+static inline bool ringbuf_get_u16(ringbuf_t* rb, uint16_t* x) { return ringbuf_get(rb, x, sizeof(*x)); }
+static inline bool ringbuf_get_u32(ringbuf_t* rb, uint32_t* x) { return ringbuf_get(rb, x, sizeof(*x)); }
+static inline bool ringbuf_get_u64(ringbuf_t* rb, uint64_t* x) { return ringbuf_get(rb, x, sizeof(*x)); }
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/riscv.h b/app/src/main/java/libengine/RVVM/src/riscv.h
new file mode 100644
index 00000000..8fc7e687
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/riscv.h
@@ -0,0 +1,7 @@
+#pragma once
+
+#include <stdint.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <assert.h>
+#include <stdbool.h>
diff --git a/app/src/main/java/libengine/RVVM/src/riscv_cpu.c b/app/src/main/java/libengine/RVVM/src/riscv_cpu.c
new file mode 100644
index 00000000..cb472ae1
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/riscv_cpu.c
@@ -0,0 +1,157 @@
+/*
+riscv_cpu.c - RISC-V CPU Interfaces
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "riscv_cpu.h"
+#include "riscv_hart.h"
+
+void riscv_run_till_event(rvvm_hart_t* vm)
+{
+    #ifdef USE_RV64
+    if (vm->rv64) {
+        riscv64_run_interpreter(vm);
+        return;
+    }
+    #endif
+    riscv32_run_interpreter(vm);
+}
+
+slow_path void riscv_illegal_insn(rvvm_hart_t* vm, const uint32_t insn)
+{
+    riscv_trap(vm, TRAP_ILL_INSTR, insn);
+}
+
+void riscv_jit_flush_cache(rvvm_hart_t* vm)
+{
+#ifdef USE_JIT
+    if (vm->jit_enabled) {
+        riscv_jit_discard(vm);
+        riscv_jit_tlb_flush(vm);
+        rvjit_flush_cache(&vm->jit);
+    }
+#else
+    UNUSED(vm);
+#endif
+}
+
+#ifdef USE_JIT
+
+void riscv_jit_mark_dirty_mem(rvvm_machine_t* machine, rvvm_addr_t addr, size_t size)
+{
+    vector_foreach(machine->harts, i) {
+        rvjit_mark_dirty_mem(&vector_at(machine->harts, i)->jit, addr, size);
+    }
+}
+
+/*
+ * When returning from recompiled blocks, hart state
+ * stays consistent, thus allowing to switch between
+ * interpret-trace-compile and trace-execute states
+ */
+
+static inline void riscv_jit_tlb_put(rvvm_hart_t* vm, virt_addr_t vaddr, rvjit_func_t block)
+{
+    virt_addr_t entry = (vaddr >> 1) & TLB_MASK;
+    vm->jtlb[entry].pc = vaddr;
+    vm->jtlb[entry].block = block;
+}
+
+static bool riscv_jit_lookup(rvvm_hart_t* vm)
+{
+    // Translate virtual PC into physical, JIT operates on phys_pc
+    virt_addr_t virt_pc = vm->registers[REGISTER_PC];
+    phys_addr_t phys_pc = 0;
+    // Lookup in the hashmap, cache virt_pc->block in JTLB
+    if (riscv_virt_translate_e(vm, virt_pc, &phys_pc)) {
+        rvjit_func_t block = rvjit_block_lookup(&vm->jit, phys_pc);
+        if (block) {
+            riscv_jit_tlb_put(vm, virt_pc, block);
+            block(vm);
+            return true;
+        }
+
+        // No valid block compiled for this location,
+        // init a new one and enable JIT compiler
+        rvjit_block_init(&vm->jit);
+        vm->jit.pc_off = 0;
+        vm->jit.virt_pc = virt_pc;
+        vm->jit.phys_pc = phys_pc;
+
+        // Von Neumann icache: Flush JTLB upon hiting a dirty block
+        riscv_jit_tlb_flush(vm);
+
+        vm->jit_compiling = true;
+        vm->block_ends = false;
+    }
+    return false;
+}
+
+#ifndef RVJIT_NATIVE_LINKER
+
+static inline bool riscv_jtlb_lookup(rvvm_hart_t* vm)
+{
+    // Try to find & execute a block
+    virt_addr_t pc = vm->registers[REGISTER_PC];
+    virt_addr_t entry = (pc >> 1) & (TLB_SIZE - 1);
+    virt_addr_t tpc = vm->jtlb[entry].pc;
+    if (likely(pc == tpc)) {
+        vm->jtlb[entry].block(vm);
+        return true;
+    } else {
+        return false;
+    }
+}
+
+#endif
+
+slow_path bool riscv_jit_tlb_lookup(rvvm_hart_t* vm)
+{
+    if (unlikely(!vm->jit_enabled)) return false;
+
+    virt_addr_t pc = vm->registers[REGISTER_PC];
+    virt_addr_t entry = (pc >> 1) & (TLB_SIZE - 1);
+    virt_addr_t tpc = vm->jtlb[entry].pc;
+    if (likely(pc == tpc)) {
+        vm->jtlb[entry].block(vm);
+#ifndef RVJIT_NATIVE_LINKER
+        // Try to execute more blocks if they aren't linked
+        for (size_t i=0; i<10 && riscv_jtlb_lookup(vm); ++i);
+#endif
+        return true;
+    } else {
+        return riscv_jit_lookup(vm);
+    }
+}
+
+slow_path void riscv_jit_finalize(rvvm_hart_t* vm)
+{
+    if (rvjit_block_nonempty(&vm->jit)) {
+        rvjit_func_t block = rvjit_block_finalize(&vm->jit);
+
+        if (block) {
+            riscv_jit_tlb_put(vm, vm->jit.virt_pc, block);
+        } else {
+            // Our cache is full, flush it
+            riscv_jit_tlb_flush(vm);
+            rvjit_flush_cache(&vm->jit);
+        }
+    }
+
+    vm->jit_compiling = false;
+}
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/riscv_cpu.h b/app/src/main/java/libengine/RVVM/src/riscv_cpu.h
new file mode 100644
index 00000000..0e43b6d3
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/riscv_cpu.h
@@ -0,0 +1,81 @@
+/*
+riscv_cpu.h - RISC-V CPU Interfaces
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef RISCV_CPU_H
+#define RISCV_CPU_H
+
+#include "rvvm.h"
+#include "riscv_mmu.h"
+
+// Run the vCPU in current thread
+void riscv_run_till_event(rvvm_hart_t* vm);
+
+// Trap the vCPU on illegal instruction
+slow_path void riscv_illegal_insn(rvvm_hart_t* vm, const uint32_t insn);
+
+// Internal interpreter ISA switching
+void riscv32_run_interpreter(rvvm_hart_t* vm);
+void riscv64_run_interpreter(rvvm_hart_t* vm);
+
+/*
+ * JIT infrastructure
+ */
+
+// Flush the JIT cache (Kinda like instruction cache)
+void riscv_jit_flush_cache(rvvm_hart_t* vm);
+
+// Discard the currently JITed block
+static inline void riscv_jit_discard(rvvm_hart_t* vm)
+{
+#ifdef USE_JIT
+    vm->jit_compiling = false;
+#else
+    UNUSED(vm);
+#endif
+}
+
+// Finish the currently JITed block
+static inline void riscv_jit_compile(rvvm_hart_t* vm)
+{
+#ifdef USE_JIT
+    vm->block_ends = true;
+#else
+    UNUSED(vm);
+#endif
+}
+
+// Mark the physical memory as dirty (Overwritten)
+#ifdef USE_JIT
+void riscv_jit_mark_dirty_mem(rvvm_machine_t* machine, rvvm_addr_t addr, size_t size);
+#else
+static inline void riscv_jit_mark_dirty_mem(rvvm_machine_t* machine, rvvm_addr_t addr, size_t size) {
+    UNUSED(machine);
+    UNUSED(addr);
+    UNUSED(size);
+}
+#endif
+
+/*
+ * Interpreter JIT glue
+ */
+
+slow_path bool riscv_jit_tlb_lookup(rvvm_hart_t* vm);
+
+slow_path void riscv_jit_finalize(rvvm_hart_t* vm);
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/riscv_csr.c b/app/src/main/java/libengine/RVVM/src/riscv_csr.c
new file mode 100644
index 00000000..0be91521
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/riscv_csr.c
@@ -0,0 +1,698 @@
+/*
+riscv_csr.c - RISC-V Control and Status Registers
+Copyright (C) 2021  LekKit <github.com/LekKit>
+                    cerg2010cerg2010 <github.com/cerg2010cerg2010>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "riscv_csr.h"
+#include "riscv_hart.h"
+#include "riscv_mmu.h"
+#include "riscv_cpu.h"
+
+#ifdef USE_FPU
+// For host FPU exception manipulation
+#include "fpu_ops.h"
+#endif
+
+// Get RVVM commit in a mimpid hex form
+static uint32_t rvvm_mimpid(void)
+{
+    const char* version_string = RVVM_VERSION;
+    const char* dash = rvvm_strfind(version_string, "-");
+    if (dash) {
+        uint32_t commit_hex = str_to_uint_base(dash + 1, NULL, 16) << 4;
+        if (rvvm_strfind(version_string, "dirty")) {
+            commit_hex |= 0xD;
+        }
+        return commit_hex;
+    }
+    return 0;
+}
+
+// Make a misa CSR value from ISA string
+static uint64_t riscv_mkmisa(const char* str)
+{
+    uint64_t ret = 0;
+    if (rvvm_strfind(str, "rv64")) {
+        ret |= CSR_MISA_RV64;
+        str += 4;
+    } else if (rvvm_strfind(str, "rv32")) {
+        ret |= CSR_MISA_RV32;
+        str += 4;
+    }
+    while (*str && *str != '_') {
+        if (*str >= 'a' && *str <= 'z') {
+            ret |= (1 << (*str - 'a'));
+        }
+        str++;
+    }
+    return ret;
+}
+
+static inline bool riscv_csr_helper_masked(rvvm_hart_t* vm, maxlen_t* csr, maxlen_t* dest, maxlen_t mask, uint8_t op)
+{
+    maxlen_t tmp = *csr;
+    if (!vm->rv64) {
+        mask &= (uint32_t)-1;
+    }
+    switch (op) {
+        case CSR_SWAP:
+            *csr &= (~mask);
+            *csr |= (*dest & mask);
+            break;
+        case CSR_SETBITS:
+            *csr |= (*dest & mask);
+            break;
+        case CSR_CLEARBITS:
+            *csr &= (~(*dest & mask));
+            break;
+    }
+    *dest = tmp & mask;
+    return true;
+}
+
+static inline bool riscv_csr_helper(rvvm_hart_t* vm, maxlen_t* csr, maxlen_t* dest, uint8_t op)
+{
+    if (vm->rv64) {
+        maxlen_t tmp = *csr;
+        switch (op) {
+            case CSR_SWAP:
+                *csr = *dest;
+                break;
+            case CSR_SETBITS:
+                *csr |= *dest;
+                break;
+            case CSR_CLEARBITS:
+                *csr &= ~(*dest);
+                break;
+        }
+        *dest = tmp;
+        return true;
+    } else {
+        return riscv_csr_helper_masked(vm, csr, dest, -1, op);
+    }
+}
+
+static inline bool riscv_csr_helper_l(rvvm_hart_t* vm, uint64_t* csr, maxlen_t* dest, uint64_t mask, uint8_t op)
+{
+    maxlen_t tmp = *csr;
+    riscv_csr_helper_masked(vm, &tmp, dest, mask, op);
+    if (vm->rv64) {
+        *csr = tmp;
+    } else {
+        *csr = bit_replace(*csr, 0, 32, tmp);
+    }
+    return true;
+}
+
+static inline bool riscv_csr_helper_h(rvvm_hart_t* vm, uint64_t* csr, maxlen_t* dest, uint64_t mask, uint8_t op)
+{
+    if (!vm->rv64) {
+        maxlen_t tmp = (*csr >> 32);
+        riscv_csr_helper_masked(vm, &tmp, dest, mask >> 32, op);
+        *csr = bit_replace(*csr, 32, 32, tmp);
+        return true;
+    }
+    return false;
+}
+
+static inline bool riscv_csr_const(maxlen_t* dest, maxlen_t val)
+{
+    *dest = val;
+    return true;
+}
+
+static inline bool riscv_csr_zero(maxlen_t* dest)
+{
+    return riscv_csr_const(dest, 0);
+}
+
+static inline bool riscv_csr_zero_h(rvvm_hart_t* vm, maxlen_t* dest)
+{
+    if (!vm->rv64) {
+        return riscv_csr_const(dest, 0);
+    }
+    return false;
+}
+
+static inline bool riscv_csr_time(rvvm_hart_t* vm, maxlen_t* dest)
+{
+    if (riscv_csr_timer_enabled(vm)) {
+        return riscv_csr_const(dest, rvtimer_get(&vm->machine->timer));
+    }
+    return false;
+}
+
+static inline bool riscv_csr_timeh(rvvm_hart_t* vm, maxlen_t* dest)
+{
+    if (!vm->rv64 && riscv_csr_timer_enabled(vm)) {
+        return riscv_csr_const(dest, rvtimer_get(&vm->machine->timer) >> 32);
+    }
+    return false;
+}
+
+static inline bool riscv_csr_seed(rvvm_hart_t* vm, maxlen_t* dest)
+{
+    if (riscv_csr_seed_enabled(vm)) {
+        uint16_t seed = 0;
+        rvvm_randombytes(&seed, sizeof(seed));
+        return riscv_csr_const(dest, seed);
+    }
+    return false;
+}
+
+static bool riscv_csr_misa(rvvm_hart_t* vm, maxlen_t* dest, uint8_t op)
+{
+    maxlen_t misa = vm->csr.isa;
+#ifdef USE_FPU
+    misa |= riscv_mkmisa("imafdcbsu");
+#else
+    misa |= riscv_mkmisa("imacbsu");
+#endif
+    riscv_csr_helper(vm, &misa, dest, op);
+
+    if ((vm->csr.isa & CSR_MISA_RV64) && (misa & CSR_MISA_RV32)) {
+        vm->csr.isa = CSR_MISA_RV32;
+        riscv_update_xlen(vm);
+    } else if ((vm->csr.isa & CSR_MISA_RV32) && (misa & (CSR_MISA_RV64 >> 32))) {
+        // Switch to RV64 if machine allows
+        if (vm->machine->rv64) {
+            vm->csr.isa = (maxlen_t)CSR_MISA_RV64;
+            riscv_update_xlen(vm);
+        }
+    }
+    return true;
+}
+
+static inline maxlen_t riscv_csr_sd_bit(rvvm_hart_t* vm)
+{
+    if (vm->rv64) {
+        return (maxlen_t)0x8000000000000000ULL;
+    } else {
+        return 0x80000000U;
+    }
+}
+
+static bool riscv_csr_status(rvvm_hart_t* vm, maxlen_t* dest, uint64_t mask, uint8_t op)
+{
+    maxlen_t status = vm->csr.status;
+    maxlen_t old_status = status;
+
+    riscv_csr_helper_masked(vm, &status, dest, mask, op);
+
+    // Validate status fields
+    if (vm->machine->rv64) {
+        // Validate UXL, SXL if machine is 64-bit
+        uint8_t uxl = bit_cut(status, 32, 2);
+        if (uxl != 1 && uxl != 2) {
+            uxl = 2;
+            status = bit_replace(status, 32, 2, uxl);
+        }
+
+        uint8_t sxl = bit_cut(status, 34, 2);
+        if (sxl != 1 && sxl != 2) {
+            sxl = 2;
+            status = bit_replace(status, 34, 2, sxl);
+        }
+    }
+
+    uint8_t mpp = bit_cut(status, 11, 2);
+    if (mpp == 2) {
+        mpp = 0;
+        status = bit_replace(status, 11, 2, mpp);
+    }
+
+    uint8_t fs = bit_cut(status, 13, 2);
+#ifdef USE_FPU
+#ifndef USE_PRECISE_FS
+    if (fs != FS_OFF && fs != FS_DIRTY) {
+        // FPU was enabled, make it dirty immediately
+        fs = FS_DIRTY;
+        status = bit_replace(status, 13, 2, fs);
+    }
+#endif
+#else
+    if (fs != FS_OFF) {
+        fs = FS_OFF;
+        status = bit_replace(status, 13, 2, fs);
+    }
+#endif
+
+    uint8_t vs = bit_cut(status, 9, 2);
+#ifdef USE_RVV
+    // TODO: Vector extension state handling
+#else
+    if (vs != FS_OFF) {
+        vs = FS_OFF;
+        status = bit_replace(status, 9, 2, vs);
+    }
+#endif
+
+    // Set XS
+    uint8_t xs = EVAL_MAX(fs, vs);
+    status = bit_replace(status, 15, 2, xs);
+
+    vm->csr.status = status;
+
+    if (bit_cut(old_status, 15, 2) == FS_DIRTY) {
+        // XS is dirty, set SD bit
+        *dest |= riscv_csr_sd_bit(vm);
+    }
+
+    if (bit_cut(status, 0, 4) & ~bit_cut(old_status, 0, 4)) {
+        // IRQ enable bits were set, check interrupts
+        riscv_hart_check_interrupts(vm);
+    }
+    return true;
+}
+
+static inline bool riscv_csr_ie(rvvm_hart_t* vm, maxlen_t* dest, maxlen_t mask, uint8_t op)
+{
+    riscv_csr_helper_masked(vm, &vm->csr.ie, dest, mask, op);
+    riscv_hart_check_interrupts(vm);
+    return true;
+}
+
+static inline bool riscv_csr_ip(rvvm_hart_t* vm, maxlen_t* dest, maxlen_t mask, uint8_t op)
+{
+    riscv_csr_helper_masked(vm, &vm->csr.ip, dest, mask, op);
+    *dest |= (riscv_interrupts_raised(vm) & mask);
+    riscv_hart_check_interrupts(vm);
+    return true;
+}
+
+static void riscv_csr_stimecmp_set(rvvm_hart_t* vm, uint64_t stimecmp)
+{
+    rvtimecmp_set(&vm->stimecmp, stimecmp);
+    if (rvtimecmp_pending(&vm->stimecmp)) {
+        riscv_interrupt(vm, INTERRUPT_STIMER);
+    } else {
+        riscv_interrupt_clear(vm, INTERRUPT_STIMER);
+    }
+}
+
+static inline bool riscv_csr_stimecmp(rvvm_hart_t* vm, maxlen_t* dest, uint8_t op)
+{
+    if (riscv_csr_sstc_enabled(vm)) {
+        uint64_t stimecmp = rvtimecmp_get(&vm->stimecmp);
+        riscv_csr_helper_l(vm, &stimecmp, dest, -1ULL, op);
+        riscv_csr_stimecmp_set(vm, stimecmp);
+        return true;
+    }
+    return false;
+}
+
+static inline bool riscv_csr_stimecmph(rvvm_hart_t* vm, maxlen_t* dest, uint8_t op)
+{
+    if (!vm->rv64 && riscv_csr_sstc_enabled(vm)) {
+        uint64_t stimecmp = rvtimecmp_get(&vm->stimecmp);
+        riscv_csr_helper_h(vm, &stimecmp, dest, -1ULL, op);
+        riscv_csr_stimecmp_set(vm, stimecmp);
+        return true;
+    }
+    return false;
+}
+
+static bool riscv_csr_satp(rvvm_hart_t* vm, maxlen_t* dest, uint8_t op)
+{
+    uint8_t prev_mmu = vm->mmu_mode;
+    if (vm->csr.status & CSR_STATUS_TVM) return false; // TVM should trap on acces to satp
+    if (vm->rv64) {
+        maxlen_t satp = (((uint64_t)vm->mmu_mode) << 60) | (vm->root_page_table >> MMU_PAGE_SHIFT);
+        riscv_csr_helper(vm, &satp, dest, op);
+        vm->mmu_mode = bit_cut(satp, 60, 4);
+        if (vm->mmu_mode < CSR_SATP_MODE_SV39
+         || vm->mmu_mode > CSR_SATP_MODE_SV57
+         || (vm->mmu_mode == CSR_SATP_MODE_SV48 && !rvvm_has_arg("sv48"))
+         || (vm->mmu_mode == CSR_SATP_MODE_SV57 && !rvvm_has_arg("sv57"))) {
+            vm->mmu_mode = CSR_SATP_MODE_PHYS;
+        }
+        vm->root_page_table = (satp & bit_mask(44)) << MMU_PAGE_SHIFT;
+    } else {
+        maxlen_t satp = (((maxlen_t)vm->mmu_mode) << 31) | (vm->root_page_table >> MMU_PAGE_SHIFT);
+        riscv_csr_helper(vm, &satp, dest, op);
+        vm->mmu_mode = bit_cut(satp, 31, 1);
+        vm->root_page_table = (satp & bit_mask(22)) << MMU_PAGE_SHIFT;
+    }
+    /*
+    * We currently cache physical addresses in TLB as well, so switching
+    * between bare/virtual modes will pollute the address space with illegal entries
+    * Hence, a TLB flush is required on MMU switch
+    */
+    if (!!vm->mmu_mode != !!prev_mmu) riscv_tlb_flush(vm);
+    return true;
+}
+
+#ifdef USE_FPU
+
+static uint32_t fpu_get_exceptions(void)
+{
+    uint32_t ret = 0;
+    uint32_t exc = fetestexcept(FE_ALL_EXCEPT);
+    if (exc & FE_INEXACT)   ret |= FFLAG_NX;
+    if (exc & FE_UNDERFLOW) ret |= FFLAG_UF;
+    if (exc & FE_OVERFLOW)  ret |= FFLAG_OF;
+    if (exc & FE_DIVBYZERO) ret |= FFLAG_DZ;
+    if (exc & FE_INVALID)   ret |= FFLAG_NV;
+    return ret;
+}
+
+static void fpu_set_rm(uint8_t newrm)
+{
+    switch (newrm) {
+        case RM_RNE:
+            fesetround(FE_TONEAREST);
+            break;
+        case RM_RTZ:
+            fesetround(FE_TOWARDZERO);
+            break;
+        case RM_RDN:
+            fesetround(FE_DOWNWARD);
+            break;
+        case RM_RUP:
+            fesetround(FE_UPWARD);
+            break;
+        case RM_RMM:
+            // TODO: Handle this somehow?
+            fesetround(FE_TONEAREST);
+            break;
+    }
+}
+
+static void riscv_csr_set_fcsr(rvvm_hart_t* vm, maxlen_t fcsr)
+{
+    if (fcsr != vm->csr.fcsr) {
+        if (~bit_cut(fcsr, 0, 5) & fpu_get_exceptions()) {
+            // Clear host-set FPU exceptions, anything needed is left in fcsr
+            feclearexcept(FE_ALL_EXCEPT);
+        }
+        if (bit_cut(fcsr, 5, 3) != bit_cut(vm->csr.fcsr, 5, 3)) {
+            // Set host rounding mode
+            fpu_set_rm(bit_cut(fcsr, 5, 3));
+        }
+        vm->csr.fcsr = fcsr;
+    }
+}
+
+static bool riscv_csr_fflags(rvvm_hart_t* vm, maxlen_t* dest, uint8_t op)
+{
+    if (!fpu_is_enabled(vm)) {
+        return false;
+    }
+    vm->csr.fcsr |= fpu_get_exceptions();
+    maxlen_t fcsr = vm->csr.fcsr;
+    riscv_csr_helper_masked(vm, &fcsr, dest, 0x1F, op);
+    riscv_csr_set_fcsr(vm, fcsr);
+    return true;
+}
+
+static bool riscv_csr_frm(rvvm_hart_t* vm, maxlen_t* dest, uint8_t op)
+{
+    if (!fpu_is_enabled(vm)) {
+        return false;
+    }
+    maxlen_t fcsr = vm->csr.fcsr;
+    maxlen_t frm = fcsr >> 5;
+    riscv_csr_helper_masked(vm, &frm, dest, 0x7, op);
+    fcsr = bit_replace(fcsr, 5, 3, frm);
+    riscv_csr_set_fcsr(vm, fcsr);
+    return true;
+}
+
+static bool riscv_csr_fcsr(rvvm_hart_t* vm, maxlen_t* dest, uint8_t op)
+{
+    if (!fpu_is_enabled(vm)) {
+        return false;
+    }
+    vm->csr.fcsr |= fpu_get_exceptions();
+    maxlen_t fcsr = vm->csr.fcsr;
+    riscv_csr_helper_masked(vm, &fcsr, dest, 0xFF, op);
+    riscv_csr_set_fcsr(vm, fcsr);
+    return true;
+}
+
+#endif
+
+static forceinline bool riscv_csr_op_internal(rvvm_hart_t* vm, uint32_t csr_id, maxlen_t* dest, uint8_t op)
+{
+    switch (csr_id) {
+#ifdef USE_FPU
+        // User Floating-Point CSRs
+        case CSR_FFLAGS:
+            return riscv_csr_fflags(vm, dest, op);
+        case CSR_FRM:
+            return riscv_csr_frm(vm, dest, op);
+        case CSR_FCSR:
+            return riscv_csr_fcsr(vm, dest, op);
+#endif
+
+        // Unprivileged Entropy Source CSR
+        case CSR_SEED:
+            return riscv_csr_seed(vm, dest);
+
+        // User Counters / Timers
+        case CSR_CYCLE:
+            return riscv_csr_zero(dest);
+        case CSR_CYCLEH:
+            return riscv_csr_zero_h(vm, dest);
+        case CSR_TIME:
+            return riscv_csr_time(vm, dest);
+        case CSR_TIMEH:
+            return riscv_csr_timeh(vm, dest);
+        case CSR_INSTRET:
+            return riscv_csr_zero(dest);
+        case CSR_INSTRETH:
+            return riscv_csr_zero_h(vm, dest);
+
+        // Supervisor Trap Setup
+        case CSR_SSTATUS:
+            return riscv_csr_status(vm, dest, CSR_SSTATUS_MASK, op);
+        case CSR_SIE:
+            return riscv_csr_ie(vm, dest, CSR_SEIP_MASK, op);
+        case CSR_STVEC:
+            return riscv_csr_helper(vm, &vm->csr.tvec[PRIVILEGE_SUPERVISOR], dest, op);
+        case CSR_SCOUNTEREN:
+            return riscv_csr_helper_masked(vm, &vm->csr.counteren[PRIVILEGE_SUPERVISOR], dest, CSR_COUNTEREN_MASK, op);
+
+        // Supervisor Configuration
+        case CSR_SENVCFG:
+            return riscv_csr_helper_l(vm, &vm->csr.envcfg[PRIVILEGE_SUPERVISOR], dest, CSR_SENVCFG_MASK, op);
+
+        // Supervisor Trap Handling
+        case CSR_SSCRATCH:
+            return riscv_csr_helper(vm, &vm->csr.scratch[PRIVILEGE_SUPERVISOR], dest, op);
+        case CSR_SEPC:
+            return riscv_csr_helper(vm, &vm->csr.epc[PRIVILEGE_SUPERVISOR], dest, op);
+        case CSR_SCAUSE:
+            return riscv_csr_helper(vm, &vm->csr.cause[PRIVILEGE_SUPERVISOR], dest, op);
+        case CSR_STVAL:
+            return riscv_csr_helper(vm, &vm->csr.tval[PRIVILEGE_SUPERVISOR], dest, op);
+        case CSR_SIP:
+            return riscv_csr_ip(vm, dest, CSR_SEIP_MASK, op);
+        case CSR_STIMECMP:
+            return riscv_csr_stimecmp(vm, dest, op);
+        case CSR_STIMECMPH:
+            return riscv_csr_stimecmph(vm, dest, op);
+
+        // Supervisor Protection and Translation
+        case CSR_SATP:
+            return riscv_csr_satp(vm, dest, op);
+
+        // Machine Information Registers
+        case CSR_MVENDORID:
+            return riscv_csr_zero(dest); // Not a commercial implementation
+        case CSR_MARCHID:
+            return riscv_csr_const(dest, 0x5256564D); // 'RVVM' in hex
+        case CSR_MIMPID:
+            return riscv_csr_const(dest, rvvm_mimpid());
+        case CSR_MHARTID:
+            return riscv_csr_const(dest, vm->csr.hartid);
+
+        // Machine Trap Setup
+        case CSR_MSTATUS:
+            return riscv_csr_status(vm, dest, CSR_MSTATUS_MASK, op);
+        case CSR_MSTATUSH:
+            return riscv_csr_zero(dest); // We don't need upper half on rv32 for now
+        case CSR_MISA:
+            return riscv_csr_misa(vm, dest, op);
+        case CSR_MEDELEG:
+            return riscv_csr_helper_masked(vm, &vm->csr.edeleg[PRIVILEGE_MACHINE], dest, CSR_MEDELEG_MASK, op);
+        case CSR_MIDELEG:
+            return riscv_csr_helper_masked(vm, &vm->csr.ideleg[PRIVILEGE_MACHINE], dest, CSR_MIDELEG_MASK, op);
+        case CSR_MIE:
+            return riscv_csr_ie(vm, dest, CSR_MEIP_MASK, op);
+        case CSR_MTVEC:
+            return riscv_csr_helper(vm, &vm->csr.tvec[PRIVILEGE_MACHINE], dest, op);
+        case CSR_MCOUNTEREN:
+            return riscv_csr_helper_masked(vm, &vm->csr.counteren[PRIVILEGE_MACHINE], dest, CSR_COUNTEREN_MASK, op);
+
+        // Machine Trap Handling
+        case CSR_MSCRATCH:
+            return riscv_csr_helper(vm, &vm->csr.scratch[PRIVILEGE_MACHINE], dest, op);
+        case CSR_MEPC:
+            return riscv_csr_helper(vm, &vm->csr.epc[PRIVILEGE_MACHINE], dest, op);
+        case CSR_MCAUSE:
+            return riscv_csr_helper(vm, &vm->csr.cause[PRIVILEGE_MACHINE], dest, op);
+        case CSR_MTVAL:
+            return riscv_csr_helper(vm, &vm->csr.tval[PRIVILEGE_MACHINE], dest, op);
+        case CSR_MIP:
+            return riscv_csr_ip(vm, dest, CSR_MEIP_MASK, op);
+
+        // Machine Configuration
+        case CSR_MENVCFG:
+            return riscv_csr_helper_l(vm, &vm->csr.envcfg[PRIVILEGE_MACHINE], dest, CSR_MENVCFG_MASK, op);
+        case CSR_MENVCFGH:
+            return riscv_csr_helper_h(vm, &vm->csr.envcfg[PRIVILEGE_MACHINE], dest, CSR_MENVCFG_MASK, op);
+        case CSR_MSECCFG:
+            return riscv_csr_helper_l(vm, &vm->csr.mseccfg, dest, CSR_MSECCFG_MASK, op);
+        case CSR_MSECCFGH:
+            return riscv_csr_helper_h(vm, &vm->csr.mseccfg, dest, CSR_MSECCFG_MASK, op);
+
+        // Machine Memory Protection
+        case 0x3A0: // pmpcfg0
+        case 0x3A1: // pmpcfg1
+        case 0x3A2: // pmpcfg2
+        case 0x3A3: // pmpcfg3
+            return riscv_csr_zero(dest); // TODO: PMP
+        case 0x3B0: // pmpaddr0
+        case 0x3B1: // pmpaddr1
+        case 0x3B2: // pmpaddr2
+        case 0x3B3: // pmpaddr3
+        case 0x3B4: // pmpaddr4
+        case 0x3B5: // pmpaddr5
+        case 0x3B6: // pmpaddr6
+        case 0x3B7: // pmpaddr7
+        case 0x3B8: // pmpaddr8
+        case 0x3B9: // pmpaddr9
+        case 0x3BA: // pmpaddr10
+        case 0x3BB: // pmpaddr11
+        case 0x3BC: // pmpaddr12
+        case 0x3BD: // pmpaddr13
+        case 0x3BE: // pmpaddr14
+        case 0x3BF: // pmpaddr15
+            return riscv_csr_zero(dest); // TODO: PMP
+
+        // Machine Counters/Timers
+        case CSR_MCYCLE:
+        case CSR_MINSTRET:
+        case 0xB03: // mhpmcounter3
+        case 0xB04: // mhpmcounter4
+        case 0xB05: // mhpmcounter5
+        case 0xB06: // mhpmcounter6
+        case 0xB07: // mhpmcounter7
+        case 0xB08: // mhpmcounter8
+        case 0xB09: // mhpmcounter9
+        case 0xB0A: // mhpmcounter10
+        case 0xB0B: // mhpmcounter11
+        case 0xB0C: // mhpmcounter12
+        case 0xB0D: // mhpmcounter13
+        case 0xB0E: // mhpmcounter14
+        case 0xB0F: // mhpmcounter15
+        case 0xB10: // mhpmcounter16
+        case 0xB11: // mhpmcounter17
+        case 0xB12: // mhpmcounter18
+        case 0xB13: // mhpmcounter19
+        case 0xB14: // mhpmcounter20
+        case 0xB15: // mhpmcounter21
+        case 0xB16: // mhpmcounter22
+        case 0xB17: // mhpmcounter23
+        case 0xB18: // mhpmcounter24
+        case 0xB19: // mhpmcounter25
+        case 0xB1A: // mhpmcounter26
+        case 0xB1B: // mhpmcounter27
+        case 0xB1C: // mhpmcounter28
+        case 0xB1D: // mhpmcounter29
+        case 0xB1E: // mhpmcounter30
+        case 0xB1F: // mhpmcounter31
+            return riscv_csr_zero(dest);
+        case CSR_MCYCLEH:
+        case CSR_MINSTRETH:
+        case 0xB83: // mhpmcounter3h
+        case 0xB84: // mhpmcounter4h
+        case 0xB85: // mhpmcounter5h
+        case 0xB86: // mhpmcounter6h
+        case 0xB87: // mhpmcounter7h
+        case 0xB88: // mhpmcounter8h
+        case 0xB89: // mhpmcounter9h
+        case 0xB8A: // mhpmcounter10h
+        case 0xB8B: // mhpmcounter11h
+        case 0xB8C: // mhpmcounter12h
+        case 0xB8D: // mhpmcounter13h
+        case 0xB8E: // mhpmcounter14h
+        case 0xB8F: // mhpmcounter15h
+        case 0xB90: // mhpmcounter16h
+        case 0xB91: // mhpmcounter17h
+        case 0xB92: // mhpmcounter18h
+        case 0xB93: // mhpmcounter19h
+        case 0xB94: // mhpmcounter20h
+        case 0xB95: // mhpmcounter21h
+        case 0xB96: // mhpmcounter22h
+        case 0xB97: // mhpmcounter23h
+        case 0xB98: // mhpmcounter24h
+        case 0xB99: // mhpmcounter25h
+        case 0xB9A: // mhpmcounter26h
+        case 0xB9B: // mhpmcounter27h
+        case 0xB9C: // mhpmcounter28h
+        case 0xB9D: // mhpmcounter29h
+        case 0xB9E: // mhpmcounter30h
+        case 0xB9F: // mhpmcounter31h
+            return riscv_csr_zero_h(vm, dest);
+
+        // Machine Counter Setup
+        case CSR_MCOUNTINHIBIT:
+            return riscv_csr_zero(dest);
+    }
+
+    return false;
+}
+
+bool riscv_csr_op(rvvm_hart_t* vm, uint32_t csr_id, maxlen_t* dest, uint8_t op)
+{
+    if (riscv_csr_readonly(csr_id)) {
+        // This is a readonly CSR, only set/clear zero bits is allowed
+        if (unlikely(op == CSR_SWAP || *dest != 0)) return false;
+    }
+
+    if (unlikely(riscv_csr_privilege(csr_id) > vm->priv_mode)) {
+        // Not privileged enough to access this CSR
+        return false;
+    }
+
+    bool ret = riscv_csr_op_internal(vm, csr_id, dest, op);
+    if (!vm->rv64) {
+        // Sign-extend the result into the register
+        *dest = (int32_t)*dest;
+    }
+    return ret;
+}
+
+void riscv_csr_init(rvvm_hart_t* vm)
+{
+    // Delegate exceptions from M to S
+    vm->csr.edeleg[PRIVILEGE_HYPERVISOR] = 0xFFFFFFFF;
+    vm->csr.ideleg[PRIVILEGE_HYPERVISOR] = 0xFFFFFFFF;
+
+    if (vm->rv64) {
+#ifdef USE_RV64
+        vm->csr.status = 0xA00000000;
+        vm->csr.isa = CSR_MISA_RV64;
+#else
+        rvvm_warn("Requested RV64 in RV32-only build");
+#endif
+    } else {
+        vm->csr.isa = CSR_MISA_RV32;
+    }
+}
diff --git a/app/src/main/java/libengine/RVVM/src/riscv_csr.h b/app/src/main/java/libengine/RVVM/src/riscv_csr.h
new file mode 100644
index 00000000..f8895641
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/riscv_csr.h
@@ -0,0 +1,348 @@
+/*
+riscv_csr.h - RISC-V Control and Status Registers
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef RISCV_CSR_H
+#define RISCV_CSR_H
+
+#include "rvvm.h"
+#include "bit_ops.h"
+
+/*
+ * CSR Listing
+ */
+
+// Unprivileged Floating-Point CSRs
+#define CSR_FFLAGS 0x001
+#define CSR_FRM    0x002
+#define CSR_FCSR   0x003
+
+// Unprivileged Entropy Source CSR
+#define CSR_SEED 0x015
+
+// Unprivileged Counters/Timers
+#define CSR_CYCLE    0xC00
+#define CSR_CYCLEH   0xC80
+#define CSR_TIME     0xC01
+#define CSR_TIMEH    0xC81
+#define CSR_INSTRET  0xC02
+#define CSR_INSTRETH 0xC82
+
+// Supervisor Trap Setup
+#define CSR_SSTATUS    0x100
+#define CSR_SIE        0x104
+#define CSR_STVEC      0x105
+#define CSR_SCOUNTEREN 0x106
+#define CSR_STIMECMP   0x14D
+#define CSR_STIMECMPH  0x15D
+
+// Supervisor Configuration
+#define CSR_SENVCFG 0x10A
+
+// Supervisor Trap Handling
+#define CSR_SSCRATCH 0x140
+#define CSR_SEPC     0x141
+#define CSR_SCAUSE   0x142
+#define CSR_STVAL    0x143
+#define CSR_SIP      0x144
+
+// Supervisor Protection and Translation
+#define CSR_SATP 0x180
+
+// Debug/Trace Registers (Debug extension)
+#define CSR_SCONTEXT 0x5A8
+
+// Hypervisor Trap Setup
+#define CSR_HSTATUS    0x600
+#define CSR_HEDELEG    0x602
+#define CSR_HIDELEG    0x603
+#define CSR_HIE        0x604
+#define CSR_HCOUNTEREN 0x606
+#define CSR_HGEIE      0x607
+#define CSR_HEDELEGH   0x612
+
+// Hypervisor Trap Handling
+#define CSR_HTVAL  0x643
+#define CSR_HIP    0x644
+#define CSR_HVIP   0x645
+#define CSR_HTINST 0x64A
+#define CSR_HGEIP  0xE12
+
+// Hypervisor Configuration
+#define CSR_HENVCFG  0x60A
+#define CSR_HENVCFGH 0x61A
+
+// Debug/Trace Registers (Debug extension)
+#define CSR_HCONTEXT 0x6A8
+
+// Hypervisor Counter/Timer Virtualization Registers
+#define CSR_HTIMEDELTA  0x605
+#define CSR_HTIMEDELTAH 0x615
+
+// Virtual Supervisor Registers (Swapped on HS<->VS)
+#define CSR_VSSTATUS  0x200
+#define CSR_VSIE      0x204
+#define CSR_VSTVEC    0x205
+#define CSR_VSSCRATCH 0x240
+#define CSR_VSEPC     0x241
+#define CSR_VSCAUSE   0x242
+#define CSR_VSTVAL    0x243
+#define CSR_VSIP      0x244
+#define CSR_VSATP     0x280
+
+// Machine Information Registers
+#define CSR_MVENDORID  0xF11
+#define CSR_MARCHID    0xF12
+#define CSR_MIMPID     0xF13
+#define CSR_MHARTID    0xF14
+#define CSR_MCONFIGPTR 0xF15
+
+// Machine Trap Setup
+#define CSR_MSTATUS    0x300
+#define CSR_MSTATUSH   0x310
+#define CSR_MISA       0x301
+#define CSR_MEDELEG    0x302
+#define CSR_MEDELEGH   0x312
+#define CSR_MIDELEG    0x303
+#define CSR_MIE        0x304
+#define CSR_MTVEC      0x305
+#define CSR_MCOUNTEREN 0x306
+
+// Machine Trap Handling
+#define CSR_MSCRATCH 0x340
+#define CSR_MEPC     0x341
+#define CSR_MCAUSE   0x342
+#define CSR_MTVAL    0x343
+#define CSR_MIP      0x344
+#define CSR_MTINST   0x34A // Machine trap instruction (transformed)
+#define CSR_MTVAL2   0x34B // Machine bad guest physical address
+
+// Machine Configuration
+#define CSR_MENVCFG  0x30A
+#define CSR_MENVCFGH 0x31A
+#define CSR_MSECCFG  0x747 // THE BOEING 747???
+#define CSR_MSECCFGH 0x757
+
+// Machine Memory Protection
+// 0x3A0 - 0x3A3 pmpcfg0 - pmpcfg3
+// 0x3B0 - 0x3BF pmpaddr0 - pmpaddr15
+
+// Machine Non-Maskable Interrupt Handling (But no NMIs in RVVM)
+#define CSR_MNSCRATCH 0x740
+#define CSR_MNEPC     0x741
+#define CSR_MNCAUSE   0x742
+#define CSR_MNSTATUS  0x744
+
+// Machine Counters/Timers
+#define CSR_MCYCLE    0xB00
+#define CSR_MCYCLEH   0xB80
+#define CSR_MINSTRET  0xB02
+#define CSR_MINSTRETH 0xB82
+// 0xB03 - 0xB1F mhpmcounter3 - mhpmcounter31
+// 0xB83 - 0xB9F mhpmcounter3h - mhpmcounter31h
+
+// Machine Counter Setup
+#define CSR_MCOUNTINHIBIT 0x320
+// 0x323 - 0x33F mhpmevent3 - mhpmevent31
+
+// Debug/Trace Registers (Shared with Debug Mode)
+#define CSR_TSELECT  0x7A0
+#define CSR_TDATA1   0x7A1
+#define CSR_TDATA2   0x7A2
+#define CSR_TDATA3   0x7A3
+#define CSR_MCONTEXT 0x7A8
+
+// Debug Mode Registers
+#define CSR_DCSR      0x7B0
+#define CSR_DPC       0x7B1
+#define CSR_DSCRATCH0 0x7B2
+#define CSR_DSCRATCH1 0x7B3
+
+/*
+ * CSR Operations
+ */
+
+#define CSR_SWAP       0x1
+#define CSR_SETBITS    0x2
+#define CSR_CLEARBITS  0x3
+
+/*
+ * CSR Values / Bitfields
+ */
+
+#define CSR_STATUS_MPRV (1ULL << 17)
+#define CSR_STATUS_SUM  (1ULL << 18)
+#define CSR_STATUS_MXR  (1ULL << 19)
+#define CSR_STATUS_TVM  (1ULL << 20)
+#define CSR_STATUS_TW   (1ULL << 21)
+#define CSR_STATUS_TSR  (1ULL << 22)
+
+#define CSR_ENVCFG_CBIE  (1ULL << 4)
+#define CSR_ENVCFG_CBCFE (1ULL << 6)
+#define CSR_ENVCFG_CBZE  (1ULL << 7)
+#define CSR_ENVCFG_STCE  (1ULL << 63)
+
+#define CSR_MSECCFG_USEED (1ULL << 8)
+#define CSR_MSECCFG_SSEED (1ULL << 9)
+
+#define CSR_SATP_MODE_PHYS   0
+#define CSR_SATP_MODE_SV32   1
+#define CSR_SATP_MODE_SV39   8
+#define CSR_SATP_MODE_SV48   9
+#define CSR_SATP_MODE_SV57   10
+
+#define CSR_MISA_RV32  0x40000000U
+#define CSR_MISA_RV64  0x8000000000000000ULL
+
+#define CSR_COUNTEREN_TM 0x2U
+
+/*
+ * CSR Masks (For WARL behavior of CSRs)
+ */
+
+#define CSR_MSTATUS_MASK 0xF007FFFAAULL
+#define CSR_SSTATUS_MASK 0x3000DE7A2ULL
+#define CSR_STATUS_FS_MASK 0x6000
+
+#define CSR_MEDELEG_MASK 0xB109
+#define CSR_MIDELEG_MASK 0x0222
+
+#define CSR_MEIP_MASK    0xAAA
+#define CSR_SEIP_MASK    0x222
+
+#define CSR_COUNTEREN_MASK CSR_COUNTEREN_TM
+
+#define CSR_MENVCFG_MASK 0x80000000000000D0ULL
+#define CSR_SENVCFG_MASK 0xD0ULL
+
+#define CSR_MSECCFG_MASK 0x300ULL
+
+/*
+ * FPU control stuff
+ */
+
+#define FS_OFF      0
+#define FS_INITIAL  1
+#define FS_CLEAN    2
+#define FS_DIRTY    3
+
+#define FFLAG_NX (1 << 0) // Inexact
+#define FFLAG_UF (1 << 1) // Undeflow
+#define FFLAG_OF (1 << 2) // Overflow
+#define FFLAG_DZ (1 << 3) // Divide by zero
+#define FFLAG_NV (1 << 4) // Invalid operation
+
+#define RM_RNE 0 // Round to nearest, ties to even
+#define RM_RTZ 1 // Round to zero
+#define RM_RDN 2 // Round down - towards -inf
+#define RM_RUP 3 // Round up - towards +inf
+#define RM_RMM 4 // Round to nearest, ties to max magnitude
+#define RM_DYN 7 // Round to instruction's rm field
+#define RM_INVALID 255 // Invalid rounding mode was specified - should cause a trap
+
+static forceinline bool fpu_is_enabled(rvvm_hart_t* vm)
+{
+    return bit_cut(vm->csr.status, 13, 2) != FS_OFF;
+}
+
+static forceinline void fpu_set_fs(rvvm_hart_t* vm, uint8_t value)
+{
+#ifdef USE_PRECISE_FS
+    vm->csr.status = bit_replace(vm->csr.status, 13, 2, value);
+#else
+    UNUSED(vm);
+    UNUSED(value);
+#endif
+}
+
+/*
+ * CSR interface
+ */
+
+// Get minimal privilege mode to access CSR
+static inline uint8_t riscv_csr_privilege(uint32_t csr_id)
+{
+    return bit_cut(csr_id, 8, 2);
+}
+
+// Check whether writes are illegal for this CSR
+static inline bool riscv_csr_readonly(uint32_t csr_id)
+{
+    return bit_cut(csr_id, 10, 2) == 0x3;
+}
+
+// Perform a CSR operation, set *dest to original CSR value
+// Returns false on failure (To raise exception afterwards)
+bool riscv_csr_op(rvvm_hart_t* vm, uint32_t csr_id, maxlen_t* dest, uint8_t op);
+
+void riscv_csr_init(rvvm_hart_t* vm);
+
+/*
+ * Feature enablement checks
+ */
+
+static inline bool riscv_csr_envcfg_enabled(rvvm_hart_t* vm, uint64_t mask)
+{
+    if (vm->priv_mode < PRIVILEGE_MACHINE) mask &= vm->csr.envcfg[PRIVILEGE_MACHINE];
+    // TODO: henvcfg delegation?
+    if (vm->priv_mode < PRIVILEGE_SUPERVISOR) mask &= vm->csr.envcfg[PRIVILEGE_SUPERVISOR];
+    return !!mask;
+}
+
+static inline bool riscv_csr_counter_enabled(rvvm_hart_t* vm, uint32_t mask)
+{
+    if (vm->priv_mode < PRIVILEGE_MACHINE) mask &= vm->csr.counteren[PRIVILEGE_MACHINE];
+    // TODO: hcounteren delegation?
+    if (vm->priv_mode < PRIVILEGE_SUPERVISOR) mask &= vm->csr.counteren[PRIVILEGE_SUPERVISOR];
+    return !!mask;
+}
+
+static inline bool riscv_csr_timer_enabled(rvvm_hart_t* vm)
+{
+    return riscv_csr_counter_enabled(vm, CSR_COUNTEREN_TM);
+}
+
+static inline bool riscv_csr_seed_enabled(rvvm_hart_t* vm)
+{
+    if (vm->priv_mode == PRIVILEGE_USER) {
+        return !!(vm->csr.mseccfg & CSR_MSECCFG_USEED);
+    } else if (vm->priv_mode < PRIVILEGE_MACHINE) {
+        return !!(vm->csr.mseccfg & CSR_MSECCFG_SSEED);
+    } else return true;
+}
+
+static inline bool riscv_csr_cbi_enabled(rvvm_hart_t* vm)
+{
+    return riscv_csr_envcfg_enabled(vm, CSR_ENVCFG_CBIE);
+}
+
+static inline bool riscv_csr_cbcf_enabled(rvvm_hart_t* vm)
+{
+    return riscv_csr_envcfg_enabled(vm, CSR_ENVCFG_CBCFE);
+}
+
+static inline bool riscv_csr_cbz_enabled(rvvm_hart_t* vm)
+{
+    return riscv_csr_envcfg_enabled(vm, CSR_ENVCFG_CBZE);
+}
+
+static inline bool riscv_csr_sstc_enabled(rvvm_hart_t* vm)
+{
+    return riscv_csr_envcfg_enabled(vm, CSR_ENVCFG_STCE);
+}
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/riscv_hart.c b/app/src/main/java/libengine/RVVM/src/riscv_hart.c
new file mode 100644
index 00000000..f694b08b
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/riscv_hart.c
@@ -0,0 +1,371 @@
+/*
+riscv_hart.c - RISC-V Hardware Thread
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "rvvm_isolation.h"
+#include "riscv_hart.h"
+#include "riscv_mmu.h"
+#include "riscv_csr.h"
+#include "riscv_priv.h"
+#include "riscv_cpu.h"
+#include "threading.h"
+#include "atomics.h"
+#include "bit_ops.h"
+
+// Valid vm->wait_event values
+#define HART_STOPPED 0
+#define HART_RUNNING 1
+
+// Valid vm->pending_events bits deliverable to the hart
+#define HART_EVENT_PAUSE   0x1 // Pause the hart in a consistent state
+#define HART_EVENT_PREEMPT 0x2 // Preempt the hart for vm->preempt_ms
+
+rvvm_hart_t* riscv_hart_init(rvvm_machine_t* machine)
+{
+    rvvm_hart_t* vm = safe_new_obj(rvvm_hart_t);
+    vm->wfi_cond = condvar_create();
+    vm->machine = machine;
+    vm->mem = machine->mem;
+    vm->rv64 = machine->rv64;
+    vm->priv_mode = PRIVILEGE_MACHINE;
+
+    riscv_csr_init(vm);
+
+    rvtimecmp_init(&vm->mtimecmp, &vm->machine->timer);
+    rvtimecmp_init(&vm->stimecmp, &vm->machine->timer);
+
+    riscv_tlb_flush(vm);
+    return vm;
+}
+
+void riscv_hart_prepare(rvvm_hart_t *vm)
+{
+#ifdef USE_JIT
+    if (!vm->jit_enabled && rvvm_get_opt(vm->machine, RVVM_OPT_JIT)) {
+        vm->jit_enabled = rvjit_ctx_init(&vm->jit, rvvm_get_opt(vm->machine, RVVM_OPT_JIT_CACHE));
+
+        if (vm->jit_enabled) {
+            rvjit_set_rv64(&vm->jit, vm->rv64);
+            if (!rvvm_get_opt(vm->machine, RVVM_OPT_JIT_HARVARD)) {
+                rvjit_init_memtracking(&vm->jit, vm->mem.size);
+            }
+        } else {
+            rvvm_set_opt(vm->machine, RVVM_OPT_JIT, false);
+            rvvm_warn("RVJIT failed to initialize, falling back to interpreter");
+        }
+    }
+#else
+    UNUSED(vm);
+#endif
+}
+
+void riscv_hart_free(rvvm_hart_t* vm)
+{
+#ifdef USE_JIT
+    if (vm->jit_enabled) rvjit_ctx_free(&vm->jit);
+#endif
+    condvar_free(vm->wfi_cond);
+    free(vm);
+}
+
+rvvm_addr_t riscv_hart_run_userland(rvvm_hart_t* vm)
+{
+    vm->userland = true;
+    atomic_store_uint32(&vm->wait_event, HART_RUNNING);
+    riscv_run_till_event(vm);
+    if (vm->trap) {
+        vm->registers[REGISTER_PC] = vm->trap_pc;
+        vm->trap = false;
+    }
+    return vm->csr.cause[PRIVILEGE_USER];
+}
+
+void riscv_switch_priv(rvvm_hart_t* vm, uint8_t priv_mode)
+{
+    if (vm->priv_mode != priv_mode) {
+        vm->priv_mode = priv_mode;
+        riscv_update_xlen(vm);
+        riscv_tlb_flush(vm);
+    }
+}
+
+void riscv_update_xlen(rvvm_hart_t* vm)
+{
+#ifdef USE_RV64
+    bool rv64 = false;
+    switch (vm->priv_mode) {
+        case PRIVILEGE_MACHINE:
+            rv64 = !!(vm->csr.isa & CSR_MISA_RV64);
+            break;
+        case PRIVILEGE_HYPERVISOR: // TODO
+        case PRIVILEGE_SUPERVISOR:
+            rv64 = bit_check(vm->csr.status, 35);
+            break;
+        case PRIVILEGE_USER:
+            rv64 = bit_check(vm->csr.status, 33);
+            break;
+    }
+
+    if (vm->rv64 != rv64) {
+        vm->rv64 = rv64;
+#ifdef USE_JIT
+        rvjit_set_rv64(&vm->jit, rv64);
+        riscv_jit_flush_cache(vm);
+#endif
+        riscv_restart_dispatch(vm);
+    }
+#else
+    UNUSED(vm);
+#endif
+}
+
+// Save current priv to xPP, xIE to xPIE, disable interrupts for target priv
+static void riscv_trap_priv_helper(rvvm_hart_t* vm, uint8_t target_priv)
+{
+    switch (target_priv) {
+        case PRIVILEGE_MACHINE:
+            vm->csr.status = bit_replace(vm->csr.status, 11, 2, vm->priv_mode);
+            vm->csr.status = bit_replace(vm->csr.status, 7, 1, bit_cut(vm->csr.status, 3, 1));
+            vm->csr.status = bit_replace(vm->csr.status, 3, 1, 0);
+            break;
+        case PRIVILEGE_HYPERVISOR:
+            vm->csr.status = bit_replace(vm->csr.status, 9, 2, vm->priv_mode);
+            vm->csr.status = bit_replace(vm->csr.status, 6, 1, bit_cut(vm->csr.status, 2, 1));
+            vm->csr.status = bit_replace(vm->csr.status, 2, 1, 0);
+            break;
+        case PRIVILEGE_SUPERVISOR:
+            vm->csr.status = bit_replace(vm->csr.status, 8, 1, vm->priv_mode);
+            vm->csr.status = bit_replace(vm->csr.status, 5, 1, bit_cut(vm->csr.status, 1, 1));
+            vm->csr.status = bit_replace(vm->csr.status, 1, 1, 0);
+            break;
+        case PRIVILEGE_USER:
+            vm->csr.status = bit_replace(vm->csr.status, 4, 1, bit_cut(vm->csr.status, 0, 1));
+            vm->csr.status = bit_replace(vm->csr.status, 0, 1, 0);
+            break;
+    }
+}
+
+void riscv_trap(rvvm_hart_t* vm, bitcnt_t cause, maxlen_t tval)
+{
+    vm->trap = true;
+    if (cause < TRAP_ENVCALL_UMODE || cause > TRAP_ENVCALL_MMODE) {
+        riscv_jit_discard(vm);
+    }
+    if (vm->userland) {
+        // Defer userland trap
+        vm->csr.cause[PRIVILEGE_USER] = cause;
+        vm->csr.tval[PRIVILEGE_USER] = tval;
+        vm->trap_pc = vm->registers[REGISTER_PC];
+    } else {
+        // Target privilege mode
+        uint8_t priv = PRIVILEGE_MACHINE;
+        // Delegate to lower privilege mode if needed
+        while ((priv > vm->priv_mode) && (vm->csr.edeleg[priv] & (1 << cause))) priv--;
+        // Write exception info
+        vm->csr.epc[priv] = vm->registers[REGISTER_PC];
+        vm->csr.cause[priv] = cause;
+        vm->csr.tval[priv] = tval;
+        // Modify exception stack in csr.status
+        riscv_trap_priv_helper(vm, priv);
+        // Jump to trap vector, switch to target priv
+        vm->trap_pc = vm->csr.tvec[priv] & (~3ULL);
+        riscv_switch_priv(vm, priv);
+    }
+    riscv_restart_dispatch(vm);
+}
+
+void riscv_restart_dispatch(rvvm_hart_t* vm)
+{
+    atomic_store_uint32_ex(&vm->wait_event, HART_STOPPED, ATOMIC_RELAXED);
+}
+
+static void riscv_hart_notify(rvvm_hart_t* vm)
+{
+    riscv_restart_dispatch(vm);
+    // Wake from WFI sleep
+    condvar_wake(vm->wfi_cond);
+}
+
+// Set IRQ bit, return true if it wasn't already set
+static inline bool riscv_interrupt_set(rvvm_hart_t* vm, bitcnt_t irq)
+{
+    uint64_t mask = (1ULL << irq);
+    return !!(~atomic_or_uint64_ex(&vm->pending_irqs, mask, ATOMIC_RELAXED) & mask);
+}
+
+void riscv_interrupt(rvvm_hart_t* vm, bitcnt_t irq)
+{
+    if (riscv_interrupt_set(vm, irq)) {
+        riscv_hart_notify(vm);
+    }
+}
+
+void riscv_interrupt_clear(rvvm_hart_t* vm, bitcnt_t irq)
+{
+    // Discard pending irq
+    atomic_and_uint64_ex(&vm->pending_irqs, ~(1U << irq), ATOMIC_RELAXED);
+}
+
+void riscv_hart_check_interrupts(rvvm_hart_t* vm)
+{
+    if (riscv_interrupts_pending(vm)) {
+        riscv_restart_dispatch(vm);
+    }
+}
+
+void riscv_hart_check_timer(rvvm_hart_t* vm)
+{
+    // Raise IRQ and kick hart if it's not sleeping in WFI
+    // WFI precisely checks timers by itself
+    if (!condvar_waiters(vm->wfi_cond)) {
+        uint64_t timer = rvtimer_get(&vm->machine->timer);
+        if (timer >= rvtimecmp_get(&vm->mtimecmp) && riscv_interrupt_set(vm, INTERRUPT_MTIMER)) {
+            riscv_restart_dispatch(vm);
+        }
+        if (timer >= rvtimecmp_get(&vm->stimecmp) && riscv_interrupt_set(vm, INTERRUPT_STIMER)) {
+            riscv_restart_dispatch(vm);
+        }
+    }
+}
+
+void riscv_hart_preempt(rvvm_hart_t* vm, uint32_t preempt_ms)
+{
+    if (preempt_ms) {
+        atomic_store_uint32(&vm->preempt_ms, preempt_ms);
+        atomic_or_uint32(&vm->pending_events, HART_EVENT_PREEMPT);
+        riscv_restart_dispatch(vm);
+    }
+}
+
+static inline maxlen_t riscv_cause_irq_mask(rvvm_hart_t* vm)
+{
+#ifdef USE_RV64
+    if (vm->rv64) {
+        return 0x8000000000000000ULL;
+    } else {
+        return 0x80000000U;
+    }
+#else
+    UNUSED(vm);
+    return 0x80000000U;
+#endif
+}
+
+static void riscv_handle_irqs(rvvm_hart_t* vm)
+{
+    // IRQs that are pending & enabled by mie
+    uint32_t pending_irqs = riscv_interrupts_pending(vm);
+    if (unlikely(pending_irqs)) {
+        // Target privilege mode
+        uint8_t priv = PRIVILEGE_MACHINE;
+        uint32_t irqs = 0;
+        // Delegate pending IRQs from M to the highest possible mode
+        do {
+            irqs = pending_irqs & ~vm->csr.ideleg[priv];
+            pending_irqs &= vm->csr.ideleg[priv];
+            if (irqs) break;
+        } while (--priv);
+        // Skip if target priv < current priv, or equal and IRQs are disabled in status CSR
+        if (vm->priv_mode > priv) return;
+        if (vm->priv_mode == priv && !((1 << vm->priv_mode) & vm->csr.status)) return;
+
+        for (int i=11; i>=0; --i) {
+            if (irqs & (1 << i)) {
+                // Modify exception stack in csr.status
+                riscv_trap_priv_helper(vm, priv);
+                // Discard unfinished JIT block
+                riscv_jit_discard(vm);
+                // Switch privilege
+                riscv_switch_priv(vm, priv);
+                // Write exception info
+                vm->csr.epc[priv] = vm->registers[REGISTER_PC];
+                vm->csr.cause[priv] = i | riscv_cause_irq_mask(vm);
+                vm->csr.tval[priv] = 0;
+                // Jump to trap vector
+                if (vm->csr.tvec[priv] & 1) {
+                    vm->registers[REGISTER_PC] = (vm->csr.tvec[priv] & (~3ULL)) + (i << 2);
+                } else {
+                    vm->registers[REGISTER_PC] = vm->csr.tvec[priv] & (~3ULL);
+                }
+                return;
+            }
+        }
+    }
+    return;
+}
+
+void riscv_hart_run(rvvm_hart_t* vm)
+{
+    rvvm_info("Hart %p started", vm);
+
+    while (true) {
+        // Allow hart to run
+        atomic_store_uint32_ex(&vm->wait_event, HART_RUNNING, ATOMIC_RELAXED);
+
+        // Handle events
+        uint32_t events = atomic_swap_uint32(&vm->pending_events, 0);
+        if (unlikely(events)) {
+            if (events & HART_EVENT_PAUSE) {
+                rvvm_info("Hart %p stopped", vm);
+                return;
+            }
+            if (events & HART_EVENT_PREEMPT) {
+                sleep_ms(atomic_swap_uint32(&vm->preempt_ms, 0));
+            }
+        }
+
+        riscv_handle_irqs(vm);
+
+        // Run the hart
+        riscv_run_till_event(vm);
+        if (vm->trap) {
+            vm->registers[REGISTER_PC] = vm->trap_pc;
+            vm->trap = false;
+        }
+    }
+}
+
+static void* riscv_hart_run_wrap(void* ptr)
+{
+    if (rvvm_getarg_int("noisolation") < 1) {
+        rvvm_restrict_this_thread();
+    }
+    riscv_hart_run((rvvm_hart_t*)ptr);
+    return NULL;
+}
+
+void riscv_hart_spawn(rvvm_hart_t *vm)
+{
+    atomic_store_uint32(&vm->pending_events, 0);
+    vm->thread = thread_create(riscv_hart_run_wrap, (void*)vm);
+}
+
+void riscv_hart_queue_pause(rvvm_hart_t* vm)
+{
+    atomic_or_uint32(&vm->pending_events, HART_EVENT_PAUSE);
+    riscv_hart_notify(vm);
+}
+
+void riscv_hart_pause(rvvm_hart_t* vm)
+{
+    riscv_hart_queue_pause(vm);
+
+    // Clear vm->thread before freeing it
+    thread_ctx_t* thread = vm->thread;
+    vm->thread = NULL;
+    thread_join(thread);
+}
diff --git a/app/src/main/java/libengine/RVVM/src/riscv_hart.h b/app/src/main/java/libengine/RVVM/src/riscv_hart.h
new file mode 100644
index 00000000..5a08f30c
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/riscv_hart.h
@@ -0,0 +1,106 @@
+/*
+riscv_hart.h - RISC-V Hardware Thread
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef RISCV_HART_H
+#define RISCV_HART_H
+
+#include "rvvm.h"
+
+/*
+ * Hart context creation, disposal
+ */
+
+// Create hart context
+rvvm_hart_t* riscv_hart_init(rvvm_machine_t* machine);
+
+// Prepare harts before spawning any of them
+void riscv_hart_prepare(rvvm_hart_t* vm);
+
+// Free hart context
+void riscv_hart_free(rvvm_hart_t* vm);
+
+/*
+ * Hart operations, may be called on any thread
+ */
+
+// Makes vCPU return from riscv_run_till_event() to check for IRQs,
+// or after flushing pages overlapping PC (optimization quirk)
+void riscv_restart_dispatch(rvvm_hart_t* vm);
+
+// Signals interrupt to the hart
+void riscv_interrupt(rvvm_hart_t* vm, bitcnt_t irq);
+
+// Clears interrupt in IP csr of the hart
+void riscv_interrupt_clear(rvvm_hart_t* vm, bitcnt_t irq);
+
+// Hart interrupts that are raised externally
+static inline uint64_t riscv_interrupts_raised(rvvm_hart_t* vm)
+{
+    return atomic_load_uint64_ex(&vm->pending_irqs, ATOMIC_RELAXED);
+}
+
+// Signal the vCPU to check for timer interrupts
+void riscv_hart_check_timer(rvvm_hart_t* vm);
+
+// Preempt the hart vCPU thread from consuming CPU for preempt_ms
+void riscv_hart_preempt(rvvm_hart_t* vm, uint32_t preempt_ms);
+
+/*
+ * Hart operations, may be called ONLY on hart thread
+ */
+
+// Hart interrupts that are pending & enabled by ie CSR
+static inline uint64_t riscv_interrupts_pending(rvvm_hart_t* vm)
+{
+    return (riscv_interrupts_raised(vm) | vm->csr.ip) & vm->csr.ie;
+}
+
+// Check interrupts after writing to ie/ip/status CSRs, or after sret/mret
+void riscv_hart_check_interrupts(rvvm_hart_t* vm);
+
+// Correctly applies side-effects of switching privileges
+void riscv_switch_priv(rvvm_hart_t* vm, uint8_t priv_mode);
+
+// Correctly applies side-effects of switching XLEN
+void riscv_update_xlen(rvvm_hart_t* vm);
+
+// Traps the hart. Should be the last operation before returning to dispatch.
+void riscv_trap(rvvm_hart_t* vm, bitcnt_t cause, maxlen_t tval);
+
+/*
+ * Running the hart
+ */
+
+// Executes the machine hart in a current thread
+// Returns upon receiving EXT_EVENT_PAUSE
+void riscv_hart_run(rvvm_hart_t* vm);
+
+// Execute a userland thread context in current thread
+// Returns trap cause upon any CPU trap
+rvvm_addr_t riscv_hart_run_userland(rvvm_hart_t* vm);
+
+// Spawns hart vCPU thread, returns immediately
+void riscv_hart_spawn(rvvm_hart_t *vm);
+
+// Requests the hart to be paused as soon as possible
+void riscv_hart_queue_pause(rvvm_hart_t* vm);
+
+// Pauses hart in a consistent state, terminates vCPU thread
+void riscv_hart_pause(rvvm_hart_t* vm);
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/riscv_mmu.c b/app/src/main/java/libengine/RVVM/src/riscv_mmu.c
new file mode 100644
index 00000000..1e35e168
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/riscv_mmu.c
@@ -0,0 +1,716 @@
+/*
+riscv_mmu.c - RISC-V Memory Mapping Unit
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "riscv_mmu.h"
+#include "riscv_csr.h"
+#include "riscv_hart.h"
+#include "riscv_cpu.h"
+#include "bit_ops.h"
+#include "atomics.h"
+#include "utils.h"
+#include "vma_ops.h"
+#include <string.h>
+
+#define SV32_VPN_BITS     10
+#define SV32_VPN_MASK     0x3FF
+#define SV32_PHYS_BITS    34
+#define SV32_LEVELS       2
+
+#define SV64_VPN_BITS     9
+#define SV64_VPN_MASK     0x1FF
+#define SV64_PHYS_BITS    56
+#define SV64_PHYS_MASK    bit_mask(SV64_PHYS_BITS)
+#define SV39_LEVELS       3
+#define SV48_LEVELS       4
+#define SV57_LEVELS       5
+
+bool riscv_init_ram(rvvm_ram_t* mem, phys_addr_t begin, phys_addr_t size)
+{
+    // Memory boundaries should be always aligned to page size
+    if ((begin & MMU_PAGE_MASK) || (size & MMU_PAGE_MASK)) {
+        rvvm_error("Memory boundaries misaligned: 0x%08"PRIxXLEN" - 0x%08"PRIxXLEN, begin, begin+size);
+        return false;
+    }
+
+    uint32_t flags = VMA_RDWR;
+    if (!rvvm_has_arg("no_ksm")) flags |= VMA_KSM;
+    if (!rvvm_has_arg("no_thp")) flags |= VMA_THP;
+    mem->data = vma_alloc(NULL, size, flags);
+    if (mem->data) {
+        mem->begin = begin;
+        mem->size = size;
+        return true;
+    }
+    rvvm_error("Memory allocation failure");
+    return false;
+}
+
+void riscv_free_ram(rvvm_ram_t* mem)
+{
+    vma_free(mem->data, mem->size);
+    // Prevent accidental access
+    mem->data = NULL;
+    mem->begin = 0;
+    mem->size = 0;
+}
+
+#ifdef USE_JIT
+void riscv_jit_tlb_flush(rvvm_hart_t* vm)
+{
+    memset(vm->jtlb, 0, sizeof(vm->jtlb));
+    vm->jtlb[0].pc = -1;
+}
+#endif
+
+void riscv_tlb_flush(rvvm_hart_t* vm)
+{
+    // Any lookup to nonzero page fails as VPN is zero
+    memset(vm->tlb, 0, sizeof(vm->tlb));
+    // For zero page, place nonzero VPN
+    vm->tlb[0].r = -1;
+    vm->tlb[0].w = -1;
+    vm->tlb[0].e = -1;
+#ifdef USE_JIT
+    riscv_jit_tlb_flush(vm);
+#endif
+    riscv_restart_dispatch(vm);
+}
+
+void riscv_tlb_flush_page(rvvm_hart_t* vm, virt_addr_t addr)
+{
+    virt_addr_t vpn = (addr >> MMU_PAGE_SHIFT);
+    // VPN is off by 1, thus invalidating the entry
+    vm->tlb[vpn & TLB_MASK].r = vpn - 1;
+    vm->tlb[vpn & TLB_MASK].w = vpn - 1;
+    vm->tlb[vpn & TLB_MASK].e = vpn - 1;
+#ifdef USE_JIT
+    riscv_jit_tlb_flush(vm);
+#endif
+    if (vpn == (vm->registers[REGISTER_PC] >> MMU_PAGE_SHIFT)) {
+        riscv_restart_dispatch(vm);
+    }
+}
+
+static void riscv_tlb_put(rvvm_hart_t* vm, virt_addr_t vaddr, vmptr_t ptr, uint8_t op)
+{
+    virt_addr_t vpn = vaddr >> MMU_PAGE_SHIFT;
+    rvvm_tlb_entry_t* entry = &vm->tlb[vpn & TLB_MASK];
+
+    /*
+    * Add only requested access bits for correct access/dirty flags
+    * implementation. Assume the software does not clear A/D bits without
+    * calling SFENCE.VMA
+    */
+    switch (op) {
+        case MMU_READ:
+            entry->r = vpn;
+            // If same tlb entry contains different VPNs,
+            // they should be invalidated
+            if (entry->w != vpn) entry->w = vpn - 1;
+            if (entry->e != vpn) entry->e = vpn - 1;
+            break;
+        case MMU_WRITE:
+            entry->r = vpn;
+            entry->w = vpn;
+            if (entry->e != vpn) entry->e = vpn - 1;
+            break;
+        case MMU_EXEC:
+            if (entry->r != vpn) entry->r = vpn - 1;
+            //if (entry->w != vpn) entry->w = vpn - 1;
+            entry->w = vpn - 1; // W^X on the TLB to track dirtiness
+            entry->e = vpn;
+            break;
+        default:
+            // (???) lets just complain and flush the entry
+            rvvm_error("Unknown MMU op in riscv_tlb_put");
+            entry->r = vpn - 1;
+            entry->w = vpn - 1;
+            entry->e = vpn - 1;
+            break;
+    }
+
+    entry->ptr = ((size_t)ptr) - TLB_VADDR(vaddr);
+}
+
+// Virtual memory addressing mode (SV32)
+static bool riscv_mmu_translate_sv32(rvvm_hart_t* vm, virt_addr_t vaddr, phys_addr_t* paddr, uint8_t priv, uint8_t access)
+{
+    // Pagetable is always aligned to PAGE_SIZE
+    phys_addr_t pagetable = vm->root_page_table;
+    phys_addr_t pte, pgt_off;
+    vmptr_t pte_addr;
+    bitcnt_t bit_off = SV32_VPN_BITS + MMU_PAGE_SHIFT;
+
+    for (size_t i=0; i<SV32_LEVELS; ++i) {
+        pgt_off = ((vaddr >> bit_off) & SV32_VPN_MASK) << 2;
+        pte_addr = riscv_phys_translate(vm, pagetable + pgt_off);
+        if (pte_addr) {
+            pte = read_uint32_le(pte_addr);
+            if (pte & MMU_VALID_PTE) {
+                if (pte & MMU_LEAF_PTE) {
+                    // PGT entry is a leaf, check permissions
+                    // Check U bit != priv mode, otherwise do extended check
+                    if (!!(pte & MMU_USER_USABLE) == !!priv) {
+                        // If we are supervisor with SUM bit set, rw operations are allowed
+                        // MXR sets access to MMU_READ | MMU_EXEC
+                        if (access == MMU_EXEC ||
+                            priv != PRIVILEGE_SUPERVISOR ||
+                            (vm->csr.status & CSR_STATUS_SUM) == 0)
+                            return false;
+                    }
+                    // Check access bits & translate
+                    if (pte & access) {
+                        virt_addr_t vmask = bit_mask(bit_off);
+                        phys_addr_t pmask = bit_mask(SV32_PHYS_BITS - bit_off) << bit_off;
+                        phys_addr_t pte_flags = pte | MMU_PAGE_ACCESSED | ((access & MMU_WRITE) << 5);
+                        phys_addr_t pte_shift = pte << 2;
+                        // Check that PPN[i-1:0] is 0, otherwise the page is misaligned
+                        if (unlikely(pte_shift & vmask & MMU_PAGE_PNMASK))
+                            return false;
+                        // Atomically update A/D flags
+                        if (pte != pte_flags) atomic_cas_uint32_le(pte_addr, pte, pte_flags);
+                        // Combine ppn & vpn & pgoff
+                        *paddr = (pte_shift & pmask) | (vaddr & vmask);
+                        return true;
+                    }
+                } else if ((pte & MMU_WRITE) == 0) {
+                    // PGT entry is a pointer to next pagetable
+                    pagetable = (pte >> 10) << MMU_PAGE_SHIFT;
+                    bit_off -= SV32_VPN_BITS;
+                    continue;
+                }
+            }
+        }
+        // No valid address translation can be done (invalid PTE or protection fault)
+        return false;
+    }
+    return false;
+}
+
+#ifdef USE_RV64
+
+// Virtual memory addressing mode (RV64 MMU template)
+static bool riscv_mmu_translate_rv64(rvvm_hart_t* vm, virt_addr_t vaddr, phys_addr_t* paddr, uint8_t priv, uint8_t access, uint8_t sv_levels)
+{
+    // Pagetable is always aligned to PAGE_SIZE
+    phys_addr_t pagetable = vm->root_page_table;
+    phys_addr_t pte, pgt_off;
+    vmptr_t pte_addr;
+    bitcnt_t bit_off = (sv_levels * SV64_VPN_BITS) + MMU_PAGE_SHIFT - SV64_VPN_BITS;
+
+    if (unlikely(vaddr != (virt_addr_t)sign_extend(vaddr, bit_off+SV64_VPN_BITS)))
+        return false;
+
+    for (size_t i=0; i<sv_levels; ++i) {
+        pgt_off = ((vaddr >> bit_off) & SV64_VPN_MASK) << 3;
+        pte_addr = riscv_phys_translate(vm, pagetable + pgt_off);
+        if (pte_addr) {
+            pte = read_uint64_le(pte_addr);
+            if (pte & MMU_VALID_PTE) {
+                if (pte & MMU_LEAF_PTE) {
+                    // PGT entry is a leaf, check permissions
+                    // Check U bit != priv mode, otherwise do extended check
+                    if (!!(pte & MMU_USER_USABLE) == !!priv) {
+                        // If we are supervisor with SUM bit set, rw operations are allowed
+                        // MXR sets access to MMU_READ | MMU_EXEC
+                        if (access == MMU_EXEC ||
+                            priv != PRIVILEGE_SUPERVISOR ||
+                            (vm->csr.status & CSR_STATUS_SUM) == 0)
+                            return false;
+                    }
+                    // Check access bits & translate
+                    if (pte & access) {
+                        virt_addr_t vmask = bit_mask(bit_off);
+                        phys_addr_t pmask = bit_mask(SV64_PHYS_BITS - bit_off) << bit_off;
+                        phys_addr_t pte_flags = pte | MMU_PAGE_ACCESSED | ((access & MMU_WRITE) << 5);
+                        phys_addr_t pte_shift = pte << 2;
+                        // Check that PPN[i-1:0] is 0, otherwise the page is misaligned
+                        if (unlikely(pte_shift & vmask & MMU_PAGE_PNMASK))
+                            return false;
+                        // Atomically update A/D flags
+                        if (pte != pte_flags) atomic_cas_uint64_le(pte_addr, pte, pte_flags);
+                        // Combine ppn & vpn & pgoff
+                        *paddr = (pte_shift & pmask) | (vaddr & vmask);
+                        return true;
+                    }
+                } else if ((pte & MMU_WRITE) == 0) {
+                    // PGT entry is a pointer to next pagetable
+                    pagetable = ((pte >> 10) << MMU_PAGE_SHIFT) & SV64_PHYS_MASK;
+                    bit_off -= SV64_VPN_BITS;
+                    continue;
+                }
+            }
+        }
+        // No valid address translation can be done (invalid PTE or protection fault)
+        return false;
+    }
+    return false;
+}
+
+#endif
+
+// Translate virtual address to physical with respect to current CPU mode
+bool riscv_mmu_translate(rvvm_hart_t* vm, virt_addr_t vaddr, phys_addr_t* paddr, uint8_t access)
+{
+    uint8_t priv = vm->priv_mode;
+    // If MPRV is enabled, and we aren't fetching an instruction,
+    // change effective privilege mode to STATUS.MPP
+    if ((vm->csr.status & CSR_STATUS_MPRV) && (access != MMU_EXEC)) {
+        priv = bit_cut(vm->csr.status, 11, 2);
+    }
+    // If MXR is enabled, reads from pages marked as executable-only should succeed
+    if ((vm->csr.status & CSR_STATUS_MXR) && (access == MMU_READ)) {
+        access |= MMU_EXEC;
+    }
+    if (priv <= PRIVILEGE_SUPERVISOR) {
+        switch (vm->mmu_mode) {
+            case CSR_SATP_MODE_PHYS:
+                *paddr = vaddr;
+                return true;
+            case CSR_SATP_MODE_SV32:
+                return riscv_mmu_translate_sv32(vm, vaddr, paddr, priv, access);
+#ifdef USE_RV64
+            case CSR_SATP_MODE_SV39:
+                return riscv_mmu_translate_rv64(vm, vaddr, paddr, priv, access, SV39_LEVELS);
+            case CSR_SATP_MODE_SV48:
+                return riscv_mmu_translate_rv64(vm, vaddr, paddr, priv, access, SV48_LEVELS);
+            case CSR_SATP_MODE_SV57:
+                return riscv_mmu_translate_rv64(vm, vaddr, paddr, priv, access, SV57_LEVELS);
+#endif
+            default:
+                // satp is a WARL field
+                rvvm_error("Unknown MMU mode in riscv_mmu_translate");
+                return false;
+        }
+    } else {
+        *paddr = vaddr;
+        return true;
+    }
+}
+
+static bool riscv_mmio_unaligned_op(rvvm_mmio_dev_t* dev, void* dest, size_t offset, uint8_t size, uint8_t access)
+{
+    uint8_t tmp[16] = {0};
+    size_t align = (size < dev->min_op_size) ? dev->min_op_size :
+                   ((size > dev->max_op_size) ? dev->max_op_size : size);
+    size_t offset_align = offset & ~(size_t)(align - 1);
+    size_t offset_diff = offset - offset_align;
+    size_t offset_dest = 0, size_dest = 0;
+
+    if (align > sizeof(tmp)) {
+        // This should not happen, but a sanity check is always nice
+        rvvm_warn("MMIO realign bounce buffer overflow!");
+        return false;
+    }
+
+    while (size) {
+        // Amount of bytes actually being read/written by this iteration
+        size_dest = (align - offset_diff > size) ? size : (align - offset_diff);
+        if (access != MMU_WRITE || offset_diff != 0 || size_dest != align) {
+            // Either this is a read operation, or an RMW due to misaligned write
+            if (dev->read == NULL || !dev->read(dev, tmp, offset_align, align)) return false;
+        }
+
+        if (access == MMU_WRITE) {
+            // Carry the changed bytes in the RMW operation, write back to the device
+            memcpy(tmp + offset_diff, ((uint8_t*)dest) + offset_dest, size_dest);
+            if (dev->write == NULL || !dev->write(dev, tmp, offset_align, align)) return false;
+        } else {
+            // Copy the read bytes from the aligned buffer
+            memcpy(((uint8_t*)dest) + offset_dest, tmp + offset_diff, size_dest);
+        }
+
+        // Advance the pointers
+        offset_dest += size_dest;
+        offset_align += align;
+        size -= size_dest;
+        // First iteration always takes care of offset diff
+        offset_diff = 0;
+    }
+    return true;
+}
+
+/*
+ * Since aligned loads/stores expect relaxed atomicity, MMU should use this
+ * instead of a regular memcpy, to prevent other harts from observing
+ * half-made memory operation on TLB miss
+ */
+TSAN_SUPPRESS static inline void atomic_memcpy_relaxed(void* dest, const void* src, uint8_t size)
+{
+    if (likely(((((size_t)src) & (size-1)) == 0) && ((((size_t)dest) & (size-1)) == 0))) {
+        switch(size) {
+#ifdef USE_RV64
+            case 8:
+                *(uint64_t*)dest = *(const uint64_t*)src;
+                return;
+#endif
+            case 4:
+                *(uint32_t*)dest = *(const uint32_t*)src;
+                return;
+            case 2:
+                *(uint16_t*)dest = *(const uint16_t*)src;
+                return;
+        }
+    }
+    for (uint8_t i=0; i<size; ++i) {
+        ((uint8_t*)dest)[i] = ((const uint8_t*)src)[i];
+    }
+}
+
+// Receives any operation on physical address space out of RAM region
+static bool riscv_mmio_scan(rvvm_hart_t* vm, virt_addr_t vaddr, phys_addr_t paddr, void* dest, uint8_t size, uint8_t access)
+{
+    //rvvm_info("Scanning MMIO at 0x%08"PRIxXLEN, paddr);
+    vector_foreach(vm->machine->mmio_devs, i) {
+        rvvm_mmio_dev_t* mmio = vector_at(vm->machine->mmio_devs, i);
+        rvvm_mmio_handler_t rwfunc = NULL;
+        if (paddr >= mmio->addr && (paddr + size) <= (mmio->addr + mmio->size)) {
+            // Found the device, access lies in range
+            //rvvm_info("Hart %p accessing MMIO at 0x%08x", vm, paddr);
+            size_t offset = paddr - mmio->addr;
+            if (access == MMU_WRITE) {
+                rwfunc = mmio->write;
+            } else {
+                rwfunc = mmio->read;
+            }
+
+            if (mmio->mapping) {
+                // This is a direct memory region, cache translation in TLB if possible
+                if ((paddr & MMU_PAGE_PNMASK) >= mmio->addr && mmio->size - (offset & MMU_PAGE_PNMASK) >= MMU_PAGE_SIZE) {
+                    riscv_tlb_put(vm, vaddr, ((vmptr_t)mmio->mapping) + offset, access);
+                }
+                if (rwfunc == NULL) {
+                    // Just copy the data over
+                    if (access == MMU_WRITE) {
+                        atomic_memcpy_relaxed(((vmptr_t)mmio->mapping) + offset, dest, size);
+                    } else {
+                        atomic_memcpy_relaxed(dest, ((vmptr_t)mmio->mapping) + offset, size);
+                    }
+                    return true;
+                }
+            } else if (rwfunc == NULL) return false;
+
+            if (unlikely(size > mmio->max_op_size || size < mmio->min_op_size || (offset & (size - 1)))) {
+                // Misaligned or poorly sized operation, attempt fixup
+                //rvvm_info("Hart %p accessing unaligned MMIO at 0x%08"PRIxXLEN, vm, paddr);
+                return riscv_mmio_unaligned_op(mmio, dest, offset, size, access);
+            }
+            return rwfunc(mmio, dest, offset, size);
+        }
+    }
+
+    return false;
+}
+
+static bool riscv_mmu_op(rvvm_hart_t* vm, virt_addr_t addr, void* dest, uint8_t size, uint8_t access)
+{
+    //rvvm_info("Hart %p tlb miss at 0x%08"PRIxXLEN, vm, addr);
+    phys_addr_t paddr;
+    vmptr_t ptr;
+    uint32_t trap_cause;
+
+    // Handle misalign between pages
+    if (!riscv_block_in_page(addr, size)) {
+        // Prevent recursive faults by checking return flag
+        uint8_t part_size = MMU_PAGE_SIZE - (addr & MMU_PAGE_MASK);
+        return riscv_mmu_op(vm, addr, dest, part_size, access) &&
+               riscv_mmu_op(vm, addr + part_size, ((vmptr_t)dest) + part_size, size - part_size, access);
+    }
+
+    if (riscv_mmu_translate(vm, addr, &paddr, access)) {
+        //rvvm_info("Hart %p accessing physmem at 0x%08x", vm, paddr);
+        ptr = riscv_phys_translate(vm, paddr);
+        if (ptr) {
+            // Physical address in main memory, cache address translation
+            riscv_tlb_put(vm, addr, ptr, access);
+            if (access == MMU_WRITE) {
+                // Clear JITted blocks & flush trace cache if necessary
+                riscv_jit_mark_dirty_mem(vm->machine, paddr, size);
+                // Should we make this atomic? RVWMO expects ld/st atomicity
+                //memcpy(ptr, dest, size);
+                atomic_memcpy_relaxed(ptr, dest, size);
+            } else {
+                //memcpy(dest, ptr, size);
+                atomic_memcpy_relaxed(dest, ptr, size);
+            }
+            return true;
+        }
+        // Physical address not in memory region, check MMIO
+        if (riscv_mmio_scan(vm, addr, paddr, dest, size, access)) {
+            return true;
+        }
+        // Ignore writes and read zeroes on invalid memory regions
+        // Experimentally confirmed this actually happens on real hardware (VF2)
+        if (rvvm_get_opt(vm->machine, RVVM_OPT_HW_IMITATE)) {
+            memset(dest, 0, size);
+            return true;
+        }
+        // Physical memory access fault (bad physical address)
+        switch (access) {
+            case MMU_WRITE:
+                trap_cause = TRAP_STORE_FAULT;
+                break;
+            case MMU_READ:
+                trap_cause = TRAP_LOAD_FAULT;
+                break;
+            case MMU_EXEC:
+                trap_cause = TRAP_INSTR_FETCH;
+                break;
+            default:
+                rvvm_error("Unknown MMU op in riscv_mmu_op (phys)");
+                trap_cause = 0;
+                break;
+        }
+    } else {
+        // Pagefault (no translation for address or protection fault)
+        switch (access) {
+            case MMU_WRITE:
+                trap_cause = TRAP_STORE_PAGEFAULT;
+                break;
+            case MMU_READ:
+                trap_cause = TRAP_LOAD_PAGEFAULT;
+                break;
+            case MMU_EXEC:
+                trap_cause = TRAP_INSTR_PAGEFAULT;
+                break;
+            default:
+                rvvm_error("Unknown MMU op in riscv_mmu_op (page)");
+                trap_cause = 0;
+                break;
+        }
+    }
+    // Trap the CPU & instruct the caller to discard operation
+    riscv_trap(vm, trap_cause, addr);
+    return false;
+}
+
+/*
+ * Non-inlined slow memory operations, perform MMU translation,
+ * call MMIO handlers if needed.
+ */
+
+vmptr_t riscv_mmu_vma_translate(rvvm_hart_t* vm, virt_addr_t addr, void* buff, size_t size, uint8_t access)
+{
+    //rvvm_info("Hart %p vma tlb miss at 0x%08"PRIxXLEN, vm, addr);
+    phys_addr_t paddr;
+    vmptr_t ptr;
+    uint32_t trap_cause;
+
+    if (riscv_mmu_translate(vm, addr, &paddr, access)) {
+        ptr = riscv_phys_translate(vm, paddr);
+        if (ptr) {
+            if (access == MMU_WRITE) {
+                // Clear JITted blocks & flush trace cache if necessary
+                riscv_jit_mark_dirty_mem(vm->machine, paddr, 8);
+            }
+            // Physical address in main memory, cache address translation
+            riscv_tlb_put(vm, addr, ptr, access);
+            return ptr;
+        }
+        // Physical address not in memory region, check MMIO
+        if (buff && riscv_mmio_scan(vm, addr, paddr, buff, size, MMU_READ)) {
+            return buff;
+        }
+        // Physical memory access fault (bad physical address)
+        switch (access) {
+            case MMU_WRITE:
+                trap_cause = TRAP_STORE_FAULT;
+                break;
+            case MMU_READ:
+                trap_cause = TRAP_LOAD_FAULT;
+                break;
+            case MMU_EXEC:
+                trap_cause = TRAP_INSTR_FETCH;
+                break;
+            default:
+                rvvm_error("Unknown MMU op in riscv_mmu_op (phys)");
+                trap_cause = 0;
+                break;
+        }
+    } else {
+        // Pagefault (no translation for address or protection fault)
+        switch (access) {
+            case MMU_WRITE:
+                trap_cause = TRAP_STORE_PAGEFAULT;
+                break;
+            case MMU_READ:
+                trap_cause = TRAP_LOAD_PAGEFAULT;
+                break;
+            case MMU_EXEC:
+                trap_cause = TRAP_INSTR_PAGEFAULT;
+                break;
+            default:
+                rvvm_error("Unknown MMU op in riscv_mmu_op (page)");
+                trap_cause = 0;
+                break;
+        }
+    }
+    // Trap the CPU & instruct the caller to discard operation
+    riscv_trap(vm, trap_cause, addr);
+    return NULL;
+}
+
+void riscv_mmu_vma_mmio_write(rvvm_hart_t* vm, virt_addr_t addr, void* buff, size_t size)
+{
+    phys_addr_t paddr = 0;
+    if (riscv_mmu_translate(vm, addr, &paddr, MMU_WRITE)) {
+        riscv_mmio_scan(vm, addr, paddr, buff, size, MMU_WRITE);
+    }
+}
+
+bool riscv_mmu_fetch_inst(rvvm_hart_t* vm, virt_addr_t addr, uint32_t* inst)
+{
+    uint8_t buff[4] = {0};
+    if (!riscv_block_in_page(addr, 4)) {
+        if (!riscv_mmu_op(vm, addr, buff, 2, MMU_EXEC)) return false;
+        if ((buff[0] & 0x3) == 0x3) {
+            // This is a 4-byte instruction scattered between pages
+            // Fetch second part (may trigger a pagefault, that's the point)
+            if (!riscv_mmu_op(vm, addr + 2, buff + 2, 2, MMU_EXEC)) return false;
+        }
+        *inst = read_uint32_le_m(buff);
+        return true;
+    }
+
+    if (riscv_mmu_op(vm, addr, buff, 4, MMU_EXEC)) {
+        *inst = read_uint32_le_m(buff);
+        return true;
+    } else {
+        return false;
+    }
+}
+
+void riscv_mmu_load_u64(rvvm_hart_t* vm, virt_addr_t addr, regid_t reg)
+{
+    uint8_t buff[8];
+    if (riscv_mmu_op(vm, addr, buff, 8, MMU_READ)) {
+        vm->registers[reg] = read_uint64_le_m(buff);
+    }
+}
+
+void riscv_mmu_load_u32(rvvm_hart_t* vm, virt_addr_t addr, regid_t reg)
+{
+    uint8_t buff[4];
+    if (riscv_mmu_op(vm, addr, buff, 4, MMU_READ)) {
+        vm->registers[reg] = read_uint32_le_m(buff);
+    }
+}
+
+void riscv_mmu_load_s32(rvvm_hart_t* vm, virt_addr_t addr, regid_t reg)
+{
+    uint8_t buff[4];
+    if (riscv_mmu_op(vm, addr, buff, 4, MMU_READ)) {
+        vm->registers[reg] = (int32_t)read_uint32_le_m(buff);
+    }
+}
+
+void riscv_mmu_load_u16(rvvm_hart_t* vm, virt_addr_t addr, regid_t reg)
+{
+    uint8_t buff[2];
+    if (riscv_mmu_op(vm, addr, buff, 2, MMU_READ)) {
+        vm->registers[reg] = read_uint16_le_m(buff);
+    }
+}
+
+void riscv_mmu_load_s16(rvvm_hart_t* vm, virt_addr_t addr, regid_t reg)
+{
+    uint8_t buff[2];
+    if (riscv_mmu_op(vm, addr, buff, 2, MMU_READ)) {
+        vm->registers[reg] = (int16_t)read_uint16_le_m(buff);
+    }
+}
+
+void riscv_mmu_load_u8(rvvm_hart_t* vm, virt_addr_t addr, regid_t reg)
+{
+    uint8_t buff[1];
+    if (riscv_mmu_op(vm, addr, buff, 1, MMU_READ)) {
+        vm->registers[reg] = buff[0];
+    }
+}
+
+void riscv_mmu_load_s8(rvvm_hart_t* vm, virt_addr_t addr, regid_t reg)
+{
+    uint8_t buff[1];
+    if (riscv_mmu_op(vm, addr, buff, 1, MMU_READ)) {
+        vm->registers[reg] = (int8_t)buff[0];
+    }
+}
+
+void riscv_mmu_store_u64(rvvm_hart_t* vm, virt_addr_t addr, regid_t reg)
+{
+    uint8_t buff[8];
+    write_uint64_le_m(buff, vm->registers[reg]);
+    riscv_mmu_op(vm, addr, buff, 8, MMU_WRITE);
+}
+
+void riscv_mmu_store_u32(rvvm_hart_t* vm, virt_addr_t addr, regid_t reg)
+{
+    uint8_t buff[4];
+    write_uint32_le_m(buff, vm->registers[reg]);
+    riscv_mmu_op(vm, addr, buff, 4, MMU_WRITE);
+}
+
+void riscv_mmu_store_u16(rvvm_hart_t* vm, virt_addr_t addr, regid_t reg)
+{
+    uint8_t buff[2];
+    write_uint16_le_m(buff, vm->registers[reg]);
+    riscv_mmu_op(vm, addr, buff, 2, MMU_WRITE);
+}
+
+void riscv_mmu_store_u8(rvvm_hart_t* vm, virt_addr_t addr, regid_t reg)
+{
+    uint8_t buff[1];
+    buff[0] = vm->registers[reg];
+    riscv_mmu_op(vm, addr, buff, 1, MMU_WRITE);
+}
+
+#ifdef USE_FPU
+
+void riscv_mmu_load_double(rvvm_hart_t* vm, virt_addr_t addr, regid_t reg)
+{
+    uint8_t buff[8];
+    if (riscv_mmu_op(vm, addr, buff, 8, MMU_READ)) {
+        vm->fpu_registers[reg] = read_double_le_m(buff);
+        fpu_set_fs(vm, FS_DIRTY);
+    }
+}
+
+void riscv_mmu_load_float(rvvm_hart_t* vm, virt_addr_t addr, regid_t reg)
+{
+    uint8_t buff[4];
+    if (riscv_mmu_op(vm, addr, buff, 4, MMU_READ)) {
+        write_float_nanbox(&vm->fpu_registers[reg], read_float_le_m(buff));
+        fpu_set_fs(vm, FS_DIRTY);
+    }
+}
+
+void riscv_mmu_store_double(rvvm_hart_t* vm, virt_addr_t addr, regid_t reg)
+{
+    uint8_t buff[8];
+    write_double_le_m(buff, vm->fpu_registers[reg]);
+    riscv_mmu_op(vm, addr, buff, 8, MMU_WRITE);
+}
+
+void riscv_mmu_store_float(rvvm_hart_t* vm, virt_addr_t addr, regid_t reg)
+{
+    uint8_t buff[4];
+    write_float_le_m(buff, read_float_nanbox(&vm->fpu_registers[reg]));
+    riscv_mmu_op(vm, addr, buff, 4, MMU_WRITE);
+}
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/riscv_mmu.h b/app/src/main/java/libengine/RVVM/src/riscv_mmu.h
new file mode 100644
index 00000000..eb1e64a0
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/riscv_mmu.h
@@ -0,0 +1,372 @@
+/*
+riscv_mmu.h - RISC-V Memory Mapping Unit
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef RISCV_MMU_H
+#define RISCV_MMU_H
+
+#include "rvvm.h"
+#include "compiler.h"
+#include "mem_ops.h"
+#include "riscv_csr.h"
+
+#define MMU_VALID_PTE     0x1
+#define MMU_READ          0x2
+#define MMU_WRITE         0x4
+#define MMU_EXEC          0x8
+#define MMU_LEAF_PTE      0xA
+#define MMU_USER_USABLE   0x10
+#define MMU_GLOBAL_MAP    0x20
+#define MMU_PAGE_ACCESSED 0x40
+#define MMU_PAGE_DIRTY    0x80
+
+#define MMU_PAGE_SHIFT    12
+#define MMU_PAGE_MASK     0xFFF
+#define MMU_PAGE_SIZE     0x1000
+#define MMU_PAGE_PNMASK   (~0xFFFULL)
+
+#define TLB_MASK          (TLB_SIZE-1)
+#define TLB_VADDR(vaddr)  (vaddr)
+//#define TLB_VADDR(vaddr)  ((vaddr) & PAGE_MASK) // we may remove vaddr offset if needed
+
+// Init physical memory (be careful to not overlap MMIO regions!)
+bool riscv_init_ram(rvvm_ram_t* mem, phys_addr_t begin, phys_addr_t size);
+void riscv_free_ram(rvvm_ram_t* mem);
+
+// Flush the TLB (on context switch, SFENCE.VMA, etc)
+void riscv_tlb_flush(rvvm_hart_t* vm);
+void riscv_tlb_flush_page(rvvm_hart_t* vm, virt_addr_t addr);
+
+#ifdef USE_JIT
+void riscv_jit_tlb_flush(rvvm_hart_t* vm);
+#endif
+
+/*
+ * Non-inlined slow memory operations, perform MMU translation,
+ * call MMIO handlers if needed.
+ */
+
+// Translate virtual address to physical with respect to current CPU mode
+bool riscv_mmu_translate(rvvm_hart_t* vm, virt_addr_t vaddr, phys_addr_t* paddr, uint8_t access);
+// Translate virtual address into VM pointer OR buff in case of RMW MMIO operation
+vmptr_t riscv_mmu_vma_translate(rvvm_hart_t* vm, virt_addr_t addr, void* buff, size_t size, uint8_t access);
+// Commit changes back to MMIO
+void riscv_mmu_vma_mmio_write(rvvm_hart_t* vm, virt_addr_t addr, void* buff, size_t size);
+
+// Fetch instruction from virtual address
+bool riscv_mmu_fetch_inst(rvvm_hart_t* vm, virt_addr_t addr, uint32_t* inst);
+
+// Load/store operations on virtual address (uses MMU translation)
+void riscv_mmu_load_u64(rvvm_hart_t* vm, virt_addr_t addr, regid_t reg);
+void riscv_mmu_load_u32(rvvm_hart_t* vm, virt_addr_t addr, regid_t reg);
+void riscv_mmu_load_s32(rvvm_hart_t* vm, virt_addr_t addr, regid_t reg);
+void riscv_mmu_load_u16(rvvm_hart_t* vm, virt_addr_t addr, regid_t reg);
+void riscv_mmu_load_s16(rvvm_hart_t* vm, virt_addr_t addr, regid_t reg);
+void riscv_mmu_load_u8(rvvm_hart_t* vm, virt_addr_t addr, regid_t reg);
+void riscv_mmu_load_s8(rvvm_hart_t* vm, virt_addr_t addr, regid_t reg);
+
+void riscv_mmu_store_u64(rvvm_hart_t* vm, virt_addr_t addr, regid_t reg);
+void riscv_mmu_store_u32(rvvm_hart_t* vm, virt_addr_t addr, regid_t reg);
+void riscv_mmu_store_u16(rvvm_hart_t* vm, virt_addr_t addr, regid_t reg);
+void riscv_mmu_store_u8(rvvm_hart_t* vm, virt_addr_t addr, regid_t reg);
+
+#ifdef USE_FPU
+void riscv_mmu_load_double(rvvm_hart_t* vm, virt_addr_t addr, regid_t reg);
+void riscv_mmu_load_float(rvvm_hart_t* vm, virt_addr_t addr, regid_t reg);
+
+void riscv_mmu_store_double(rvvm_hart_t* vm, virt_addr_t addr, regid_t reg);
+void riscv_mmu_store_float(rvvm_hart_t* vm, virt_addr_t addr, regid_t reg);
+#endif
+
+// Alignment checks / fixup
+
+static inline bool riscv_block_in_page(virt_addr_t addr, size_t size)
+{
+    return (addr & MMU_PAGE_MASK) + size <= MMU_PAGE_SIZE;
+}
+
+static inline bool riscv_block_aligned(virt_addr_t addr, size_t size)
+{
+    return (addr & (size - 1)) == 0;
+}
+
+static inline virt_addr_t riscv_align_addr(virt_addr_t addr, size_t size)
+{
+    return addr & (~(virt_addr_t)(size - 1));
+}
+
+/*
+ * Inlined TLB-cached memory operations (used for performance)
+ * Fall back to MMU functions if:
+ *     Address is not TLB-cached (TLB miss/protection fault)
+ *     Address misalign (optimized on hosts without misalign)
+ *     MMIO is accessed (since MMIO regions aren't memory)
+ */
+
+static forceinline bool riscv_fetch_inst(rvvm_hart_t* vm, virt_addr_t addr, uint32_t* inst)
+{
+    virt_addr_t vpn = addr >> MMU_PAGE_SHIFT;
+    if (likely(vm->tlb[vpn & TLB_MASK].e == vpn)) {
+        *inst = read_uint16_le_m((void*)(size_t)(vm->tlb[vpn & TLB_MASK].ptr + TLB_VADDR(addr)));
+        if ((*inst & 0x3) == 0x3) {
+            // This is a 4-byte instruction, force tlb lookup again
+            vpn = (addr + 2) >> MMU_PAGE_SHIFT;
+            if (likely(vm->tlb[vpn & TLB_MASK].e == vpn)) {
+                *inst |= ((uint32_t)read_uint16_le_m((void*)(size_t)(vm->tlb[vpn & TLB_MASK].ptr + TLB_VADDR(addr + 2)))) << 16;
+                return true;
+            }
+        } else return true;
+    }
+    return riscv_mmu_fetch_inst(vm, addr, inst);
+}
+
+// VM Address translation (translated within single page bounds)
+
+static inline bool riscv_virt_translate_r(rvvm_hart_t* vm, virt_addr_t vaddr, phys_addr_t* paddr)
+{
+    virt_addr_t vpn = vaddr >> MMU_PAGE_SHIFT;
+    if (likely(vm->tlb[vpn & TLB_MASK].r == vpn)) {
+        *paddr = vm->tlb[vpn & TLB_MASK].ptr + TLB_VADDR(vaddr) - (size_t)vm->mem.data + vm->mem.begin;
+        return true;
+    }
+    return riscv_mmu_translate(vm, vaddr, paddr, MMU_READ);
+}
+
+static inline bool riscv_virt_translate_w(rvvm_hart_t* vm, virt_addr_t vaddr, phys_addr_t* paddr)
+{
+    virt_addr_t vpn = vaddr >> MMU_PAGE_SHIFT;
+    if (likely(vm->tlb[vpn & TLB_MASK].w == vpn)) {
+        *paddr = vm->tlb[vpn & TLB_MASK].ptr + TLB_VADDR(vaddr) - (size_t)vm->mem.data + vm->mem.begin;
+        return true;
+    }
+    return riscv_mmu_translate(vm, vaddr, paddr, MMU_WRITE);
+}
+
+static inline bool riscv_virt_translate_e(rvvm_hart_t* vm, virt_addr_t vaddr, phys_addr_t* paddr)
+{
+    virt_addr_t vpn = vaddr >> MMU_PAGE_SHIFT;
+    if (likely(vm->tlb[vpn & TLB_MASK].e == vpn)) {
+        *paddr = vm->tlb[vpn & TLB_MASK].ptr + TLB_VADDR(vaddr) - (size_t)vm->mem.data + vm->mem.begin;
+        return true;
+    }
+    return riscv_mmu_translate(vm, vaddr, paddr, MMU_EXEC);
+}
+
+static inline vmptr_t riscv_vma_translate_r(rvvm_hart_t* vm, virt_addr_t addr, void* buff, size_t size)
+{
+    virt_addr_t vpn = addr >> MMU_PAGE_SHIFT;
+    if (likely(vm->tlb[vpn & TLB_MASK].r == vpn)) {
+        return (vmptr_t)(size_t)(vm->tlb[vpn & TLB_MASK].ptr + TLB_VADDR(addr));
+    }
+    return riscv_mmu_vma_translate(vm, addr, buff, size, MMU_READ);
+}
+
+static inline vmptr_t riscv_vma_translate_w(rvvm_hart_t* vm, virt_addr_t addr, void* buff, size_t size)
+{
+    virt_addr_t vpn = addr >> MMU_PAGE_SHIFT;
+    if (likely(vm->tlb[vpn & TLB_MASK].w == vpn)) {
+        return (vmptr_t)(size_t)(vm->tlb[vpn & TLB_MASK].ptr + TLB_VADDR(addr));
+    }
+    return riscv_mmu_vma_translate(vm, addr, buff, size, MMU_WRITE);
+}
+
+static inline vmptr_t riscv_vma_translate_e(rvvm_hart_t* vm, virt_addr_t addr, void* buff, size_t size)
+{
+    virt_addr_t vpn = addr >> MMU_PAGE_SHIFT;
+    if (likely(vm->tlb[vpn & TLB_MASK].e == vpn)) {
+        return (vmptr_t)(size_t)(vm->tlb[vpn & TLB_MASK].ptr + TLB_VADDR(addr));
+    }
+    return riscv_mmu_vma_translate(vm, addr, buff, size, MMU_EXEC);
+}
+
+#ifdef USE_VMSWAP
+vmptr_t riscv_phys_translate(rvvm_hart_t* vm, phys_addr_t addr)
+#else
+static inline vmptr_t riscv_phys_translate(rvvm_hart_t* vm, phys_addr_t addr)
+{
+    if (likely(addr >= vm->mem.begin && (addr - vm->mem.begin) < vm->mem.size)) {
+        return vm->mem.data + (addr - vm->mem.begin);
+    }
+    return NULL;
+}
+#endif
+
+// Integer load operations
+
+static forceinline void riscv_load_u64(rvvm_hart_t* vm, virt_addr_t addr, regid_t reg)
+{
+    virt_addr_t vpn = addr >> MMU_PAGE_SHIFT;
+    if (likely(vm->tlb[vpn & TLB_MASK].r == vpn && (addr & 7) == 0)) {
+        vm->registers[reg] = read_uint64_le((void*)(size_t)(vm->tlb[vpn & TLB_MASK].ptr + TLB_VADDR(addr)));
+        return;
+    }
+    riscv_mmu_load_u64(vm, addr, reg);
+}
+
+static forceinline void riscv_load_u32(rvvm_hart_t* vm, virt_addr_t addr, regid_t reg)
+{
+    virt_addr_t vpn = addr >> MMU_PAGE_SHIFT;
+    if (likely(vm->tlb[vpn & TLB_MASK].r == vpn && (addr & 3) == 0)) {
+        vm->registers[reg] = read_uint32_le((void*)(size_t)(vm->tlb[vpn & TLB_MASK].ptr + TLB_VADDR(addr)));
+        return;
+    }
+    riscv_mmu_load_u32(vm, addr, reg);
+}
+
+static forceinline void riscv_load_s32(rvvm_hart_t* vm, virt_addr_t addr, regid_t reg)
+{
+    virt_addr_t vpn = addr >> MMU_PAGE_SHIFT;
+    if (likely(vm->tlb[vpn & TLB_MASK].r == vpn && (addr & 3) == 0)) {
+        vm->registers[reg] = (int32_t)read_uint32_le((void*)(size_t)(vm->tlb[vpn & TLB_MASK].ptr + TLB_VADDR(addr)));
+        return;
+    }
+    riscv_mmu_load_s32(vm, addr, reg);
+}
+
+static forceinline void riscv_load_u16(rvvm_hart_t* vm, virt_addr_t addr, regid_t reg)
+{
+    virt_addr_t vpn = addr >> MMU_PAGE_SHIFT;
+    if (likely(vm->tlb[vpn & TLB_MASK].r == vpn && (addr & 1) == 0)) {
+        vm->registers[reg] = read_uint16_le((void*)(size_t)(vm->tlb[vpn & TLB_MASK].ptr + TLB_VADDR(addr)));
+        return;
+    }
+    riscv_mmu_load_u16(vm, addr, reg);
+}
+
+static forceinline void riscv_load_s16(rvvm_hart_t* vm, virt_addr_t addr, regid_t reg)
+{
+    virt_addr_t vpn = addr >> MMU_PAGE_SHIFT;
+    if (likely(vm->tlb[vpn & TLB_MASK].r == vpn && (addr & 1) == 0)) {
+        vm->registers[reg] = (int16_t)read_uint16_le((void*)(size_t)(vm->tlb[vpn & TLB_MASK].ptr + TLB_VADDR(addr)));
+        return;
+    }
+    riscv_mmu_load_s16(vm, addr, reg);
+}
+
+static forceinline void riscv_load_u8(rvvm_hart_t* vm, virt_addr_t addr, regid_t reg)
+{
+    virt_addr_t vpn = addr >> MMU_PAGE_SHIFT;
+    if (likely(vm->tlb[vpn & TLB_MASK].r == vpn)) {
+        vm->registers[reg] = read_uint8((void*)(size_t)(vm->tlb[vpn & TLB_MASK].ptr + TLB_VADDR(addr)));
+        return;
+    }
+    riscv_mmu_load_u8(vm, addr, reg);
+}
+
+static forceinline void riscv_load_s8(rvvm_hart_t* vm, virt_addr_t addr, regid_t reg)
+{
+    virt_addr_t vpn = addr >> MMU_PAGE_SHIFT;
+    if (likely(vm->tlb[vpn & TLB_MASK].r == vpn)) {
+        vm->registers[reg] = (int8_t)read_uint8((void*)(size_t)(vm->tlb[vpn & TLB_MASK].ptr + TLB_VADDR(addr)));
+        return;
+    }
+    riscv_mmu_load_s8(vm, addr, reg);
+}
+
+// Integer store operations
+
+static forceinline void riscv_store_u64(rvvm_hart_t* vm, virt_addr_t addr, regid_t reg)
+{
+    virt_addr_t vpn = addr >> MMU_PAGE_SHIFT;
+    if (likely(vm->tlb[vpn & TLB_MASK].w == vpn && (addr & 7) == 0)) {
+        write_uint64_le((void*)(size_t)(vm->tlb[vpn & TLB_MASK].ptr + TLB_VADDR(addr)), vm->registers[reg]);
+        return;
+    }
+    riscv_mmu_store_u64(vm, addr, reg);
+}
+
+static forceinline void riscv_store_u32(rvvm_hart_t* vm, virt_addr_t addr, regid_t reg)
+{
+    virt_addr_t vpn = addr >> MMU_PAGE_SHIFT;
+    if (likely(vm->tlb[vpn & TLB_MASK].w == vpn && (addr & 3) == 0)) {
+        write_uint32_le((void*)(size_t)(vm->tlb[vpn & TLB_MASK].ptr + TLB_VADDR(addr)), vm->registers[reg]);
+        return;
+    }
+    riscv_mmu_store_u32(vm, addr, reg);
+}
+
+static forceinline void riscv_store_u16(rvvm_hart_t* vm, virt_addr_t addr, regid_t reg)
+{
+    virt_addr_t vpn = addr >> MMU_PAGE_SHIFT;
+    if (likely(vm->tlb[vpn & TLB_MASK].w == vpn && (addr & 1) == 0)) {
+        write_uint16_le((void*)(size_t)(vm->tlb[vpn & TLB_MASK].ptr + TLB_VADDR(addr)), vm->registers[reg]);
+        return;
+    }
+    riscv_mmu_store_u16(vm, addr, reg);
+}
+
+static forceinline void riscv_store_u8(rvvm_hart_t* vm, virt_addr_t addr, regid_t reg)
+{
+    virt_addr_t vpn = addr >> MMU_PAGE_SHIFT;
+    if (likely(vm->tlb[vpn & TLB_MASK].w == vpn)) {
+        write_uint8((void*)(size_t)(vm->tlb[vpn & TLB_MASK].ptr + TLB_VADDR(addr)), vm->registers[reg]);
+        return;
+    }
+    riscv_mmu_store_u8(vm, addr, reg);
+}
+
+#ifdef USE_FPU
+
+// FPU load operations
+
+static forceinline void riscv_load_double(rvvm_hart_t* vm, virt_addr_t addr, regid_t reg)
+{
+    virt_addr_t vpn = addr >> MMU_PAGE_SHIFT;
+    if (likely(vm->tlb[vpn & TLB_MASK].r == vpn && (addr & 7) == 0)) {
+        vm->fpu_registers[reg] = read_double_le((void*)(size_t)(vm->tlb[vpn & TLB_MASK].ptr + TLB_VADDR(addr)));
+        fpu_set_fs(vm, FS_DIRTY);
+        return;
+    }
+    riscv_mmu_load_double(vm, addr, reg);
+}
+
+static forceinline void riscv_load_float(rvvm_hart_t* vm, virt_addr_t addr, regid_t reg)
+{
+    virt_addr_t vpn = addr >> MMU_PAGE_SHIFT;
+    if (likely(vm->tlb[vpn & TLB_MASK].r == vpn && (addr & 3) == 0)) {
+        write_float_nanbox(&vm->fpu_registers[reg], read_float_le((void*)(size_t)(vm->tlb[vpn & TLB_MASK].ptr + TLB_VADDR(addr))));
+        fpu_set_fs(vm, FS_DIRTY);
+        return;
+    }
+    riscv_mmu_load_float(vm, addr, reg);
+}
+
+// FPU store operations
+
+static forceinline void riscv_store_double(rvvm_hart_t* vm, virt_addr_t addr, regid_t reg)
+{
+    virt_addr_t vpn = addr >> MMU_PAGE_SHIFT;
+    if (likely(vm->tlb[vpn & TLB_MASK].w == vpn && (addr & 7) == 0)) {
+        write_double_le((void*)(size_t)(vm->tlb[vpn & TLB_MASK].ptr + TLB_VADDR(addr)), vm->fpu_registers[reg]);
+        return;
+    }
+    riscv_mmu_store_double(vm, addr, reg);
+}
+
+static forceinline void riscv_store_float(rvvm_hart_t* vm, virt_addr_t addr, regid_t reg)
+{
+    virt_addr_t vpn = addr >> MMU_PAGE_SHIFT;
+    if (likely(vm->tlb[vpn & TLB_MASK].w == vpn && (addr & 3) == 0)) {
+        write_float_le((void*)(size_t)(vm->tlb[vpn & TLB_MASK].ptr + TLB_VADDR(addr)), read_float_nanbox(&vm->fpu_registers[reg]));
+        return;
+    }
+    riscv_mmu_store_float(vm, addr, reg);
+}
+
+#endif
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/riscv_priv.c b/app/src/main/java/libengine/RVVM/src/riscv_priv.c
new file mode 100644
index 00000000..42eb7cde
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/riscv_priv.c
@@ -0,0 +1,238 @@
+/*
+riscv_priv.c - RISC-V Privileged
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "riscv_priv.h"
+#include "riscv_csr.h"
+#include "riscv_hart.h"
+#include "riscv_mmu.h"
+#include "riscv_cpu.h"
+#include "bit_ops.h"
+#include "atomics.h"
+
+// Precise instruction values for SYSTEM opcode decoding
+#define RV_PRIV_S_ECALL       0x73
+#define RV_PRIV_S_EBREAK      0x100073
+#define RV_PRIV_S_SRET        0x10200073
+#define RV_PRIV_S_MRET        0x30200073
+#define RV_PRIV_S_WFI         0x10500073
+
+// Privileged FENCE instructions mask and decoding
+#define RV_PRIV_S_FENCE_MASK  0xFE007FFF
+#define RV_PRIV_S_SFENCE_VMA  0x12000073
+
+#define RISCV_INSN_PAUSE 0x100000F // Instruction value for pause hint
+
+slow_path void riscv_emulate_opc_system(rvvm_hart_t* vm, const uint32_t insn)
+{
+    switch (insn) {
+        case RV_PRIV_S_ECALL:
+            riscv_trap(vm, TRAP_ENVCALL_UMODE + vm->priv_mode, 0);
+            return;
+        case RV_PRIV_S_EBREAK:
+            riscv_trap(vm, TRAP_BREAKPOINT, 0);
+            return;
+        case RV_PRIV_S_SRET:
+            // Allow sret only when in S-mode or more privileged, and TSR isn't enabled
+            if (vm->priv_mode >= PRIVILEGE_SUPERVISOR && !(vm->csr.status & CSR_STATUS_TSR)) {
+                uint8_t next_priv = bit_cut(vm->csr.status, 8, 1);
+                // Set SPP to U
+                vm->csr.status = bit_replace(vm->csr.status, 8, 1, PRIVILEGE_USER);
+                // Set SIE to SPIE
+                vm->csr.status = bit_replace(vm->csr.status, 1, 1, bit_cut(vm->csr.status, 5, 1));
+                // Set PC to csr.sepc
+                vm->registers[REGISTER_PC] = vm->csr.epc[PRIVILEGE_SUPERVISOR];
+                // Set privilege mode to SPP
+                riscv_switch_priv(vm, next_priv);
+                // If we aren't unwinded to dispatch decrement PC by instruction size
+                vm->registers[REGISTER_PC] -= 4;
+                riscv_hart_check_interrupts(vm);
+                return;
+            }
+            break;
+        case RV_PRIV_S_MRET:
+            if (vm->priv_mode >= PRIVILEGE_MACHINE) {
+                uint8_t next_priv = bit_cut(vm->csr.status, 11, 2);
+                if (next_priv < PRIVILEGE_MACHINE) {
+                    // Clear MPRV when returning to less privileged mode
+                    vm->csr.status &= ~CSR_STATUS_MPRV;
+                }
+                // Set MPP to U
+                vm->csr.status = bit_replace(vm->csr.status, 11, 2, PRIVILEGE_USER);
+                // Set MIE to MPIE
+                vm->csr.status = bit_replace(vm->csr.status, 3, 1, bit_cut(vm->csr.status, 7, 1));
+                // Set PC to csr.mepc
+                vm->registers[REGISTER_PC] = vm->csr.epc[PRIVILEGE_MACHINE];
+                // Set privilege mode to MPP
+                riscv_switch_priv(vm, next_priv);
+                // If we aren't unwinded to dispatch decrement PC by instruction size
+                vm->registers[REGISTER_PC] -= 4;
+                riscv_hart_check_interrupts(vm);
+                return;
+            }
+            break;
+        case RV_PRIV_S_WFI:
+            // Resume execution for locally enabled interrupts pending at any privilege level
+            if (!riscv_interrupts_pending(vm)) {
+                while (atomic_load_uint32(&vm->wait_event)) {
+                    // Stall the hart until an interrupt might need servicing
+                    uint64_t delay = CONDVAR_INFINITE;
+                    if (vm->csr.ie & (1U << INTERRUPT_MTIMER)) {
+                        delay = rvtimecmp_delay_ns(&vm->mtimecmp);
+                    }
+                    if (vm->csr.ie & (1U << INTERRUPT_STIMER)) {
+                        delay = EVAL_MIN(delay, rvtimecmp_delay_ns(&vm->stimecmp));
+                    }
+                    condvar_wait_ns(vm->wfi_cond, delay);
+
+                    // Check timer expiration
+                    riscv_hart_check_timer(vm);
+                }
+            }
+            return;
+    }
+
+    const regid_t rds = bit_cut(insn, 7, 5);
+    const uint32_t funct3 = bit_cut(insn, 12, 3);
+    const regid_t rs1 = bit_cut(insn, 15, 5);
+    const uint32_t csr = insn >> 20;
+
+    switch (funct3) {
+        case 0x0:
+            switch (insn & RV_PRIV_S_FENCE_MASK) {
+                case RV_PRIV_S_SFENCE_VMA:
+                    // Allow sfence.vma only when in S-mode or more privileged, and TVM isn't enabled
+                    if (vm->priv_mode >= PRIVILEGE_SUPERVISOR && !(vm->csr.status & CSR_STATUS_TVM)) {
+                        if (rs1) {
+                            riscv_tlb_flush_page(vm, vm->registers[rs1]);
+                        } else {
+                            riscv_tlb_flush(vm);
+                        }
+                        return;
+                    }
+                    break;
+            }
+            break;
+        case 0x1: { // csrrw
+            maxlen_t val = vm->registers[rs1];
+            if (riscv_csr_op(vm, csr, &val, CSR_SWAP)) {
+                vm->registers[rds] = val;
+                return;
+            }
+            break;
+        }
+        case 0x2: { // csrrs
+            maxlen_t val = vm->registers[rs1];
+            if (riscv_csr_op(vm, csr, &val, CSR_SETBITS)) {
+                vm->registers[rds] = val;
+                return;
+            }
+            break;
+        }
+        case 0x3: { // csrrc
+            maxlen_t val = vm->registers[rs1];
+            if (riscv_csr_op(vm, csr, &val, CSR_CLEARBITS)) {
+                vm->registers[rds] = val;
+                return;
+            }
+            break;
+        }
+        case 0x5: { // csrrwi
+            maxlen_t val = bit_cut(insn, 15, 5);
+            if (riscv_csr_op(vm, csr, &val, CSR_SWAP)) {
+                vm->registers[rds] = val;
+                return;
+            }
+            break;
+        }
+        case 0x6: { // csrrsi
+            maxlen_t val = bit_cut(insn, 15, 5);
+            if (riscv_csr_op(vm, csr, &val, CSR_SETBITS)) {
+                vm->registers[rds] = val;
+                return;
+            }
+            break;
+        }
+        case 0x7: { // csrrci
+            maxlen_t val = bit_cut(insn, 15, 5);
+            if (riscv_csr_op(vm, csr, &val, CSR_CLEARBITS)) {
+                vm->registers[rds] = val;
+                return;
+            }
+            break;
+        }
+    }
+
+    riscv_illegal_insn(vm, insn);
+}
+
+slow_path void riscv_emulate_opc_misc_mem(rvvm_hart_t* vm, const uint32_t insn)
+{
+    const uint32_t funct3 = bit_cut(insn, 12, 3);
+    switch (funct3) {
+        case 0x0:
+            if (insn == RISCV_INSN_PAUSE) {
+                // pause hint, yield the vCPU thread
+                sleep_ms(0);
+            } else {
+                // fence
+                atomic_fence();
+            }
+            return;
+        case 0x1: // fence.i
+#ifdef USE_JIT
+            if (rvvm_get_opt(vm->machine, RVVM_OPT_JIT_HARVARD)) {
+                riscv_jit_flush_cache(vm);
+            } else {
+                // This eliminates possible dangling dirty blocks in JTLB
+                riscv_jit_tlb_flush(vm);
+            }
+#endif
+            return;
+        case 0x2:
+            if (likely(!bit_cut(insn, 7, 5))) {
+                switch (insn >> 20) {
+                    case 0x0: // cbo.inval
+                        if (riscv_csr_cbi_enabled(vm)) {
+                            // Simply use a fence, all emulated devices are coherent
+                            atomic_fence();
+                            return;
+                        }
+                        break;
+                    case 0x1: // cbo.clean
+                    case 0x2: // cbo.flush
+                        if (riscv_csr_cbcf_enabled(vm)) {
+                            // Simply use a fence, all emulated devices are coherent
+                            atomic_fence();
+                            return;
+                        }
+                        break;
+                    case 0x4: // cbo.zero
+                        if (riscv_csr_cbz_enabled(vm)) {
+                            const regid_t rs1 = bit_cut(insn, 15, 5);
+                            const virt_addr_t addr = vm->registers[rs1] & ~63ULL;
+                            void* ptr = riscv_vma_translate_w(vm, addr, NULL, 64);
+                            if (ptr) memset(ptr, 0, 64);
+                            return;
+                        }
+                        break;
+                }
+            }
+            break;
+    }
+    riscv_illegal_insn(vm, insn);
+}
diff --git a/app/src/main/java/libengine/RVVM/src/riscv_priv.h b/app/src/main/java/libengine/RVVM/src/riscv_priv.h
new file mode 100644
index 00000000..721fd5ec
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/riscv_priv.h
@@ -0,0 +1,27 @@
+/*
+riscv_priv.h - RISC-V Privileged
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef RISCV_PRIV_H
+#define RISCV_PRIV_H
+
+#include "rvvm.h"
+
+slow_path void riscv_emulate_opc_system(rvvm_hart_t* vm, const uint32_t insn);
+slow_path void riscv_emulate_opc_misc_mem(rvvm_hart_t* vm, const uint32_t insn);
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/rvjit/rvjit.c b/app/src/main/java/libengine/RVVM/src/rvjit/rvjit.c
new file mode 100644
index 00000000..660d32a2
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/rvjit/rvjit.c
@@ -0,0 +1,297 @@
+/*
+rvjit.c - Retargetable Versatile JIT Compiler
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "rvjit.h"
+#include "rvjit_emit.h"
+#include "../utils.h"
+#include "../vector.h"
+#include "../atomics.h"
+#include "../bit_ops.h"
+#include "../vma_ops.h"
+
+#if defined(_WIN32) && !defined(RVJIT_X86) && !defined(GNU_EXTS)
+#include <windows.h>
+#endif
+
+#if defined(__APPLE__) && __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ >= 110000
+void sys_icache_invalidate(void* start, size_t len);
+#include <pthread.h>
+#define RVJIT_APPLE_SILICON
+#endif
+
+#if defined(RVJIT_RISCV) && defined(__linux__)
+/*
+ * Clang doesn't seem to implement __builtin___clear_cache properly
+ * on RISC-V, wreaking havok on hosts with non-coherent icache
+ * (RVVM is also affected, heh), hence we make a direct syscall
+ */
+#include <sys/syscall.h>
+#include <unistd.h>
+#ifndef __NR_riscv_flush_icache
+#define __NR_riscv_flush_icache 259
+#endif
+#endif
+
+static void rvjit_flush_icache(const void* addr, size_t size)
+{
+#ifdef RVJIT_X86
+    // x86 has coherent instruction caches
+    UNUSED(addr);
+    UNUSED(size);
+#elif defined(RVJIT_APPLE_SILICON)
+    sys_icache_invalidate((void*)addr, size);
+#elif defined(RVJIT_RISCV) && defined(__linux__)
+    syscall(__NR_riscv_flush_icache, addr, ((char*)addr) + size, 0);
+#elif GCC_CHECK_VER(4, 7) || CLANG_CHECK_VER(3, 5)
+    // Use __builtin___clear_cache on modern toolchains
+    __builtin___clear_cache((char*)addr, ((char*)addr) + size);
+#elif defined(GNU_EXTS)
+    __clear_cache((char*)addr, ((char*)addr) + size);
+#elif defined(_WIN32)
+    FlushInstructionCache(GetCurrentProcess(), addr, size);
+#else
+    #error No rvjit_flush_icache() support!
+#endif
+}
+
+bool rvjit_ctx_init(rvjit_block_t* block, size_t size)
+{
+    // Assume it's already inited
+    if (block->heap.data) return true;
+
+    if (rvvm_has_arg("rvjit_disable_rwx")) {
+        rvvm_info("RWX disabled, allocating W^X multi-mmap RVJIT heap");
+    } else {
+        block->heap.data = vma_alloc(NULL, size, VMA_RWX);
+        block->heap.code = block->heap.data;
+
+        // Possible on Linux PaX (hardened) or OpenBSD
+        if (block->heap.data == NULL) {
+            rvvm_info("Failed to allocate RWX RVJIT heap, falling back to W^X multi-mmap");
+        }
+    }
+
+    if (block->heap.data == NULL) {
+        void* rw = NULL;
+        void* exec = NULL;
+        if (!vma_multi_mmap(&rw, &exec, size)) {
+            rvvm_warn("Failed to allocate W^X RVJIT heap!");
+            return false;
+        }
+        block->heap.data = rw;
+        block->heap.code = exec;
+    }
+
+    rvjit_flush_icache(block->heap.code, block->heap.size);
+
+    block->space = 1024;
+    block->code = safe_malloc(block->space);
+
+    block->heap.size = size;
+    block->heap.curr = 0;
+
+    block->rv64 = false;
+
+    hashmap_init(&block->heap.blocks, 64);
+    hashmap_init(&block->heap.block_links, 64);
+    vector_init(block->links);
+    return true;
+}
+
+void rvjit_init_memtracking(rvjit_block_t* block, size_t size)
+{
+    // Each dirty page is marked in atomic bitmask
+    free(block->heap.dirty_pages);
+    free(block->heap.jited_pages);
+    block->heap.dirty_mask = bit_next_pow2((size + 0x1FFFF) >> 17) - 1;
+    block->heap.dirty_pages = safe_new_arr(uint32_t, block->heap.dirty_mask + 1);
+    block->heap.jited_pages = safe_new_arr(uint32_t, block->heap.dirty_mask + 1);
+}
+
+static void rvjit_linker_cleanup(rvjit_block_t* block)
+{
+    vector_t(void*)* linked_blocks;
+    hashmap_foreach(&block->heap.block_links, k, v) {
+        UNUSED(k);
+        linked_blocks = (void*)v;
+        vector_free(*linked_blocks);
+        free(linked_blocks);
+    }
+    hashmap_clear(&block->heap.block_links);
+}
+
+void rvjit_ctx_free(rvjit_block_t* block)
+{
+    vma_free(block->heap.data, block->heap.size);
+    if (block->heap.code != block->heap.data) {
+        vma_free((void*)block->heap.code, block->heap.size);
+    }
+    rvjit_linker_cleanup(block);
+    hashmap_destroy(&block->heap.blocks);
+    hashmap_destroy(&block->heap.block_links);
+    vector_free(block->links);
+    free(block->code);
+    free(block->heap.dirty_pages);
+    free(block->heap.jited_pages);
+}
+
+static inline void rvjit_mark_jited_page(rvjit_block_t* block, phys_addr_t addr)
+{
+    if (block->heap.jited_pages == NULL) return;
+    size_t offset = (addr >> 17) & block->heap.dirty_mask;
+    uint32_t mask = 1U << ((addr >> 12) & 0x1F);
+    atomic_or_uint32_ex(block->heap.jited_pages + offset, mask, ATOMIC_RELAXED);
+}
+
+static inline void rvjit_mark_dirty_page(rvjit_block_t* block, phys_addr_t addr)
+{
+    size_t offset = (addr >> 17) & block->heap.dirty_mask;
+    uint32_t mask = 1U << ((addr >> 12) & 0x1F);
+    if (atomic_load_uint32_ex(block->heap.jited_pages + offset, ATOMIC_RELAXED) & mask) {
+        atomic_or_uint32_ex(block->heap.dirty_pages + offset, mask, ATOMIC_RELAXED);
+        atomic_and_uint32_ex(block->heap.jited_pages + offset, ~mask, ATOMIC_RELAXED);
+    }
+}
+
+void rvjit_mark_dirty_mem(rvjit_block_t* block, phys_addr_t addr, size_t size)
+{
+    if (block->heap.dirty_pages == NULL) return;
+    for (size_t i=0; i<size; i += 4096) {
+        rvjit_mark_dirty_page(block, addr + i);
+    }
+}
+
+static inline bool rvjit_page_needs_flush(rvjit_block_t* block, phys_addr_t addr)
+{
+    size_t offset = (addr >> 17) & block->heap.dirty_mask;
+    uint32_t mask = 1U << ((addr >> 12) & 0x1F);
+    if (block->heap.dirty_pages == NULL) return false;
+    return (atomic_load_uint32_ex(block->heap.dirty_pages + offset, ATOMIC_RELAXED) & mask)
+        && (atomic_and_uint32(block->heap.dirty_pages + offset, ~mask) & mask);
+}
+
+void rvjit_block_init(rvjit_block_t* block)
+{
+    block->size = 0;
+    block->linkage = LINKAGE_JMP;
+    vector_clear(block->links);
+    rvjit_emit_init(block);
+}
+
+rvjit_func_t rvjit_block_finalize(rvjit_block_t* block)
+{
+    void* dest = block->heap.data + block->heap.curr;
+    const void* code = block->heap.code + block->heap.curr;
+
+    rvjit_emit_end(block, block->linkage);
+
+    if (block->heap.curr + block->size > block->heap.size) {
+        // The cache is full
+        return NULL;
+    }
+
+#ifdef RVJIT_APPLE_SILICON
+    pthread_jit_write_protect_np(false);
+#endif
+
+    memcpy(dest, block->code, block->size);
+    rvjit_flush_icache(code, block->size);
+    //block->heap.curr = (block->heap.curr + block->size + 31) & ~31ULL;
+    block->heap.curr += block->size;
+
+    hashmap_put(&block->heap.blocks, block->phys_pc, (size_t)code);
+
+#ifdef RVJIT_NATIVE_LINKER
+    vector_t(uint8_t*)* linked_blocks;
+    phys_addr_t k;
+    size_t v;
+    vector_foreach(block->links, i) {
+        k = vector_at(block->links, i).dest;
+        v = vector_at(block->links, i).ptr;
+        linked_blocks = (void*)hashmap_get(&block->heap.block_links, k);
+        if (!linked_blocks) {
+            linked_blocks = safe_calloc(1, sizeof(vector_t(uint8_t*)));
+            vector_init(*linked_blocks);
+            hashmap_put(&block->heap.block_links, k, (size_t)linked_blocks);
+        }
+        vector_push_back(*linked_blocks, (uint8_t*)v);
+    }
+
+    linked_blocks = (void*)hashmap_get(&block->heap.block_links, block->phys_pc);
+    if (linked_blocks) {
+        vector_foreach(*linked_blocks, i) {
+            uint8_t* jptr = vector_at(*linked_blocks, i);
+            rvjit_linker_patch_jmp(jptr, ((size_t)dest) - ((size_t)jptr));
+        }
+        vector_free(*linked_blocks);
+        free(linked_blocks);
+        hashmap_remove(&block->heap.block_links, block->phys_pc);
+    }
+#endif
+
+#ifdef RVJIT_APPLE_SILICON
+    pthread_jit_write_protect_np(true);
+#endif
+
+    rvjit_mark_jited_page(block, block->phys_pc);
+
+    return (rvjit_func_t)code;
+}
+
+rvjit_func_t rvjit_block_lookup(rvjit_block_t* block, phys_addr_t phys_pc)
+{
+    if (unlikely(rvjit_page_needs_flush(block, phys_pc))) {
+        vector_t(uint8_t*)* linked_blocks;
+        phys_pc &= ~0xFFFULL;
+
+        for (size_t i=0; i<4096; ++i) {
+            hashmap_remove(&block->heap.blocks, phys_pc + i);
+            linked_blocks = (void*)hashmap_get(&block->heap.block_links, phys_pc + i);
+            if (linked_blocks) {
+                vector_free(*linked_blocks);
+                free(linked_blocks);
+                hashmap_remove(&block->heap.block_links, phys_pc + i);
+            }
+        }
+        return NULL;
+    }
+    return (rvjit_func_t)hashmap_get(&block->heap.blocks, phys_pc);
+}
+
+void rvjit_flush_cache(rvjit_block_t* block)
+{
+    if (block->heap.curr > 0x10000) {
+        // Deallocate the physical memory used for RWX JIT cache
+        // This reduces average memory usage since the cache is never full
+        vma_clean(block->heap.data, block->heap.size, true);
+    }
+    rvjit_flush_icache(block->heap.code, block->heap.curr);
+
+    hashmap_clear(&block->heap.blocks);
+    block->heap.curr = 0;
+
+    rvjit_linker_cleanup(block);
+
+    if (block->heap.dirty_pages) {
+        for (size_t i=0; i<=block->heap.dirty_mask; ++i) {
+            atomic_store_uint32_ex(block->heap.dirty_pages + i, 0, ATOMIC_RELAXED);
+        }
+    }
+
+    rvjit_block_init(block);
+}
diff --git a/app/src/main/java/libengine/RVVM/src/rvjit/rvjit.h b/app/src/main/java/libengine/RVVM/src/rvjit/rvjit.h
new file mode 100644
index 00000000..31f726dd
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/rvjit/rvjit.h
@@ -0,0 +1,245 @@
+/*
+rvjit.h - Retargetable Versatile JIT Compiler
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef RVJIT_H
+#define RVJIT_H
+
+#include "../rvvm_types.h"
+#include "../hashmap.h"
+#include "../vector.h"
+
+// RISC-V register allocator details
+#define RVJIT_REGISTERS 32
+#define RVJIT_REGISTER_ZERO 0
+
+#if defined(__x86_64__) || defined(_M_AMD64)
+    #ifdef _WIN32
+        #ifdef __MINGW64__
+            #define RVJIT_CALL __attribute__((sysv_abi))
+            #define RVJIT_ABI_SYSV 1
+        #else
+            #define RVJIT_ABI_WIN64 1
+        #endif
+    #else
+        #if GNU_ATTRIBUTE(sysv_abi)
+            #define RVJIT_CALL __attribute__((sysv_abi))
+        #endif
+        #define RVJIT_ABI_SYSV 1
+    #endif
+    #define RVJIT_NATIVE_64BIT 1
+    #define RVJIT_NATIVE_LINKER 1
+    #define RVJIT_X86 1
+#elif defined(__i386__) || defined(_M_IX86)
+    #ifdef _WIN32
+        #ifdef __MINGW32__
+            #define RVJIT_CALL __attribute__((fastcall))
+        #else
+            #define RVJIT_CALL __fastcall
+        #endif
+    #else
+        #define RVJIT_CALL __attribute__((fastcall))
+    #endif
+    #define RVJIT_ABI_FASTCALL 1
+    #define RVJIT_NATIVE_LINKER 1
+    #define RVJIT_X86 1
+#elif defined(__riscv)
+    #if __riscv_xlen == 64
+        #define RVJIT_NATIVE_64BIT 1
+    #elif __riscv_xlen != 32
+        #error No JIT support for RV128!
+    #endif
+    #define RVJIT_ABI_SYSV 1
+    #define RVJIT_NATIVE_LINKER 1
+    #define RVJIT_RISCV 1
+#elif defined(__aarch64__) || defined(_M_ARM64)
+    #define RVJIT_NATIVE_64BIT 1
+    #define RVJIT_ABI_SYSV 1
+    //#define RVJIT_NATIVE_LINKER 1
+    #define RVJIT_ARM64 1
+#elif defined(__arm__) || defined(_M_ARM)
+    #define RVJIT_ABI_SYSV 1
+    #define RVJIT_ARM 1
+#else
+    #error No JIT support for the target platform!!!
+#endif
+
+// No specific calling convention requirements
+#ifndef RVJIT_CALL
+#define RVJIT_CALL
+#endif
+
+typedef void (* RVJIT_CALL rvjit_func_t)(void* vm);
+typedef size_t   branch_t;
+typedef uint8_t  regflags_t;
+typedef uint32_t regmask_t;
+
+#define BRANCH_NEW ((branch_t)-1)
+#define BRANCH_ENTRY  false
+#define BRANCH_TARGET true
+
+#define LINKAGE_NONE 0
+#define LINKAGE_TAIL 1
+#define LINKAGE_JMP  2
+
+#define REG_ILL 0xFF // Register is not allocated
+
+typedef struct {
+    uint8_t* data;
+    const uint8_t* code;
+    size_t curr;
+    size_t size;
+    hashmap_t blocks;
+    hashmap_t block_links;
+
+    // Dirty memory tracking
+    uint32_t* jited_pages;
+    uint32_t* dirty_pages;
+    size_t    dirty_mask;
+} rvjit_heap_t;
+
+typedef struct {
+    uint32_t last_used; // Last usage of register for LRU reclaim
+    int32_t auipc_off;
+    regid_t hreg;       // Claimed host register, REG_ILL if not mapped
+    regflags_t flags;   // Register allocation details
+} rvjit_reginfo_t;
+
+typedef struct {
+    rvjit_heap_t heap;
+
+    uint8_t* code;
+    size_t size;
+    size_t space;
+
+    // Block exit paths
+    vector_t(struct {phys_addr_t dest; size_t ptr;}) links;
+
+    regmask_t hreg_mask;       // Bitmask of available non-clobbered host registers
+    regmask_t abireclaim_mask; // Bitmask of reclaimed abi-clobbered host registers to restore
+    rvjit_reginfo_t regs[RVJIT_REGISTERS];
+
+#ifdef RVJIT_NATIVE_FPU
+    regmask_t fpu_reg_mask;
+    rvjit_reginfo_t fpu_regs[RVJIT_REGISTERS];
+#endif
+
+    virt_addr_t virt_pc;
+    phys_addr_t phys_pc;
+    int32_t pc_off;
+
+    bool rv64;
+    bool native_ptrs;
+    uint8_t linkage;
+} rvjit_block_t;
+
+// Creates JIT context, sets upper limit on cache size
+bool rvjit_ctx_init(rvjit_block_t* block, size_t heap_size);
+
+// Frees the JIT context and block cache
+// All functions generated by this context are invalid after freeing it!
+void rvjit_ctx_free(rvjit_block_t* block);
+
+// Set guest bitness
+static inline void rvjit_set_rv64(rvjit_block_t* block, bool rv64)
+{
+#ifdef RVJIT_NATIVE_64BIT
+    block->rv64 = rv64;
+#else
+    UNUSED(rv64);
+    block->rv64 = false;
+#endif
+}
+
+static inline void rvjit_set_native_ptrs(rvjit_block_t* block, bool native_ptrs)
+{
+    block->native_ptrs = native_ptrs;
+}
+
+// Creates a new block, prepares codegen
+void rvjit_block_init(rvjit_block_t* block);
+
+// Returns true if the block has some instructions emitted
+static inline bool rvjit_block_nonempty(rvjit_block_t* block)
+{
+    return block->size != 0;
+}
+
+// Returns NULL when cache is full, otherwise returns a valid function pointer
+// Inserts block into the lookup cache by phys_pc key
+rvjit_func_t rvjit_block_finalize(rvjit_block_t* block);
+
+// Looks up for compiled block by phys_pc, returns NULL when no block was found
+rvjit_func_t rvjit_block_lookup(rvjit_block_t* block, phys_addr_t phys_pc);
+
+// Track dirty memory to transparently invalidate JIT caches
+void rvjit_init_memtracking(rvjit_block_t* block, size_t size);
+void rvjit_mark_dirty_mem(rvjit_block_t* block, phys_addr_t addr, size_t size);
+
+// Cleans up internal heap & lookup cache entirely
+void rvjit_flush_cache(rvjit_block_t* block);
+
+/*
+ * Internal codegen APIs
+ */
+
+// Register bitmask
+static inline regmask_t rvjit_hreg_mask(regid_t hreg)
+{
+    return (1ULL << hreg);
+}
+
+// Emit RVJIT prologue, set up codegen state
+void rvjit_emit_init(rvjit_block_t* block);
+
+// Emit RVJIT epilogue
+void rvjit_emit_end(rvjit_block_t* block, uint8_t linkage);
+
+// Emit instruction bytes into the block
+static inline void rvjit_put_code(rvjit_block_t* block, const void* inst, size_t size)
+{
+    if (unlikely(block->space < block->size + size)) {
+        block->space += 1024;
+        block->code = safe_realloc(block->code, block->space);
+    }
+    memcpy(block->code + block->size, inst, size);
+    block->size += size;
+}
+
+// Claims any free hardware register, or reclaims mapped register preserving it's value in VM
+regid_t rvjit_claim_hreg(rvjit_block_t* block);
+
+// Frees explicitly claimed hardware register
+static inline void rvjit_free_hreg(rvjit_block_t* block, regid_t hreg)
+{
+    block->hreg_mask |= rvjit_hreg_mask(hreg);
+}
+
+#ifdef RVJIT_NATIVE_FPU
+
+// Claims any free hardware register, or reclaims mapped register preserving it's value in VM
+regid_t rvjit_claim_fpu_reg(rvjit_block_t* block);
+
+// Frees explicitly claimed hardware register
+static inline void rvjit_free_fpu_reg(rvjit_block_t* block, regid_t hreg)
+{
+    block->fpu_reg_mask |= rvjit_hreg_mask(hreg);
+}
+
+#endif
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/rvjit/rvjit_arm.h b/app/src/main/java/libengine/RVVM/src/rvjit/rvjit_arm.h
new file mode 100644
index 00000000..5fc8bd8f
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/rvjit/rvjit_arm.h
@@ -0,0 +1,953 @@
+/*
+rvjit_arm.h - RVJIT ARM Backend
+Copyright (C) 2022  cerg2010cerg2010 <github.com/cerg2010cerg2010>
+                    LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "rvjit.h"
+#include "../mem_ops.h"
+#include "../bit_ops.h"
+
+#if defined(__linux__)
+#include <sys/auxv.h>
+#else
+#warning No RVJIT ARM CPU flags detection for target OS
+#endif
+
+#ifndef RVJIT_ARM_H
+#define RVJIT_ARM_H
+
+#define rvjit_a32_assert(expr) \
+do { \
+    if (unlikely(!(expr))) rvvm_fatal("Assertion (" #expr ") failed at " SOURCE_LINE); \
+} while (0)
+
+static int32_t rvjit_a32_soft_idiv(int32_t a, int32_t b)
+{
+    return a / b;
+}
+
+extern uint32_t rvjit_a32_soft_uidiv(uint32_t a, uint32_t b)
+{
+    return a / b;
+}
+
+#define RVJIT_ARM_IDIVA (1 << 17)
+
+static uint32_t rvjit_a32_hwcaps = 0;
+
+static inline void rvjit_a32_test_cpu()
+{
+#ifdef __linux__
+    rvjit_a32_hwcaps = getauxval(AT_HWCAP);
+#endif
+    if (rvjit_a32_hwcaps & RVJIT_ARM_IDIVA) {
+        rvvm_info("RVJIT detected ARM IDIV/UDIV extension");
+    }
+}
+
+static bool rvjit_a32_check_div()
+{
+    DO_ONCE(rvjit_a32_test_cpu());
+    return !!(rvjit_a32_hwcaps & RVJIT_ARM_IDIVA);
+}
+
+static inline bool check_imm_bits(int32_t val, bitcnt_t bits)
+{
+    return sign_extend(val, bits) == val;
+}
+
+#ifdef RVJIT_ABI_SYSV
+#define VM_PTR_REG 0 // Argument/scratch reg 1
+#endif
+
+static inline size_t rvjit_native_default_hregmask(void)
+{
+    return rvjit_hreg_mask(1)  /* argument/result/scratch reg 2 */
+         | rvjit_hreg_mask(2)  /* argument/scratch reg 3 */
+         | rvjit_hreg_mask(3); /* argument/scratch reg 4 */
+}
+
+static inline size_t rvjit_native_abireclaim_hregmask(void)
+{
+    return rvjit_hreg_mask(4)   /* variable reg 1 */
+         | rvjit_hreg_mask(5)   /* variable reg 2 */
+         | rvjit_hreg_mask(6)   /* variable reg 3 */
+         | rvjit_hreg_mask(7)   /* variable reg 4 */
+         | rvjit_hreg_mask(8)   /* variable reg 5 */
+         | rvjit_hreg_mask(9)   /* platform/variable reg 6 */
+         | rvjit_hreg_mask(10)  /* variable reg 7 */
+         | rvjit_hreg_mask(11); /* frame pointer/variable reg 8 */
+}
+
+enum a32_regs
+{
+    A32_FP = 11, /* frame pointer */
+    A32_IP = 12, /* intra-procedure call scratch register */
+    A32_SP = 13, /* stack pointer */
+    A32_LR = 14, /* link register (return address) */
+    A32_PC = 15, /* program counter */
+    /* use numbers for others! */
+};
+
+enum a32_cc
+{
+    A32_EQ, A32_NE,
+    A32_CS, A32_CC,
+    A32_MI, A32_PL,
+    A32_VS, A32_VC,
+    A32_HI, A32_LS,
+    A32_GE, A32_LT,
+    A32_GT, A32_LE,
+    A32_AL, A32_UNCOND
+};
+typedef uint32_t a32_cc_t;
+
+enum a32_shtype
+{
+    A32_LSL = 0,
+    A32_LSR = 1,
+    A32_ASR = 2,
+    A32_ROR = 3,
+};
+typedef uint32_t a32_shtype_t;
+
+enum a32_dp_opcs
+{
+    A32_AND  = (0  << 21) | (0 << 20),
+    A32_ANDS = (0  << 21) | (1 << 20),
+    A32_EOR  = (1  << 21) | (0 << 20),
+    A32_EORS = (1  << 21) | (1 << 20),
+    A32_SUB  = (2  << 21) | (0 << 20),
+    A32_SUBS = (2  << 21) | (1 << 20),
+    A32_RSB  = (3  << 21) | (0 << 20),
+    A32_RSBS = (3  << 21) | (1 << 20),
+    A32_ADD  = (4  << 21) | (0 << 20),
+    A32_ADDS = (4  << 21) | (1 << 20),
+    A32_ADC  = (5  << 21) | (0 << 20),
+    A32_ADCS = (5  << 21) | (1 << 20),
+    A32_SBC  = (6  << 21) | (0 << 20),
+    A32_SBCS = (6  << 21) | (1 << 20),
+    A32_RSC  = (7  << 21) | (0 << 20),
+    A32_RSCS = (7  << 21) | (1 << 20),
+    A32_TST  = (8  << 21) | (1 << 20),
+    A32_BX   = (9  << 21) | (0 << 20),
+    A32_TEQ  = (9  << 21) | (1 << 20),
+    A32_CMP  = (10 << 21) | (1 << 20),
+    A32_CMN  = (11 << 21) | (1 << 20),
+    A32_ORR  = (12 << 21) | (0 << 20),
+    A32_ORRS = (12 << 21) | (1 << 20),
+    A32_MOV  = (13 << 21) | (0 << 20),
+    A32_MOVS = (13 << 21) | (1 << 20),
+    A32_BIC  = (14 << 21) | (0 << 20),
+    A32_BICS = (14 << 21) | (1 << 20),
+    A32_MVN  = (15 << 21) | (0 << 20),
+    A32_MVNS = (15 << 21) | (1 << 20),
+};
+typedef uint32_t a32_dp_opcs_t;
+
+enum a32_ma_opcs
+{
+    A32_MUL  =   (0 << 21) | (0 << 20),
+    A32_MULS =   (0 << 21) | (1 << 20),
+    // NOTE: MLA/MLAS use rdlo as ra and rdhi as rds
+    A32_MLA  =   (1 << 21) | (0 << 20),
+    A32_MLAS =   (1 << 21) | (1 << 20),
+    // NOTE: UMAAL use rdhi and rdlo for accumulate accumulate
+    A32_UMAAL =  (2 << 21) | (0 << 20),
+    // NOTE: MLS use rdlo as ra and rdhi as rds
+    A32_MLS =    (3 << 21) | (0 << 20),
+    A32_UMULL =  (4 << 21) | (0 << 20),
+    A32_UMULLS = (4 << 21) | (1 << 20),
+    // NOTE: UMLAL/UMLALS use rdhi:rdlo for accumulate
+    A32_UMLAL =  (5 << 21) | (0 << 20),
+    A32_UMLALS = (5 << 21) | (1 << 20),
+    A32_SMULL =  (6 << 21) | (0 << 20),
+    A32_SMULLS = (6 << 21) | (1 << 20),
+    // NOTE: SMLAL/SMLALS use rdhi:rdlo for accumulate
+    A32_SMLAL =  (7 << 21) | (0 << 20),
+    A32_SMLALS = (7 << 21) | (0 << 20),
+};
+typedef uint32_t a32_ma_opcs_t;
+
+enum a32_md_opcs
+{
+    A32_SDIV = (0x71 << 20),
+    A32_UDIV = (0x73 << 20),
+};
+typedef uint32_t a32_md_opcs_t;
+
+static inline void rvjit_a32_insn32(rvjit_block_t* block, uint32_t insn)
+{
+    uint8_t code[sizeof(insn)];
+    write_uint32_le_m(code, insn);
+    rvjit_put_code(block, code, sizeof(code));
+}
+
+static inline bool rvjit_a32_encode_imm(uint32_t imm, uint8_t* pimm, uint8_t* prot)
+{
+    uint8_t rotation = 0;
+
+    // No rotation required
+    if ((imm & 0xff) == imm) {
+        *pimm = imm;
+        *prot = 0;
+        return true;
+    }
+
+    // If the value is split between top and the bottom part of the register, rotate it out
+    if ((imm & 0xFFFF) && (imm & 0xFFFF0000)) {
+        imm = bit_rotr32(imm, 8);
+        rotation = 8;
+    }
+
+    uint8_t ctz = bit_ctz32(imm);
+    rotation += ctz;
+    rotation &= 31;
+    imm = bit_rotr32(imm, ctz);
+
+    // Rotation must be an even number, lower amount preferred
+    if (rotation & 1) {
+        --rotation;
+        imm = bit_rotl32(imm, 1);
+    }
+
+    // Immediate must fit in one byte
+    if (imm & ~0xff) {
+        return false;
+    }
+
+    *prot = (32 - (rotation & 31)) & 31;
+    *pimm = imm;
+    return true;
+}
+
+static inline uint32_t rvjit_a32_shifter_imm(uint8_t imm, uint8_t rotate)
+{
+    rvjit_a32_assert((rotate & 1) == 0);
+    return (1 << 25) | (rotate << 7) | imm;
+}
+
+static inline uint32_t rvjit_a32_shifter_reg_imm(regid_t rm, a32_shtype_t shtype, uint8_t shamt)
+{
+    rvjit_a32_assert((rm & ~15) == 0);
+    rvjit_a32_assert((shamt & ~31) == 0);
+    return (0 << 25) | (shamt << 7) | (shtype << 5) | (0 << 4) | rm;
+}
+
+static inline uint32_t rvjit_a32_shifter_reg_reg(regid_t rm, a32_shtype_t shtype, regid_t rs)
+{
+    rvjit_a32_assert((rm & ~15) == 0);
+    rvjit_a32_assert((rs & ~15) == 0);
+    return (0 << 25) | (rs << 8) | (shtype << 5) | (1 << 4) | rm;
+}
+
+static inline void rvjit_a32_dp(rvjit_block_t* block, a32_dp_opcs_t op, a32_cc_t cc, regid_t rd, regid_t rn, uint32_t shifter)
+{
+    rvjit_a32_assert((rd & ~15) == 0);
+    rvjit_a32_assert((rn & ~15) == 0);
+    rvjit_a32_insn32(block, (cc << 28) | op | shifter | (rn << 16) | (rd << 12));
+}
+
+static inline void rvjit_a32_ma(rvjit_block_t *block, a32_ma_opcs_t op, a32_cc_t cc, regid_t rdlo, regid_t rdhi, regid_t rn, regid_t rm)
+{
+    rvjit_a32_assert((rdhi & ~15) == 0);
+    rvjit_a32_assert((rdlo & ~15) == 0);
+    rvjit_a32_assert((rn & ~15) == 0);
+    rvjit_a32_assert((rm & ~15) == 0);
+    rvjit_a32_assert((rdhi != rdlo));
+    rvjit_a32_insn32(block, (cc << 28) | op | (rdhi << 16) | (rdlo << 12) | (rm << 8) | (1 << 7) | (1 << 4) | rn);
+}
+
+static inline void rvjit_a32_ma2(rvjit_block_t *block, a32_ma_opcs_t op, a32_cc_t cc, regid_t rd, regid_t ra, regid_t rn, regid_t rm)
+{
+    rvjit_a32_assert((rd & ~15) == 0);
+    rvjit_a32_assert((ra & ~15) == 0);
+    rvjit_a32_assert((rn & ~15) == 0);
+    rvjit_a32_assert((rm & ~15) == 0);
+    rvjit_a32_insn32(block, (cc << 28) | op | (rd << 16) | (ra << 12) | (rm << 8) | (1 << 7) | (1 << 4) | rn);
+}
+
+// NOTE: Work only with udiv and sdiv
+static inline void rvjit_a32_md(rvjit_block_t *block, a32_md_opcs_t op, a32_cc_t cc, regid_t rd, regid_t ra, regid_t rn, regid_t rm)
+{
+    rvjit_a32_assert((rd & ~15) == 0);
+    rvjit_a32_assert((rn & ~15) == 0);
+    rvjit_a32_assert((rm & ~15) == 0);
+    rvjit_a32_insn32(block, (cc << 28) | op | (rd << 16) | (ra << 12) | (rm << 8) | (1 << 4) | rn);
+}
+
+static inline void rvjit_a32_blx_reg(rvjit_block_t* block, a32_cc_t cc, regid_t rm)
+{
+    rvjit_a32_dp(block, A32_BX, cc, A32_PC, A32_PC, rvjit_a32_shifter_reg_reg(rm, A32_LSR, A32_PC));
+}
+
+static inline void rvjit_a32_bx_reg(rvjit_block_t* block, a32_cc_t cc, regid_t rm)
+{
+    rvjit_a32_dp(block, A32_BX, cc, A32_PC, A32_PC, rvjit_a32_shifter_reg_reg(rm, A32_LSL, A32_PC));
+}
+
+enum a32_mem_opcs
+{
+    A32_STR   = (1 << 26) | (0 << 20) | (0 << 22),
+    A32_STRB  = (1 << 26) | (0 << 20) | (1 << 22),
+    A32_LDR   = (1 << 26) | (1 << 20) | (0 << 22),
+    A32_LDRB  = (1 << 26) | (1 << 20) | (1 << 22),
+    A32_LDRSB = (0 << 26) | (1 << 20) | (1 << 6) | (0 << 5) | (1 << 7) | (1 << 4),
+    A32_LDRSH = (0 << 26) | (1 << 20) | (1 << 6) | (1 << 5) | (1 << 7) | (1 << 4),
+    A32_LDRH  = (0 << 26) | (1 << 20) | (0 << 6) | (1 << 5) | (1 << 7) | (1 << 4),
+    A32_STRH  = (0 << 26) | (0 << 20) | (0 << 6) | (1 << 5) | (1 << 7) | (1 << 4),
+    A32_STRM  = (1 << 27) | (0 << 20) | (0 << 22),
+    A32_LDRM  = (1 << 27) | (1 << 20) | (0 << 22)
+};
+typedef uint32_t a32_mem_opcs_t;
+
+enum a32_addrmode
+{
+    A32_POSTINDEX = (0 << 24) | (0 << 21), // Use value, modify it and write it to the register
+    A32_OFFSET    = (1 << 24) | (0 << 21), // Just use the value
+    A32_PREINDEX  = (1 << 24) | (1 << 21)  // Modify the value, write it to the register and use it
+};
+typedef uint32_t a32_addrmode_t;
+
+static inline uint32_t rvjit_a32_addrmode_imm(int32_t imm, a32_addrmode_t am)
+{
+    rvjit_a32_assert(check_imm_bits(imm, 13));
+    return (0 << 25) | am | ((imm >= 0) << 23) | (((imm >= 0) ? imm : -imm) & bit_mask(12));
+}
+
+static inline uint32_t rvjit_a32_addrmode_reg(bool add, regid_t rm, a32_shtype_t shtype, uint8_t shimm, a32_addrmode_t am)
+{
+    rvjit_a32_assert((rm & ~15) == 0);
+    rvjit_a32_assert((shimm & ~31) == 0);
+    return (1 << 25) | am | (add << 23) | (shimm << 7) | (shtype << 5) | rm;
+}
+
+static inline uint32_t rvjit_a32_addrmode3_imm(int32_t imm, a32_addrmode_t am)
+{
+    rvjit_a32_assert(check_imm_bits(imm, 9));
+    bool add = imm >= 0;
+    if (imm < 0) imm = -imm;
+    return (1 << 22) | am | (add << 23) | ((imm & 0xf0) << 4) | (imm & 0x0f);
+}
+
+static inline uint32_t rvjit_a32_addrmode3_reg(bool add, regid_t rm, a32_addrmode_t am)
+{
+    rvjit_a32_assert((rm & ~15) == 0);
+    return (0 << 22) | am | (add << 23) | rm;
+}
+
+static inline uint32_t rvjit_a32_addrmode_multiple_reg(a32_addrmode_t am, uint16_t regsmask)
+{
+    rvjit_a32_assert(bit_popcnt32(regsmask) > 1); // One register in mask is undefined behavor
+    rvjit_a32_assert((regsmask & (1u << 13)) == 0);
+    rvjit_a32_assert((regsmask & (1u << 15)) == 0);
+    return (0 << 22) | am | regsmask;
+}
+
+static inline void rvjit_a32_mem_op(rvjit_block_t* block, a32_mem_opcs_t op, a32_cc_t cc, regid_t rd, regid_t rn, a32_addrmode_t addrmode)
+{
+    rvjit_a32_assert((rd & ~15) == 0);
+    rvjit_a32_assert((rn & ~15) == 0);
+    rvjit_a32_insn32(block, (cc << 28) | op | addrmode | (rn << 16) | (rd << 12));
+}
+
+/*
+static inline void rvjit_a32_push_multiple(rvjit_block_t *block, a32_mem_opcs_t op, a32_cc_t cc, regid_t rn, uint16_t regmask)
+{
+    rvjit_a32_assert((rn & ~15) == 0);
+
+    rvjit_a32_insn32(block, (cc << 28) | op | addrmode | (rn << 16) | (rd << 12));
+}
+*/
+
+static inline void rvjit_native_push(rvjit_block_t* block, regid_t reg)
+{
+    rvjit_a32_mem_op(block, A32_STR, A32_AL, reg, A32_SP, rvjit_a32_addrmode_imm(-4, A32_PREINDEX));
+}
+
+static inline void rvjit_native_pop(rvjit_block_t* block, regid_t reg)
+{
+    rvjit_a32_mem_op(block, A32_LDR, A32_AL, reg, A32_SP, rvjit_a32_addrmode_imm(4, A32_POSTINDEX));
+}
+
+static inline void rvjit_native_ret(rvjit_block_t* block)
+{
+    // bx lr
+    rvjit_a32_bx_reg(block, A32_AL, A32_LR);
+}
+
+static inline void rvjit_native_zero_reg(rvjit_block_t* block, regid_t reg)
+{
+    rvjit_a32_dp(block, A32_MOV, A32_AL, reg, 0, rvjit_a32_shifter_imm(0, 0));
+}
+
+// Set native register reg to zero-extended 32-bit imm
+static inline void rvjit_native_setreg32(rvjit_block_t* block, regid_t reg, uint32_t imm)
+{
+    uint8_t pimm, prot = 32;
+    if (rvjit_a32_encode_imm(imm, &pimm, &prot)) {
+        rvjit_a32_dp(block, A32_MOV, A32_AL, reg, 0, rvjit_a32_shifter_imm(pimm, prot));
+        return;
+    } else if (rvjit_a32_encode_imm(~imm, &pimm, &prot)) {
+        rvjit_a32_dp(block, A32_MVN, A32_AL, reg, 0, rvjit_a32_shifter_imm(pimm, prot));
+        return;
+    }
+
+    // XXX: This can be optimized with popcnt if count of 1's is greater that 0's
+    bool wasneg = (int32_t)imm < 0;
+    if (wasneg) {
+        imm = ~imm;
+    }
+    a32_dp_opcs_t op = wasneg ? A32_MVN : A32_MOV;
+    regid_t rn = 0;
+    while (imm != 0)
+    {
+        pimm = imm & 0xff;
+        imm >>= 8;
+        if (pimm != 0) {
+            rvjit_a32_dp(block, op, A32_AL, reg, rn, rvjit_a32_shifter_imm(pimm, prot & 31));
+            op = wasneg ? A32_EOR : A32_ORR;
+            rn = reg;
+        }
+        prot -= 8;
+
+        uint8_t prot2;
+        if (rvjit_a32_encode_imm(imm, &pimm, &prot2)) {
+            rvjit_a32_dp(block, op, A32_AL, reg, rn, rvjit_a32_shifter_imm(pimm, (prot + prot2) & 31));
+            return;
+        }
+    }
+}
+
+#define RVJIT_NATIVE_ZEROEXT 1
+static inline void rvjit_native_signext(rvjit_block_t* block, regid_t reg)
+{
+    /* not needed */
+    UNUSED(block);
+    UNUSED(reg);
+}
+
+// Set native register reg to sign-extended 32-bit imm
+static inline void rvjit_native_setreg32s(rvjit_block_t* block, regid_t reg, int32_t imm)
+{
+    rvjit_native_setreg32(block, reg, imm);
+}
+
+static inline void rvjit_a32_b_reloc(void *addr, bool link, a32_cc_t cond, uint32_t offset)
+{
+    // ARM PC is offseted by 8
+    offset -= 8;
+    rvjit_a32_assert((offset & 3) == 0);
+    rvjit_a32_assert(check_imm_bits(offset, 26));
+    uint32_t mask = bit_mask(24);
+    uint32_t insn = (cond << 28) | (0x5 << 25) | (link << 24) | ((offset >> 2) & mask);
+    write_uint32_le_m(addr, insn);
+}
+
+static inline void rvjit_a32_b(rvjit_block_t* block, bool link, a32_cc_t cond, uint32_t offset)
+{
+    uint32_t insn;
+    rvjit_a32_b_reloc((void*) &insn, link, cond, offset);
+    rvjit_a32_insn32(block, insn);
+}
+
+static inline branch_t rvjit_native_jmp(rvjit_block_t* block, branch_t handle, bool label)
+{
+    if (label) {
+        // We want to set a label for a branch
+        if (handle) {
+            // We have an instruction handle - this is a forward jump, relocate the address.
+            rvjit_a32_b_reloc(block->code + handle, false, A32_AL, block->size - handle);
+            return BRANCH_NEW;
+        } else {
+            // We don't have a handle - just set the label. This is a backward jump.
+            return block->size;
+        }
+    } else {
+        // We want to emit a branch instruction
+        if (handle) {
+            // We have a branch address - emit a full instruction. This is a backward jump.
+            rvjit_a32_b(block, false, A32_AL, handle - block->size);
+            return BRANCH_NEW;
+        } else {
+            // We don't have an address - it will be patched in the future. This is a forward jump.
+            branch_t tmp = block->size;
+            rvjit_a32_b(block, false, A32_AL, 0);
+            return tmp;
+        }
+    }
+}
+
+static inline void rvjit32_native_add(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a32_dp(block, A32_ADD, A32_AL, hrds, hrs1, rvjit_a32_shifter_reg_imm(hrs2, A32_LSL, 0));
+}
+
+static inline void rvjit32_native_sub(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a32_dp(block, A32_SUB, A32_AL, hrds, hrs1, rvjit_a32_shifter_reg_imm(hrs2, A32_LSL, 0));
+}
+
+static inline void rvjit32_native_or(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a32_dp(block, A32_ORR, A32_AL, hrds, hrs1, rvjit_a32_shifter_reg_imm(hrs2, A32_LSL, 0));
+}
+
+static inline void rvjit32_native_and(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a32_dp(block, A32_AND, A32_AL, hrds, hrs1, rvjit_a32_shifter_reg_imm(hrs2, A32_LSL, 0));
+}
+
+static inline void rvjit32_native_xor(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a32_dp(block, A32_EOR, A32_AL, hrds, hrs1, rvjit_a32_shifter_reg_imm(hrs2, A32_LSL, 0));
+}
+
+static inline void rvjit32_a32_native_shift_op(rvjit_block_t* block, a32_shtype_t sh, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    if (hrds == hrs2 && hrs1 != hrs2) {
+        rvjit_a32_dp(block, A32_AND, A32_AL, hrds, hrs2, rvjit_a32_shifter_imm(31, 0));
+        rvjit_a32_dp(block, A32_MOV, A32_AL, hrds, 0, rvjit_a32_shifter_reg_reg(hrs1, sh, hrs2));
+    } else {
+        regid_t rtmp = rvjit_claim_hreg(block);
+        rvjit_a32_dp(block, A32_AND, A32_AL, rtmp, hrs2, rvjit_a32_shifter_imm(31, 0));
+        rvjit_a32_dp(block, A32_MOV, A32_AL, hrds, 0, rvjit_a32_shifter_reg_reg(hrs1, sh, rtmp));
+        rvjit_free_hreg(block, rtmp);
+    }
+}
+
+static inline void rvjit32_native_sra(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit32_a32_native_shift_op(block, A32_ASR, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit32_native_srl(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit32_a32_native_shift_op(block, A32_LSR, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit32_native_sll(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit32_a32_native_shift_op(block, A32_LSL, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit_a32_native_imm_op(rvjit_block_t* block, a32_dp_opcs_t op, regid_t hrds, regid_t hrs1, int32_t imm)
+{
+    uint8_t pimm, prot = 0;
+    if (rvjit_a32_encode_imm(imm, &pimm, &prot)) {
+        rvjit_a32_dp(block, op, A32_AL, hrds, hrs1, rvjit_a32_shifter_imm(pimm, prot));
+    } else {
+        regid_t rtmp = rvjit_claim_hreg(block);
+        rvjit_native_setreg32s(block, rtmp, imm);
+        rvjit_a32_dp(block, op, A32_AL, hrds, hrs1, rvjit_a32_shifter_reg_imm(rtmp, A32_LSL, 0));
+        rvjit_free_hreg(block, rtmp);
+    }
+}
+
+static inline void rvjit32_native_addi(rvjit_block_t* block, regid_t hrds, regid_t hrs1, int32_t imm)
+{
+    uint8_t pimm, prot = 0;
+    if (rvjit_a32_encode_imm(imm, &pimm, &prot)) {
+        rvjit_a32_dp(block, A32_ADD, A32_AL, hrds, hrs1, rvjit_a32_shifter_imm(pimm, prot));
+    } else if (rvjit_a32_encode_imm(-imm, &pimm, &prot)) {
+        rvjit_a32_dp(block, A32_SUB, A32_AL, hrds, hrs1, rvjit_a32_shifter_imm(pimm, prot));
+    } else {
+        regid_t rtmp = rvjit_claim_hreg(block);
+        rvjit_native_setreg32s(block, rtmp, imm);
+        rvjit_a32_dp(block, A32_ADD, A32_AL, hrds, hrs1, rvjit_a32_shifter_reg_imm(rtmp, A32_LSL, 0));
+        rvjit_free_hreg(block, rtmp);
+    }
+}
+
+// Set native register reg to wide imm
+static inline void rvjit_native_setregw(rvjit_block_t* block, regid_t reg, uintptr_t imm)
+{
+    rvjit_native_setreg32(block, reg, imm);
+}
+
+static inline void rvjit32_native_ori(rvjit_block_t* block, regid_t hrds, regid_t hrs1, int32_t imm)
+{
+    rvjit_a32_native_imm_op(block, A32_ORR, hrds, hrs1, imm);
+}
+
+static inline void rvjit32_native_andi(rvjit_block_t* block, regid_t hrds, regid_t hrs1, int32_t imm)
+{
+    rvjit_a32_native_imm_op(block, A32_AND, hrds, hrs1, imm);
+}
+
+static inline void rvjit32_native_xori(rvjit_block_t* block, regid_t hrds, regid_t hrs1, int32_t imm)
+{
+    rvjit_a32_native_imm_op(block, A32_EOR, hrds, hrs1, imm);
+}
+
+static inline void rvjit32_native_srai(rvjit_block_t* block, regid_t hrds, regid_t hrs1, uint8_t imm)
+{
+    rvjit_a32_dp(block, A32_MOV, A32_AL, hrds, 0, rvjit_a32_shifter_reg_imm(hrs1, A32_ASR, imm));
+}
+
+static inline void rvjit32_native_srli(rvjit_block_t* block, regid_t hrds, regid_t hrs1, uint8_t imm)
+{
+    rvjit_a32_dp(block, A32_MOV, A32_AL, hrds, 0, rvjit_a32_shifter_reg_imm(hrs1, A32_LSR, imm));
+}
+
+static inline void rvjit32_native_slli(rvjit_block_t* block, regid_t hrds, regid_t hrs1, uint8_t imm)
+{
+    rvjit_a32_dp(block, A32_MOV, A32_AL, hrds, 0, rvjit_a32_shifter_reg_imm(hrs1, A32_LSL, imm));
+}
+
+static inline void rvjit32_native_slti(rvjit_block_t* block, regid_t hrds, regid_t hrs1, int32_t imm)
+{
+    rvjit_a32_native_imm_op(block, A32_CMP, 0, hrs1, imm);
+    rvjit_native_zero_reg(block, hrds);
+    rvjit_a32_dp(block, A32_MOV, A32_LT, hrds, 0, rvjit_a32_shifter_imm(1, 0));
+}
+
+static inline void rvjit32_native_sltiu(rvjit_block_t* block, regid_t hrds, regid_t hrs1, int32_t imm)
+{
+    rvjit_a32_native_imm_op(block, A32_CMP, 0, hrs1, imm);
+    rvjit_native_zero_reg(block, hrds);
+    rvjit_a32_dp(block, A32_MOV, A32_CC, hrds, 0, rvjit_a32_shifter_imm(1, 0));
+}
+
+static inline void rvjit32_native_slt(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a32_dp(block, A32_CMP, A32_AL, 0, hrs1, rvjit_a32_shifter_reg_imm(hrs2, A32_LSL, 0));
+    rvjit_native_zero_reg(block, hrds);
+    rvjit_a32_dp(block, A32_MOV, A32_LT, hrds, 0, rvjit_a32_shifter_imm(1, 0));
+}
+
+static inline void rvjit32_native_sltu(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a32_dp(block, A32_CMP, A32_AL, 0, hrs1, rvjit_a32_shifter_reg_imm(hrs2, A32_LSL, 0));
+    rvjit_native_zero_reg(block, hrds);
+    rvjit_a32_dp(block, A32_MOV, A32_CC, hrds, 0, rvjit_a32_shifter_imm(1, 0));
+}
+
+static inline void rvjit_a32_native_mem_op(rvjit_block_t* block, a32_mem_opcs_t op, regid_t dest, regid_t addr, int32_t off)
+{
+    if (bit_check(op, 26)) {
+        if (check_imm_bits(off, 13)) {
+            rvjit_a32_mem_op(block, op, A32_AL, dest, addr, rvjit_a32_addrmode_imm(off, A32_OFFSET));
+        } else {
+            regid_t rtmp = rvjit_claim_hreg(block);
+            rvjit_native_setreg32s(block, rtmp, off >= 0 ? off : -off);
+            rvjit_a32_mem_op(block, op, A32_AL, dest, addr, rvjit_a32_addrmode_reg(off >= 0, rtmp, A32_LSL, 0, A32_OFFSET));
+            rvjit_free_hreg(block, rtmp);
+        }
+    } else {
+        if (check_imm_bits(off, 9)) {
+            rvjit_a32_mem_op(block, op, A32_AL, dest, addr, rvjit_a32_addrmode3_imm(off, A32_OFFSET));
+        } else {
+            regid_t rtmp = rvjit_claim_hreg(block);
+            rvjit_native_setreg32s(block, rtmp, off >= 0 ? off : -off);
+            rvjit_a32_mem_op(block, op, A32_AL, dest, addr, rvjit_a32_addrmode3_reg(off >= 0, rtmp, A32_OFFSET));
+            rvjit_free_hreg(block, rtmp);
+        }
+    }
+
+}
+
+static inline void rvjit32_native_lb(rvjit_block_t* block, regid_t dest, regid_t addr, int32_t off)
+{
+    rvjit_a32_native_mem_op(block, A32_LDRSB, dest, addr, off);
+}
+
+static inline void rvjit32_native_lbu(rvjit_block_t* block, regid_t dest, regid_t addr, int32_t off)
+{
+    rvjit_a32_native_mem_op(block, A32_LDRB, dest, addr, off);
+}
+
+static inline void rvjit32_native_lh(rvjit_block_t* block, regid_t dest, regid_t addr, int32_t off)
+{
+    rvjit_a32_native_mem_op(block, A32_LDRSH, dest, addr, off);
+}
+
+static inline void rvjit32_native_lhu(rvjit_block_t* block, regid_t dest, regid_t addr, int32_t off)
+{
+    rvjit_a32_native_mem_op(block, A32_LDRH, dest, addr, off);
+}
+
+static inline void rvjit32_native_lw(rvjit_block_t* block, regid_t dest, regid_t addr, int32_t off)
+{
+    rvjit_a32_native_mem_op(block, A32_LDR, dest, addr, off);
+}
+
+static inline void rvjit32_native_sb(rvjit_block_t* block, regid_t src, regid_t addr, int32_t off)
+{
+    rvjit_a32_native_mem_op(block, A32_STRB, src, addr, off);
+}
+
+static inline void rvjit32_native_sh(rvjit_block_t* block, regid_t src, regid_t addr, int32_t off)
+{
+    rvjit_a32_native_mem_op(block, A32_STRH, src, addr, off);
+}
+
+static inline void rvjit32_native_sw(rvjit_block_t* block, regid_t src, regid_t addr, int32_t off)
+{
+    rvjit_a32_native_mem_op(block, A32_STR, src, addr, off);
+}
+
+static inline branch_t rvjit_a32_bcc(rvjit_block_t* block, a32_cc_t cc, regid_t hrs1, uint32_t shifter, branch_t handle, bool label)
+{
+    if (label) {
+        // We want to set a label for a branch
+        if (handle == BRANCH_NEW) {
+            // We don't have a handle - just set the label. This is a backward jump.
+            return block->size;
+        } else {
+            // We have an instruction handle - this is a forward jump, relocate the address.
+            rvjit_a32_b_reloc(block->code + handle, false, (read_uint8(block->code + handle + 3) & 0xf0) >> 4, block->size - handle);
+            return BRANCH_NEW;
+        }
+    } else {
+        // We want to emit a branch instruction
+        if (handle == BRANCH_NEW) {
+            // We don't have an address - it will be patched in the future. This is a forward jump.
+            rvjit_a32_dp(block, A32_CMP, A32_AL, 0, hrs1, shifter);
+            branch_t tmp = block->size;
+            rvjit_a32_b(block, false, cc, 0);
+            return tmp;
+        } else {
+            // We have a branch address - emit a full instruction. This is a backward jump.
+            rvjit_a32_dp(block, A32_CMP, A32_AL, 0, hrs1, shifter);
+            rvjit_a32_b(block, false, cc, handle - block->size);
+            return BRANCH_NEW;
+        }
+    }
+}
+
+static inline branch_t rvjit32_native_beq(rvjit_block_t* block, regid_t hrs1, regid_t hrs2, branch_t handle, bool target)
+{
+    return rvjit_a32_bcc(block, A32_EQ, hrs1, rvjit_a32_shifter_reg_imm(hrs2, A32_LSL, 0), handle, target);
+}
+
+static inline branch_t rvjit32_native_bne(rvjit_block_t* block, regid_t hrs1, regid_t hrs2, branch_t handle, bool target)
+{
+    return rvjit_a32_bcc(block, A32_NE, hrs1, rvjit_a32_shifter_reg_imm(hrs2, A32_LSL, 0), handle, target);
+}
+
+static inline branch_t rvjit32_native_beqz(rvjit_block_t* block, regid_t hrs1, branch_t handle, bool target)
+{
+    return rvjit_a32_bcc(block, A32_EQ, hrs1, rvjit_a32_shifter_imm(0, 0), handle, target);
+}
+
+static inline branch_t rvjit32_native_bnez(rvjit_block_t* block, regid_t hrs1, branch_t handle, bool target)
+{
+    return rvjit_a32_bcc(block, A32_NE, hrs1, rvjit_a32_shifter_imm(0, 0), handle, target);
+}
+
+static inline branch_t rvjit32_native_blt(rvjit_block_t* block, regid_t hrs1, regid_t hrs2, branch_t handle, bool target)
+{
+    return rvjit_a32_bcc(block, A32_LT, hrs1, rvjit_a32_shifter_reg_imm(hrs2, A32_LSL, 0), handle, target);
+}
+
+static inline branch_t rvjit32_native_bge(rvjit_block_t* block, regid_t hrs1, regid_t hrs2, branch_t handle, bool target)
+{
+    return rvjit_a32_bcc(block, A32_GE, hrs1, rvjit_a32_shifter_reg_imm(hrs2, A32_LSL, 0), handle, target);
+}
+
+static inline branch_t rvjit32_native_bltu(rvjit_block_t* block, regid_t hrs1, regid_t hrs2, branch_t handle, bool target)
+{
+    return rvjit_a32_bcc(block, A32_CC, hrs1, rvjit_a32_shifter_reg_imm(hrs2, A32_LSL, 0), handle, target);
+}
+
+static inline branch_t rvjit32_native_bgeu(rvjit_block_t* block, regid_t hrs1, regid_t hrs2, branch_t handle, bool target)
+{
+    return rvjit_a32_bcc(block, A32_CS, hrs1, rvjit_a32_shifter_reg_imm(hrs2, A32_LSL, 0), handle, target);
+}
+
+static inline void rvjit32_native_mul(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a32_ma(block, A32_MUL, A32_AL, 0, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit32_native_mulh(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    regid_t trash = rvjit_claim_hreg(block);
+    rvjit_a32_ma(block, A32_SMULL, A32_AL, trash, hrds, hrs1, hrs2);
+    rvjit_free_hreg(block, trash);
+}
+
+static inline void rvjit32_native_mulhu(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    regid_t trash = rvjit_claim_hreg(block);
+    rvjit_a32_ma(block, A32_UMULL, A32_AL, trash, hrds, hrs1, hrs2);
+    rvjit_free_hreg(block, trash);
+}
+
+static inline void rvjit32_native_mulhsu(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    regid_t sign = rvjit_claim_hreg(block);
+    regid_t rdhi = rvjit_claim_hreg(block);
+    regid_t rdlo = rvjit_claim_hreg(block);
+    rvjit_a32_dp(block, A32_MOV, A32_AL, sign, 0, rvjit_a32_shifter_reg_imm(hrs1, A32_ASR, 31)); // extract flag we get -1 if its negative
+    rvjit_a32_ma(block, A32_UMULL, A32_AL, rdlo, rdhi, hrs1, hrs2); // rdlo:rdhi = (hrs1 * hrs2)
+    rvjit_a32_ma2(block, A32_MLA, A32_AL, hrds, rdhi, hrs2, sign); // hrds = rdhi + (hrs2 * sign)
+    rvjit_free_hreg(block, sign);
+    rvjit_free_hreg(block, rdhi);
+    rvjit_free_hreg(block, rdlo);
+}
+
+static inline void rvjit_a32_soft_div_divu(rvjit_block_t* block, a32_md_opcs_t op, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    bool badreg  = (hrds <= 3);
+
+    if (unlikely(badreg))
+        rvjit_native_push(block, 4); // lazy to find free reg
+
+    //rvjit_a32_op_bkpt(block);
+    rvjit_native_push(block, 0);
+    rvjit_native_push(block, 1);
+    rvjit_native_push(block, 2);
+    rvjit_native_push(block, 3);
+    rvjit_native_push(block, A32_IP);
+
+    rvjit_a32_dp(block, A32_MOV, A32_AL, 0, 0, rvjit_a32_shifter_reg_imm(hrs1, A32_LSL, 0));
+    if (unlikely(hrs2 != 1))
+        rvjit_a32_dp(block, A32_MOV, A32_AL, 1, 0, rvjit_a32_shifter_reg_imm(hrs2, A32_LSL, 0));
+
+    if (likely(op == A32_SDIV)) {
+        rvjit_native_setreg32(block, A32_IP, (unsigned)rvjit_a32_soft_idiv);
+    } else if (likely(op == A32_UDIV)) {
+        rvjit_native_setreg32(block, A32_IP, (unsigned)rvjit_a32_soft_uidiv);
+    }
+
+    rvjit_native_push(block, A32_LR);
+    rvjit_a32_blx_reg(block, A32_AL, A32_IP);
+    rvjit_native_pop(block, A32_LR);
+
+    // god save me
+    if (unlikely(badreg)) {
+        rvjit_a32_dp(block, A32_MOV, A32_AL, 4, 0, rvjit_a32_shifter_reg_imm(0, A32_LSL, 0));
+    } else {
+        rvjit_a32_dp(block, A32_MOV, A32_AL, hrds, 0, rvjit_a32_shifter_reg_imm(0, A32_LSL, 0));
+    }
+
+    rvjit_native_pop(block, A32_IP);
+    rvjit_native_pop(block, 3);
+    rvjit_native_pop(block, 2);
+    rvjit_native_pop(block, 1);
+    rvjit_native_pop(block, 0);
+
+    if (unlikely(badreg)) {
+        rvjit_a32_dp(block, A32_MOV, A32_AL, hrds, 0, rvjit_a32_shifter_reg_imm(4, A32_LSL, 0));
+        rvjit_native_pop(block, 4);
+    }
+}
+
+// NOTE: aarch32 generate for overflow same behavor just need to check for divide by zero
+static inline void rvjit32_native_div(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    bool need_allocate = (hrds == hrs1 || hrds == hrs2);
+    regid_t tmphrds = need_allocate ? rvjit_claim_hreg(block) : hrds;
+
+    rvjit_native_setreg32s(block, tmphrds, -1);
+
+    if (likely(rvjit_a32_check_div())) {
+        rvjit_a32_dp(block, A32_CMP, A32_AL, hrs2, 0x0, rvjit_a32_shifter_imm(0,0));
+        rvjit_a32_md(block, A32_SDIV, A32_NE, tmphrds, 0xf, hrs1, hrs2);
+    } else {
+        branch_t zerocheck = rvjit32_native_beqz(block, hrs2, BRANCH_NEW, BRANCH_ENTRY);
+        rvjit_a32_soft_div_divu(block, A32_SDIV, tmphrds, hrs1, hrs2);
+        rvjit32_native_beqz(block, hrs2, zerocheck, BRANCH_TARGET);
+    }
+
+    if (need_allocate) {
+        rvjit_a32_dp(block, A32_MOV, A32_AL, hrds, 0, rvjit_a32_shifter_reg_imm(tmphrds, A32_LSL, 0));
+        rvjit_free_hreg(block, tmphrds);
+    }
+}
+
+static inline void rvjit32_native_divu(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    bool need_allocate = (hrds == hrs1 || hrds == hrs2);
+    regid_t tmphrds = need_allocate ? rvjit_claim_hreg(block) : hrds;
+
+    rvjit_native_setreg32s(block, tmphrds, -1);
+
+    if (likely(rvjit_a32_check_div())) {
+        rvjit_a32_dp(block, A32_CMP, A32_AL, hrs2, 0x0, rvjit_a32_shifter_imm(0,0));
+        rvjit_a32_md(block, A32_UDIV, A32_NE, tmphrds, 0xf, hrs1, hrs2);
+    } else {
+        branch_t zerocheck = rvjit32_native_beqz(block, hrs2, BRANCH_NEW, BRANCH_ENTRY);
+        rvjit_a32_soft_div_divu(block, A32_UDIV, tmphrds, hrs1, hrs2);
+        rvjit32_native_beqz(block, hrs2, zerocheck, BRANCH_TARGET);
+    }
+
+    if (need_allocate) {
+        rvjit_a32_dp(block, A32_MOV, A32_AL, hrds, 0, rvjit_a32_shifter_reg_imm(tmphrds, A32_LSL, 0));
+        rvjit_free_hreg(block, tmphrds);
+    }
+}
+
+// need to hrds = hrs1 - ((hrs1 / hrs2) * hrs2)
+// its cool we need just check for zero and after then for INT_MIN in div result
+static inline void rvjit32_native_rem(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    bool need_allocate = (hrds == hrs1 || hrds == hrs2);
+    regid_t tmphrds = need_allocate ? rvjit_claim_hreg(block) : hrds;
+    regid_t tmp = rvjit_claim_hreg(block);
+
+    rvjit_a32_dp(block, A32_MOV, A32_AL, tmphrds, 0, rvjit_a32_shifter_reg_imm(hrs1, A32_LSL, 0));
+    branch_t zerocheck = rvjit32_native_beqz(block, hrs2, BRANCH_NEW, BRANCH_ENTRY);
+
+    if (likely(rvjit_a32_check_div())) {
+        rvjit_a32_md(block, A32_SDIV, A32_AL, tmp, 0xf, hrs1, hrs2); // tmp = (hrs1 sdiv hrs2)
+    } else {
+        rvjit_a32_soft_div_divu(block, A32_SDIV, tmp, hrs1, hrs2);
+    }
+
+    rvjit_a32_dp(block, A32_CMP, A32_AL, 0, hrs1, rvjit_a32_shifter_reg_imm(tmp, A32_LSL, 0)); // cmp(hrs1, tmp)
+    rvjit_a32_dp(block, A32_MOV, A32_EQ, tmphrds, 0, rvjit_a32_shifter_imm(0, 0)); // if (tmp == cmpreg) { hrds = 0; }
+    rvjit_a32_ma2(block, A32_MLS, A32_NE, tmphrds, hrs1, tmp, hrs2); // else { hrds = (hrs1 - (tmp * hrs2)); }
+    rvjit32_native_beqz(block, hrs2, zerocheck, BRANCH_TARGET);
+
+    if (need_allocate) {
+        rvjit_a32_dp(block, A32_MOV, A32_AL, hrds, 0, rvjit_a32_shifter_reg_imm(tmphrds, A32_LSL, 0));
+        rvjit_free_hreg(block, tmphrds);
+    }
+
+    rvjit_free_hreg(block, tmp);
+}
+
+static inline void rvjit32_native_remu(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    bool need_allocate = (hrds == hrs1 || hrds == hrs2);
+    regid_t tmphrds = need_allocate ? rvjit_claim_hreg(block) : hrds;
+    regid_t tmp = rvjit_claim_hreg(block);
+
+    rvjit_a32_dp(block, A32_MOV, A32_AL, tmphrds, 0, rvjit_a32_shifter_reg_imm(hrs1, A32_LSL, 0));
+    branch_t zerocheck = rvjit32_native_beqz(block, hrs2, BRANCH_NEW, BRANCH_ENTRY);
+
+    if (likely(rvjit_a32_check_div())) {
+        rvjit_a32_md(block, A32_UDIV, A32_AL, tmp, 0xf, hrs1, hrs2); // tmp = (hrs1 divu hrs2)
+    } else {
+        rvjit_a32_soft_div_divu(block, A32_UDIV, tmp, hrs1, hrs2);
+    }
+
+    rvjit_a32_ma2(block, A32_MLS, A32_AL, tmphrds, hrs1, tmp, hrs2); // hrds = hrs1 - (tmp * hrs2)
+    rvjit32_native_beqz(block, hrs2, zerocheck, BRANCH_TARGET);
+
+    if (need_allocate) {
+        rvjit_a32_dp(block, A32_MOV, A32_AL, hrds, 0, rvjit_a32_shifter_reg_imm(tmphrds, A32_LSL, 0));
+        rvjit_free_hreg(block, tmphrds);
+    }
+
+    rvjit_free_hreg(block, tmp);
+}
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/rvjit/rvjit_arm64.h b/app/src/main/java/libengine/RVVM/src/rvjit/rvjit_arm64.h
new file mode 100644
index 00000000..cf9ad928
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/rvjit/rvjit_arm64.h
@@ -0,0 +1,1358 @@
+/*
+rvjit_arm64.h - RVJIT ARM64 Backend
+Copyright (C) 2022  cerg2010cerg2010 <github.com/cerg2010cerg2010>
+                    LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "rvjit.h"
+#include "../mem_ops.h"
+#include "../bit_ops.h"
+
+#ifndef RVJIT_ARM64_H
+#define RVJIT_ARM64_H
+
+#ifdef RVJIT_ABI_SYSV
+#define VM_PTR_REG 0
+#endif
+
+enum a64_regs {
+    A64_XZR = 31, // when used as a source register
+    A64_WZR = 31,
+    A64_SP  = 31, // when used as a destination
+    A64_WSP = 31
+    // just use numbers for others!
+};
+
+enum a64_movw_opcs {
+    A64_MOVNW = 0,
+    A64_MOVZW = 2,
+    A64_MOVKW = 3,
+    A64_MOVN  = 4,
+    A64_MOVZ  = 6,
+    A64_MOVK  = 7
+};
+
+enum a64_movw_off {
+    A64_MOV_0,
+    A64_MOV_16,
+    A64_MOV_32,
+    A64_MOV_48
+};
+
+enum a64_addsub_shifted {
+    A64_ADDW  = 0,
+    A64_ADDSW = 1,
+    A64_SUBW  = 2,
+    A64_SUBSW = 3,
+    A64_ADD   = 4,
+    A64_ADDS  = 5,
+    A64_SUB   = 6,
+    A64_SUBS  = 7,
+};
+
+enum a64_addsub_imm {
+    A64_ADDIW  = 0,
+    A64_ADDSIW = 1,
+    A64_SUBIW  = 2,
+    A64_SUBSIW = 3,
+    A64_ADDI   = 4,
+    A64_ADDSI  = 5,
+    A64_SUBI   = 6,
+    A64_SUBSI  = 7,
+};
+
+enum a64_addsub_shift {
+    A64_LSL = 0,
+    A64_LSR = 1,
+    A64_ASR = 2,
+    // 3 is reserved for ADD/SUB instructions, but for logical it's:
+    A64_ROR = 3,
+};
+
+enum a64_bitfield_opcs {
+    A64_SBFMW = 0, // N == 0
+    A64_BFMW  = 1,
+    A64_UBFMW = 2,
+    A64_SBFM  = 4, // N == 1
+    A64_BFM   = 5,
+    A64_UBFM  = 6,
+};
+
+enum a64_logical_imm {
+    A64_ANDIW  = 0, // N is always 0
+    A64_ORRIW  = 1,
+    A64_EORIW  = 2,
+    A64_ANDSIW = 3,
+    A64_ANDI   = 4, // N is part of immediate
+    A64_ORRI   = 5,
+    A64_EORI   = 6,
+    A64_ANDSI  = 7,
+};
+
+enum a64_logical_shifted {
+    A64_ANDW  = (0u << 29) | (0 << 21),
+    A64_BICW  = (0u << 29) | (1 << 21),
+    A64_ORRW  = (1u << 29) | (0 << 21),
+    A64_ORNW  = (1u << 29) | (1 << 21),
+    A64_EORW  = (2u << 29) | (0 << 21),
+    A64_EONW  = (2u << 29) | (1 << 21),
+    A64_ANDSW = (3u << 29) | (0 << 21),
+    A64_BICSW = (3u << 29) | (1 << 21),
+    A64_AND   = (4u << 29) | (0 << 21),
+    A64_BIC   = (4u << 29) | (1 << 21),
+    A64_ORR   = (5u << 29) | (0 << 21),
+    A64_ORN   = (5u << 29) | (1 << 21),
+    A64_EOR   = (6u << 29) | (0 << 21),
+    A64_EON   = (6u << 29) | (1 << 21),
+    A64_ANDS  = (7u << 29) | (0 << 21),
+    A64_BICS  = (7u << 29) | (1 << 21),
+};
+
+enum a64_csel {
+    A64_CSELW  = (0u << 29) | (0 << 10),
+    A64_CSINCW = (0u << 29) | (1 << 10),
+    A64_CSINVW = (2u << 29) | (0 << 10),
+    A64_CSNEGW = (2u << 29) | (1 << 10),
+    A64_CSEL   = (4u << 29) | (0 << 10),
+    A64_CSINC  = (4u << 29) | (1 << 10),
+    A64_CSINV  = (6u << 29) | (0 << 10),
+    A64_CSNEG  = (6u << 29) | (1 << 10),
+};
+
+enum a64_cc {
+    A64_EQ, A64_NE,
+    A64_CS, A64_CC,
+    A64_MI, A64_PL,
+    A64_VS, A64_VC,
+    A64_HI, A64_LS,
+    A64_GE, A64_LT,
+    A64_GT, A64_LE,
+    A64_AL, A64_AL2 // 1110 and 1111 are always-true
+};
+
+enum a64_b_cc {
+    A64_B_EQ = (0x54U << 24) | A64_EQ,
+    A64_B_NE = (0x54U << 24) | A64_NE,
+    A64_B_CS = (0x54U << 24) | A64_CS,
+    A64_B_CC = (0x54U << 24) | A64_CC,
+    A64_B_LT = (0x54U << 24) | A64_LT,
+    A64_B_GE = (0x54U << 24) | A64_GE,
+    A64_CBZ  = (0xB4U << 24),
+    A64_CBNZ = (0xB5U << 24),
+    A64_CBZW = (0x34U << 24),
+    A64_CBNZW = (0x35U << 24)
+};
+
+enum a64_ldst_imm_unsigned {
+    A64_STRB   = (0u << 30) | (0 << 26) | (0 << 22),
+    A64_LDRB   = (0u << 30) | (0 << 26) | (1 << 22),
+    A64_LDRSB  = (0u << 30) | (0 << 26) | (2 << 22),
+    A64_LDRSBW = (0u << 30) | (0 << 26) | (3 << 22),
+    A64_STRH   = (1u << 30) | (0 << 26) | (0 << 22),
+    A64_LDRH   = (1u << 30) | (0 << 26) | (1 << 22),
+    A64_LDRSH  = (1u << 30) | (0 << 26) | (2 << 22),
+    A64_LDRSHW = (1u << 30) | (0 << 26) | (3 << 22),
+    A64_STRW   = (2u << 30) | (0 << 26) | (0 << 22),
+    A64_LDRW   = (2u << 30) | (0 << 26) | (1 << 22),
+    A64_LDRSW  = (2u << 30) | (0 << 26) | (2 << 22),
+    A64_STR    = (3u << 30) | (0 << 26) | (0 << 22),
+    A64_LDR    = (3u << 30) | (0 << 26) | (1 << 22),
+    A64_PRFUM  = (3u << 30) | (0 << 26) | (2 << 22),
+};
+
+enum a64_dp_2src {
+    A64_UDIVW = (0u << 31) | (0 << 29) | (2  << 10),
+    A64_SDIVW = (0u << 31) | (0 << 29) | (3  << 10),
+    A64_LSLVW = (0u << 31) | (0 << 29) | (8  << 10),
+    A64_LSRVW = (0u << 31) | (0 << 29) | (9  << 10),
+    A64_ASRVW = (0u << 31) | (0 << 29) | (10 << 10),
+    A64_RORVW = (0u << 31) | (0 << 29) | (11 << 10),
+    A64_UDIV  = (1u << 31) | (0 << 29) | (2  << 10),
+    A64_SDIV  = (1u << 31) | (0 << 29) | (3  << 10),
+    A64_LSLV  = (1u << 31) | (0 << 29) | (8  << 10),
+    A64_LSRV  = (1u << 31) | (0 << 29) | (9  << 10),
+    A64_ASRV  = (1u << 31) | (0 << 29) | (10 << 10),
+    A64_RORV  = (1u << 31) | (0 << 29) | (11 << 10),
+};
+
+enum a64_dp_3src
+{
+    A64_MADDW   = (0u << 31) | (0 << 29) | (0 << 21) | (0 << 15),
+    A64_MSUBW   = (0u << 31) | (0 << 29) | (0 << 21) | (1 << 15),
+    A64_MADD    = (1u << 31) | (0 << 29) | (0 << 21) | (0 << 15),
+    A64_MSUB    = (1u << 31) | (0 << 29) | (0 << 21) | (1 << 15),
+    A64_SMADDL  = (1u << 31) | (0 << 29) | (1 << 21) | (0 << 15),
+    A64_SMSUBL  = (1u << 31) | (0 << 29) | (1 << 21) | (1 << 15),
+    A64_SMULH   = (1u << 31) | (0 << 29) | (2 << 21) | (0 << 15),
+    A64_UMADDL  = (1u << 31) | (0 << 29) | (5 << 21) | (0 << 15),
+    A64_UMSUBL  = (1u << 31) | (0 << 29) | (5 << 21) | (1 << 15),
+    A64_UMULH   = (1u << 31) | (0 << 29) | (6 << 21) | (0 << 15),
+};
+
+static inline bool check_imm_bits(int32_t val, bitcnt_t bits)
+{
+    return sign_extend(val, bits) == val;
+}
+
+static inline size_t rvjit_native_default_hregmask(void)
+{
+    // X0 - X15 registers are caller-saved
+    // X0 is preserver as vmptr
+    // X16-X18 are possibly usable, needs more research
+    return 0xFFFE;
+}
+
+static inline size_t rvjit_native_abireclaim_hregmask(void)
+{
+    // We have enough caller-saved registers, no need for push/pop as well
+    return 0;
+}
+
+static inline void rvjit_native_push(rvjit_block_t* block, regid_t reg)
+{
+    UNUSED(block);
+    UNUSED(reg);
+    rvvm_fatal("Unimplemented rvjit_native_push for ARM64 backend");
+}
+
+static inline void rvjit_native_pop(rvjit_block_t* block, regid_t reg)
+{
+    UNUSED(block);
+    UNUSED(reg);
+    rvvm_fatal("Unimplemented rvjit_native_pop for ARM64 backend");
+}
+
+static inline void rvjit_native_ret(rvjit_block_t* block)
+{
+    rvjit_put_code(block, "\xC0\x03\x5F\xD6", 4);
+}
+
+static inline void rvjit_a64_insn32(rvjit_block_t* block, uint32_t insn)
+{
+    uint8_t code[sizeof(insn)];
+    write_uint32_le_m(code, insn);
+    rvjit_put_code(block, code, sizeof(code));
+}
+
+// Direct instruction types codegen
+
+static inline void rvjit_a64_addsub_shifted(rvjit_block_t* block,
+        enum a64_addsub_shifted opc,
+        regid_t rd,
+        regid_t rn,
+        regid_t rm,
+        enum a64_addsub_shift shift,
+        uint8_t amount)
+{
+    rvjit_a64_insn32(block, ((uint32_t)opc << 29) | (0xB << 24) | (shift << 22) | (rm << 16) | (amount << 10) | (rn << 5) | rd);
+}
+
+static inline void rvjit_a64_addsub_imm(rvjit_block_t* block, enum a64_addsub_imm opc, regid_t rd, regid_t rn, uint16_t imm, bool shift)
+{
+    rvjit_a64_insn32(block, ((uint32_t)opc << 29) | (0x22 << 23) | (shift << 22) | (imm << 10) | (rn << 5) | rd);
+}
+
+static inline void rvjit_a64_logical_shifted(rvjit_block_t* block,
+        enum a64_logical_shifted opc,
+        regid_t rd,
+        regid_t rn,
+        regid_t rm,
+        enum a64_addsub_shift shift,
+        uint8_t amount)
+{
+    rvjit_a64_insn32(block, (uint32_t)opc | (0xA << 24) | (shift << 22) | (rm << 16) | (amount << 10) | (rn << 5) | rd);
+}
+
+static inline void rvjit_a64_logical_imm(rvjit_block_t* block, enum a64_logical_imm opc, regid_t rd, regid_t rn, uint8_t immr, uint8_t imms)
+{
+    rvjit_a64_insn32(block, ((uint32_t)opc << 29) | (0x24 << 23) | ((opc >= 4) << 22) | (immr << 16) | (imms << 10) | (rn << 5) | rd);
+}
+
+static inline void rvjit_a64_bitfield(rvjit_block_t* block, enum a64_bitfield_opcs opc, regid_t rd, regid_t rn, uint8_t immr, uint8_t imms)
+{
+    rvjit_a64_insn32(block, ((uint32_t)opc << 29) | (0x26 << 23) | ((opc >= 4) << 22) | (immr << 16) | (imms << 10) | (rn << 5) | rd);
+}
+
+static inline void rvjit_a64_dp_2src(rvjit_block_t* block, enum a64_dp_2src opc, regid_t rd, regid_t rn, regid_t rm)
+{
+    rvjit_a64_insn32(block, (uint32_t)opc | (0xD6 << 21) | (rm << 16) | (rn << 5) | rd);
+}
+
+static inline void rvjit_a64_dp_3src(rvjit_block_t* block, enum a64_dp_3src opc, regid_t rd, regid_t rn, regid_t rm, regid_t ra)
+{
+    rvjit_a64_insn32(block, (uint32_t)opc | (0x1B << 24) | (rm << 16) | (ra << 10) | (rn << 5) | rd);
+}
+
+static inline void rvjit_a64_movw(rvjit_block_t* block, enum a64_movw_opcs opc, regid_t rd, uint16_t imm, enum a64_movw_off off)
+{
+    rvjit_a64_insn32(block, ((uint32_t)opc << 29) | (0x25 << 23) | (off << 21) | (imm << 5) | rd);
+}
+
+static inline void rvjit_a64_csel(rvjit_block_t* block, enum a64_csel opc, regid_t rd, regid_t rn, regid_t rm, enum a64_cc cc)
+{
+    rvjit_a64_insn32(block, (uint32_t)opc | (0xD4 << 21) | (rm << 16) | (cc << 12) | (rn << 5) | rd);
+}
+
+static inline void rvjit_a64_ldst_imm_unsigned(rvjit_block_t* block, enum a64_ldst_imm_unsigned opc, regid_t rt, regid_t rn, uint16_t imm)
+{
+    rvjit_a64_insn32(block, (uint32_t)opc | (0x39 << 24) | (imm << 10) | (rn << 5) | rt);
+}
+
+// Wrappers, common codegen logic
+
+static inline void rvjit_native_zero_reg(rvjit_block_t* block, regid_t reg)
+{
+    rvjit_a64_logical_shifted(block, A64_ORR, reg, A64_XZR, A64_XZR, A64_LSL, 0);
+}
+
+static inline void rvjit_native_signext(rvjit_block_t* block, regid_t reg)
+{
+    rvjit_a64_bitfield(block, A64_SBFM, reg, reg, 0, 31);
+}
+
+// Set native register reg to zero-extended 32-bit imm
+static inline void rvjit_native_setreg32(rvjit_block_t* block, regid_t reg, uint32_t imm)
+{
+    if (imm == 0) {
+        rvjit_native_zero_reg(block, reg);
+    } else if ((imm & 0xFFFF) == imm) {
+        rvjit_a64_movw(block, A64_MOVZ, reg, imm, A64_MOV_0);
+    } else if ((imm & 0xFFFF0000) == imm) {
+        rvjit_a64_movw(block, A64_MOVZ, reg, (imm >> 16) & 0xFFFF, A64_MOV_16);
+    } else {
+        rvjit_a64_movw(block, A64_MOVZ, reg, imm & 0xFFFF, A64_MOV_0);
+        rvjit_a64_movw(block, A64_MOVK, reg, (imm >> 16) & 0xFFFF, A64_MOV_16);
+    }
+}
+
+// Set native register reg to sign-extended 32-bit imm
+static inline void rvjit_native_setreg32s(rvjit_block_t* block, regid_t reg, int32_t imm)
+{
+    if (imm >= 0) {
+        rvjit_native_setreg32(block, reg, imm);
+    } else if ((~imm & ~0xFFFF) == 0) {
+        rvjit_a64_movw(block, A64_MOVN, reg, (~imm) & 0xFFFF, A64_MOV_0);
+    } else if ((~imm & ~0xFFFF0000) == 0) {
+        rvjit_a64_movw(block, A64_MOVN, reg, ~(imm >> 16) & 0xFFFF, A64_MOV_16);
+    } else {
+        rvjit_a64_movw(block, A64_MOVN, reg, ~imm & 0xFFFF, A64_MOV_0);
+        rvjit_a64_movw(block, A64_MOVK, reg, (imm >> 16) & 0xFFFF, A64_MOV_16);
+    }
+}
+
+// Set native register reg to wide imm
+static inline void rvjit_native_setregw(rvjit_block_t* block, regid_t reg, uintptr_t imm)
+{
+    if ((imm & 0xFFFFFFFF) == imm) {
+        rvjit_native_setreg32(block, reg, (uint32_t) imm);
+    } else if ((~imm & 0xFFFFFFFF) == ~imm) {
+        rvjit_native_setreg32s(block, reg, (int32_t) imm);
+    } else {
+        rvjit_a64_movw(block, A64_MOVZ, reg, imm & 0xFFFF, A64_MOV_0);
+        rvjit_a64_movw(block, A64_MOVK, reg, (imm >> 16) & 0xFFFF, A64_MOV_16);
+        rvjit_a64_movw(block, A64_MOVK, reg, (imm >> 32) & 0xFFFF, A64_MOV_32);
+        rvjit_a64_movw(block, A64_MOVK, reg, (imm >> 48) & 0xFFFF, A64_MOV_48);
+    }
+}
+
+static inline void rvjit_a64_b_reloc(void* addr, uint32_t offset)
+{
+    uint32_t mask = bit_mask(26);
+    uint32_t insn = (0x5 << 26) | ((offset >> 2) & mask);
+    write_uint32_le_m(addr, insn);
+}
+
+static inline void rvjit_a64_b(rvjit_block_t* block, uint32_t offset)
+{
+    uint8_t insn[4];
+    rvjit_a64_b_reloc(insn, offset);
+    rvjit_a64_insn32(block, read_uint32_le_m(insn));
+}
+
+static inline branch_t rvjit_native_jmp(rvjit_block_t* block, branch_t handle, bool label)
+{
+    if (label) {
+        // We want to set a label for a branch
+        if (handle == BRANCH_NEW) {
+            // We don't have a handle - just set the label. This is a backward jump.
+            return block->size;
+        } else {
+            // We have an instruction handle - this is a forward jump, relocate the address.
+            rvjit_a64_b_reloc(block->code + handle, block->size - handle);
+            return BRANCH_NEW;
+        }
+    } else {
+        // We want to emit a branch instruction
+        if (handle == BRANCH_NEW) {
+            // We don't have an address - it will be patched in the future. This is a forward jump.
+            branch_t tmp = block->size;
+            rvjit_a64_b(block, 0);
+            return tmp;
+        } else {
+            // We have a branch address - emit a full instruction. This is a backward jump.
+            rvjit_a64_b(block, handle - block->size);
+            return BRANCH_NEW;
+        }
+    }
+}
+
+static inline bool rvjit_a64_addi_shifted(rvjit_block_t* block, regid_t hrds, regid_t hrs1, int32_t imm, bool bits_64)
+{
+    enum a64_addsub_imm opc = (imm < 0) ? (bits_64 ? A64_SUBI : A64_SUBIW) : (bits_64 ? A64_ADDI : A64_ADDIW);
+    if (imm < 0) imm = -imm;
+    if (imm == (imm & 0xFFF)) {
+        rvjit_a64_addsub_imm(block, opc, hrds, hrs1, imm, false);
+        return true;
+    } else if (imm == (imm & 0xFFF000)) {
+        rvjit_a64_addsub_imm(block, opc, hrds, hrs1, imm >> 12, true);
+        return true;
+    }
+    return false;
+}
+
+static inline void rvjit_a64_addi(rvjit_block_t* block, regid_t hrds, regid_t hrs1, int32_t imm, bool bits_64)
+{
+    if (imm == 0) {
+        if (hrds != hrs1 || !bits_64) {
+            rvjit_a64_logical_shifted(block, A64_ORR, hrds, A64_XZR, hrs1, A64_LSL, 0);
+        }
+    } else if (!rvjit_a64_addi_shifted(block, hrds, hrs1, imm, bits_64)) {
+        regid_t rtmp = rvjit_claim_hreg(block);
+        rvjit_native_setreg32s(block, rtmp, imm);
+        rvjit_a64_addsub_shifted(block, bits_64 ? A64_ADD : A64_ADDW, hrds, hrs1, rtmp, A64_LSL, 0);
+        rvjit_free_hreg(block, rtmp);
+    }
+}
+
+static inline bool rvjit_a64_ispow2(unsigned long long x)
+{
+    return x != 0 && (x & (x - 1)) == 0;
+}
+
+// Checks that immediate value is suitable for use in logical operation
+bool rvjit_a64_check_logical_imm64(uint64_t val, unsigned *rot, unsigned *len)
+{
+    unsigned rotation, count;
+    if ((int64_t)val < 0) {
+        val = ~val;
+        if (val == 0) return false;
+        rotation = bit_clz64(val);
+        count = rotation + bit_ctz64(val);
+        if (!rvjit_a64_ispow2((val >> (count - rotation)) + 1)) {
+            return false;
+        }
+    } else {
+        if (val == 0) return false;
+        rotation = (sizeof(val) * 8 - bit_ctz64(val));
+        count = rotation - bit_clz64(val);
+        rotation &= sizeof(val) * 8 - 1;
+        if (!rvjit_a64_ispow2((val >> (sizeof(val) * 8 - rotation)) + 1)) {
+            return false;
+        }
+    }
+
+    *rot = rotation;
+    *len = count - 1;
+    return true;
+}
+
+bool rvjit_a64_check_logical_imm32(uint32_t val, unsigned *rot, unsigned *len)
+{
+    unsigned rotation, count;
+    if ((int32_t)val < 0) {
+        val = ~val;
+        if (val == 0) return false;
+        rotation = bit_clz32(val);
+        count = rotation + bit_ctz32(val);
+        if (!rvjit_a64_ispow2((val >> (count - rotation)) + 1)) {
+            return false;
+        }
+    } else {
+        if (val == 0) return false;
+        rotation = (sizeof(val) * 8 - bit_ctz32(val));
+        count = rotation - bit_clz32(val);
+        rotation &= sizeof(val) * 8 - 1;
+        if (!rvjit_a64_ispow2((val >> (sizeof(val) * 8 - rotation)) + 1)) {
+            return false;
+        }
+    }
+
+    *rot = rotation;
+    *len = count - 1;
+    return true;
+}
+
+static enum a64_logical_shifted rvjit_a64_logical_imm_to_shifted(enum a64_logical_imm opc)
+{
+    switch (opc) {
+        case A64_ANDIW:  return A64_ANDW;
+        case A64_ORRIW:  return A64_ORRW;
+        case A64_EORIW:  return A64_EORW;
+        case A64_ANDSIW: return A64_ANDSW;
+        case A64_ANDI:   return A64_AND;
+        case A64_ORRI:   return A64_ORR;
+        case A64_EORI:   return A64_EOR;
+        case A64_ANDSI:  return A64_ANDS;
+        default: rvvm_fatal("Invalid opcode in rvjit_a64_logical_imm_to_shifted()"); return 0;
+    }
+}
+
+static void rvjit_a64_native_log_op32(rvjit_block_t* block, enum a64_logical_imm opc, regid_t rd, regid_t rn, int32_t imm)
+{
+    unsigned rotation, count;
+    if (rvjit_a64_check_logical_imm32((int64_t)imm, &rotation, &count)) {
+        rvjit_a64_logical_imm(block, opc, rd, rn, rotation, count);
+    } else {
+        regid_t rtmp = rvjit_claim_hreg(block);
+        enum a64_logical_shifted sopc = rvjit_a64_logical_imm_to_shifted(opc);
+        rvjit_native_setreg32s(block, rtmp, imm);
+        rvjit_a64_logical_shifted(block, sopc, rd, rn, rtmp, A64_LSL, 0);
+        rvjit_free_hreg(block, rtmp);
+    }
+}
+
+static void rvjit_a64_native_log_op64(rvjit_block_t* block, enum a64_logical_imm opc, regid_t rd, regid_t rn, int64_t imm)
+{
+    unsigned rotation, count;
+    if (rvjit_a64_check_logical_imm64((int64_t)imm, &rotation, &count)) {
+        rvjit_a64_logical_imm(block, opc, rd, rn, rotation | (1 << 6), count); /* N bit needs to be set */
+    } else {
+        regid_t rtmp = rvjit_claim_hreg(block);
+        enum a64_logical_shifted sopc = rvjit_a64_logical_imm_to_shifted(opc);
+        rvjit_native_setregw(block, rtmp, imm);
+        rvjit_a64_logical_shifted(block, sopc, rd, rn, rtmp, A64_LSL, 0);
+        rvjit_free_hreg(block, rtmp);
+    }
+}
+
+static inline bool rvjit_a64_is_store(enum a64_ldst_imm_unsigned opc)
+{
+    return !bit_cut(opc, 22, 2);
+}
+
+static inline void rvjit_a64_mem_op(rvjit_block_t* block, enum a64_ldst_imm_unsigned opc, regid_t dest, regid_t addr, int32_t off)
+{
+    uint8_t mask = (opc >> 30) & 3;
+    int32_t ldst_off = (off >> mask) & bit_mask(12);
+    off -= (ldst_off << mask);
+    if (off == 0) {
+        rvjit_a64_ldst_imm_unsigned(block, opc, dest, addr, ldst_off);
+    } else if (rvjit_a64_addi_shifted(block, addr, addr, off, true)) {
+        rvjit_a64_ldst_imm_unsigned(block, opc, dest, addr, ldst_off);
+        if (rvjit_a64_is_store(opc) || dest != addr) {
+            rvjit_a64_addi_shifted(block, addr, addr, -off, true);
+        }
+    } else {
+        regid_t rtmp = rvjit_claim_hreg(block);
+        rvjit_native_setreg32s(block, rtmp, off);
+        rvjit_a64_addsub_shifted(block, A64_ADD, rtmp, rtmp, addr, A64_LSL, 0);
+        rvjit_a64_ldst_imm_unsigned(block, opc, dest, rtmp, ldst_off);
+        rvjit_free_hreg(block, rtmp);
+    }
+}
+
+static inline bool rvjit_is_valid_branch_imm(int32_t imm)
+{
+    return check_imm_bits(imm, 21) && (imm & 0x3) == 0;
+}
+
+static inline void rvjit_a64_b_cond_reloc(void* addr, uint32_t opcode, int32_t offset)
+{
+    if (!rvjit_is_valid_branch_imm(offset)) rvvm_fatal("Illegal branch offset in RVJIT!");
+    uint32_t insn = opcode | ((offset << 3) & 0xFFFFE0);
+    write_uint32_le_m(addr, insn);
+}
+
+static inline void rvjit_a64_b_cond(rvjit_block_t* block, uint32_t opcode, int32_t offset)
+{
+    uint8_t insn[4];
+    rvjit_a64_b_cond_reloc((void*) &insn, opcode, offset);
+    rvjit_a64_insn32(block, read_uint32_le_m(insn));
+}
+
+static inline branch_t rvjit_a64_bcc(rvjit_block_t* block, uint32_t opcode, branch_t handle, bool label)
+{
+    if (label) {
+        // We want to set a label for a branch
+        if (handle == BRANCH_NEW) {
+            // We don't have a handle - just set the label. This is a backward jump.
+            return block->size;
+        } else {
+            // We have an instruction handle - this is a forward jump, relocate the address.
+            rvjit_a64_b_cond_reloc(block->code + handle, read_uint32_le_m(block->code + handle) & 0xFF00000F, block->size - handle);
+            return BRANCH_NEW;
+        }
+    } else {
+        // We want to emit a branch instruction
+        if (handle == BRANCH_NEW) {
+            // We don't have an address - it will be patched in the future. This is a forward jump.
+            branch_t tmp = block->size;
+            rvjit_a64_b_cond(block, opcode, 0);
+            return tmp;
+        } else {
+            // We have a branch address - emit a full instruction. This is a backward jump.
+            rvjit_a64_b_cond(block, opcode, handle - block->size);
+            return BRANCH_NEW;
+        }
+    }
+}
+
+static inline void rvjit32_native_add(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a64_addsub_shifted(block, A64_ADDW, hrds, hrs1, hrs2, A64_LSL, 0);
+}
+
+static inline void rvjit32_native_sub(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a64_addsub_shifted(block, A64_SUBW, hrds, hrs1, hrs2, A64_LSL, 0);
+}
+
+static inline void rvjit32_native_or(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a64_logical_shifted(block, A64_ORRW, hrds, hrs1, hrs2, A64_LSL, 0);
+}
+
+static inline void rvjit32_native_and(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a64_logical_shifted(block, A64_ANDW, hrds, hrs1, hrs2, A64_LSL, 0);
+}
+
+static inline void rvjit32_native_xor(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a64_logical_shifted(block, A64_EORW, hrds, hrs1, hrs2, A64_LSL, 0);
+}
+
+static inline void rvjit32_native_sra(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a64_dp_2src(block, A64_ASRVW, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit32_native_srl(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a64_dp_2src(block, A64_LSRVW, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit32_native_sll(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a64_dp_2src(block, A64_LSLVW, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit32_native_addi(rvjit_block_t* block, regid_t hrds, regid_t hrs1, int32_t imm)
+{
+    rvjit_a64_addi(block, hrds, hrs1, imm, false);
+}
+
+static inline void rvjit32_native_ori(rvjit_block_t* block, regid_t hrds, regid_t hrs1, int32_t imm)
+{
+    rvjit_a64_native_log_op32(block, A64_ORRIW, hrds, hrs1, imm);
+}
+
+static inline void rvjit32_native_andi(rvjit_block_t* block, regid_t hrds, regid_t hrs1, int32_t imm)
+{
+    rvjit_a64_native_log_op32(block, A64_ANDIW, hrds, hrs1, imm);
+}
+
+static inline void rvjit32_native_xori(rvjit_block_t* block, regid_t hrds, regid_t hrs1, int32_t imm)
+{
+    rvjit_a64_native_log_op32(block, A64_EORIW, hrds, hrs1, imm);
+}
+
+static inline void rvjit32_native_srai(rvjit_block_t* block, regid_t hrds, regid_t hrs1, uint8_t imm)
+{
+    rvjit_a64_bitfield(block, A64_SBFMW, hrds, hrs1, imm, 31);
+}
+
+static inline void rvjit32_native_srli(rvjit_block_t* block, regid_t hrds, regid_t hrs1, uint8_t imm)
+{
+    rvjit_a64_bitfield(block, A64_UBFMW, hrds, hrs1, imm, 31);
+}
+
+static inline void rvjit32_native_slli(rvjit_block_t* block, regid_t hrds, regid_t hrs1, uint8_t imm)
+{
+    rvjit_a64_bitfield(block, A64_UBFMW, hrds, hrs1, (-imm & 31), 31 - imm);
+}
+
+static inline void rvjit32_native_slti(rvjit_block_t* block, regid_t hrds, regid_t hrs1, int32_t imm)
+{
+    if (imm >= 0) {
+        rvjit_a64_addsub_imm(block, A64_SUBSIW, A64_WZR, hrs1, imm, false);
+        rvjit_a64_csel(block, A64_CSINCW, hrds, A64_WZR, A64_WZR, A64_LT ^ 1); // CSET pseudocode - invert cond
+    } else {
+        rvjit_a64_addsub_imm(block, A64_ADDSIW, A64_WZR, hrs1, -imm, false);
+        rvjit_a64_csel(block, A64_CSINCW, hrds, A64_WZR, A64_WZR, A64_LT ^ 1);
+    }
+}
+
+static inline void rvjit32_native_sltiu(rvjit_block_t* block, regid_t hrds, regid_t hrs1, int32_t imm)
+{
+    if (imm >= 0) {
+        rvjit_a64_addsub_imm(block, A64_SUBSIW, A64_WZR, hrs1, imm, false);
+        rvjit_a64_csel(block, A64_CSINCW, hrds, A64_WZR, A64_WZR, A64_CC ^ 1);
+    } else {
+        rvjit_a64_addsub_imm(block, A64_ADDSIW, A64_WZR, hrs1, -imm, false);
+        rvjit_a64_csel(block, A64_CSINCW, hrds, A64_WZR, A64_WZR, A64_CC ^ 1);
+    }
+}
+
+static inline void rvjit32_native_slt(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a64_addsub_shifted(block, A64_SUBSW, A64_WZR, hrs1, hrs2, A64_LSL, 0);
+    rvjit_a64_csel(block, A64_CSINCW, hrds, A64_WZR, A64_WZR, A64_LT ^ 1);
+}
+
+static inline void rvjit32_native_sltu(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a64_addsub_shifted(block, A64_SUBSW, A64_WZR, hrs1, hrs2, A64_LSL, 0);
+    rvjit_a64_csel(block, A64_CSINCW, hrds, A64_WZR, A64_WZR, A64_CC ^ 1);
+}
+
+static inline void rvjit32_native_lb(rvjit_block_t* block, regid_t dest, regid_t addr, int32_t off)
+{
+    rvjit_a64_mem_op(block, A64_LDRSBW, dest, addr, off);
+}
+
+static inline void rvjit32_native_lbu(rvjit_block_t* block, regid_t dest, regid_t addr, int32_t off)
+{
+    rvjit_a64_mem_op(block, A64_LDRB, dest, addr, off);
+}
+
+static inline void rvjit32_native_lh(rvjit_block_t* block, regid_t dest, regid_t addr, int32_t off)
+{
+    rvjit_a64_mem_op(block, A64_LDRSHW, dest, addr, off);
+}
+
+static inline void rvjit32_native_lhu(rvjit_block_t* block, regid_t dest, regid_t addr, int32_t off)
+{
+    rvjit_a64_mem_op(block, A64_LDRH, dest, addr, off);
+}
+
+static inline void rvjit32_native_lw(rvjit_block_t* block, regid_t dest, regid_t addr, int32_t off)
+{
+    rvjit_a64_mem_op(block, A64_LDRW, dest, addr, off);
+}
+
+static inline void rvjit32_native_sb(rvjit_block_t* block, regid_t src, regid_t addr, int32_t off)
+{
+    rvjit_a64_mem_op(block, A64_STRB, src, addr, off);
+}
+
+static inline void rvjit32_native_sh(rvjit_block_t* block, regid_t src, regid_t addr, int32_t off)
+{
+    rvjit_a64_mem_op(block, A64_STRH, src, addr, off);
+}
+
+static inline void rvjit32_native_sw(rvjit_block_t* block, regid_t src, regid_t addr, int32_t off)
+{
+    rvjit_a64_mem_op(block, A64_STRW, src, addr, off);
+}
+
+static inline branch_t rvjit32_native_beq(rvjit_block_t* block, regid_t hrs1, regid_t hrs2, branch_t handle, bool target)
+{
+    if (!target) rvjit_a64_addsub_shifted(block, A64_SUBSW, A64_WZR, hrs1, hrs2, A64_LSL, 0);
+    return rvjit_a64_bcc(block, A64_B_EQ, handle, target);
+}
+
+static inline branch_t rvjit32_native_bne(rvjit_block_t* block, regid_t hrs1, regid_t hrs2, branch_t handle, bool target)
+{
+    if (!target) rvjit_a64_addsub_shifted(block, A64_SUBSW, A64_WZR, hrs1, hrs2, A64_LSL, 0);
+    return rvjit_a64_bcc(block, A64_B_NE, handle, target);
+}
+
+static inline branch_t rvjit32_native_beqz(rvjit_block_t* block, regid_t hrs1, branch_t handle, bool target)
+{
+    return rvjit_a64_bcc(block, A64_CBZW | hrs1, handle, target);
+}
+
+static inline branch_t rvjit32_native_bnez(rvjit_block_t* block, regid_t hrs1, branch_t handle, bool target)
+{
+    return rvjit_a64_bcc(block, A64_CBNZW | hrs1, handle, target);
+}
+
+static inline branch_t rvjit32_native_blt(rvjit_block_t* block, regid_t hrs1, regid_t hrs2, branch_t handle, bool target)
+{
+    if (!target) rvjit_a64_addsub_shifted(block, A64_SUBSW, A64_WZR, hrs1, hrs2, A64_LSL, 0);
+    return rvjit_a64_bcc(block, A64_B_LT, handle, target);
+}
+
+static inline branch_t rvjit32_native_bge(rvjit_block_t* block, regid_t hrs1, regid_t hrs2, branch_t handle, bool target)
+{
+    if (!target) rvjit_a64_addsub_shifted(block, A64_SUBSW, A64_WZR, hrs1, hrs2, A64_LSL, 0);
+    return rvjit_a64_bcc(block, A64_B_GE, handle, target);
+}
+
+static inline branch_t rvjit32_native_bltu(rvjit_block_t* block, regid_t hrs1, regid_t hrs2, branch_t handle, bool target)
+{
+    if (!target) rvjit_a64_addsub_shifted(block, A64_SUBSW, A64_WZR, hrs1, hrs2, A64_LSL, 0);
+    return rvjit_a64_bcc(block, A64_B_CC, handle, target);
+}
+
+static inline branch_t rvjit32_native_bgeu(rvjit_block_t* block, regid_t hrs1, regid_t hrs2, branch_t handle, bool target)
+{
+    if (!target) rvjit_a64_addsub_shifted(block, A64_SUBSW, A64_WZR, hrs1, hrs2, A64_LSL, 0);
+    return rvjit_a64_bcc(block, A64_B_CS, handle, target);
+}
+
+/* RV64 */
+
+static inline void rvjit64_native_add(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a64_addsub_shifted(block, A64_ADD, hrds, hrs1, hrs2, A64_LSL, 0);
+}
+
+static inline void rvjit64_native_sub(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a64_addsub_shifted(block, A64_SUB, hrds, hrs1, hrs2, A64_LSL, 0);
+}
+
+static inline void rvjit64_native_addw(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a64_addsub_shifted(block, A64_ADDW, hrds, hrs1, hrs2, A64_LSL, 0);
+    rvjit_native_signext(block, hrds);
+}
+
+static inline void rvjit64_native_subw(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a64_addsub_shifted(block, A64_SUBW, hrds, hrs1, hrs2, A64_LSL, 0);
+    rvjit_native_signext(block, hrds);
+}
+
+static inline void rvjit64_native_or(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a64_logical_shifted(block, A64_ORR, hrds, hrs1, hrs2, A64_LSL, 0);
+}
+
+static inline void rvjit64_native_and(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a64_logical_shifted(block, A64_AND, hrds, hrs1, hrs2, A64_LSL, 0);
+}
+
+static inline void rvjit64_native_xor(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a64_logical_shifted(block, A64_EOR, hrds, hrs1, hrs2, A64_LSL, 0);
+}
+
+static inline void rvjit64_native_sra(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a64_dp_2src(block, A64_ASRV, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit64_native_srl(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a64_dp_2src(block, A64_LSRV, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit64_native_sll(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a64_dp_2src(block, A64_LSLV, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit64_native_sraw(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a64_dp_2src(block, A64_ASRVW, hrds, hrs1, hrs2);
+    rvjit_native_signext(block, hrds);
+}
+
+static inline void rvjit64_native_srlw(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a64_dp_2src(block, A64_LSRVW, hrds, hrs1, hrs2);
+    rvjit_native_signext(block, hrds);
+}
+
+static inline void rvjit64_native_sllw(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a64_dp_2src(block, A64_LSLVW, hrds, hrs1, hrs2);
+    rvjit_native_signext(block, hrds);
+}
+
+static inline void rvjit64_native_addi(rvjit_block_t* block, regid_t hrds, regid_t hrs1, int32_t imm)
+{
+    rvjit_a64_addi(block, hrds, hrs1, imm, true);
+}
+
+static inline void rvjit64_native_addiw(rvjit_block_t* block, regid_t hrds, regid_t hrs1, int32_t imm)
+{
+    rvjit32_native_addi(block, hrds, hrs1, imm);
+    rvjit_native_signext(block, hrds);
+}
+
+static inline void rvjit64_native_ori(rvjit_block_t* block, regid_t hrds, regid_t hrs1, int32_t imm)
+{
+    rvjit_a64_native_log_op64(block, A64_ORRI, hrds, hrs1, imm);
+}
+
+static inline void rvjit64_native_andi(rvjit_block_t* block, regid_t hrds, regid_t hrs1, int32_t imm)
+{
+    rvjit_a64_native_log_op64(block, A64_ANDI, hrds, hrs1, imm);
+}
+
+static inline void rvjit64_native_xori(rvjit_block_t* block, regid_t hrds, regid_t hrs1, int32_t imm)
+{
+    rvjit_a64_native_log_op64(block, A64_EORI, hrds, hrs1, imm);
+}
+
+static inline void rvjit64_native_srai(rvjit_block_t* block, regid_t hrds, regid_t hrs1, uint8_t imm)
+{
+    rvjit_a64_bitfield(block, A64_SBFM, hrds, hrs1, imm, 63);
+}
+
+static inline void rvjit64_native_srli(rvjit_block_t* block, regid_t hrds, regid_t hrs1, uint8_t imm)
+{
+    rvjit_a64_bitfield(block, A64_UBFM, hrds, hrs1, imm, 63);
+}
+
+static inline void rvjit64_native_slli(rvjit_block_t* block, regid_t hrds, regid_t hrs1, uint8_t imm)
+{
+    rvjit_a64_bitfield(block, A64_UBFM, hrds, hrs1, (-imm & 63), 63 - imm);
+}
+
+static inline void rvjit64_native_sraiw(rvjit_block_t* block, regid_t hrds, regid_t hrs1, uint8_t imm)
+{
+    rvjit_a64_bitfield(block, A64_SBFMW, hrds, hrs1, imm, 31);
+    rvjit_native_signext(block, hrds);
+}
+
+static inline void rvjit64_native_srliw(rvjit_block_t* block, regid_t hrds, regid_t hrs1, uint8_t imm)
+{
+    rvjit_a64_bitfield(block, A64_UBFMW, hrds, hrs1, imm, 31);
+    rvjit_native_signext(block, hrds);
+}
+
+static inline void rvjit64_native_slliw(rvjit_block_t* block, regid_t hrds, regid_t hrs1, uint8_t imm)
+{
+    rvjit_a64_bitfield(block, A64_UBFMW, hrds, hrs1, (-imm & 31), 31 - imm);
+    rvjit_native_signext(block, hrds);
+}
+
+static inline void rvjit64_native_slti(rvjit_block_t* block, regid_t hrds, regid_t hrs1, int32_t imm)
+{
+    if (imm >= 0) {
+        rvjit_a64_addsub_imm(block, A64_SUBSI, A64_WZR, hrs1, imm, false);
+        rvjit_a64_csel(block, A64_CSINC, hrds, A64_WZR, A64_WZR, A64_LT ^ 1); // CSET pseudocode - invert cond
+    } else {
+        rvjit_a64_addsub_imm(block, A64_ADDSI, A64_WZR, hrs1, -imm, false);
+        rvjit_a64_csel(block, A64_CSINC, hrds, A64_WZR, A64_WZR, A64_LT ^ 1);
+    }
+}
+
+static inline void rvjit64_native_sltiu(rvjit_block_t* block, regid_t hrds, regid_t hrs1, int32_t imm)
+{
+    if (imm >= 0) {
+        rvjit_a64_addsub_imm(block, A64_SUBSI, A64_WZR, hrs1, imm, false);
+        rvjit_a64_csel(block, A64_CSINC, hrds, A64_WZR, A64_WZR, A64_CC ^ 1);
+    } else {
+        rvjit_a64_addsub_imm(block, A64_ADDSI, A64_WZR, hrs1, -imm, false);
+        rvjit_a64_csel(block, A64_CSINC, hrds, A64_WZR, A64_WZR, A64_CC ^ 1);
+    }
+}
+
+static inline void rvjit64_native_slt(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a64_addsub_shifted(block, A64_SUBS, A64_WZR, hrs1, hrs2, A64_LSL, 0);
+    rvjit_a64_csel(block, A64_CSINC, hrds, A64_WZR, A64_WZR, A64_LT ^ 1);
+}
+
+static inline void rvjit64_native_sltu(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a64_addsub_shifted(block, A64_SUBS, A64_WZR, hrs1, hrs2, A64_LSL, 0);
+    rvjit_a64_csel(block, A64_CSINC, hrds, A64_WZR, A64_WZR, A64_CC ^ 1);
+}
+
+static inline void rvjit64_native_lb(rvjit_block_t* block, regid_t dest, regid_t addr, int32_t off)
+{
+    rvjit_a64_mem_op(block, A64_LDRSB, dest, addr, off);
+}
+
+static inline void rvjit64_native_lbu(rvjit_block_t* block, regid_t dest, regid_t addr, int32_t off)
+{
+    rvjit_a64_mem_op(block, A64_LDRB, dest, addr, off);
+}
+
+static inline void rvjit64_native_lh(rvjit_block_t* block, regid_t dest, regid_t addr, int32_t off)
+{
+    rvjit_a64_mem_op(block, A64_LDRSH, dest, addr, off);
+}
+
+static inline void rvjit64_native_lhu(rvjit_block_t* block, regid_t dest, regid_t addr, int32_t off)
+{
+    rvjit_a64_mem_op(block, A64_LDRH, dest, addr, off);
+}
+
+static inline void rvjit64_native_lw(rvjit_block_t* block, regid_t dest, regid_t addr, int32_t off)
+{
+    rvjit_a64_mem_op(block, A64_LDRSW, dest, addr, off);
+}
+
+static inline void rvjit64_native_lwu(rvjit_block_t* block, regid_t dest, regid_t addr, int32_t off)
+{
+    rvjit_a64_mem_op(block, A64_LDRW, dest, addr, off);
+}
+
+static inline void rvjit64_native_ld(rvjit_block_t* block, regid_t dest, regid_t addr, int32_t off)
+{
+    rvjit_a64_mem_op(block, A64_LDR, dest, addr, off);
+}
+
+static inline void rvjit64_native_sb(rvjit_block_t* block, regid_t src, regid_t addr, int32_t off)
+{
+    rvjit_a64_mem_op(block, A64_STRB, src, addr, off);
+}
+
+static inline void rvjit64_native_sh(rvjit_block_t* block, regid_t src, regid_t addr, int32_t off)
+{
+    rvjit_a64_mem_op(block, A64_STRH, src, addr, off);
+}
+
+static inline void rvjit64_native_sw(rvjit_block_t* block, regid_t src, regid_t addr, int32_t off)
+{
+    rvjit_a64_mem_op(block, A64_STRW, src, addr, off);
+}
+
+static inline void rvjit64_native_sd(rvjit_block_t* block, regid_t dest, regid_t addr, int32_t off)
+{
+    rvjit_a64_mem_op(block, A64_STR, dest, addr, off);
+}
+
+static inline branch_t rvjit64_native_beq(rvjit_block_t* block, regid_t hrs1, regid_t hrs2, branch_t handle, bool target)
+{
+    if (!target) rvjit_a64_addsub_shifted(block, A64_SUBS, A64_WZR, hrs1, hrs2, A64_LSL, 0);
+    return rvjit_a64_bcc(block, A64_B_EQ, handle, target);
+}
+
+static inline branch_t rvjit64_native_bne(rvjit_block_t* block, regid_t hrs1, regid_t hrs2, branch_t handle, bool target)
+{
+    if (!target) rvjit_a64_addsub_shifted(block, A64_SUBS, A64_WZR, hrs1, hrs2, A64_LSL, 0);
+    return rvjit_a64_bcc(block, A64_B_NE, handle, target);
+}
+
+static inline branch_t rvjit64_native_beqz(rvjit_block_t* block, regid_t hrs1, branch_t handle, bool target)
+{
+    return rvjit_a64_bcc(block, A64_CBZ | hrs1, handle, target);
+}
+
+static inline branch_t rvjit64_native_bnez(rvjit_block_t* block, regid_t hrs1, branch_t handle, bool target)
+{
+    return rvjit_a64_bcc(block, A64_CBNZ | hrs1, handle, target);
+}
+
+static inline branch_t rvjit64_native_blt(rvjit_block_t* block, regid_t hrs1, regid_t hrs2, branch_t handle, bool target)
+{
+    if (!target) rvjit_a64_addsub_shifted(block, A64_SUBS, A64_WZR, hrs1, hrs2, A64_LSL, 0);
+    return rvjit_a64_bcc(block, A64_B_LT, handle, target);
+}
+
+static inline branch_t rvjit64_native_bge(rvjit_block_t* block, regid_t hrs1, regid_t hrs2, branch_t handle, bool target)
+{
+    if (!target) rvjit_a64_addsub_shifted(block, A64_SUBS, A64_WZR, hrs1, hrs2, A64_LSL, 0);
+    return rvjit_a64_bcc(block, A64_B_GE, handle, target);
+}
+
+static inline branch_t rvjit64_native_bltu(rvjit_block_t* block, regid_t hrs1, regid_t hrs2, branch_t handle, bool target)
+{
+    if (!target) rvjit_a64_addsub_shifted(block, A64_SUBS, A64_WZR, hrs1, hrs2, A64_LSL, 0);
+    return rvjit_a64_bcc(block, A64_B_CC, handle, target);
+}
+
+static inline branch_t rvjit64_native_bgeu(rvjit_block_t* block, regid_t hrs1, regid_t hrs2, branch_t handle, bool target)
+{
+    if (!target) rvjit_a64_addsub_shifted(block, A64_SUBS, A64_WZR, hrs1, hrs2, A64_LSL, 0);
+    return rvjit_a64_bcc(block, A64_B_CS, handle, target);
+}
+
+// Multiply / Divide
+
+static inline void rvjit_a64_native_div(rvjit_block_t* block, enum a64_dp_2src divopc, bool is32bit, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    branch_t ifzero = rvjit64_native_beqz(block, hrs2, BRANCH_NEW, false);
+
+    regid_t hrmostneg = rvjit_claim_hreg(block);
+    rvjit_a64_movw(block, is32bit ? A64_MOVNW : A64_MOVN, hrmostneg, 0, A64_MOV_0);
+    branch_t ifmin1 = rvjit64_native_bne(block, hrs2, hrmostneg, BRANCH_NEW, false);
+
+    if (!(divopc & (1u << 31))) {
+        rvjit_native_setregw(block, hrmostneg, (uintptr_t)1 << 63);
+    } else {
+        rvjit_a64_movw(block, is32bit ? A64_MOVZW : A64_MOVZ, hrmostneg, 1 << 15, A64_MOV_16);
+        if (!is32bit) rvjit_native_signext(block, hrmostneg);
+    }
+    branch_t ifmin2 = rvjit64_native_bne(block, hrs1, hrmostneg, BRANCH_NEW, false);
+
+    rvjit_a64_addsub_shifted(block, is32bit ? A64_ADDW : A64_ADD, hrds, hrmostneg, A64_XZR, A64_LSL, 0);
+    branch_t skipdiv = rvjit_native_jmp(block, BRANCH_NEW, false);
+
+    rvjit64_native_bne(block, hrs2, hrmostneg, ifmin1, true);
+    rvjit64_native_bne(block, hrs2, hrmostneg, ifmin2, true);
+    rvjit_a64_dp_2src(block, divopc, hrds, hrs1, hrs2);
+    if (!is32bit && !(divopc & (1u << 31))) {
+        rvjit_native_signext(block, hrds);
+    }
+
+    rvjit_native_jmp(block, skipdiv, true);
+    rvjit_free_hreg(block, hrmostneg);
+    branch_t toend = rvjit_native_jmp(block, BRANCH_NEW, false);
+    rvjit64_native_beqz(block, hrs2, ifzero, true);
+    rvjit_a64_movw(block, is32bit ? A64_MOVNW : A64_MOVN, hrds, 0, A64_MOV_0);
+    rvjit_native_jmp(block, toend, true);
+}
+
+static inline void rvjit_a64_native_divu(rvjit_block_t* block, enum a64_dp_2src divopc, bool is32bit, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    branch_t ifzero = rvjit64_native_beqz(block, hrs2, BRANCH_NEW, false);
+
+    rvjit_a64_dp_2src(block, divopc, hrds, hrs1, hrs2);
+    if (!is32bit && !(divopc & (1u << 31))) {
+        rvjit_native_signext(block, hrds);
+    }
+
+    branch_t toend = rvjit_native_jmp(block, BRANCH_NEW, false);
+    rvjit64_native_beqz(block, hrs2, ifzero, true);
+    rvjit_a64_movw(block, A64_MOVN, hrds, 0, A64_MOV_0);
+    rvjit_native_jmp(block, toend, true);
+}
+
+static inline void rvjit_a64_native_rem(rvjit_block_t* block, enum a64_dp_2src divopc, enum a64_dp_3src mulopc, bool is32bit, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    branch_t ifzero = rvjit64_native_beqz(block, hrs2, BRANCH_NEW, false);
+
+    regid_t hrmostneg = rvjit_claim_hreg(block);
+    rvjit_a64_movw(block, is32bit ? A64_MOVNW : A64_MOVN, hrmostneg, 0, A64_MOV_0);
+    branch_t ifmin1 = rvjit64_native_bne(block, hrs2, hrmostneg, BRANCH_NEW, false);
+
+    if (!(divopc & (1u << 31))) {
+        rvjit_native_setregw(block, hrmostneg, (uintptr_t)1 << 63);
+    } else {
+        rvjit_a64_movw(block, is32bit ? A64_MOVZW : A64_MOVZ, hrmostneg, 1 << 15, A64_MOV_16);
+        if (!is32bit) rvjit_native_signext(block, hrmostneg);
+    }
+    branch_t ifmin2 = rvjit64_native_bne(block, hrs1, hrmostneg, BRANCH_NEW, false);
+
+    rvjit_native_zero_reg(block, hrds);
+    branch_t skipdiv = rvjit_native_jmp(block, BRANCH_NEW, false);
+
+    rvjit64_native_bne(block, hrs2, hrmostneg, ifmin1, true);
+    rvjit64_native_bne(block, hrs2, hrmostneg, ifmin2, true);
+
+    rvjit_a64_dp_2src(block, divopc, hrmostneg, hrs1, hrs2);
+    rvjit_a64_dp_3src(block, mulopc, hrds, hrmostneg, hrs2, hrs1);
+    if (!is32bit && !(divopc & (1u << 31))) {
+        rvjit_native_signext(block, hrds);
+    }
+
+    rvjit_native_jmp(block, skipdiv, true);
+    rvjit_free_hreg(block, hrmostneg);
+    branch_t toend = rvjit_native_jmp(block, BRANCH_NEW, false);
+    rvjit64_native_beqz(block, hrs2, ifzero, true);
+    rvjit_a64_addsub_shifted(block, is32bit ? A64_ADDW : A64_ADD, hrds, hrs1, A64_XZR, A64_LSL, 0);
+    rvjit_native_jmp(block, toend, true);
+}
+
+static inline void rvjit64_native_mul(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a64_dp_3src(block, A64_MADD, hrds, hrs1, hrs2, A64_XZR);
+}
+
+static inline void rvjit64_native_mulh(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a64_dp_3src(block, A64_SMULH, hrds, hrs1, hrs2, A64_XZR);
+}
+
+static inline void rvjit64_native_mulhu(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a64_dp_3src(block, A64_UMULH, hrds, hrs1, hrs2, A64_XZR);
+}
+
+static inline void rvjit64_native_mulhsu(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    regid_t hrs1h = rvjit_claim_hreg(block);
+    rvjit64_native_srai(block, hrs1h, hrs1, 63);
+    regid_t hrdsu = rvjit_claim_hreg(block);
+    rvjit64_native_mulhu(block, hrdsu, hrs2, hrs1);
+    rvjit_a64_dp_3src(block, A64_MADD, hrds, hrs2, hrs1h, hrdsu);
+    rvjit_free_hreg(block, hrs1h);
+    rvjit_free_hreg(block, hrdsu);
+}
+
+static inline void rvjit64_native_div(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a64_native_div(block, A64_SDIV, false, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit64_native_divu(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a64_native_divu(block, A64_UDIV, false, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit64_native_rem(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a64_native_rem(block, A64_SDIV, A64_MSUB, false, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit64_native_remu(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a64_native_rem(block, A64_UDIV, A64_MSUB, false, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit64_native_mulw(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a64_dp_3src(block, A64_MADDW, hrds, hrs1, hrs2, A64_XZR);
+    rvjit_native_signext(block, hrds);
+}
+
+static inline void rvjit64_native_divw(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a64_native_div(block, A64_SDIVW, false, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit64_native_divuw(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a64_native_divu(block, A64_UDIVW, false, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit64_native_remw(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a64_native_rem(block, A64_SDIVW, A64_MSUBW, false, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit64_native_remuw(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a64_native_rem(block, A64_UDIVW, A64_MSUBW, false, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit32_native_mul(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a64_dp_3src(block, A64_MADDW, hrds, hrs1, hrs2, A64_XZR);
+}
+
+static inline void rvjit32_native_mulh(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a64_dp_3src(block, A64_SMADDL, hrds, hrs1, hrs2, A64_XZR);
+    rvjit64_native_srli(block, hrds, hrds, 32);
+}
+
+static inline void rvjit32_native_mulhu(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a64_dp_3src(block, A64_UMADDL, hrds, hrs1, hrs2, A64_XZR);
+    rvjit64_native_srli(block, hrds, hrds, 32);
+}
+
+static inline void rvjit32_native_mulhsu(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    regid_t hrsext = rvjit_claim_hreg(block);
+    rvjit_a64_bitfield(block, A64_SBFM, hrsext, hrs1, 0, 31);
+    regid_t hrzext = rvjit_claim_hreg(block);
+    rvjit_a64_addsub_shifted(block, A64_ADDW, hrzext, hrs2, A64_XZR, A64_LSL, 0);
+    rvjit64_native_mul(block, hrsext, hrzext, hrsext);
+    rvjit64_native_srli(block, hrds, hrsext, 32);
+    rvjit_free_hreg(block, hrsext);
+    rvjit_free_hreg(block, hrzext);
+}
+
+static inline void rvjit32_native_div(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a64_native_div(block, A64_SDIVW, true, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit32_native_divu(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a64_native_divu(block, A64_UDIVW, true, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit32_native_rem(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a64_native_rem(block, A64_SDIVW, A64_MSUB, true, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit32_native_remu(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_a64_native_rem(block, A64_UDIVW, A64_MSUB, true, hrds, hrs1, hrs2);
+}
+
+/*
+* Linker routines
+*/
+
+static inline bool rvjit_a64_valid_reloc(int32_t offset)
+{
+    return check_imm_bits(offset, 28) && (offset & 0x3) == 0;
+}
+
+// Emit jump instruction (may return false if offset cannot be encoded)
+static inline bool rvjit_tail_jmp(rvjit_block_t* block, int32_t offset)
+{
+    if (rvjit_a64_valid_reloc(offset)) {
+        rvjit_a64_b(block, offset);
+        return true;
+    }
+    return false;
+}
+
+// Emit patchable ret instruction
+static inline void rvjit_patchable_ret(rvjit_block_t* block)
+{
+    // Always 4-bytes, same as jmp
+    rvjit_native_ret(block);
+}
+
+// Jump if word pointed to by addr is nonzero (may emit nothing if the offset cannot be encoded)
+// Used to check interrupts in block linkage
+static inline void rvjit_tail_bnez(rvjit_block_t* block, regid_t addr, int32_t offset)
+{
+    size_t offset_fixup = block->size;
+    int32_t off;
+    regid_t tmp = rvjit_claim_hreg(block);
+    rvjit32_native_lw(block, tmp, addr, 0);
+
+    off = offset - (block->size - offset_fixup);
+    if (rvjit_is_valid_branch_imm(off)) {
+        // Offset fits into branch instruction
+        rvjit_a64_b_cond(block, A64_CBNZW | tmp, off);
+    } else {
+        // Use A64_B for 28-bit offset
+        branch_t l1 = rvjit32_native_beqz(block, tmp, BRANCH_NEW, false);
+        off = offset - (block->size - offset_fixup);
+        if (rvjit_a64_valid_reloc(off)) {
+            rvjit_a64_b(block, off);
+        } else {
+            rvvm_warn("Unimplemented 32-bit relative jump in ARM64 RVJIT backend!");
+        }
+        rvjit32_native_beqz(block, tmp, l1, true);
+    }
+
+    rvjit_free_hreg(block, tmp);
+}
+
+// Patch instruction at addr into ret
+static inline void rvjit_patch_ret(void* addr)
+{
+    write_uint32_le_m(addr, 0xD65F03C0);
+}
+
+// Patch jump instruction at addr (may return false if offset cannot be encoded)
+static inline bool rvjit_patch_jmp(void* addr, int32_t offset)
+{
+    if (rvjit_a64_valid_reloc(offset)) {
+        write_uint32_le_m(addr, 0);
+        rvjit_a64_b_reloc(addr, offset);
+        return true;
+    }
+    return false;
+}
+
+static inline void rvjit_jmp_reg(rvjit_block_t* block, regid_t reg)
+{
+    rvjit_a64_insn32(block, 0xD61F0000 | (reg << 5));
+}
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/rvjit/rvjit_emit.c b/app/src/main/java/libengine/RVVM/src/rvjit/rvjit_emit.c
new file mode 100644
index 00000000..7b3098c9
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/rvjit/rvjit_emit.c
@@ -0,0 +1,925 @@
+/*
+rvjit_emit.c - Retargetable Versatile JIT Compiler
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "rvjit_emit.h"
+#include "../rvvm.h"
+#include "../bit_ops.h"
+
+#ifdef RVJIT_X86
+#include "rvjit_x86.h"
+#elif  RVJIT_RISCV
+#include "rvjit_riscv.h"
+#elif  RVJIT_ARM64
+#include "rvjit_arm64.h"
+#elif  RVJIT_ARM
+#include "rvjit_arm.h"
+#endif
+
+#define REG_SRC    0x1
+#define REG_DST    0x2
+#define REG_AUIPC  0x4
+
+#define REG_LOADED REG_SRC
+#define REG_DIRTY  REG_DST
+
+// RVVM-specific configuration
+
+#define VM_REG_OFFSET(reg) (offsetof(rvvm_hart_t, registers) + (sizeof(maxlen_t) * reg))
+#define VM_TLB_OFFSET      offsetof(rvvm_hart_t, tlb)
+#define VM_TLB_MASK        (TLB_SIZE-1)
+#define VM_TLB_R           offsetof(rvvm_tlb_entry_t, r)
+#define VM_TLB_W           offsetof(rvvm_tlb_entry_t, w)
+#define VM_TLB_E           offsetof(rvvm_tlb_entry_t, e)
+
+#if defined(USE_RV64) || defined(RVJIT_NATIVE_64BIT)
+#define VM_TLB_SHIFT 5
+#else
+#define VM_TLB_SHIFT 4
+#endif
+
+void rvjit_emit_init(rvjit_block_t* block)
+{
+    block->hreg_mask = rvjit_native_default_hregmask();
+    block->abireclaim_mask = 0;
+    for (regid_t i=0; i<RVJIT_REGISTERS; ++i) {
+        block->regs[i].hreg = REG_ILL;
+        block->regs[i].last_used = 0;
+        block->regs[i].flags = 0;
+    }
+}
+
+static void rvjit_load_reg(rvjit_block_t* block, regid_t reg)
+{
+    if (block->regs[reg].hreg != REG_ILL) {
+#ifdef RVJIT_NATIVE_64BIT
+        if (block->rv64) {
+            rvjit64_native_ld(block, block->regs[reg].hreg, VM_PTR_REG, VM_REG_OFFSET(reg));
+        } else {
+            rvjit32_native_lw(block, block->regs[reg].hreg, VM_PTR_REG, VM_REG_OFFSET(reg));
+        }
+#else
+        rvjit32_native_lw(block, block->regs[reg].hreg, VM_PTR_REG, VM_REG_OFFSET(reg));
+#endif
+    }
+}
+
+static void rvjit_save_reg(rvjit_block_t* block, regid_t reg)
+{
+    if (block->regs[reg].hreg != REG_ILL) {
+        if (block->regs[reg].flags & REG_DIRTY) {
+            if (reg != RVJIT_REGISTER_ZERO) {
+#ifdef RVJIT_NATIVE_64BIT
+                if (block->rv64) {
+                    rvjit64_native_sd(block, block->regs[reg].hreg, VM_PTR_REG, VM_REG_OFFSET(reg));
+                } else {
+                    rvjit32_native_sw(block, block->regs[reg].hreg, VM_PTR_REG, VM_REG_OFFSET(reg));
+                }
+#else
+                rvjit32_native_sw(block, block->regs[reg].hreg, VM_PTR_REG, VM_REG_OFFSET(reg));
+#endif
+            }
+        }
+    }
+}
+
+static void rvjit_free_reg(rvjit_block_t* block, regid_t reg)
+{
+    if (block->regs[reg].hreg != REG_ILL) {
+        rvjit_save_reg(block, reg);
+        rvjit_free_hreg(block, block->regs[reg].hreg);
+        block->regs[reg].hreg = REG_ILL;
+    }
+}
+
+static regid_t rvjit_reclaim_hreg(rvjit_block_t* block)
+{
+    // If we have any registers clobbered by ABI we can reuse them
+    if (block->abireclaim_mask != rvjit_native_abireclaim_hregmask()) {
+        for (regid_t i=0; i<RVJIT_REGISTERS; ++i) {
+            if ((block->abireclaim_mask & rvjit_hreg_mask(i)) !=
+            (rvjit_native_abireclaim_hregmask() & rvjit_hreg_mask(i))) {
+                block->abireclaim_mask |= rvjit_hreg_mask(i);
+                rvjit_native_push(block, i);
+                return i;
+            }
+        }
+    }
+    // Reclaim least recently used register mapping
+    regid_t greg = 0, hreg;
+    size_t lru = (size_t)-1;
+    for (regid_t i=0; i<RVJIT_REGISTERS; ++i) {
+        if (block->regs[i].hreg != REG_ILL && block->regs[i].last_used < lru) {
+            lru = block->regs[i].last_used;
+            greg = i;
+        }
+    }
+    if (unlikely(lru == (size_t)-1)) {
+        rvvm_fatal("No reclaimable RVJIT registers!");
+    }
+    hreg = block->regs[greg].hreg;
+    rvjit_free_reg(block, greg);
+    block->hreg_mask &= ~rvjit_hreg_mask(hreg);
+    return hreg;
+}
+
+static inline regid_t rvjit_try_claim_hreg(rvjit_block_t* block)
+{
+    if (block->hreg_mask) {
+        regid_t reg = bit_clz32(block->hreg_mask) ^ 31;
+        block->hreg_mask &= ~rvjit_hreg_mask(reg);
+        return reg;
+    }
+    return REG_ILL;
+}
+
+regid_t rvjit_claim_hreg(rvjit_block_t* block)
+{
+    regid_t hreg = rvjit_try_claim_hreg(block);
+    // No free host registers
+    if (hreg == REG_ILL) {
+        hreg = rvjit_reclaim_hreg(block);
+    }
+    return hreg;
+}
+
+// Maps virtual register to hardware register
+static regid_t rvjit_map_reg(rvjit_block_t* block, regid_t greg, regflags_t flags)
+{
+    if (unlikely(greg >= RVJIT_REGISTERS)) {
+        rvvm_fatal("Mapped RVJIT register is out of range!");
+        return REG_ILL;
+    }
+#if defined(RVJIT_RISCV)
+    if (greg == RVJIT_REGISTER_ZERO) return 0;
+#elif defined(RVJIT_ARM64)
+    if (greg == RVJIT_REGISTER_ZERO) return 31;
+#endif
+    if (block->regs[greg].hreg == REG_ILL) {
+        regid_t hreg = rvjit_claim_hreg(block);
+        block->regs[greg].hreg = hreg;
+        block->regs[greg].flags = 0;
+    }
+    block->regs[greg].last_used = block->size;
+#if !defined(RVJIT_RISCV) && !defined(RVJIT_ARM64)
+    if (greg == RVJIT_REGISTER_ZERO) {
+        if (!(block->regs[greg].flags & REG_LOADED) || (block->regs[greg].flags & REG_DIRTY)) {
+            rvjit_native_zero_reg(block, block->regs[greg].hreg);
+        }
+        block->regs[greg].flags = REG_LOADED;
+    }
+#endif
+
+    if (flags & REG_DST) {
+        block->regs[greg].flags |= REG_DIRTY;
+        block->regs[greg].flags &= ~REG_AUIPC;
+    }
+    if ((flags & REG_SRC) && !(block->regs[greg].flags & (REG_LOADED | REG_DIRTY))) {
+        block->regs[greg].flags |= REG_LOADED;
+        rvjit_load_reg(block, greg);
+    }
+    return block->regs[greg].hreg;
+}
+
+static void rvjit_update_vm_pc(rvjit_block_t* block)
+{
+    if (block->pc_off == 0) return;
+#ifdef RVJIT_X86
+    rvjit_x86_memref_addi(block, VM_PTR_REG, offsetof(rvvm_hart_t, registers[REGISTER_PC]), block->pc_off, block->rv64);
+#else
+    regid_t pc = rvjit_claim_hreg(block);
+#ifdef RVJIT_NATIVE_64BIT
+    if (block->rv64) {
+        rvjit64_native_ld(block, pc, VM_PTR_REG, offsetof(rvvm_hart_t, registers[REGISTER_PC]));
+        rvjit64_native_addi(block, pc, pc, block->pc_off);
+        rvjit64_native_sd(block, pc, VM_PTR_REG, offsetof(rvvm_hart_t, registers[REGISTER_PC]));
+    } else
+#endif
+    {
+        rvjit32_native_lw(block, pc, VM_PTR_REG, offsetof(rvvm_hart_t, registers[REGISTER_PC]));
+        rvjit32_native_addi(block, pc, pc, block->pc_off);
+        rvjit32_native_sw(block, pc, VM_PTR_REG, offsetof(rvvm_hart_t, registers[REGISTER_PC]));
+    }
+    rvjit_free_hreg(block, pc);
+#endif
+}
+
+//#define RVJIT_LOOKUP_TAILCALL
+
+#ifdef RVJIT_LOOKUP_TAILCALL
+
+#include "riscv_mmu.h"
+#include "riscv_cpu.h"
+
+/*
+ * It's possible to offload the lookup to C code and call it from JIT.
+ * This is shorter as well (~1% of JIT cache used for lookups vs ~5%),
+ * and allows hashmap lookups which might be beneficial,
+ * but it's slightly slower for hot calls.
+ *
+ * ! Experimental stuff !
+ */
+
+RVJIT_CALL static void rvjit_tail_lookup(rvvm_hart_t* vm)
+{
+    size_t pc, tpc, entry, phys_pc;
+    rvjit_func_t block;
+    pc = vm->registers[REGISTER_PC];
+    entry = (pc >> 1) & (TLB_SIZE - 1);
+    tpc = vm->jtlb[entry].pc;
+    if (likely(vm->wait_event)) {
+        if (false && likely(pc == tpc)) {
+            // This *should* optimize into tail call,
+            // but that's not guaranteed...
+            vm->jtlb[entry].block(vm);
+        } else {
+            vmptr_t ptr = riscv_vma_translate_e(vm, pc);
+            if (ptr) {
+                phys_pc = (size_t)(ptr - vm->mem.data) + vm->mem.begin;
+                block = rvjit_block_lookup(&vm->jit, phys_pc);
+                if (block) {
+                    vm->jtlb[entry].pc = pc;
+                    vm->jtlb[entry].block = block;
+                    block(vm);
+                }
+            }
+        }
+    }
+}
+
+#endif
+
+static void rvjit_lookup_block(rvjit_block_t* block)
+{
+#ifdef RVJIT_NATIVE_LINKER
+
+#ifdef RVJIT_LOOKUP_TAILCALL
+    regid_t reg = rvjit_claim_hreg(block);
+    rvjit_native_setregw(block, reg, (size_t)rvjit_tail_lookup);
+    rvjit_jmp_reg(block, reg);
+    rvjit_free_hreg(block, reg);
+#elif defined(RVJIT_X86) && defined(RVJIT_NATIVE_64BIT)
+/*
+ * For future reference:
+ * Hand-optimized inline lookup for x86_64 and i386, uses memrefs and other CISC stuff.
+ * Since i386 doesn't have enough registers for RVJIT IR lookup, this is the only way there.
+ *
+    mov rdx, QWORD PTR [rdi+0x108]
+    mov eax, edx
+    sal eax, 3
+    and eax, 0xff0
+    add rax, rdi
+    cmp QWORD PTR [rax+0x2220], rdx
+    jne L1
+    cmp DWORD PTR [rdi], 0
+    je  L1
+    jmp QWORD PTR [rax+0x2218]
+    L1:
+    ret
+ * While RVJIT would compile the IR to:
+    mov rax, QWORD PTR [rdi+0x108]
+    mov ecx, eax
+    shl ecx, 0x3
+    and ecx, 0xff0
+    add rcx, rdi
+    mov rdx, QWORD PTR [rcx+0x2220]
+    cmp rdx, rax
+    jne L1
+    mov edx, DWORD PTR [rdi]
+    cmp edx, 0x0
+    je  L1
+    mov rax, QWORD PTR [rcx+0x2218]
+    jmp rax
+    L1:
+    ret
+ */
+    uint8_t code[41] = {0x48, 0x8B, 0x90, 0x08, 0x01, 0x00, 0x00, 0x89,
+        0xD0, 0xC1, 0xE0, 0x03, 0x25, 0xF0, 0x0F, 0x00, 0x00, 0x48, 0x01,
+        0xC0, 0x48, 0x39, 0x90, 0x20, 0x22, 0x00, 0x00, 0x75, 0x0B, 0x83,
+        0x38, 0x00, 0x74, 0x06, 0xFF, 0xA0, 0x18, 0x22, 0x00, 0x00, 0xC3};
+    code[2] |= VM_PTR_REG;
+    code[19] |= (VM_PTR_REG << 3);
+    code[30] |= VM_PTR_REG;
+    write_uint32_le_m(code + 3, offsetof(rvvm_hart_t, registers[REGISTER_PC]));
+    code[11] = VM_TLB_SHIFT - 2;
+    write_uint32_le_m(code + 13, VM_TLB_MASK << (VM_TLB_SHIFT - 1));
+    write_uint32_le_m(code + 23, offsetof(rvvm_hart_t, jtlb) + offsetof(rvvm_jtlb_entry_t, pc));
+    write_uint32_le_m(code + 36, offsetof(rvvm_hart_t, jtlb) + offsetof(rvvm_jtlb_entry_t, block));
+    rvjit_put_code(block, code, sizeof(code));
+#elif defined(RVJIT_X86) && defined(RVJIT_ABI_FASTCALL)
+    uint8_t code[38] = {0x8B, 0x91, 0x04, 0x01, 0x00, 0x00, 0x89, 0xD0,
+        0xC1, 0xE0, 0x03, 0x25, 0xF0, 0x0F, 0x00, 0x00, 0x01, 0xC8, 0x39,
+        0x90, 0x1C, 0x22, 0x00, 0x00, 0x75, 0x0B, 0x83, 0x39, 0x00, 0x74,
+        0x06, 0xFF, 0xA0, 0x14, 0x22, 0x00, 0x00, 0xC3};
+    write_uint32_le_m(code + 2, offsetof(rvvm_hart_t, registers[REGISTER_PC]));
+    code[10] = VM_TLB_SHIFT - 2;
+    write_uint32_le_m(code + 12, VM_TLB_MASK << (VM_TLB_SHIFT - 1));
+    write_uint32_le_m(code + 20, offsetof(rvvm_hart_t, jtlb) + offsetof(rvvm_jtlb_entry_t, pc));
+    write_uint32_le_m(code + 33, offsetof(rvvm_hart_t, jtlb) + offsetof(rvvm_jtlb_entry_t, block));
+    rvjit_put_code(block, code, sizeof(code));
+#else
+    regid_t pc = rvjit_try_claim_hreg(block);
+    regid_t tpc = rvjit_try_claim_hreg(block);
+    regid_t cpc = rvjit_try_claim_hreg(block);
+
+    static bool allow_ir_lookup = true;
+    if (!allow_ir_lookup || pc == REG_ILL || tpc == REG_ILL || cpc == REG_ILL) {
+        if (allow_ir_lookup) {
+            allow_ir_lookup = false;
+            // This is usually the case on i386
+            rvvm_warn("Insufficient RVJIT registers for IR-based block lookup");
+        }
+        rvjit_native_ret(block);
+        return;
+    }
+
+#if defined(RVJIT_NATIVE_64BIT) && defined(USE_RV64)
+    rvjit64_native_ld(block, pc, VM_PTR_REG, offsetof(rvvm_hart_t, registers[REGISTER_PC]));
+#else
+    rvjit32_native_lw(block, pc, VM_PTR_REG, offsetof(rvvm_hart_t, registers[REGISTER_PC]));
+#endif
+
+#if defined(RVJIT_X86) || defined(RVJIT_ARM64)
+    // x86 & ARM64 can carry big mask immediate without spilling
+    rvjit32_native_slli(block, tpc, pc, VM_TLB_SHIFT - 2);
+    rvjit32_native_andi(block, tpc, tpc, VM_TLB_MASK << (VM_TLB_SHIFT - 1));
+#else
+    rvjit32_native_srli(block, tpc, pc, 1);
+    rvjit32_native_andi(block, tpc, tpc, VM_TLB_MASK);
+    rvjit32_native_slli(block, tpc, tpc, VM_TLB_SHIFT - 1);
+#endif
+
+#ifdef RVJIT_NATIVE_64BIT
+    rvjit64_native_add(block, tpc, tpc, VM_PTR_REG);
+#else
+    rvjit32_native_add(block, tpc, tpc, VM_PTR_REG);
+#endif
+#if defined(RVJIT_NATIVE_64BIT) && defined(USE_RV64)
+    rvjit64_native_ld(block, cpc, tpc, offsetof(rvvm_hart_t, jtlb) + offsetof(rvvm_jtlb_entry_t, pc));
+    branch_t l1 = rvjit64_native_bne(block, cpc, pc, BRANCH_NEW, false);
+#else
+    rvjit32_native_lw(block, cpc, tpc, offsetof(rvvm_hart_t, jtlb) + offsetof(rvvm_jtlb_entry_t, pc));
+    branch_t l1 = rvjit32_native_bne(block, cpc, pc, BRANCH_NEW, false);
+#endif
+    rvjit32_native_lw(block, cpc, VM_PTR_REG, 0);
+    branch_t l2 = rvjit32_native_beqz(block, cpc, BRANCH_NEW, false);
+#ifdef RVJIT_NATIVE_64BIT
+    rvjit64_native_ld(block, pc, tpc, offsetof(rvvm_hart_t, jtlb) + offsetof(rvvm_jtlb_entry_t, block));
+#else
+    rvjit32_native_lw(block, pc, tpc, offsetof(rvvm_hart_t, jtlb) + offsetof(rvvm_jtlb_entry_t, block));
+#endif
+    rvjit_jmp_reg(block, pc);
+#if defined(RVJIT_NATIVE_64BIT) && defined(USE_RV64)
+    rvjit64_native_bne(block, cpc, pc, l1, true);
+#else
+    rvjit32_native_bne(block, cpc, pc, l1, true);
+#endif
+    rvjit32_native_beqz(block, cpc, l2, true);
+    rvjit_native_ret(block);
+
+    rvjit_free_hreg(block, pc);
+    rvjit_free_hreg(block, tpc);
+    rvjit_free_hreg(block, cpc);
+#endif
+
+#else
+    rvjit_native_ret(block);
+#endif
+}
+
+static void rvjit_link_block(rvjit_block_t* block)
+{
+#ifdef RVJIT_NATIVE_LINKER
+    phys_addr_t next_pc = block->phys_pc + block->pc_off;
+    size_t exit_ptr = (size_t)(block->heap.data + block->heap.curr + block->size);
+    size_t next_block;
+    if (next_pc == block->phys_pc) {
+        next_block = (size_t)(block->heap.data + block->heap.curr);
+    } else {
+        next_block = hashmap_get(&block->heap.blocks, next_pc);
+        if (next_block && block->heap.code) {
+            next_block += (size_t)(block->heap.data) - (size_t)(block->heap.code);
+        }
+    }
+
+    if ((next_pc >> 12) == (block->phys_pc >> 12)) {
+        if (next_block) {
+            rvjit_tail_bnez(block, VM_PTR_REG, next_block - exit_ptr);
+            //rvjit_tail_jmp(block, next_block - exit_ptr);
+        } else {
+            rvjit_patchable_ret(block);
+            vector_emplace_back(block->links);
+            vector_at(block->links, vector_size(block->links) - 1).dest = next_pc;
+            vector_at(block->links, vector_size(block->links) - 1).ptr = exit_ptr;
+            return;
+        }
+    } else {
+        rvjit_lookup_block(block);
+        return;
+    }
+#endif
+    rvjit_native_ret(block);
+}
+
+void rvjit_linker_patch_jmp(void* addr, int32_t offset)
+{
+#ifdef RVJIT_NATIVE_LINKER
+    rvjit_patch_jmp(addr, offset);
+#else
+    UNUSED(addr);
+    UNUSED(offset);
+#endif
+}
+
+void rvjit_linker_patch_ret(void* addr)
+{
+#ifdef RVJIT_NATIVE_LINKER
+    rvjit_patch_ret(addr);
+#else
+    UNUSED(addr);
+#endif
+}
+
+void rvjit_emit_end(rvjit_block_t* block, uint8_t linkage)
+{
+    size_t hreg_mask = block->hreg_mask;
+    size_t abireclaim_mask = block->abireclaim_mask;
+
+    // Save allocated native registers into VM context
+    for (regid_t i=0; i<RVJIT_REGISTERS; ++i) {
+        rvjit_save_reg(block, i);
+    }
+
+    block->hreg_mask = rvjit_native_default_hregmask();
+    rvjit_update_vm_pc(block);
+
+    // Recover clobbered registers
+    for (regid_t i=RVJIT_REGISTERS; i>0; --i) {
+        if (block->abireclaim_mask & rvjit_hreg_mask(i-1)) {
+            rvjit_native_pop(block, i-1);
+        }
+    }
+
+    switch (linkage) {
+        case LINKAGE_JMP:
+            rvjit_link_block(block);
+            break;
+        case LINKAGE_TAIL:
+            rvjit_lookup_block(block);
+            break;
+        default:
+            rvjit_native_ret(block);
+            break;
+    }
+
+    block->hreg_mask = hreg_mask;
+    block->abireclaim_mask = abireclaim_mask;
+}
+
+/*
+ * Important: REG_DST (destination) registers should be mapped at the end,
+ * otherwise nasty errors occur, this simplifies register remapping
+ */
+
+/*
+ * ALU Register-Register intrinsics
+ */
+
+#define RVJIT_3REG_OP(native_func, rds, rs1, rs2) { \
+    if (rds == RVJIT_REGISTER_ZERO) return; \
+    regid_t hrs1 = rvjit_map_reg(block, rs1, REG_SRC); \
+    regid_t hrs2 = rvjit_map_reg(block, rs2, REG_SRC); \
+    regid_t hrds = rvjit_map_reg(block, rds, REG_DST); \
+    native_func(block, hrds, hrs1, hrs2); }
+
+#define RVJIT_2REG_IMM_OP(native_func, rds, rs1, imm) { \
+    if (rds == RVJIT_REGISTER_ZERO) return; \
+    regid_t hrs1 = rvjit_map_reg(block, rs1, REG_SRC); \
+    regid_t hrds = rvjit_map_reg(block, rds, REG_DST); \
+    native_func(block, hrds, hrs1, imm); }
+
+// Peephole optimization for cases like addi reg, zero, imm
+#define RVJIT32_IMM_INC_OPTIMIZE(rds, rs1, imm) \
+    if (rds != RVJIT_REGISTER_ZERO && rs1 == RVJIT_REGISTER_ZERO) { \
+        regid_t hrds = rvjit_map_reg(block, rds, REG_DST); \
+        rvjit_native_setreg32(block, hrds, imm); \
+        return; \
+    }
+
+#define RVJIT64_IMM_INC_OPTIMIZE(rds, rs1, imm) \
+    if (rds != RVJIT_REGISTER_ZERO && rs1 == RVJIT_REGISTER_ZERO) { \
+        regid_t hrds = rvjit_map_reg(block, rds, REG_DST); \
+        rvjit_native_setreg32s(block, hrds, imm); \
+        return; \
+    }
+
+#define RVJIT_IMM_ZERO_OPTIMIZE(rds, rs1, imm) \
+    if (rds != RVJIT_REGISTER_ZERO && rs1 == RVJIT_REGISTER_ZERO) { \
+        regid_t hrds = rvjit_map_reg(block, rds, REG_DST); \
+        rvjit_native_zero_reg(block, hrds); \
+        return; \
+    }
+
+#define RVJIT32_3REG(instr) \
+void rvjit32_##instr(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2) \
+{ \
+    RVJIT_3REG_OP(rvjit32_native_##instr, rds, rs1, rs2); \
+}
+
+#ifdef RVJIT_NATIVE_64BIT
+#define RVJIT64_3REG(instr) \
+void rvjit64_##instr(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2) \
+{ \
+    RVJIT_3REG_OP(rvjit64_native_##instr, rds, rs1, rs2); \
+}
+#else
+#define RVJIT64_3REG(instr)
+#endif
+
+#define RVJIT_3REG(instr) \
+RVJIT32_3REG(instr) \
+RVJIT64_3REG(instr)
+
+/*
+ * ALU Register-Immediate intrinsics
+ */
+
+#define RVJIT32_IMM_INC(instr) \
+void rvjit32_##instr(rvjit_block_t* block, regid_t rds, regid_t rs1, int32_t imm) \
+{ \
+    RVJIT32_IMM_INC_OPTIMIZE(rds, rs1, imm); \
+    RVJIT_2REG_IMM_OP(rvjit32_native_##instr, rds, rs1, imm); \
+}
+
+#ifdef RVJIT_NATIVE_64BIT
+#define RVJIT64_IMM_INC(instr) \
+void rvjit64_##instr(rvjit_block_t* block, regid_t rds, regid_t rs1, int32_t imm) \
+{ \
+    RVJIT64_IMM_INC_OPTIMIZE(rds, rs1, imm); \
+    RVJIT_2REG_IMM_OP(rvjit64_native_##instr, rds, rs1, imm); \
+}
+#else
+#define RVJIT64_IMM_INC(instr)
+#endif
+
+#define RVJIT_IMM_INC(instr) \
+RVJIT32_IMM_INC(instr) \
+RVJIT64_IMM_INC(instr)
+
+#define RVJIT32_IMM(instr) \
+void rvjit32_##instr(rvjit_block_t* block, regid_t rds, regid_t rs1, int32_t imm) \
+{ \
+    RVJIT_IMM_ZERO_OPTIMIZE(rds, rs1, imm); \
+    RVJIT_2REG_IMM_OP(rvjit32_native_##instr, rds, rs1, imm); \
+}
+
+#ifdef RVJIT_NATIVE_64BIT
+#define RVJIT64_IMM(instr) \
+void rvjit64_##instr(rvjit_block_t* block, regid_t rds, regid_t rs1, int32_t imm) \
+{ \
+    RVJIT_IMM_ZERO_OPTIMIZE(rds, rs1, imm); \
+    RVJIT_2REG_IMM_OP(rvjit64_native_##instr, rds, rs1, imm); \
+}
+#else
+#define RVJIT64_IMM(instr)
+#endif
+
+#define RVJIT_IMM(instr) \
+RVJIT32_IMM(instr) \
+RVJIT64_IMM(instr)
+
+/*
+ * Branch intrinsics
+ */
+
+#define RVJIT32_BRANCH(instr) \
+void rvjit32_##instr(rvjit_block_t* block, regid_t rs1, regid_t rs2) \
+{ \
+    regid_t hrs1 = rvjit_map_reg(block, rs1, REG_SRC); \
+    regid_t hrs2 = rvjit_map_reg(block, rs2, REG_SRC); \
+    branch_t l1 = rvjit32_native_##instr(block, hrs1, hrs2, BRANCH_NEW, BRANCH_ENTRY); \
+    rvjit_emit_end(block, LINKAGE_JMP); \
+    rvjit32_native_##instr(block, hrs1, hrs2, l1, BRANCH_TARGET); \
+}
+
+#ifdef RVJIT_NATIVE_64BIT
+#define RVJIT64_BRANCH(instr) \
+void rvjit64_##instr(rvjit_block_t* block, regid_t rs1, regid_t rs2) \
+{ \
+    regid_t hrs1 = rvjit_map_reg(block, rs1, REG_SRC); \
+    regid_t hrs2 = rvjit_map_reg(block, rs2, REG_SRC); \
+    branch_t l1 = rvjit64_native_##instr(block, hrs1, hrs2, BRANCH_NEW, BRANCH_ENTRY); \
+    rvjit_emit_end(block, LINKAGE_JMP); \
+    rvjit64_native_##instr(block, hrs1, hrs2, l1, BRANCH_TARGET); \
+}
+#else
+#define RVJIT64_BRANCH(instr)
+#endif
+
+#define RVJIT_BRANCH(instr) \
+RVJIT32_BRANCH(instr) \
+RVJIT64_BRANCH(instr)
+
+RVJIT_3REG(add)
+RVJIT_3REG(sub)
+RVJIT_3REG(or)
+RVJIT_3REG(and)
+RVJIT_3REG(xor)
+RVJIT_3REG(sra)
+RVJIT_3REG(srl)
+RVJIT_3REG(sll)
+RVJIT_3REG(slt)
+RVJIT_3REG(sltu)
+RVJIT_3REG(mul)
+RVJIT_3REG(mulh)
+RVJIT_3REG(mulhu)
+RVJIT_3REG(mulhsu)
+RVJIT_3REG(div)
+RVJIT_3REG(divu)
+RVJIT_3REG(rem)
+RVJIT_3REG(remu)
+
+RVJIT_IMM_INC(addi)
+RVJIT_IMM_INC(ori)
+RVJIT_IMM_INC(xori)
+
+RVJIT_IMM(andi)
+RVJIT_IMM(srai)
+RVJIT_IMM(srli)
+RVJIT_IMM(slli)
+RVJIT_IMM(slti)
+RVJIT_IMM(sltiu)
+
+RVJIT64_3REG(addw)
+RVJIT64_3REG(subw)
+RVJIT64_3REG(sraw)
+RVJIT64_3REG(srlw)
+RVJIT64_3REG(sllw)
+RVJIT64_3REG(mulw)
+RVJIT64_3REG(divw)
+RVJIT64_3REG(divuw)
+RVJIT64_3REG(remw)
+RVJIT64_3REG(remuw)
+
+RVJIT64_IMM_INC(addiw)
+RVJIT64_IMM(sraiw)
+RVJIT64_IMM(srliw)
+RVJIT64_IMM(slliw)
+
+RVJIT_BRANCH(beq)
+RVJIT_BRANCH(bne)
+RVJIT_BRANCH(blt)
+RVJIT_BRANCH(bge)
+RVJIT_BRANCH(bltu)
+RVJIT_BRANCH(bgeu)
+
+void rvjit32_li(rvjit_block_t* block, regid_t rds, int32_t imm)
+{
+    if (rds == RVJIT_REGISTER_ZERO) return;
+    regid_t hrds = rvjit_map_reg(block, rds, REG_DST);
+    rvjit_native_setreg32(block, hrds, imm);
+}
+
+void rvjit32_auipc(rvjit_block_t* block, regid_t rds, int32_t imm)
+{
+    if (rds == RVJIT_REGISTER_ZERO) return;
+    regid_t hrds = rvjit_map_reg(block, rds, REG_DST);
+    rvjit32_native_lw(block, hrds, VM_PTR_REG, offsetof(rvvm_hart_t, registers[REGISTER_PC]));
+    imm += block->pc_off;
+    if (imm) {
+        rvjit32_native_addi(block, hrds, hrds, imm);
+    }
+    block->regs[rds].flags |= REG_AUIPC;
+    block->regs[rds].auipc_off = imm;
+}
+
+void rvjit32_jalr(rvjit_block_t* block, regid_t rds, regid_t rs, int32_t imm, uint8_t isize)
+{
+    regid_t hrs = rvjit_map_reg(block, rs, REG_SRC);
+    regid_t hjmp = rvjit_claim_hreg(block);
+    rvjit32_native_addi(block, hjmp, hrs, imm);
+    if (rds != RVJIT_REGISTER_ZERO) {
+        int32_t new_imm = block->pc_off + isize;
+        regid_t hrds = rvjit_map_reg(block, rds, REG_DST);
+        rvjit32_native_lw(block, hrds, VM_PTR_REG, offsetof(rvvm_hart_t, registers[REGISTER_PC]));
+        if (new_imm) {
+            rvjit32_native_addi(block, hrds, hrds, new_imm);
+        }
+    }
+
+    if (block->regs[rs].flags & REG_AUIPC) {
+        block->pc_off = block->regs[rs].auipc_off + imm;
+        block->linkage = LINKAGE_JMP;
+    } else {
+        block->pc_off = 0;
+        block->linkage = LINKAGE_TAIL;
+        rvjit32_native_sw(block, hjmp, VM_PTR_REG, offsetof(rvvm_hart_t, registers[REGISTER_PC]));
+    }
+
+    rvjit_free_hreg(block, hjmp);
+}
+
+// RV64
+
+#ifdef RVJIT_NATIVE_64BIT
+
+void rvjit64_li(rvjit_block_t* block, regid_t rds, int32_t imm)
+{
+    if (rds == RVJIT_REGISTER_ZERO) return;
+    regid_t hrds = rvjit_map_reg(block, rds, REG_DST);
+    rvjit_native_setreg32s(block, hrds, imm);
+}
+
+void rvjit64_auipc(rvjit_block_t* block, regid_t rds, int32_t imm)
+{
+    if (rds == RVJIT_REGISTER_ZERO) return;
+    regid_t hrds = rvjit_map_reg(block, rds, REG_DST);
+    rvjit64_native_ld(block, hrds, VM_PTR_REG, offsetof(rvvm_hart_t, registers[REGISTER_PC]));
+    imm += block->pc_off;
+    if (imm) {
+        rvjit64_native_addi(block, hrds, hrds, imm);
+    }
+    block->regs[rds].flags |= REG_AUIPC;
+    block->regs[rds].auipc_off = imm;
+}
+
+void rvjit64_jalr(rvjit_block_t* block, regid_t rds, regid_t rs, int32_t imm, uint8_t isize)
+{
+    regid_t hrs = rvjit_map_reg(block, rs, REG_SRC);
+    regid_t hjmp = rvjit_claim_hreg(block);
+    rvjit64_native_addi(block, hjmp, hrs, imm);
+    if (rds != RVJIT_REGISTER_ZERO) {
+        int32_t new_imm = block->pc_off + isize;
+        regid_t hrds = rvjit_map_reg(block, rds, REG_DST);
+        rvjit64_native_ld(block, hrds, VM_PTR_REG, offsetof(rvvm_hart_t, registers[REGISTER_PC]));
+        if (new_imm) {
+            rvjit64_native_addi(block, hrds, hrds, new_imm);
+        }
+    }
+
+    if (block->regs[rs].flags & REG_AUIPC) {
+        block->pc_off = block->regs[rs].auipc_off + imm;
+        block->linkage = LINKAGE_JMP;
+    } else {
+        block->pc_off = 0;
+        block->linkage = LINKAGE_TAIL;
+        rvjit64_native_sd(block, hjmp, VM_PTR_REG, offsetof(rvvm_hart_t, registers[REGISTER_PC]));
+    }
+
+    rvjit_free_hreg(block, hjmp);
+}
+
+#endif
+
+#if defined(RVJIT_NATIVE_64BIT) && defined(USE_RV64)
+
+// Possibly may be optimized more
+static void rvjit_tlb_lookup(rvjit_block_t* block, regid_t haddr, regid_t vaddr, int32_t offset, uint8_t moff, uint8_t align)
+{
+    regid_t a2 = rvjit_claim_hreg(block);
+    regid_t a3 = rvjit_claim_hreg(block);
+    regid_t hvaddr = rvjit_claim_hreg(block);
+    regid_t hrs = rvjit_map_reg(block, vaddr, REG_SRC);
+
+    rvjit64_native_addi(block, hvaddr, hrs, offset);
+    rvjit64_native_srli(block, a3, hvaddr, 12);
+    rvjit64_native_andi(block, a2, a3, VM_TLB_MASK);
+    rvjit32_native_slli(block, a2, a2, VM_TLB_SHIFT);
+    rvjit64_native_add(block, a2, a2, VM_PTR_REG);
+    rvjit64_native_ld(block, haddr, a2, VM_TLB_OFFSET + moff);
+    if (align > 1) {
+        rvjit64_native_xor(block, haddr, haddr, a3);
+        rvjit64_native_andi(block, a3, hvaddr, (align - 1));
+        rvjit64_native_or(block, a3, a3, haddr);
+    } else {
+        rvjit64_native_xor(block, a3, a3, haddr);
+    }
+    branch_t l1 = rvjit64_native_beqz(block, a3, BRANCH_NEW, BRANCH_ENTRY);
+
+    rvjit_emit_end(block, LINKAGE_NONE);
+
+    rvjit64_native_beqz(block, a3, l1, BRANCH_TARGET);
+    rvjit64_native_ld(block, haddr, a2, VM_TLB_OFFSET);
+    rvjit64_native_add(block, haddr, haddr, hvaddr);
+
+    rvjit_free_hreg(block, a2);
+    rvjit_free_hreg(block, a3);
+    rvjit_free_hreg(block, hvaddr);
+}
+
+#else
+
+static void rvjit_tlb_lookup(rvjit_block_t* block, regid_t haddr, regid_t vaddr, int32_t offset, uint8_t moff, uint8_t align)
+{
+    regid_t a2 = rvjit_claim_hreg(block);
+    regid_t a3 = rvjit_claim_hreg(block);
+    regid_t hvaddr = rvjit_claim_hreg(block);
+    regid_t hrs = rvjit_map_reg(block, vaddr, REG_SRC);
+
+    rvjit32_native_addi(block, hvaddr, hrs, offset);
+    rvjit32_native_srli(block, a3, hvaddr, 12);
+    rvjit32_native_andi(block, a2, a3, VM_TLB_MASK);
+    rvjit32_native_slli(block, a2, a2, VM_TLB_SHIFT);
+#ifdef RVJIT_NATIVE_64BIT
+    rvjit64_native_add(block, a2, a2, VM_PTR_REG);
+#else
+    rvjit32_native_add(block, a2, a2, VM_PTR_REG);
+#endif
+    rvjit32_native_lw(block, haddr, a2, VM_TLB_OFFSET + moff);
+    if (align > 1) {
+        rvjit32_native_xor(block, haddr, haddr, a3);
+        rvjit32_native_andi(block, a3, hvaddr, (align - 1));
+        rvjit32_native_or(block, a3, a3, haddr);
+    } else {
+        rvjit32_native_xor(block, a3, a3, haddr);
+    }
+    branch_t l1 = rvjit32_native_beqz(block, a3, BRANCH_NEW, BRANCH_ENTRY);
+
+    rvjit_emit_end(block, LINKAGE_NONE);
+
+    rvjit32_native_beqz(block, a3, l1, BRANCH_TARGET);
+#ifdef RVJIT_NATIVE_64BIT
+    rvjit64_native_ld(block, haddr, a2, VM_TLB_OFFSET);
+    rvjit64_native_add(block, haddr, haddr, hvaddr);
+#else
+    rvjit32_native_lw(block, haddr, a2, VM_TLB_OFFSET);
+    rvjit32_native_add(block, haddr, haddr, hvaddr);
+#endif
+
+    rvjit_free_hreg(block, a2);
+    rvjit_free_hreg(block, a3);
+    rvjit_free_hreg(block, hvaddr);
+}
+
+#endif
+
+/*
+ * Load/store intrinsics
+ */
+
+#define RVJIT32_LDST(instr, align, store) \
+void rvjit32_##instr(rvjit_block_t* block, regid_t dest, regid_t vaddr, int32_t offset) \
+{ \
+    if (block->native_ptrs) { \
+        regid_t haddr = rvjit_map_reg(block, vaddr, REG_SRC); \
+        regid_t hdest = rvjit_map_reg(block, dest, store ? REG_SRC : REG_DST); \
+        rvjit32_native_##instr(block, hdest, haddr, offset); \
+    } else { \
+        regid_t haddr = rvjit_claim_hreg(block); \
+        rvjit_tlb_lookup(block, haddr, vaddr, offset, store ? VM_TLB_W : VM_TLB_R, align); \
+        regid_t hdest = rvjit_map_reg(block, dest, store ? REG_SRC : REG_DST); \
+        rvjit32_native_##instr(block, hdest, haddr, 0); \
+        rvjit_free_hreg(block, haddr); \
+    } \
+}
+
+#ifdef RVJIT_NATIVE_64BIT
+#define RVJIT64_LDST(instr, align, store) \
+void rvjit64_##instr(rvjit_block_t* block, regid_t dest, regid_t vaddr, int32_t offset) \
+{ \
+    if (block->native_ptrs) { \
+        regid_t haddr = rvjit_map_reg(block, vaddr, REG_SRC); \
+        regid_t hdest = rvjit_map_reg(block, dest, store ? REG_SRC : REG_DST); \
+        rvjit64_native_##instr(block, hdest, haddr, offset); \
+    } else { \
+        regid_t haddr = rvjit_claim_hreg(block); \
+        rvjit_tlb_lookup(block, haddr, vaddr, offset, store ? VM_TLB_W : VM_TLB_R, align); \
+        regid_t hdest = rvjit_map_reg(block, dest, store ? REG_SRC : REG_DST); \
+        rvjit64_native_##instr(block, hdest, haddr, 0); \
+        rvjit_free_hreg(block, haddr); \
+    } \
+}
+#else
+#define RVJIT64_LDST(instr, align, store)
+#endif
+
+#define RVJIT_LDST(instr, align, store) \
+RVJIT32_LDST(instr, align, store) \
+RVJIT64_LDST(instr, align, store)
+
+RVJIT_LDST(lb,    1, false)
+RVJIT_LDST(lbu,   1, false)
+RVJIT_LDST(lh,    2, false)
+RVJIT_LDST(lhu,   2, false)
+RVJIT_LDST(lw,    4, false)
+RVJIT64_LDST(lwu, 4, false)
+RVJIT64_LDST(ld,  8, false)
+
+RVJIT_LDST(sb,   1, true)
+RVJIT_LDST(sh,   2, true)
+RVJIT_LDST(sw,   4, true)
+RVJIT64_LDST(sd, 8, true)
diff --git a/app/src/main/java/libengine/RVVM/src/rvjit/rvjit_emit.h b/app/src/main/java/libengine/RVVM/src/rvjit/rvjit_emit.h
new file mode 100644
index 00000000..d2fce1a1
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/rvjit/rvjit_emit.h
@@ -0,0 +1,316 @@
+/*
+rvjit_emit.h - Retargetable Versatile JIT Compiler
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "rvjit.h"
+
+#ifndef RVJIT_EMIT_H
+#define RVJIT_EMIT_H
+
+void rvjit_linker_patch_jmp(void* addr, int32_t offset);
+void rvjit_linker_patch_ret(void* addr);
+
+// RV32IC
+void rvjit32_add(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit32_sub(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit32_or(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit32_and(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit32_xor(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit32_sra(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit32_srl(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit32_sll(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit32_addi(rvjit_block_t* block, regid_t rds, regid_t rs1, int32_t imm);
+void rvjit32_ori(rvjit_block_t* block, regid_t rds, regid_t rs1, int32_t imm);
+void rvjit32_andi(rvjit_block_t* block, regid_t rds, regid_t rs1, int32_t imm);
+void rvjit32_xori(rvjit_block_t* block, regid_t rds, regid_t rs1, int32_t imm);
+void rvjit32_srai(rvjit_block_t* block, regid_t rds, regid_t rs1, int32_t imm);
+void rvjit32_srli(rvjit_block_t* block, regid_t rds, regid_t rs1, int32_t imm);
+void rvjit32_slli(rvjit_block_t* block, regid_t rds, regid_t rs1, int32_t imm);
+void rvjit32_slti(rvjit_block_t* block, regid_t rds, regid_t rs1, int32_t imm);
+void rvjit32_sltiu(rvjit_block_t* block, regid_t rds, regid_t rs1, int32_t imm);
+void rvjit32_slt(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit32_sltu(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit32_li(rvjit_block_t* block, regid_t rds, int32_t imm);
+void rvjit32_auipc(rvjit_block_t* block, regid_t rds, int32_t imm);
+void rvjit32_jalr(rvjit_block_t* block, regid_t rds, regid_t rs, int32_t imm, uint8_t isize);
+
+void rvjit32_sb(rvjit_block_t* block, regid_t src, regid_t vaddr, int32_t offset);
+void rvjit32_lb(rvjit_block_t* block, regid_t dest, regid_t vaddr, int32_t offset);
+void rvjit32_lbu(rvjit_block_t* block, regid_t dest, regid_t vaddr, int32_t offset);
+void rvjit32_sh(rvjit_block_t* block, regid_t src, regid_t vaddr, int32_t offset);
+void rvjit32_lh(rvjit_block_t* block, regid_t dest, regid_t vaddr, int32_t offset);
+void rvjit32_lhu(rvjit_block_t* block, regid_t dest, regid_t vaddr, int32_t offset);
+void rvjit32_sw(rvjit_block_t* block, regid_t src, regid_t vaddr, int32_t offset);
+void rvjit32_lw(rvjit_block_t* block, regid_t dest, regid_t vaddr, int32_t offset);
+
+void rvjit32_beq(rvjit_block_t* block, regid_t rs1, regid_t rs2);
+void rvjit32_bne(rvjit_block_t* block, regid_t rs1, regid_t rs2);
+void rvjit32_blt(rvjit_block_t* block, regid_t rs1, regid_t rs2);
+void rvjit32_bge(rvjit_block_t* block, regid_t rs1, regid_t rs2);
+void rvjit32_bltu(rvjit_block_t* block, regid_t rs1, regid_t rs2);
+void rvjit32_bgeu(rvjit_block_t* block, regid_t rs1, regid_t rs2);
+
+// RV32M
+void rvjit32_mul(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit32_mulh(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit32_mulhu(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit32_mulhsu(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+
+void rvjit32_div(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit32_divu(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit32_rem(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit32_remu(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+
+// RV32 Zba
+void rvjit32_shadd(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2, uint8_t shift);
+
+// RV32 Zbb
+#ifdef RVJIT_NATIVE_BITMANIP
+void rvjit32_orc_b(rvjit_block_t* block, regid_t rds, regid_t rs1);
+void rvjit32_clz(rvjit_block_t* block, regid_t rds, regid_t rs1);
+void rvjit32_ctz(rvjit_block_t* block, regid_t rds, regid_t rs1);
+void rvjit32_cpop(rvjit_block_t* block, regid_t rds, regid_t rs1);
+void rvjit32_rev8(rvjit_block_t* block, regid_t rds, regid_t rs1);
+#endif
+void rvjit32_rol(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit32_ror(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit32_rori(rvjit_block_t* block, regid_t rds, regid_t rs1, int32_t imm);
+void rvjit32_andn(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit32_orn(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit32_xnor(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit32_max(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit32_maxu(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit32_min(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit32_minu(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit32_sext_b(rvjit_block_t* block, regid_t rds, regid_t rs1);
+void rvjit32_sext_h(rvjit_block_t* block, regid_t rds, regid_t rs1);
+
+// RV32 Zbs
+void rvjit32_bext(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit32_bexti(rvjit_block_t* block, regid_t rds, regid_t rs1, int32_t imm);
+void rvjit32_bclr(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit32_bclri(rvjit_block_t* block, regid_t rds, regid_t rs1, int32_t imm);
+void rvjit32_bset(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit32_bseti(rvjit_block_t* block, regid_t rds, regid_t rs1, int32_t imm);
+void rvjit32_binv(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit32_binvi(rvjit_block_t* block, regid_t rds, regid_t rs1, int32_t imm);
+
+#ifdef RVJIT_NATIVE_64BIT
+
+/*
+ * RV64-only intrinsics
+ */
+
+// RV64IC
+void rvjit64_add(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit64_sub(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit64_or(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit64_and(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit64_xor(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit64_sra(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit64_srl(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit64_sll(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit64_addi(rvjit_block_t* block, regid_t rds, regid_t rs1, int32_t imm);
+void rvjit64_ori(rvjit_block_t* block, regid_t rds, regid_t rs1, int32_t imm);
+void rvjit64_andi(rvjit_block_t* block, regid_t rds, regid_t rs1, int32_t imm);
+void rvjit64_xori(rvjit_block_t* block, regid_t rds, regid_t rs1, int32_t imm);
+void rvjit64_srai(rvjit_block_t* block, regid_t rds, regid_t rs1, int32_t imm);
+void rvjit64_srli(rvjit_block_t* block, regid_t rds, regid_t rs1, int32_t imm);
+void rvjit64_slli(rvjit_block_t* block, regid_t rds, regid_t rs1, int32_t imm);
+void rvjit64_slti(rvjit_block_t* block, regid_t rds, regid_t rs1, int32_t imm);
+void rvjit64_sltiu(rvjit_block_t* block, regid_t rds, regid_t rs1, int32_t imm);
+void rvjit64_slt(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit64_sltu(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit64_li(rvjit_block_t* block, regid_t rds, int32_t imm);
+void rvjit64_auipc(rvjit_block_t* block, regid_t rds, int32_t imm);
+void rvjit64_jalr(rvjit_block_t* block, regid_t rds, regid_t rs, int32_t imm, uint8_t isize);
+
+void rvjit64_addw(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit64_subw(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit64_sraw(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit64_srlw(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit64_sllw(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit64_addiw(rvjit_block_t* block, regid_t rds, regid_t rs1, int32_t imm);
+void rvjit64_sraiw(rvjit_block_t* block, regid_t rds, regid_t rs1, int32_t imm);
+void rvjit64_srliw(rvjit_block_t* block, regid_t rds, regid_t rs1, int32_t imm);
+void rvjit64_slliw(rvjit_block_t* block, regid_t rds, regid_t rs1, int32_t imm);
+
+void rvjit64_sb(rvjit_block_t* block, regid_t src, regid_t vaddr, int32_t offset);
+void rvjit64_lb(rvjit_block_t* block, regid_t dest, regid_t vaddr, int32_t offset);
+void rvjit64_lbu(rvjit_block_t* block, regid_t dest, regid_t vaddr, int32_t offset);
+void rvjit64_sh(rvjit_block_t* block, regid_t dest, regid_t vaddr, int32_t offset);
+void rvjit64_lh(rvjit_block_t* block, regid_t dest, regid_t vaddr, int32_t offset);
+void rvjit64_lhu(rvjit_block_t* block, regid_t dest, regid_t vaddr, int32_t offset);
+void rvjit64_sw(rvjit_block_t* block, regid_t src, regid_t vaddr, int32_t offset);
+void rvjit64_lw(rvjit_block_t* block, regid_t dest, regid_t vaddr, int32_t offset);
+void rvjit64_lwu(rvjit_block_t* block, regid_t dest, regid_t vaddr, int32_t offset);
+void rvjit64_sd(rvjit_block_t* block, regid_t dest, regid_t vaddr, int32_t offset);
+void rvjit64_ld(rvjit_block_t* block, regid_t dest, regid_t vaddr, int32_t offset);
+
+void rvjit64_beq(rvjit_block_t* block, regid_t rs1, regid_t rs2);
+void rvjit64_bne(rvjit_block_t* block, regid_t rs1, regid_t rs2);
+void rvjit64_blt(rvjit_block_t* block, regid_t rs1, regid_t rs2);
+void rvjit64_bge(rvjit_block_t* block, regid_t rs1, regid_t rs2);
+void rvjit64_bltu(rvjit_block_t* block, regid_t rs1, regid_t rs2);
+void rvjit64_bgeu(rvjit_block_t* block, regid_t rs1, regid_t rs2);
+
+// RV64M
+void rvjit64_mul(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit64_mulh(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit64_mulhu(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit64_mulhsu(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit64_mulw(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+
+void rvjit64_div(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit64_divu(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit64_rem(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit64_remu(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit64_divw(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit64_divuw(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit64_remw(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit64_remuw(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+
+// RV64 Zba
+void rvjit64_shadd(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2, uint8_t shift);
+void rvjit64_shadd_uw(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2, uint8_t shift);
+void rvjit64_slli_uw(rvjit_block_t* block, regid_t rds, regid_t rs1, int32_t imm);
+
+// RV64 Zbb
+#ifdef RVJIT_NATIVE_BITMANIP
+void rvjit64_orc_b(rvjit_block_t* block, regid_t rds, regid_t rs1);
+void rvjit64_clz(rvjit_block_t* block, regid_t rds, regid_t rs1);
+void rvjit64_clzw(rvjit_block_t* block, regid_t rds, regid_t rs1);
+void rvjit64_ctz(rvjit_block_t* block, regid_t rds, regid_t rs1);
+void rvjit64_ctzw(rvjit_block_t* block, regid_t rds, regid_t rs1);
+void rvjit64_cpop(rvjit_block_t* block, regid_t rds, regid_t rs1);
+void rvjit64_cpopw(rvjit_block_t* block, regid_t rds, regid_t rs1);
+void rvjit64_rev8(rvjit_block_t* block, regid_t rds, regid_t rs1);
+#endif
+void rvjit64_rol(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit64_rolw(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit64_ror(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit64_rorw(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit64_rori(rvjit_block_t* block, regid_t rds, regid_t rs1, int32_t imm);
+void rvjit64_roriw(rvjit_block_t* block, regid_t rds, regid_t rs1, int32_t imm);
+void rvjit64_andn(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit64_orn(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit64_xnor(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit64_max(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit64_maxu(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit64_min(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit64_minu(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit64_sext_b(rvjit_block_t* block, regid_t rds, regid_t rs1);
+void rvjit64_sext_h(rvjit_block_t* block, regid_t rds, regid_t rs1);
+
+// RV64 Zbs
+void rvjit64_bext(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit64_bexti(rvjit_block_t* block, regid_t rds, regid_t rs1, int32_t imm);
+void rvjit64_bclr(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit64_bclri(rvjit_block_t* block, regid_t rds, regid_t rs1, int32_t imm);
+void rvjit64_bset(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit64_bseti(rvjit_block_t* block, regid_t rds, regid_t rs1, int32_t imm);
+void rvjit64_binv(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit64_binvi(rvjit_block_t* block, regid_t rds, regid_t rs1, int32_t imm);
+
+#endif
+
+#ifdef RVJIT_NATIVE_FPU
+
+/*
+ * FPU intrinsics
+ */
+
+void rvjit_fsw(rvjit_block_t* block, regid_t src, regid_t vaddr, int32_t offset);
+void rvjit_flw(rvjit_block_t* block, regid_t dest, regid_t vaddr, int32_t offset);
+void rvjit_fsd(rvjit_block_t* block, regid_t dest, regid_t vaddr, int32_t offset);
+void rvjit_fld(rvjit_block_t* block, regid_t dest, regid_t vaddr, int32_t offset);
+
+void rvjit_fadd_s(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit_fadd_d(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit_fsub_s(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit_fsub_d(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit_fmul_s(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit_fmul_d(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit_fdiv_s(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit_fdiv_d(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit_fsqrt_s(rvjit_block_t* block, regid_t rds, regid_t rs1);
+void rvjit_fsqrt_d(rvjit_block_t* block, regid_t rds, regid_t rs1);
+void rvjit_fmadd_s(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2, regid_t rs3);
+void rvjit_fmadd_d(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2, regid_t rs3);
+void rvjit_fmsub_s(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2, regid_t rs3);
+void rvjit_fmsub_d(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2, regid_t rs3);
+void rvjit_fnmadd_s(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2, regid_t rs3);
+void rvjit_fnmadd_d(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2, regid_t rs3);
+void rvjit_fnmsub_s(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2, regid_t rs3);
+void rvjit_fnmsub_d(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2, regid_t rs3);
+void rvjit_fsgnj_s(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit_fsgnj_d(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit_fsgnjn_s(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit_fsgnjn_d(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit_fsgnjx_s(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit_fsgnjx_d(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit_fmin_s(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit_fmin_d(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit_fmax_s(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit_fmax_d(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+
+void rvjit_feq_s(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit_feq_d(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit_flt_s(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit_flt_d(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit_fle_s(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+void rvjit_fle_d(rvjit_block_t* block, regid_t rds, regid_t rs1, regid_t rs2);
+
+void rvjit_fclass_s(rvjit_block_t* block, regid_t rds, regid_t rs1);
+void rvjit_fclass_d(rvjit_block_t* block, regid_t rds, regid_t rs1);
+
+void rvjit_fcvt_s_d(rvjit_block_t* block, regid_t rds, regid_t rs1);
+void rvjit_fcvt_d_s(rvjit_block_t* block, regid_t rds, regid_t rs1);
+
+void rvjit_fmv_w_x(rvjit_block_t* block, regid_t rds, regid_t rs1);
+void rvjit_fmv_x_w(rvjit_block_t* block, regid_t rds, regid_t rs1);
+
+void rvjit_fcvt_w_s(rvjit_block_t* block, regid_t rds, regid_t rs1);
+void rvjit_fcvt_wu_s(rvjit_block_t* block, regid_t rds, regid_t rs1);
+void rvjit_fcvt_s_w(rvjit_block_t* block, regid_t rds, regid_t rs1);
+void rvjit_fcvt_s_wu(rvjit_block_t* block, regid_t rds, regid_t rs1);
+void rvjit_fcvt_w_d(rvjit_block_t* block, regid_t rds, regid_t rs1);
+void rvjit_fcvt_wu_d(rvjit_block_t* block, regid_t rds, regid_t rs1);
+void rvjit_fcvt_d_w(rvjit_block_t* block, regid_t rds, regid_t rs1);
+void rvjit_fcvt_d_wu(rvjit_block_t* block, regid_t rds, regid_t rs1);
+
+#ifdef RVJIT_NATIVE_64BIT
+
+// RV64-only FPU intrinsics
+
+void rvjit64_fmv_d_x(rvjit_block_t* block, regid_t rds, regid_t rs1);
+void rvjit64_fmv_x_d(rvjit_block_t* block, regid_t rds, regid_t rs1);
+
+void rvjit64_fcvt_l_s(rvjit_block_t* block, regid_t rds, regid_t rs1);
+void rvjit64_fcvt_lu_s(rvjit_block_t* block, regid_t rds, regid_t rs1);
+void rvjit64_fcvt_s_l(rvjit_block_t* block, regid_t rds, regid_t rs1);
+void rvjit64_fcvt_s_lu(rvjit_block_t* block, regid_t rds, regid_t rs1);
+void rvjit64_fcvt_l_d(rvjit_block_t* block, regid_t rds, regid_t rs1);
+void rvjit64_fcvt_lu_d(rvjit_block_t* block, regid_t rds, regid_t rs1);
+void rvjit64_fcvt_d_l(rvjit_block_t* block, regid_t rds, regid_t rs1);
+void rvjit64_fcvt_d_lu(rvjit_block_t* block, regid_t rds, regid_t rs1);
+
+#endif
+
+#endif
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/rvjit/rvjit_riscv.h b/app/src/main/java/libengine/RVVM/src/rvjit/rvjit_riscv.h
new file mode 100644
index 00000000..bb3ea8b8
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/rvjit/rvjit_riscv.h
@@ -0,0 +1,1089 @@
+/*
+rvjit_riscv.h - RVJIT RISC-V Backend
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "rvjit.h"
+#include "../mem_ops.h"
+#include "../bit_ops.h"
+#include "../compiler.h"
+#include "../utils.h"
+
+#ifndef RVJIT_RISCV_H
+#define RVJIT_RISCV_H
+
+#define RISCV_REG_ZERO 0x0
+#define RISCV_REG_RA   0x1
+#define RISCV_REG_SP   0x2
+#define RISCV_REG_A0   0xA
+
+#ifdef RVJIT_ABI_SYSV
+#define VM_PTR_REG RISCV_REG_A0
+#endif
+
+static inline size_t rvjit_native_default_hregmask(void)
+{
+    // t0-t6, a0-a7 are caller-saved
+    // a0 is preserved as vmptr
+    return rvjit_hreg_mask(5)  |
+           rvjit_hreg_mask(6)  |
+           rvjit_hreg_mask(7)  |
+           rvjit_hreg_mask(11) |
+           rvjit_hreg_mask(12) |
+           rvjit_hreg_mask(13) |
+           rvjit_hreg_mask(14) |
+           rvjit_hreg_mask(15) |
+           rvjit_hreg_mask(16) |
+           rvjit_hreg_mask(17) |
+           rvjit_hreg_mask(28) |
+           rvjit_hreg_mask(29) |
+           rvjit_hreg_mask(30) |
+           rvjit_hreg_mask(31);
+}
+
+static inline size_t rvjit_native_abireclaim_hregmask(void)
+{
+    // We have enough caller-saved registers, no need for push/pop as well
+    return 0;
+}
+
+static inline bool rvjit_is_valid_imm(int32_t imm)
+{
+    return (((int32_t)(((uint32_t)imm) << 20)) >> 20) == imm;
+}
+
+static inline void rvjit_riscv_20imm_op(rvjit_block_t* block, uint32_t opcode, regid_t reg, int32_t imm)
+{
+    uint8_t code[4];
+    write_uint32_le_m(code, opcode | (reg << 7) | (imm & 0xFFFFF000));
+    rvjit_put_code(block, code, 4);
+}
+
+// Load [31:12] bits of the register from 20-bit imm, signextend & zero lower bits
+static inline void rvjit_riscv_lui(rvjit_block_t* block, regid_t reg, int32_t imm)
+{
+    rvjit_riscv_20imm_op(block, 0x37, reg, imm);
+}
+
+// Load PC + [31:12] imm to register
+static inline void rvjit_riscv_auipc(rvjit_block_t* block, regid_t reg, int32_t imm)
+{
+    rvjit_riscv_20imm_op(block, 0x17, reg, imm);
+}
+
+#define RISCV_R_ADD   0x00000033
+#define RISCV_R_SUB   0x40000033
+#define RISCV_R_XOR   0x00004033
+#define RISCV_R_OR    0x00006033
+#define RISCV_R_AND   0x00007033
+#define RISCV_R_SLL   0x00001033
+#define RISCV_R_SRL   0x00005033
+#define RISCV_R_SRA   0x40005033
+#define RISCV_R_SLT   0x00002033
+#define RISCV_R_SLTU  0x00003033
+#define RISCV_R_MUL   0x02000033
+#define RISCV_R_MULH  0x02001033
+#define RISCV_R_MULHS 0x02002033
+#define RISCV_R_MULHU 0x02003033
+#define RISCV_R_DIV   0x02004033
+#define RISCV_R_DIVU  0x02005033
+#define RISCV_R_REM   0x02006033
+#define RISCV_R_REMU  0x02007033
+
+#define RISCV_R_ADDW  0x0000003B
+#define RISCV_R_SUBW  0x4000003B
+#define RISCV_R_SLLW  0x0000103B
+#define RISCV_R_SRLW  0x0000503B
+#define RISCV_R_SRAW  0x4000503B
+#define RISCV_R_MULW  0x0200003B
+#define RISCV_R_DIVW  0x0200403B
+#define RISCV_R_DIVUW 0x0200503B
+#define RISCV_R_REMW  0x0200603B
+#define RISCV_R_REMUW 0x0200703B
+
+#ifdef RVJIT_NATIVE_64BIT
+#define RISCV32_R_ADD  RISCV_R_ADDW
+#define RISCV32_R_SUB  RISCV_R_SUBW
+#define RISCV32_R_SLL  RISCV_R_SLLW
+#define RISCV32_R_SRL  RISCV_R_SRLW
+#define RISCV32_R_SRA  RISCV_R_SRAW
+#define RISCV32_R_MUL  RISCV_R_MULW
+#define RISCV32_R_DIV  RISCV_R_DIVW
+#define RISCV32_R_DIVU RISCV_R_DIVUW
+#define RISCV32_R_REM  RISCV_R_REMW
+#define RISCV32_R_REMU RISCV_R_REMUW
+#else
+#define RISCV32_R_ADD  RISCV_R_ADD
+#define RISCV32_R_SUB  RISCV_R_SUB
+#define RISCV32_R_SLL  RISCV_R_SLL
+#define RISCV32_R_SRL  RISCV_R_SRL
+#define RISCV32_R_SRA  RISCV_R_SRA
+#define RISCV32_R_MUL  RISCV_R_MUL
+#define RISCV32_R_DIV  RISCV_R_DIV
+#define RISCV32_R_DIVU RISCV_R_DIVU
+#define RISCV32_R_REM  RISCV_R_REM
+#define RISCV32_R_REMU RISCV_R_REMU
+#endif
+
+// R-type operation
+static inline void rvjit_riscv_r_op(rvjit_block_t* block, uint32_t opcode, regid_t rds, regid_t rs1, regid_t rs2)
+{
+    uint8_t code[4];
+    write_uint32_le_m(code, opcode | (rds << 7) | (rs1 << 15) | (rs2 << 20));
+    rvjit_put_code(block, code, 4);
+}
+
+#define RISCV_I_ADDI  0x00000013
+#define RISCV_I_XORI  0x00004013
+#define RISCV_I_ORI   0x00006013
+#define RISCV_I_ANDI  0x00007013
+#define RISCV_I_SLLI  0x00001013
+#define RISCV_I_SRLI  0x00005013
+#define RISCV_I_SRAI  0x40005013
+#define RISCV_I_SLTI  0x00002013
+#define RISCV_I_SLTIU 0x00003013
+
+#define RISCV_I_ADDIW 0x0000001B
+#define RISCV_I_SLLIW 0x0000101B
+#define RISCV_I_SRLIW 0x0000501B
+#define RISCV_I_SRAIW 0x4000501B
+
+#ifdef RVJIT_NATIVE_64BIT
+#define RISCV32_I_ADDI RISCV_I_ADDIW
+#define RISCV32_I_SLLI RISCV_I_SLLIW
+#define RISCV32_I_SRLI RISCV_I_SRLIW
+#define RISCV32_I_SRAI RISCV_I_SRAIW
+#else
+#define RISCV32_I_ADDI RISCV_I_ADDI
+#define RISCV32_I_SLLI RISCV_I_SLLI
+#define RISCV32_I_SRLI RISCV_I_SRLI
+#define RISCV32_I_SRAI RISCV_I_SRAI
+#endif
+
+#define RISCV_I_JALR  0x00000067
+
+// Loads encoded as I-type (rs is addr, imm is offset)
+#define RISCV_I_LB    0x00000003
+#define RISCV_I_LH    0x00001003
+#define RISCV_I_LW    0x00002003
+#define RISCV_I_LD    0x00003003
+#define RISCV_I_LBU   0x00004003
+#define RISCV_I_LHU   0x00005003
+#define RISCV_I_LWU   0x00006003
+
+// I-type operation (sign-extended 12-bit immediate)
+static inline void rvjit_riscv_i_op_internal(rvjit_block_t* block, uint32_t opcode, regid_t rds, regid_t rs, uint32_t imm)
+{
+    uint8_t code[4];
+    write_uint32_le_m(code, opcode | (rds << 7) | (rs << 15) | (((uint32_t)imm) << 20));
+    rvjit_put_code(block, code, 4);
+}
+
+// Set native register reg to sign-extended 32-bit imm
+static inline void rvjit_native_setreg32s(rvjit_block_t* block, regid_t reg, int32_t imm)
+{
+    if (!rvjit_is_valid_imm(imm)) {
+        // Upper 20 bits aren't sign-extension
+        if (imm & 0x800) {
+            // Lower 12-bit part will sign-extend and subtract 0x1000 from LUI value
+            imm += 0x1000;
+        }
+        rvjit_riscv_lui(block, reg, imm);
+        if ((imm & 0xFFF) != 0) {
+            rvjit_riscv_i_op_internal(block, RISCV32_I_ADDI, reg, reg, imm & 0xFFF);
+        }
+    } else {
+        rvjit_riscv_i_op_internal(block, RISCV_I_ADDI, reg, RISCV_REG_ZERO, imm & 0xFFF);
+    }
+}
+
+// Set native register reg to zero-extended 32-bit imm
+static inline void rvjit_native_setreg32(rvjit_block_t* block, regid_t reg, uint32_t imm)
+{
+    rvjit_native_setreg32s(block, reg, imm);
+}
+
+// Convert I-type opcodes to R-type opcodes
+static inline uint32_t riscv_i_to_r_op(uint32_t opcode)
+{
+    // wow big brain isa designers moment
+    return opcode | 0x20;
+}
+
+static inline bool riscv_is_load_op(uint32_t opcode)
+{
+    return (opcode & 0xFF) == 0x03;
+}
+
+// I-type operation (sign-extended 32-bit immediate)
+static inline void rvjit_riscv_i_op(rvjit_block_t* block, uint32_t opcode, regid_t rds, regid_t rs, int32_t imm)
+{
+    if (likely(rvjit_is_valid_imm(imm))) {
+        rvjit_riscv_i_op_internal(block, opcode, rds, rs, imm);
+    } else if (!riscv_is_load_op(opcode)) {
+        // Immediate doesn't fit in a single instruction
+        if ((opcode == RISCV_I_ADDI || opcode == RISCV_I_ADDIW) && rvjit_is_valid_imm(imm >> 1)) {
+            // Lower to 2 consequent addi
+            rvjit_riscv_i_op_internal(block, opcode, rds, rs, imm >> 1);
+            rvjit_riscv_i_op_internal(block, opcode, rds, rds, imm - (imm >> 1));
+        } else {
+            // Reclaim register, load 32-bit imm, use in R-type op
+            regid_t rtmp = rvjit_claim_hreg(block);
+            rvjit_native_setreg32s(block, rtmp, imm);
+            rvjit_riscv_r_op(block, riscv_i_to_r_op(opcode), rds, rs, rtmp);
+            rvjit_free_hreg(block, rtmp);
+        }
+    } else {
+        int32_t imm_lo = sign_extend(imm, 12);
+        regid_t rtmp = rvjit_claim_hreg(block);
+        rvjit_riscv_lui(block, rtmp, imm - imm_lo);
+        rvjit_riscv_r_op(block, RISCV_R_ADD, rtmp, rtmp, rs);
+        rvjit_riscv_i_op_internal(block, opcode, rds, rtmp, imm_lo);
+        rvjit_free_hreg(block, rtmp);
+    }
+}
+
+#define RISCV_S_SB    0x00000023
+#define RISCV_S_SH    0x00001023
+#define RISCV_S_SW    0x00002023
+#define RISCV_S_SD    0x00003023
+
+static inline void rvjit_riscv_s_op_internal(rvjit_block_t* block, uint32_t opcode, regid_t reg, regid_t addr, int32_t offset)
+{
+    uint8_t code[4];
+    write_uint32_le_m(code, opcode | ((offset & 0x1F) << 7) | (addr << 15)
+                                   | (reg << 20) | (((uint32_t)offset >> 5) << 25));
+    rvjit_put_code(block, code, 4);
+}
+
+// Store op (sign-extended 12-bit offset)
+static inline void rvjit_riscv_s_op(rvjit_block_t* block, uint32_t opcode, regid_t reg, regid_t addr, int32_t offset)
+{
+    if (likely(rvjit_is_valid_imm(offset))) {
+        rvjit_riscv_s_op_internal(block, opcode, reg, addr, offset);
+    } else {
+        int32_t imm_lo = sign_extend(offset, 12);
+        regid_t rtmp = rvjit_claim_hreg(block);
+        rvjit_riscv_lui(block, rtmp, offset - imm_lo);
+        rvjit_riscv_r_op(block, RISCV_R_ADD, rtmp, rtmp, addr);
+        rvjit_riscv_s_op_internal(block, opcode, reg, rtmp, imm_lo);
+        rvjit_free_hreg(block, rtmp);
+    }
+}
+
+#define RISCV_B_BEQ   0x00000063
+#define RISCV_B_BNE   0x00001063
+#define RISCV_B_BLT   0x00004063
+#define RISCV_B_BGE   0x00005063
+#define RISCV_B_BLTU  0x00006063
+#define RISCV_B_BGEU  0x00007063
+
+// Branch op (sign-extended 12-bit offset * 2)
+static inline void rvjit_riscv_b_op(rvjit_block_t* block, uint32_t opcode, regid_t rs1, regid_t rs2, int32_t offset)
+{
+    uint8_t code[4];
+    if (unlikely(!rvjit_is_valid_imm(offset >> 1))) rvvm_fatal("Illegal branch offset in RVJIT!");
+    write_uint32_le_m(code, opcode | (rs1 << 15) | (rs2 << 20) | ((offset & 0x1E) << 7) | ((offset & 0x800) >> 4)
+                                   | (((uint32_t)offset & 0x7E0) << 20) | (((uint32_t)offset & 0x1000) << 19));
+    rvjit_put_code(block, code, 4);
+}
+
+// Relative jump, stores return address to reg (sign-extended 21-bit offset)
+static inline void rvjit_riscv_jal(rvjit_block_t* block, regid_t reg, int32_t offset)
+{
+    uint8_t code[4];
+    write_uint32_le_m(code, 0x6F | ((uint32_t)reg << 7)
+                                 | (((uint32_t)(offset >> 1) & 0x3FF) << 21)
+                                 | (((uint32_t)(offset >> 11) & 0x1)  << 20)
+                                 | (((uint32_t)(offset >> 12) & 0xFF) << 12)
+                                 | (((uint32_t)(offset >> 20) & 0x1)  << 31));
+    rvjit_put_code(block, code, 4);
+}
+
+// Patching used for forward branches
+static inline void rvjit_riscv_branch_patch(void* addr, int32_t offset)
+{
+    uint32_t opcode = read_uint32_le_m(addr) & 0x1FFF07F;
+    if (unlikely(!rvjit_is_valid_imm(offset >> 1))) rvvm_fatal("Illegal branch patch offset in RVJIT!");
+    write_uint32_le_m(addr, opcode | (((uint32_t)offset & 0x1E) << 7) | ((offset & 0x800) >> 4)
+                                   | (((uint32_t)offset & 0x7E0) << 20) | (((uint32_t)offset & 0x1000) << 19));
+}
+
+static inline void rvjit_riscv_jal_patch(void* addr, int32_t offset)
+{
+    uint32_t opcode = 0x6F | (read_uint32_le_m(addr) & 0xFFF);
+    write_uint32_le_m(addr, opcode | (((uint32_t)(offset >> 1) & 0x3FF) << 21)
+                                   | (((uint32_t)(offset >> 11) & 0x1)  << 20)
+                                   | (((uint32_t)(offset >> 12) & 0xFF) << 12)
+                                   | (((uint32_t)(offset >> 20) & 0x1)  << 31));
+}
+
+#ifdef RVJIT_NATIVE_64BIT
+#define RISCV_S_SIZET RISCV_S_SD
+#define RISCV_L_SIZET RISCV_I_LD
+#else
+#define RISCV_S_SIZET RISCV_S_SW
+#define RISCV_L_SIZET RISCV_I_LW
+#endif
+
+/*
+ * Basic functionality
+ */
+static inline void rvjit_native_zero_reg(rvjit_block_t* block, regid_t reg)
+{
+    rvjit_riscv_i_op(block, RISCV_I_ADDI, reg, RISCV_REG_ZERO, 0);
+}
+
+static inline void rvjit_native_ret(rvjit_block_t* block)
+{
+    // May use compressed instruction (jr ra)
+    rvjit_riscv_i_op(block, RISCV_I_JALR, RISCV_REG_ZERO, RISCV_REG_RA, 0);
+}
+
+static inline void rvjit_native_push(rvjit_block_t* block, regid_t reg)
+{
+    UNUSED(block);
+    UNUSED(reg);
+    rvvm_fatal("Unimplemented rvjit_native_push for RISC-V backend");
+}
+
+static inline void rvjit_native_pop(rvjit_block_t* block, regid_t reg)
+{
+    UNUSED(block);
+    UNUSED(reg);
+    rvvm_fatal("Unimplemented rvjit_native_pop for RISC-V backend");
+}
+
+// Set native register reg to wide imm
+static inline void rvjit_native_setregw(rvjit_block_t* block, regid_t reg, uintptr_t imm)
+{
+#ifdef RVJIT_NATIVE_64BIT
+    if (imm >> 32) {
+        regid_t tmp = rvjit_claim_hreg(block);
+        rvjit_native_setreg32(block, tmp, imm >> 32);
+        rvjit_riscv_i_op(block, RISCV_I_SLLI, tmp, tmp, 32);
+        rvjit_native_setreg32(block, reg, (imm << 32) >> 32);
+        rvjit_riscv_r_op(block, RISCV_R_OR, reg, reg, tmp);
+        rvjit_free_hreg(block, tmp);
+    } else {
+        rvjit_native_setreg32(block, reg, imm);
+    }
+#else
+    rvjit_native_setreg32(block, reg, imm);
+#endif
+}
+
+// Call a function pointed to by native register
+static inline void rvjit_native_callreg(rvjit_block_t* block, regid_t reg)
+{
+    rvjit_riscv_i_op(block, RISCV_I_ADDI, RISCV_REG_SP, RISCV_REG_SP, -16);
+    rvjit_riscv_s_op(block, RISCV_S_SIZET, RISCV_REG_RA, RISCV_REG_SP, 16 - sizeof(size_t));
+    rvjit_riscv_i_op(block, RISCV_I_JALR, RISCV_REG_RA, reg, 0);
+    rvjit_riscv_s_op(block, RISCV_L_SIZET, RISCV_REG_RA, RISCV_REG_SP, 16 - sizeof(size_t));
+    rvjit_riscv_i_op(block, RISCV_I_ADDI, RISCV_REG_SP, RISCV_REG_SP, 16);
+}
+
+static inline branch_t rvjit_native_jmp(rvjit_block_t* block, branch_t handle, bool target)
+{
+    if (target) {
+        // This is a jump label
+        if (handle == BRANCH_NEW) {
+            // Backward jump: Save label address
+            return block->size;
+        } else {
+            // Forward jump: Patch jump offset
+            rvjit_riscv_jal_patch(block->code + handle, block->size - handle);
+            return BRANCH_NEW;
+        }
+    } else {
+        // This is a jump entry
+        if (handle == BRANCH_NEW) {
+            // Forward jump: Emit instruction, patch it later
+            branch_t tmp = block->size;
+            rvjit_riscv_jal(block, RISCV_REG_ZERO, 0);
+            return tmp;
+        } else {
+            // Backward jump: Emit instruction using label address
+            rvjit_riscv_jal(block, RISCV_REG_ZERO, handle - block->size);
+            return BRANCH_NEW;
+        }
+    }
+}
+
+static branch_t rvjit_riscv_branch_entry(rvjit_block_t* block, uint32_t opcode, regid_t hrs1, regid_t hrs2, branch_t handle)
+{
+    if (handle == BRANCH_NEW) {
+        branch_t tmp = block->size;
+        rvjit_riscv_b_op(block, opcode, hrs1, hrs2, 0);
+        return tmp;
+    } else {
+        rvjit_riscv_b_op(block, opcode, hrs1, hrs2, handle - block->size);
+        return BRANCH_NEW;
+    }
+}
+
+static branch_t rvjit_riscv_branch_target(rvjit_block_t* block, branch_t handle)
+{
+    if (handle == BRANCH_NEW) {
+        return block->size;
+    } else {
+        // Patch jump offset
+        rvjit_riscv_branch_patch(block->code + handle, block->size - handle);
+        return BRANCH_NEW;
+    }
+}
+
+static inline branch_t rvjit_riscv_branch(rvjit_block_t* block, uint32_t opcode, regid_t hrs1, regid_t hrs2, branch_t handle, bool target)
+{
+    if (target) {
+        return rvjit_riscv_branch_target(block, handle);
+    } else {
+        return rvjit_riscv_branch_entry(block, opcode, hrs1, hrs2, handle);
+    }
+}
+
+/*
+ * Linker routines
+ */
+
+static inline bool rvjit_is_valid_jal_imm(int32_t imm)
+{
+    return (((int32_t)(((uint32_t)imm) << 11)) >> 11) == imm;
+}
+
+// Emit jump instruction (may return false if offset cannot be encoded)
+static inline bool rvjit_tail_jmp(rvjit_block_t* block, int32_t offset)
+{
+    if (rvjit_is_valid_jal_imm(offset)) {
+        rvjit_riscv_jal(block, RISCV_REG_ZERO, offset);
+    } else {
+        regid_t tmp = rvjit_claim_hreg(block);
+        rvjit_riscv_auipc(block, tmp, offset + ((offset & 0x800) << 1));
+        rvjit_riscv_i_op_internal(block, RISCV_I_JALR, RISCV_REG_ZERO, tmp, offset & 0xFFF);
+        rvjit_free_hreg(block, tmp);
+    }
+    return true;
+}
+
+// Emit patchable ret instruction
+static inline void rvjit_patchable_ret(rvjit_block_t* block)
+{
+    // Always 4-bytes, same as JAL
+    rvjit_riscv_i_op(block, RISCV_I_JALR, RISCV_REG_ZERO, RISCV_REG_RA, 0);
+}
+
+// Jump if word pointed to by addr is nonzero (may emit nothing if the offset cannot be encoded)
+// Used to check interrupts in block linkage
+static inline void rvjit_tail_bnez(rvjit_block_t* block, regid_t addr, int32_t offset)
+{
+    size_t offset_fixup = block->size;
+    int32_t off;
+    regid_t tmp = rvjit_claim_hreg(block);
+    rvjit_riscv_i_op(block, RISCV_I_LW, tmp, addr, 0);
+
+    off = offset - (block->size - offset_fixup);
+    if (rvjit_is_valid_imm(off >> 1)) {
+        // Offset fits into branch instruction
+        rvjit_riscv_b_op(block, RISCV_B_BNE, RISCV_REG_ZERO, tmp, off);
+    } else {
+        // Use jal for 21-bit offset or auipc + jalr for full 32-bit offset
+        branch_t l1 = rvjit_riscv_branch(block, RISCV_B_BEQ, RISCV_REG_ZERO, tmp, BRANCH_NEW, false);
+        off = offset - (block->size - offset_fixup);
+        if (rvjit_is_valid_jal_imm(off)) {
+            rvjit_riscv_jal(block, RISCV_REG_ZERO, off);
+        } else {
+            rvjit_riscv_auipc(block, tmp, off + ((off & 0x800) << 1));
+            rvjit_riscv_i_op_internal(block, RISCV_I_JALR, RISCV_REG_ZERO, tmp, off & 0xFFF);
+        }
+        rvjit_riscv_branch(block, RISCV_B_BEQ, RISCV_REG_ZERO, tmp, l1, true);
+    }
+
+    rvjit_free_hreg(block, tmp);
+}
+
+// Patch instruction at addr into ret
+static inline void rvjit_patch_ret(void* addr)
+{
+    write_uint32_le_m(addr, 0x00008067);
+}
+
+// Patch jump instruction at addr (may return false if offset cannot be encoded)
+static inline bool rvjit_patch_jmp(void* addr, int32_t offset)
+{
+    if (rvjit_is_valid_jal_imm(offset)) {
+        write_uint32_le_m(addr, 0);
+        rvjit_riscv_jal_patch(addr, offset);
+        return true;
+    } else {
+        return false;
+    }
+}
+
+static inline void rvjit_jmp_reg(rvjit_block_t* block, regid_t reg)
+{
+    rvjit_riscv_i_op(block, RISCV_I_JALR, RISCV_REG_ZERO, reg, 0);
+}
+
+/*
+ * RV32
+ */
+static inline void rvjit32_native_add(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_riscv_r_op(block, RISCV32_R_ADD, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit32_native_sub(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_riscv_r_op(block, RISCV32_R_SUB, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit32_native_or(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_riscv_r_op(block, RISCV_R_OR, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit32_native_and(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_riscv_r_op(block, RISCV_R_AND, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit32_native_xor(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_riscv_r_op(block, RISCV_R_XOR, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit32_native_sra(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_riscv_r_op(block, RISCV32_R_SRA, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit32_native_srl(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_riscv_r_op(block, RISCV32_R_SRL, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit32_native_sll(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_riscv_r_op(block, RISCV32_R_SLL, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit32_native_addi(rvjit_block_t* block, regid_t hrds, regid_t hrs1, int32_t imm)
+{
+    rvjit_riscv_i_op(block, RISCV32_I_ADDI, hrds, hrs1, imm);
+}
+
+static inline void rvjit32_native_ori(rvjit_block_t* block, regid_t hrds, regid_t hrs1, int32_t imm)
+{
+    rvjit_riscv_i_op(block, RISCV_I_ORI, hrds, hrs1, imm);
+}
+
+static inline void rvjit32_native_andi(rvjit_block_t* block, regid_t hrds, regid_t hrs1, int32_t imm)
+{
+    rvjit_riscv_i_op(block, RISCV_I_ANDI, hrds, hrs1, imm);
+}
+
+static inline void rvjit32_native_xori(rvjit_block_t* block, regid_t hrds, regid_t hrs1, int32_t imm)
+{
+    rvjit_riscv_i_op(block, RISCV_I_XORI, hrds, hrs1, imm);
+}
+
+static inline void rvjit32_native_srai(rvjit_block_t* block, regid_t hrds, regid_t hrs1, uint8_t imm)
+{
+    rvjit_riscv_i_op(block, RISCV32_I_SRAI, hrds, hrs1, imm);
+}
+
+static inline void rvjit32_native_srli(rvjit_block_t* block, regid_t hrds, regid_t hrs1, uint8_t imm)
+{
+    rvjit_riscv_i_op(block, RISCV32_I_SRLI, hrds, hrs1, imm);
+}
+
+static inline void rvjit32_native_slli(rvjit_block_t* block, regid_t hrds, regid_t hrs1, uint8_t imm)
+{
+    rvjit_riscv_i_op(block, RISCV32_I_SLLI, hrds, hrs1, imm);
+}
+
+static inline void rvjit32_native_slti(rvjit_block_t* block, regid_t hrds, regid_t hrs1, int32_t imm)
+{
+    rvjit_riscv_i_op(block, RISCV_I_SLTI, hrds, hrs1, imm);
+}
+
+static inline void rvjit32_native_sltiu(rvjit_block_t* block, regid_t hrds, regid_t hrs1, int32_t imm)
+{
+    rvjit_riscv_i_op(block, RISCV_I_SLTIU, hrds, hrs1, imm);
+}
+
+static inline void rvjit32_native_slt(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_riscv_r_op(block, RISCV_R_SLT, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit32_native_sltu(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_riscv_r_op(block, RISCV_R_SLTU, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit32_native_lb(rvjit_block_t* block, regid_t dest, regid_t addr, int32_t off)
+{
+    rvjit_riscv_i_op(block, RISCV_I_LB, dest, addr, off);
+}
+
+static inline void rvjit32_native_lbu(rvjit_block_t* block, regid_t dest, regid_t addr, int32_t off)
+{
+    rvjit_riscv_i_op(block, RISCV_I_LBU, dest, addr, off);
+}
+
+static inline void rvjit32_native_lh(rvjit_block_t* block, regid_t dest, regid_t addr, int32_t off)
+{
+    rvjit_riscv_i_op(block, RISCV_I_LH, dest, addr, off);
+}
+
+static inline void rvjit32_native_lhu(rvjit_block_t* block, regid_t dest, regid_t addr, int32_t off)
+{
+    rvjit_riscv_i_op(block, RISCV_I_LHU, dest, addr, off);
+}
+
+static inline void rvjit32_native_lw(rvjit_block_t* block, regid_t dest, regid_t addr, int32_t off)
+{
+    rvjit_riscv_i_op(block, RISCV_I_LW, dest, addr, off);
+}
+
+static inline void rvjit32_native_sb(rvjit_block_t* block, regid_t src, regid_t addr, int32_t off)
+{
+    rvjit_riscv_s_op(block, RISCV_S_SB, src, addr, off);
+}
+
+static inline void rvjit32_native_sh(rvjit_block_t* block, regid_t src, regid_t addr, int32_t off)
+{
+    rvjit_riscv_s_op(block, RISCV_S_SH, src, addr, off);
+}
+
+static inline void rvjit32_native_sw(rvjit_block_t* block, regid_t src, regid_t addr, int32_t off)
+{
+    rvjit_riscv_s_op(block, RISCV_S_SW, src, addr, off);
+}
+
+static inline branch_t rvjit32_native_beq(rvjit_block_t* block, regid_t hrs1, regid_t hrs2, branch_t handle, bool target)
+{
+    return rvjit_riscv_branch(block, RISCV_B_BEQ, hrs1, hrs2, handle, target);
+}
+
+static inline branch_t rvjit32_native_bne(rvjit_block_t* block, regid_t hrs1, regid_t hrs2, branch_t handle, bool target)
+{
+    return rvjit_riscv_branch(block, RISCV_B_BNE, hrs1, hrs2, handle, target);
+}
+
+static inline branch_t rvjit32_native_beqz(rvjit_block_t* block, regid_t hrs1, branch_t handle, bool target)
+{
+    return rvjit_riscv_branch(block, RISCV_B_BEQ, hrs1, RISCV_REG_ZERO, handle, target);
+}
+
+static inline branch_t rvjit32_native_bnez(rvjit_block_t* block, regid_t hrs1, branch_t handle, bool target)
+{
+    return rvjit_riscv_branch(block, RISCV_B_BNE, hrs1, RISCV_REG_ZERO, handle, target);
+}
+
+static inline branch_t rvjit32_native_blt(rvjit_block_t* block, regid_t hrs1, regid_t hrs2, branch_t handle, bool target)
+{
+    return rvjit_riscv_branch(block, RISCV_B_BLT, hrs1, hrs2, handle, target);
+}
+
+static inline branch_t rvjit32_native_bge(rvjit_block_t* block, regid_t hrs1, regid_t hrs2, branch_t handle, bool target)
+{
+    return rvjit_riscv_branch(block, RISCV_B_BGE, hrs1, hrs2, handle, target);
+}
+
+static inline branch_t rvjit32_native_bltu(rvjit_block_t* block, regid_t hrs1, regid_t hrs2, branch_t handle, bool target)
+{
+    return rvjit_riscv_branch(block, RISCV_B_BLTU, hrs1, hrs2, handle, target);
+}
+
+static inline branch_t rvjit32_native_bgeu(rvjit_block_t* block, regid_t hrs1, regid_t hrs2, branch_t handle, bool target)
+{
+    return rvjit_riscv_branch(block, RISCV_B_BGEU, hrs1, hrs2, handle, target);
+}
+
+static inline void rvjit32_native_mul(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_riscv_r_op(block, RISCV32_R_MUL, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit32_native_mulh(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+#ifdef RVJIT_NATIVE_64BIT
+    rvjit_riscv_r_op(block, RISCV_R_MUL, hrds, hrs1, hrs2);
+    rvjit_riscv_i_op(block, RISCV_I_SRAI, hrds, hrds, 32);
+#else
+    rvjit_riscv_r_op(block, RISCV_R_MULH, hrds, hrs1, hrs2);
+#endif
+}
+
+static inline void rvjit32_native_mulhu(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+#ifdef RVJIT_NATIVE_64BIT
+    regid_t zrs1 = rvjit_claim_hreg(block);
+    regid_t zrs2 = rvjit_claim_hreg(block);
+    rvjit_riscv_i_op(block, RISCV_I_SLLI, zrs1, hrs1, 32);
+    rvjit_riscv_i_op(block, RISCV_I_SLLI, zrs2, hrs2, 32);
+    rvjit_riscv_r_op(block, RISCV_R_MULHU, hrds, zrs1, zrs2);
+    rvjit_riscv_i_op(block, RISCV_I_SRAI, hrds, hrds, 32);
+    rvjit_free_hreg(block, zrs1);
+    rvjit_free_hreg(block, zrs2);
+#else
+    rvjit_riscv_r_op(block, RISCV_R_MULHU, hrds, hrs1, hrs2);
+#endif
+}
+
+static inline void rvjit32_native_mulhsu(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+#ifdef RVJIT_NATIVE_64BIT
+    regid_t zrs2 = rvjit_claim_hreg(block);
+    rvjit_riscv_i_op(block, RISCV_I_SLLI, zrs2, hrs2, 32);
+    rvjit_riscv_i_op(block, RISCV_I_SRLI, zrs2, zrs2, 32);
+    rvjit_riscv_r_op(block, RISCV_R_MUL, hrds, hrs1, zrs2);
+    rvjit_riscv_i_op(block, RISCV_I_SRAI, hrds, hrds, 32);
+    rvjit_free_hreg(block, zrs2);
+#else
+    rvjit_riscv_r_op(block, RISCV_R_MULHS, hrds, hrs1, hrs2);
+#endif
+}
+
+static inline void rvjit32_native_div(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_riscv_r_op(block, RISCV32_R_DIV, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit32_native_divu(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_riscv_r_op(block, RISCV32_R_DIVU, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit32_native_rem(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_riscv_r_op(block, RISCV32_R_REM, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit32_native_remu(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_riscv_r_op(block, RISCV32_R_REMU, hrds, hrs1, hrs2);
+}
+
+/*
+ * RV64
+ */
+#ifdef RVJIT_NATIVE_64BIT
+static inline void rvjit64_native_add(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_riscv_r_op(block, RISCV_R_ADD, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit64_native_addw(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_riscv_r_op(block, RISCV_R_ADDW, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit64_native_sub(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_riscv_r_op(block, RISCV_R_SUB, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit64_native_subw(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_riscv_r_op(block, RISCV_R_SUBW, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit64_native_or(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_riscv_r_op(block, RISCV_R_OR, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit64_native_and(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_riscv_r_op(block, RISCV_R_AND, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit64_native_xor(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_riscv_r_op(block, RISCV_R_XOR, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit64_native_sra(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_riscv_r_op(block, RISCV_R_SRA, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit64_native_sraw(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_riscv_r_op(block, RISCV_R_SRAW, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit64_native_srl(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_riscv_r_op(block, RISCV_R_SRL, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit64_native_srlw(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_riscv_r_op(block, RISCV_R_SRLW, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit64_native_sll(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_riscv_r_op(block, RISCV_R_SLL, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit64_native_sllw(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_riscv_r_op(block, RISCV_R_SLLW, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit64_native_addi(rvjit_block_t* block, regid_t hrds, regid_t hrs1, int32_t imm)
+{
+    rvjit_riscv_i_op(block, RISCV_I_ADDI, hrds, hrs1, imm);
+}
+
+static inline void rvjit64_native_addiw(rvjit_block_t* block, regid_t hrds, regid_t hrs1, int32_t imm)
+{
+    rvjit_riscv_i_op(block, RISCV_I_ADDIW, hrds, hrs1, imm);
+}
+
+static inline void rvjit64_native_ori(rvjit_block_t* block, regid_t hrds, regid_t hrs1, int32_t imm)
+{
+    rvjit_riscv_i_op(block, RISCV_I_ORI, hrds, hrs1, imm);
+}
+
+static inline void rvjit64_native_andi(rvjit_block_t* block, regid_t hrds, regid_t hrs1, int32_t imm)
+{
+    rvjit_riscv_i_op(block, RISCV_I_ANDI, hrds, hrs1, imm);
+}
+
+static inline void rvjit64_native_xori(rvjit_block_t* block, regid_t hrds, regid_t hrs1, int32_t imm)
+{
+    rvjit_riscv_i_op(block, RISCV_I_XORI, hrds, hrs1, imm);
+}
+
+static inline void rvjit64_native_srli(rvjit_block_t* block, regid_t hrds, regid_t hrs1, uint8_t imm)
+{
+    rvjit_riscv_i_op(block, RISCV_I_SRLI, hrds, hrs1, imm);
+}
+
+static inline void rvjit64_native_srliw(rvjit_block_t* block, regid_t hrds, regid_t hrs1, uint8_t imm)
+{
+    rvjit_riscv_i_op(block, RISCV_I_SRLIW, hrds, hrs1, imm);
+}
+
+static inline void rvjit64_native_srai(rvjit_block_t* block, regid_t hrds, regid_t hrs1, uint8_t imm)
+{
+    rvjit_riscv_i_op(block, RISCV_I_SRAI, hrds, hrs1, imm);
+}
+
+static inline void rvjit64_native_sraiw(rvjit_block_t* block, regid_t hrds, regid_t hrs1, uint8_t imm)
+{
+    rvjit_riscv_i_op(block, RISCV_I_SRAIW, hrds, hrs1, imm);
+}
+
+static inline void rvjit64_native_slli(rvjit_block_t* block, regid_t hrds, regid_t hrs1, uint8_t imm)
+{
+    rvjit_riscv_i_op(block, RISCV_I_SLLI, hrds, hrs1, imm);
+}
+
+static inline void rvjit64_native_slliw(rvjit_block_t* block, regid_t hrds, regid_t hrs1, uint8_t imm)
+{
+    rvjit_riscv_i_op(block, RISCV_I_SLLIW, hrds, hrs1, imm);
+}
+
+static inline void rvjit64_native_slti(rvjit_block_t* block, regid_t hrds, regid_t hrs1, int32_t imm)
+{
+    rvjit_riscv_i_op(block, RISCV_I_SLTI, hrds, hrs1, imm);
+}
+
+static inline void rvjit64_native_sltiu(rvjit_block_t* block, regid_t hrds, regid_t hrs1, int32_t imm)
+{
+    rvjit_riscv_i_op(block, RISCV_I_SLTIU, hrds, hrs1, imm);
+}
+
+static inline void rvjit64_native_slt(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_riscv_r_op(block, RISCV_R_SLT, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit64_native_sltu(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_riscv_r_op(block, RISCV_R_SLTU, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit64_native_lb(rvjit_block_t* block, regid_t dest, regid_t addr, int32_t off)
+{
+    rvjit_riscv_i_op(block, RISCV_I_LB, dest, addr, off);
+}
+
+static inline void rvjit64_native_lbu(rvjit_block_t* block, regid_t dest, regid_t addr, int32_t off)
+{
+    rvjit_riscv_i_op(block, RISCV_I_LBU, dest, addr, off);
+}
+
+static inline void rvjit64_native_lh(rvjit_block_t* block, regid_t dest, regid_t addr, int32_t off)
+{
+    rvjit_riscv_i_op(block, RISCV_I_LH, dest, addr, off);
+}
+
+static inline void rvjit64_native_lhu(rvjit_block_t* block, regid_t dest, regid_t addr, int32_t off)
+{
+    rvjit_riscv_i_op(block, RISCV_I_LHU, dest, addr, off);
+}
+
+static inline void rvjit64_native_lw(rvjit_block_t* block, regid_t dest, regid_t addr, int32_t off)
+{
+    rvjit_riscv_i_op(block, RISCV_I_LW, dest, addr, off);
+}
+
+static inline void rvjit64_native_lwu(rvjit_block_t* block, regid_t dest, regid_t addr, int32_t off)
+{
+    rvjit_riscv_i_op(block, RISCV_I_LWU, dest, addr, off);
+}
+
+static inline void rvjit64_native_ld(rvjit_block_t* block, regid_t dest, regid_t addr, int32_t off)
+{
+    rvjit_riscv_i_op(block, RISCV_I_LD, dest, addr, off);
+}
+
+static inline void rvjit64_native_sb(rvjit_block_t* block, regid_t src, regid_t addr, int32_t off)
+{
+    rvjit_riscv_s_op(block, RISCV_S_SB, src, addr, off);
+}
+
+static inline void rvjit64_native_sh(rvjit_block_t* block, regid_t src, regid_t addr, int32_t off)
+{
+    rvjit_riscv_s_op(block, RISCV_S_SH, src, addr, off);
+}
+
+static inline void rvjit64_native_sw(rvjit_block_t* block, regid_t src, regid_t addr, int32_t off)
+{
+    rvjit_riscv_s_op(block, RISCV_S_SW, src, addr, off);
+}
+
+static inline void rvjit64_native_sd(rvjit_block_t* block, regid_t src, regid_t addr, int32_t off)
+{
+    rvjit_riscv_s_op(block, RISCV_S_SD, src, addr, off);
+}
+
+static inline branch_t rvjit64_native_beq(rvjit_block_t* block, regid_t hrs1, regid_t hrs2, branch_t handle, bool target)
+{
+    return rvjit_riscv_branch(block, RISCV_B_BEQ, hrs1, hrs2, handle, target);
+}
+
+static inline branch_t rvjit64_native_bne(rvjit_block_t* block, regid_t hrs1, regid_t hrs2, branch_t handle, bool target)
+{
+    return rvjit_riscv_branch(block, RISCV_B_BNE, hrs1, hrs2, handle, target);
+}
+
+static inline branch_t rvjit64_native_beqz(rvjit_block_t* block, regid_t hrs1, branch_t handle, bool target)
+{
+    return rvjit_riscv_branch(block, RISCV_B_BEQ, hrs1, RISCV_REG_ZERO, handle, target);
+}
+
+static inline branch_t rvjit64_native_bnez(rvjit_block_t* block, regid_t hrs1, branch_t handle, bool target)
+{
+    return rvjit_riscv_branch(block, RISCV_B_BNE, hrs1, RISCV_REG_ZERO, handle, target);
+}
+
+static inline branch_t rvjit64_native_blt(rvjit_block_t* block, regid_t hrs1, regid_t hrs2, branch_t handle, bool target)
+{
+    return rvjit_riscv_branch(block, RISCV_B_BLT, hrs1, hrs2, handle, target);
+}
+
+static inline branch_t rvjit64_native_bge(rvjit_block_t* block, regid_t hrs1, regid_t hrs2, branch_t handle, bool target)
+{
+    return rvjit_riscv_branch(block, RISCV_B_BGE, hrs1, hrs2, handle, target);
+}
+
+static inline branch_t rvjit64_native_bltu(rvjit_block_t* block, regid_t hrs1, regid_t hrs2, branch_t handle, bool target)
+{
+    return rvjit_riscv_branch(block, RISCV_B_BLTU, hrs1, hrs2, handle, target);
+}
+
+static inline branch_t rvjit64_native_bgeu(rvjit_block_t* block, regid_t hrs1, regid_t hrs2, branch_t handle, bool target)
+{
+    return rvjit_riscv_branch(block, RISCV_B_BGEU, hrs1, hrs2, handle, target);
+}
+
+static inline void rvjit64_native_mul(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_riscv_r_op(block, RISCV_R_MUL, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit64_native_mulh(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_riscv_r_op(block, RISCV_R_MULH, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit64_native_mulhu(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_riscv_r_op(block, RISCV_R_MULHU, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit64_native_mulhsu(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_riscv_r_op(block, RISCV_R_MULHS, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit64_native_div(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_riscv_r_op(block, RISCV_R_DIV, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit64_native_divu(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_riscv_r_op(block, RISCV_R_DIVU, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit64_native_rem(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_riscv_r_op(block, RISCV_R_REM, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit64_native_remu(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_riscv_r_op(block, RISCV_R_REMU, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit64_native_mulw(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_riscv_r_op(block, RISCV_R_MULW, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit64_native_divw(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_riscv_r_op(block, RISCV_R_DIVW, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit64_native_divuw(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_riscv_r_op(block, RISCV_R_DIVUW, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit64_native_remw(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_riscv_r_op(block, RISCV_R_REMW, hrds, hrs1, hrs2);
+}
+
+static inline void rvjit64_native_remuw(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_riscv_r_op(block, RISCV_R_REMUW, hrds, hrs1, hrs2);
+}
+
+#endif
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/rvjit/rvjit_x86.h b/app/src/main/java/libengine/RVVM/src/rvjit/rvjit_x86.h
new file mode 100644
index 00000000..612b777b
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/rvjit/rvjit_x86.h
@@ -0,0 +1,1868 @@
+/*
+rvjit_x86.h - RVJIT x86 Backend
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef RVJIT_X86_H
+#define RVJIT_X86_H
+
+#include "rvjit.h"
+#include "../mem_ops.h"
+#include "../compiler.h"
+#include "../utils.h"
+
+#if defined(RVJIT_NATIVE_64BIT) && defined(_MSC_VER)
+#include <intrin.h> // For cpuid
+#endif
+
+#define X86_EAX 0x0
+#define X86_ECX 0x1
+#define X86_EDX 0x2
+#define X86_EBX 0x3
+#define X86_ESP 0x4
+#define X86_EBP 0x5
+#define X86_ESI 0x6
+#define X86_EDI 0x7
+
+#define X64_RAX X86_EAX
+#define X64_RCX X86_ECX
+#define X64_RDX X86_EDX
+#define X64_RBX X86_EBX
+#define X64_RSP X86_ESP
+#define X64_RBP X86_EBP
+#define X64_RSI X86_ESI
+#define X64_RDI X86_EDI
+#define X64_R8  0x8
+#define X64_R9  0x9
+#define X64_R10 0xA
+#define X64_R11 0xB
+#define X64_R12 0xC
+#define X64_R13 0xD
+#define X64_R14 0xE
+#define X64_R15 0xF
+
+#define SSE_XMM0  0x0
+#define SSE_XMM1  0x1
+#define SSE_XMM2  0x2
+#define SSE_XMM3  0x3
+#define SSE_XMM4  0x4
+#define SSE_XMM5  0x5
+#define SSE_XMM6  0x6
+#define SSE_XMM7  0x7
+#define SSE_XMM8  0x8
+#define SSE_XMM9  0x9
+#define SSE_XMM10 0xA
+#define SSE_XMM11 0xB
+#define SSE_XMM12 0xC
+#define SSE_XMM13 0xD
+#define SSE_XMM14 0xE
+#define SSE_XMM15 0xF
+
+#ifdef RVJIT_ABI_SYSV
+#define VM_PTR_REG X64_RDI
+#elif RVJIT_ABI_WIN64
+#define VM_PTR_REG X64_RCX
+#elif RVJIT_ABI_FASTCALL
+#define VM_PTR_REG X86_ECX
+#endif
+
+static inline size_t rvjit_native_default_hregmask(void)
+{
+#ifdef RVJIT_NATIVE_64BIT
+    return rvjit_hreg_mask(X64_RAX) |
+#ifndef RVJIT_ABI_WIN64
+           rvjit_hreg_mask(X64_RCX) |
+           rvjit_hreg_mask(X64_RSI) |
+#endif
+           rvjit_hreg_mask(X64_RDX) |
+           rvjit_hreg_mask(X64_R8)  |
+           rvjit_hreg_mask(X64_R9)  |
+           rvjit_hreg_mask(X64_R10) |
+           rvjit_hreg_mask(X64_R11);
+#elif RVJIT_ABI_FASTCALL
+    // Pretty much useless without abireclaim
+    return rvjit_hreg_mask(X86_EAX) |
+           rvjit_hreg_mask(X86_EDX);
+#else
+    return 0;
+#endif
+}
+
+static inline size_t rvjit_native_abireclaim_hregmask(void)
+{
+#ifdef RVJIT_NATIVE_64BIT
+    return rvjit_hreg_mask(X64_RBX) |
+           rvjit_hreg_mask(X64_RBP) |
+#ifdef RVJIT_ABI_WIN64
+           rvjit_hreg_mask(X64_RSI) |
+           rvjit_hreg_mask(X64_RDI) |
+#endif
+           rvjit_hreg_mask(X64_R12) |
+           rvjit_hreg_mask(X64_R13) |
+           rvjit_hreg_mask(X64_R14) |
+           rvjit_hreg_mask(X64_R15);
+#elif RVJIT_ABI_FASTCALL
+    return rvjit_hreg_mask(X86_EBX) |
+           rvjit_hreg_mask(X86_EBP) |
+           rvjit_hreg_mask(X86_ESI) |
+           rvjit_hreg_mask(X86_EDI);
+#else
+    return 0;
+#endif
+}
+
+static inline size_t rvjit_native_default_fpu_regmask(void)
+{
+#ifdef RVJIT_ABI_SYSV
+    return 0xFFFF; // All XMM registers are caller-saved
+#elif RVJIT_ABI_WIN64
+    return 0x1F;  // XMM0 - XMM5 are caller-saved
+#elif RVJIT_ABI_FASTCALL
+    return 0x1F;  // TODO
+#else
+    return 0;
+#endif
+}
+
+// REX prefixes
+#define X64_REX_W     0x48  // Operands are 64-bit wide
+#define X64_REX_R     0x44  // Second (destination) register is >= R8
+#define X64_REX_X     0x42
+#define X64_REX_B     0x41  // First (source) register is >= R8
+
+static inline bool x86_is_byte_imm(int32_t imm)
+{
+    return imm == (int32_t)(int8_t)imm;
+}
+
+// Valid 1-byte 1-reg opcodes
+#define X86_PUSH 0x50
+#define X86_POP  0x58
+
+static inline void rvjit_x86_1byte_1reg_op(rvjit_block_t* block, uint8_t opcode, regid_t reg)
+{
+    uint8_t code[2] = { X64_REX_B, opcode | (reg & 0x7), };
+    size_t size = (reg < X64_R8) ? 1 : 2;
+    size_t off = 2 - size;
+    rvjit_put_code(block, code + off, size);
+}
+
+static inline void rvjit_native_push(rvjit_block_t* block, regid_t reg)
+{
+    rvjit_x86_1byte_1reg_op(block, X86_PUSH, reg);
+}
+
+static inline void rvjit_native_pop(rvjit_block_t* block, regid_t reg)
+{
+    rvjit_x86_1byte_1reg_op(block, X86_POP, reg);
+}
+
+// Valid 2-reg opcodes
+#define X86_ADD     0x01
+#define X86_SUB     0x29
+#define X86_OR      0x09
+#define X86_AND     0x21
+#define X86_XOR     0x31
+#define X86_CMP     0x39
+#define X86_MOV_R_M 0x89 // Move between registers
+#define X86_MOVSXD  0x63 // Sign-extend 32 to 64 bits, x86_64 only!
+#define X86_XCHG    0x87 // This has a shorter encoding..
+
+#define X86_2_REGS  0xC0
+
+static inline void rvjit_x86_2reg_op(rvjit_block_t* block, uint8_t opcode, regid_t dst, regid_t src, bool bits_64)
+{
+    uint8_t code[3] = { 0, opcode, X86_2_REGS | ((src & 0x7) << 3) | (dst & 0x7), };
+    // If we are operating on 64 bit values set wide prefix
+    if (bits_64) code[0] = X64_REX_W;
+    if (src >= X64_R8) code[0] |= X64_REX_R;
+    if (dst >= X64_R8) code[0] |= X64_REX_B;
+    rvjit_put_code(block, code + (code[0] ? 0 : 1), code[0] ? 3 : 2);
+}
+
+// Valid 2-reg 0f prefix opcodes
+#define X86_IMUL_2REG 0xAF
+#define X86_BTS       0xAB // Set bit
+#define X86_BTR       0xB3 // Clear bit
+#define X86_BTC       0xBB // Invert bit
+#define X86_BSF       0xBC // Bit scan forward
+#define X86_BSR       0xBD // Bit scan reverse
+#define X86_MOVSXW    0xBF // Sign-extend 16-bit
+#define X86_MOVZXW    0xB7 // Zero-extend 16-bit
+#define X86_CMOVE     0x44 // Conditional move if equal, Pentium Pro+
+#define X86_CMOVNE    0x45 // Conditional move if not equal, Pentium Pro+
+
+static inline void rvjit_x86_0f_2reg_op(rvjit_block_t* block, uint8_t opcode, regid_t dst, regid_t src, bool bits_64)
+{
+    uint8_t code[4] = { 0, 0x0F, opcode, X86_2_REGS | ((dst & 0x7) << 3) | (src & 0x7), };
+    if (bits_64) code[0] = X64_REX_W;
+    if (src >= X64_R8) code[0] |= X64_REX_B;
+    if (dst >= X64_R8) code[0] |= X64_REX_R;
+    rvjit_put_code(block, code + (code[0] ? 0 : 1), code[0] ? 4 : 3);
+}
+
+#define X86_MOVSXB    0xBE // Sign-extend 8-bit
+#define X86_MOVZXB    0xB6 // Zero-extend 8-bit
+
+// Zero/sign extend data from 8-bit src to full register
+// Careful: not all 8-bit registers are accessible on i386
+static inline void rvjit_x86_movxb(rvjit_block_t* block, uint8_t opcode, regid_t dst, regid_t src, bool bits_64)
+{
+    uint8_t code[4] = { 0, 0x0F, opcode, X86_2_REGS | ((dst & 0x7) << 3) | (src & 0x7), };
+    if (bits_64) code[0] = X64_REX_W;
+    if (src >= X64_R8) code[0] |= X64_REX_B;
+    if (dst >= X64_R8) code[0] |= X64_REX_R;
+    // REX prefix for using sil, dil, r8b... registers
+    if (src > X86_EBX) code[0] |= 0x40;
+    rvjit_put_code(block, code + (code[0] ? 0 : 1), code[0] ? 4 : 3);
+}
+
+// Valid reg + imm opcodes
+#define X86_ADD_IMM 0xC0
+#define X86_OR_IMM  0xC8
+#define X86_AND_IMM 0xE0
+#define X86_XOR_IMM 0xF0
+#define X86_CMP_IMM 0xF8
+
+#define X86_IMM_OP  0x81
+
+// 1 register operand + 32-bit sign-extended immediate instruction
+static inline void rvjit_x86_r_imm_op(rvjit_block_t* block, uint8_t opcode, regid_t reg, int32_t imm, bool bits_64)
+{
+    uint8_t code[7] = { 0, X86_IMM_OP, opcode | (reg & 0x7),  };
+    if (bits_64) code[0] = X64_REX_W;
+    if (reg >= X64_R8) code[0] |= X64_REX_B;
+    size_t insn_size = code[0] ? 4 : 3;
+    if (x86_is_byte_imm(imm)) {
+        code[1] |= 0x02; // IMM length override
+        write_uint8(code + 3, imm);
+    } else {
+        write_uint32_le_m(code + 3, imm);
+        insn_size += 3;
+    }
+    rvjit_put_code(block, code + (code[0] ? 0 : 1), insn_size);
+}
+
+#define X86_BTS_IMM 0xE8 // Set bit
+#define X86_BTR_IMM 0xF0 // Clear bit
+#define X86_BTC_IMM 0xF8 // Invert bit
+
+// Single-bit imm operations
+static inline void rvjit_x86_s_bit_imm(rvjit_block_t* block, uint8_t opcode, regid_t reg, uint8_t imm, bool bits_64)
+{
+    uint8_t code[5] = { 0, 0x0F, 0xBA, opcode | (reg & 0x7), imm, };
+    if (bits_64) code[0] = X64_REX_W;
+    if (reg >= X64_R8) code[0] |= X64_REX_B;
+    rvjit_put_code(block, code + (code[0] ? 0 : 1), code[0] ? 5 : 4);
+}
+
+#define X86_SLL 0xE0
+#define X86_SRL 0xE8
+#define X86_SRA 0xF8
+#define X86_ROL 0xC0
+#define X86_ROR 0xC8
+
+// 1 register operand, cl(ecx) register is used as shift amount
+// For whatever stupid reason we cannot use any register as shift amount, needs workarounds
+static inline void rvjit_x86_shift_op(rvjit_block_t* block, uint8_t opcode, regid_t reg, bool bits_64)
+{
+    uint8_t code[3] = { 0, 0xD3, opcode | (reg & 0x7), };
+    if (bits_64) code[0] = X64_REX_W;
+    if (reg >= X64_R8) code[0] |= X64_REX_B;
+    rvjit_put_code(block, code + (code[0] ? 0 : 1), code[0] ? 3 : 2);
+}
+
+static inline void rvjit_x86_imm_shift_op(rvjit_block_t* block, uint8_t opcode, regid_t reg, uint8_t imm, bool bits_64)
+{
+    uint8_t code[4] = { 0, 0xC1, opcode | (reg & 0x7), imm, };
+    if (bits_64) code[0] = X64_REX_W;
+    if (reg >= X64_R8) code[0] |= X64_REX_B;
+    rvjit_put_code(block, code + (code[0] ? 0 : 1), code[0] ? 4 : 3);
+}
+
+#define X86_NEG  0xD8
+#define X86_NOT  0xD0
+#define X86_MUL  0xE0
+#define X86_IMUL 0xE8
+#define X86_DIV  0xF0
+#define X86_IDIV 0xF8
+
+// mul/imul EDX:EAX = EAX * reg, used for mulh
+// div/idiv EAX = EDX:EAX / reg; EDX = EDX:EAX % reg, used for div
+// neg, not
+static inline void rvjit_x86_1reg_op(rvjit_block_t* block, uint8_t opcode, regid_t reg, bool bits_64)
+{
+    uint8_t code[3] = { 0, 0xF7, opcode | (reg & 0x7), };
+    if (bits_64) code[0] = X64_REX_W;
+    if (reg >= X64_R8) code[0] |= X64_REX_B;
+    rvjit_put_code(block, code + (code[0] ? 0 : 1), code[0] ? 3 : 2);
+}
+
+// Negate a register
+static inline void rvjit_x86_neg(rvjit_block_t* block, regid_t reg, bool bits_64)
+{
+    rvjit_x86_1reg_op(block, X86_NEG, reg, bits_64);
+}
+
+// Copy data from native register src to dest
+static inline void rvjit_x86_mov(rvjit_block_t* block, regid_t dest, regid_t src, bool bits_64)
+{
+    rvjit_x86_2reg_op(block, X86_MOV_R_M, dest, src, bits_64);
+}
+
+// Swap data between 2 registers
+static inline void rvjit_x86_xchg(rvjit_block_t* block, regid_t dest, regid_t src)
+{
+#ifdef RVJIT_NATIVE_64BIT
+    rvjit_x86_2reg_op(block, X86_XCHG, dest, src, true);
+#else
+    rvjit_x86_2reg_op(block, X86_XCHG, dest, src, false);
+#endif
+}
+
+// Sign-extend data from 32-bit src to 64-bit dest
+static inline void rvjit_x86_movsxd(rvjit_block_t* block, regid_t dest, regid_t src)
+{
+    rvjit_x86_2reg_op(block, X86_MOVSXD, src, dest, true);
+}
+
+static bool x86_byte_reg_usable(regid_t reg)
+{
+#ifdef RVJIT_NATIVE_64BIT
+    return reg <= X64_R15;
+#else
+    return reg <= X86_EBX;
+#endif
+}
+
+// Memory operand offset size
+#define X86_MEM_OFFB  0x40
+#define X86_MEM_OFFW  0x80
+
+// Emit memory-addressing part of the instruction
+static inline void rvjit_x86_memory_ref(rvjit_block_t* block, regid_t dst, regid_t addr, int32_t off)
+{
+    uint8_t code[6] = { (addr & 0x7) | ((dst & 0x7) << 3), };
+    uint8_t insn_size = 1;
+    if ((addr & 0x7) == X86_ESP) {
+        // SIB byte (edge case)
+        code[1] = 0x24;
+        insn_size++;
+    }
+    if (!x86_is_byte_imm(off)) {
+        // Huge offset
+        code[0] |= X86_MEM_OFFW;
+        write_uint32_le_m(code + insn_size, off);
+        insn_size += 4;
+    } else if (off || (addr & 0x7) == X86_EBP) {
+        // 1-byte offset
+        code[0] |= X86_MEM_OFFB;
+        code[insn_size] = off;
+        insn_size++;
+    }
+    rvjit_put_code(block, code, insn_size);
+}
+
+// x86 substitute for addi instruction
+static inline void rvjit_x86_lea_addi(rvjit_block_t* block, regid_t dst, regid_t src, int32_t imm, bool bits_64)
+{
+    uint8_t code[2] = { 0, 0x8D, };
+    if (bits_64) code[0] = X64_REX_W;
+    if (src >= X64_R8) code[0] |= X64_REX_B;
+    if (dst >= X64_R8) code[0] |= X64_REX_R;
+    rvjit_put_code(block, code + (code[0] ? 0 : 1), code[0] ? 2 : 1);
+    rvjit_x86_memory_ref(block, dst, src, imm);
+}
+
+// x86 substitute for 3-operand add instruction (With second operand shift)
+static inline void rvjit_x86_lea_add(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2, uint8_t shift, bool bits_64)
+{
+    uint8_t code[5] = { 0x00, 0x8D, 0x04 | ((hrds & 0x7) << 3), (hrs1 & 0x7) | ((hrs2 & 0x7) << 3) | (shift << 6), 0x00, };
+    uint8_t inst_size = 3;
+    if (bits_64) code[0] = X64_REX_W;
+    if (hrds >= X64_R8) code[0] |= X64_REX_R;
+    if (hrs1 >= X64_R8) code[0] |= X64_REX_B;
+    if (hrs2 >= X64_R8) code[0] |= X64_REX_X;
+    if ((hrs1 & 0x7) == X86_EBP) {
+        code[2] |= X86_MEM_OFFB;
+        inst_size++;
+    }
+    rvjit_put_code(block, code + (code[0] ? 0 : 1), inst_size + (code[0] ? 1 : 0));
+}
+
+static inline void rvjit_x86_3reg_op(rvjit_block_t* block, uint8_t opcode, regid_t hrds, regid_t hrs1, regid_t hrs2, bool bits_64)
+{
+    if (hrds == hrs1) {
+        rvjit_x86_2reg_op(block, opcode, hrds, hrs2, bits_64);
+    } else if (hrds == hrs2) {
+        if (opcode == X86_SUB) {
+            // Edge case: subtracted operand is destination, lower to neg + add
+            rvjit_x86_neg(block, hrs2, bits_64);
+            rvjit_x86_2reg_op(block, X86_ADD, hrds, hrs1, bits_64);
+        } else {
+            rvjit_x86_2reg_op(block, opcode, hrds, hrs1, bits_64);
+        }
+    } else {
+        if (opcode == X86_ADD) {
+            // add r1, r2, r3 -> lea r1, [r2 + r3]
+            rvjit_x86_lea_add(block, hrds, hrs1, hrs2, 0, bits_64);
+            return;
+        }
+        rvjit_x86_mov(block, hrds, hrs1, bits_64);
+        rvjit_x86_2reg_op(block, opcode, hrds, hrs2, bits_64);
+    }
+}
+
+static inline void rvjit_x86_2reg_imm_op(rvjit_block_t* block, uint8_t opcode, regid_t hrds, regid_t hrs1, int32_t imm, bool bits_64)
+{
+    if (opcode == X86_AND_IMM) {
+        if (imm == 0) {
+            // Optimize andi r1, r2, 0 -> xor r1, r1
+            rvjit_x86_2reg_op(block, X86_XOR, hrds, hrds, false);
+            return;
+        } else if (imm == 0xFF && x86_byte_reg_usable(hrs1)) {
+            // Optimize andi r1, r2, 0xFF -> movzxb r1, r2
+            rvjit_x86_movxb(block, X86_MOVZXB, hrds, hrs1, false);
+            return;
+        } else if (imm > 0) {
+            // Remove REX.W prefix for unsigned andi imm
+            bits_64 = false;
+        }
+    } else if (opcode == X86_ADD_IMM && imm && hrds != hrs1) {
+        // addi r1, r2, imm -> lea r1, [r2 + imm]
+        rvjit_x86_lea_addi(block, hrds, hrs1, imm, bits_64);
+        return;
+    }
+    if (hrds != hrs1) rvjit_x86_mov(block, hrds, hrs1, bits_64);
+    if (opcode == X86_XOR_IMM && imm == -1) {
+        // xor r1, r2, -1 -> not r1, r2
+        rvjit_x86_1reg_op(block, X86_NOT, hrds, bits_64);
+    } else if (imm) rvjit_x86_r_imm_op(block, opcode, hrds, imm, bits_64);
+}
+
+static inline void rvjit_x86_2reg_imm_shift_op(rvjit_block_t* block, uint8_t opcode, regid_t hrds, regid_t hrs1, uint8_t imm, bool bits_64)
+{
+    if (hrds != hrs1) rvjit_x86_mov(block, hrds, hrs1, bits_64);
+    if (imm) rvjit_x86_imm_shift_op(block, opcode, hrds, imm, bits_64);
+}
+
+#define X86_VEX_RI 0x80
+#define X86_VEX_BI 0x20
+#define X86_VEX_W  0x80
+
+// Orthogonal 3-operand shlx/shrx/sarx from BMI2 extension
+static inline void rvjit_x86_vex_shift_op(rvjit_block_t* block, uint8_t opcode, regid_t hrds, regid_t hrs1, regid_t hrs2, bool bits_64)
+{
+    uint8_t code[5] = { 0xC4, 0x42, ((~hrs2) & 0xF) << 3, 0xF7, 0xC0 | (hrs1 & 0x7) | ((hrds & 0x7) << 3), };
+    if (bits_64) code[2] |= X86_VEX_W;
+    if (hrds < X64_R8) code[1] |= X86_VEX_RI;
+    if (hrs1 < X64_R8) code[1] |= X86_VEX_BI;
+    switch (opcode) {
+        case X86_SLL: code[2] |= 0x1; break;
+        case X86_SRL: code[2] |= 0x3; break;
+        case X86_SRA: code[2] |= 0x2; break;
+    }
+    rvjit_put_code(block, code, 5);
+}
+
+static void rvjit_x86_cpuid_internal(uint32_t eax, uint32_t ecx, uint32_t* regs)
+{
+#if defined(RVJIT_NATIVE_64BIT) && defined(GNU_EXTS)
+    __asm__ __volatile__ (
+        "cpuid"
+        : "=a"(regs[0]), "=b"(regs[1]), "=c"(regs[2]), "=d"(regs[3])
+        : "a"(eax), "c"(ecx));
+#elif defined(RVJIT_NATIVE_64BIT) && defined(_MSC_VER)
+    __cpuidex(regs, eax, ecx);
+#else
+    // Don't bother checking fancy extensions on i386 or exotic compilers
+    UNUSED(eax);
+    UNUSED(ecx);
+    memset(regs, 0, sizeof(uint32_t) * 4);
+#endif
+}
+
+static void rvjit_x86_cpuid(uint32_t eax, uint32_t ecx, uint32_t* regs)
+{
+    // Check maximum allowed EAX value for cpuid
+    uint32_t tmp_regs[4] = {0};
+    rvjit_x86_cpuid_internal(0, 0, tmp_regs);
+
+    if (eax <= tmp_regs[0]) {
+        rvjit_x86_cpuid_internal(eax, ecx, regs);
+    } else {
+        memset(regs, 0, sizeof(uint32_t) * 4);
+    }
+}
+
+static inline bool rvjit_x86_has_bmi2(void)
+{
+    static bool bmi2 = false;
+    DO_ONCE ({
+        if (rvvm_has_arg("rvjit_force_bmi2")) {
+            bmi2 = rvvm_getarg_bool("rvjit_force_bmi2");
+        } else {
+            uint32_t regs[4] = {0};
+            rvjit_x86_cpuid(7, 0, regs);
+            bmi2 = !!(regs[1] & 0x100);
+        }
+        if (bmi2) rvvm_info("RVJIT detected x86 BMI2 extension");
+    });
+    return bmi2;
+}
+
+static inline void rvjit_x86_3reg_shift_op(rvjit_block_t* block, uint8_t opcode, regid_t hrds, regid_t hrs1, regid_t hrs2, bool bits_64)
+{
+    /* Shift by register is insane on i386, practically a 1-operand instruction,
+     * with CL hardcoded as shift amount reg.
+     * This function implements a proper 3-operand intrinsic.
+     */
+    if (rvjit_x86_has_bmi2()) {
+        // On BMI2 hardware, we have 1:1 instruction mappings into shlx/shrx/sarx
+        rvjit_x86_vex_shift_op(block, opcode, hrds, hrs1, hrs2, bits_64);
+        return;
+    }
+
+    if (hrds == hrs1) {
+        if (hrs2 != X86_ECX) {
+            rvjit_x86_xchg(block, X86_ECX, hrs2);
+            if (hrds == X86_ECX) {
+                // We exchanged rds with ECX
+                hrds = hrs2;
+            } else if (hrds == hrs2) {
+                // Everything is in ECX now
+                hrds = X86_ECX;
+            }
+            rvjit_x86_shift_op(block, opcode, hrds, bits_64);
+            rvjit_x86_xchg(block, X86_ECX, hrs2);
+        } else {
+            rvjit_x86_shift_op(block, opcode, hrds, bits_64);
+        }
+    } else if (hrds == hrs2) {
+        // Cursed...
+        rvjit_native_push(block, hrs1);
+        if (hrs1 == X86_ECX) {
+            rvjit_x86_xchg(block, X86_ECX, hrds);
+            rvjit_x86_shift_op(block, opcode, hrds, bits_64);
+            rvjit_x86_xchg(block, X86_ECX, hrds);
+        } else if (hrds != X86_ECX) {
+            rvjit_x86_xchg(block, X86_ECX, hrds);
+            rvjit_x86_shift_op(block, opcode, hrs1, bits_64);
+            rvjit_x86_xchg(block, X86_ECX, hrds);
+        } else {
+            rvjit_x86_shift_op(block, opcode, hrs1, bits_64);
+        }
+        rvjit_x86_mov(block, hrds, hrs1, bits_64);
+        rvjit_native_pop(block, hrs1);
+    } else {
+        rvjit_x86_mov(block, hrds, hrs1, bits_64);
+        if (hrds == X86_ECX) {
+            rvjit_x86_xchg(block, X86_ECX, hrs2);
+            rvjit_x86_shift_op(block, opcode, hrs2, bits_64);
+            rvjit_x86_xchg(block, X86_ECX, hrs2);
+        } else if (hrs2 != X86_ECX) {
+            rvjit_x86_xchg(block, X86_ECX, hrs2);
+            rvjit_x86_shift_op(block, opcode, hrds, bits_64);
+            rvjit_x86_xchg(block, X86_ECX, hrs2);
+        } else {
+            rvjit_x86_shift_op(block, opcode, hrds, bits_64);
+        }
+    }
+}
+
+static inline void rvjit_native_zero_reg(rvjit_block_t* block, regid_t reg)
+{
+    rvjit_x86_3reg_op(block, X86_XOR, reg, reg, reg, false);
+}
+
+// Set lower 8 bits of native register to specific cmp result
+static inline void rvjit_x86_setcc_internal(rvjit_block_t* block, uint8_t opcode, regid_t reg)
+{
+    uint8_t code[4] = { 0, 0x0F, opcode, X86_2_REGS | (reg & 0x07), };
+    if (reg >= X64_R8) code[0] |= X64_REX_B;
+    // REX prefix for using sil, dil, r8b... registers
+    if (reg > X86_EBX) code[0] |= 0x40;
+    rvjit_put_code(block, code + (code[0] ? 0 : 1), code[0] ? 4 : 3);
+}
+
+#define X86_SETB 0x92
+#define X86_SETL 0x9C
+
+// Orthogonal version of rvjit_x86_setcc_internal()
+static inline void rvjit_x86_setcc(rvjit_block_t* block, uint8_t opcode, regid_t reg)
+{
+    if (x86_byte_reg_usable(reg)) {
+        rvjit_x86_setcc_internal(block, opcode, reg);
+    } else {
+        // surprise!!!
+        rvjit_x86_xchg(block, X86_EAX, reg);
+        rvjit_x86_setcc_internal(block, opcode, X86_EAX);
+        rvjit_x86_xchg(block, X86_EAX, reg);
+    }
+}
+
+static inline void rvjit_x86_3reg_slt_op(rvjit_block_t* block, uint8_t opcode, regid_t hrds, regid_t hrs1, regid_t hrs2, bool bits_64)
+{
+    if (hrds != hrs1 && hrds != hrs2) rvjit_native_zero_reg(block, hrds);
+    rvjit_x86_2reg_op(block, X86_CMP, hrs1, hrs2, bits_64);
+    rvjit_x86_setcc(block, opcode, hrds);
+    if (hrds == hrs1 || hrds == hrs2) rvjit_x86_2reg_imm_op(block, X86_AND_IMM, hrds, hrds, 0xFF, false);
+}
+
+static inline void rvjit_x86_2reg_imm_slt_op(rvjit_block_t* block, uint8_t opcode, regid_t hrds, regid_t hrs1, int32_t imm, bool bits_64)
+{
+    if (hrds != hrs1) rvjit_native_zero_reg(block, hrds);
+    rvjit_x86_r_imm_op(block, X86_CMP_IMM, hrs1, imm, bits_64);
+    rvjit_x86_setcc(block, opcode, hrds);
+    if (hrds == hrs1) rvjit_x86_2reg_imm_op(block, X86_AND_IMM, hrds, hrds, 0xFF, false);
+}
+
+static inline void rvjit_native_ret(rvjit_block_t* block)
+{
+    rvjit_put_code(block, "\xC3", 1);
+}
+
+#define X86_MOV_IMM 0xB8
+
+// Set native register reg to zero-extended 32-bit imm
+static inline void rvjit_native_setreg32(rvjit_block_t* block, regid_t reg, uint32_t imm)
+{
+    if (imm == 0) {
+        rvjit_native_zero_reg(block, reg);
+    } else {
+        uint8_t code[6] = { 0, X86_MOV_IMM | (reg & 0x7), };
+        if (reg >= X64_R8) code[0] |= X64_REX_B;
+        write_uint32_le_m(code + 2, imm);
+        rvjit_put_code(block, code + (code[0] ? 0 : 1), code[0] ? 6 : 5);
+    }
+}
+
+// Set native register reg to sign-extended 32-bit imm
+static inline void rvjit_native_setreg32s(rvjit_block_t* block, regid_t reg, int32_t imm)
+{
+    if (imm == 0) {
+        rvjit_native_zero_reg(block, reg);
+    } else {
+#ifdef RVJIT_NATIVE_64BIT
+        uint8_t code[7] = { X64_REX_W, 0xC7, X86_2_REGS | (reg & 0x7), };
+        if (reg >= X64_R8) code[0] |= X64_REX_B;
+        write_uint32_le_m(code + 3, imm);
+        rvjit_put_code(block, code, 7);
+#else
+        rvjit_native_setreg32(block, reg, imm);
+#endif
+    }
+}
+
+// Set native register reg to wide imm
+static inline void rvjit_native_setregw(rvjit_block_t* block, regid_t reg, uintptr_t imm)
+{
+#ifdef RVJIT_NATIVE_64BIT
+    // movabsq
+    uint8_t code[10] = { X64_REX_W, X86_MOV_IMM | (reg & 0x7), };
+    if (reg >= X64_R8) code[0] |= X64_REX_B;
+    write_uint64_le_m(code + 2, imm);
+    rvjit_put_code(block, code, 10);
+#else
+    rvjit_native_setreg32(block, reg, imm);
+#endif
+}
+
+// Call a function pointed to by native register
+static inline void rvjit_native_callreg(rvjit_block_t* block, regid_t reg)
+{
+    uint8_t code[3] = { 0, 0xFF, 0xD0 | (reg & 0x7), };
+    if (reg >= X64_R8) code[0] = X64_REX_B;
+    rvjit_put_code(block, code + (code[0] ? 0 : 1), code[0] ? 3 : 2);
+}
+
+#define X86_LB  0xBE
+#define X86_LBU 0xB6
+#define X86_LH  0xBF
+#define X86_LHU 0xB7
+
+// For lb/lbu/lh/lhu; bits_64 means signext to full 64-bit reg, not needed for unsigned
+static inline void rvjit_x86_lbhu(rvjit_block_t* block, uint8_t opcode, regid_t dest, regid_t addr, int32_t off, bool bits_64)
+{
+    uint8_t code[3] = { 0, 0x0F, opcode, };
+    if (bits_64) code[0] = X64_REX_W;
+    if (addr >= X64_R8) code[0] |= X64_REX_B;
+    if (dest >= X64_R8) code[0] |= X64_REX_R;
+    rvjit_put_code(block, code + (code[0] ? 0 : 1), code[0] ? 3 : 2);
+    rvjit_x86_memory_ref(block, dest, addr, off);
+}
+
+#define X86_LWU_LD  0x8B
+#define X86_LW      X86_MOVSXD
+#define X86_SB      0x88
+#define X86_SW_SD   X86_MOV_R_M
+
+// For lwu/ld bits_64 ? ld : lwu, for lw bits_64 = true!
+// For sw/sd bits_64 ? sd : sw, for sb bits_64 = false!
+static inline void rvjit_x86_lwdu_sbwd(rvjit_block_t* block, uint8_t opcode, regid_t dest, regid_t addr, int32_t off, bool bits_64)
+{
+    uint8_t code[2] = { 0, opcode, };
+    if (bits_64) code[0] = X64_REX_W;
+    if (addr >= X64_R8) code[0] |= X64_REX_B;
+    if (dest >= X64_R8) code[0] |= X64_REX_R;
+    if (opcode == X86_SB && dest > X86_EBX) code[0] |= 0x40;
+    rvjit_put_code(block, code + (code[0] ? 0 : 1), code[0] ? 2 : 1);
+    rvjit_x86_memory_ref(block, dest, addr, off);
+}
+
+static inline void rvjit_x86_sb(rvjit_block_t* block, regid_t src, regid_t addr, int32_t off)
+{
+    if (x86_byte_reg_usable(src)) {
+        rvjit_x86_lwdu_sbwd(block, X86_SB, src, addr, off, false);
+    } else {
+        if (addr == src) {
+            addr = X86_EAX;
+        } else if (addr == X86_EAX) {
+            addr = src;
+        }
+        rvjit_x86_xchg(block, X86_EAX, src);
+        rvjit_x86_lwdu_sbwd(block, X86_SB, X86_EAX, addr, off, false);
+        rvjit_x86_xchg(block, X86_EAX, src);
+    }
+}
+
+static inline void rvjit_x86_sh(rvjit_block_t* block, regid_t src, regid_t addr, int32_t off)
+{
+    rvjit_put_code(block, "\x66", 1); // operand override
+    rvjit_x86_lwdu_sbwd(block, X86_MOV_R_M, src, addr, off, false);
+}
+
+static inline branch_t rvjit_native_jmp(rvjit_block_t* block, branch_t handle, bool target)
+{
+    if (target) {
+        if (handle == BRANCH_NEW) {
+            return block->size;
+        } else {
+            // Patch jump offset
+            write_uint32_le_m(block->code + handle + 1, block->size - handle - 5);
+            return BRANCH_NEW;
+        }
+    } else {
+        if (handle == BRANCH_NEW) {
+            branch_t tmp = block->size;
+            rvjit_put_code(block, "\xE9\xFB\xFF\xFF\xFF", 5);
+            return tmp;
+        } else {
+            uint8_t code[5] = { 0xE9, };
+            write_uint32_le_m(code + 1, handle - block->size - 5);
+            rvjit_put_code(block, code, 5);
+            return BRANCH_NEW;
+        }
+    }
+}
+
+/*
+ * Forward branches are dynamically resized,
+ * however this may introduce problems with cross-branching code.
+ * RVVM currently generates linear code with no branch intersections,
+ * so this isn't a concern, but might be revised.
+ */
+
+#define X86_JB   0x72
+#define X86_JNB  0x73
+#define X86_JE   0x74
+#define X86_JNE  0x75
+#define X86_JL   0x7C
+#define X86_JGE  0x7D
+
+#define X86_BEQ  X86_JE
+#define X86_BNE  X86_JNE
+#define X86_BLT  X86_JL
+#define X86_BGE  X86_JGE
+#define X86_BLTU X86_JB
+#define X86_BGEU X86_JNB
+
+#define X86_FAR_BRANCH 0x0F
+#define X86_FAR_BRANCH_MASK 0x10
+
+static inline branch_t rvjit_x86_branch_entry(rvjit_block_t* block, uint8_t opcode, branch_t handle)
+{
+    uint8_t code[6] = {0};
+    if (handle == BRANCH_NEW) {
+        // Forward branch, migh relocate code after it
+        branch_t tmp = block->size;
+        code[0] = opcode;
+        code[1] = 0xFE;
+        rvjit_put_code(block, code, 2);
+        return tmp;
+    } else {
+        // Backward branch, no need for relocations
+        int32_t offset = handle - block->size - 2;
+        if (x86_is_byte_imm(offset)) {
+            code[0] = opcode;
+            code[1] = offset;
+            rvjit_put_code(block, code, 2);
+        } else {
+            // Far branch
+            code[0] = X86_FAR_BRANCH;
+            code[1] = opcode + X86_FAR_BRANCH_MASK;
+            write_uint32_le_m(code + 2, offset - 4);
+            rvjit_put_code(block, code, 6);
+        }
+        return BRANCH_NEW;
+    }
+}
+
+static inline branch_t rvjit_x86_branch_target(rvjit_block_t* block, branch_t handle)
+{
+    if (handle == BRANCH_NEW) {
+        return block->size;
+    } else {
+        int32_t offset = block->size - handle - 2;
+        // Patch jump offset
+        if (x86_is_byte_imm(offset)) {
+            // Offset fits into 1 byte
+            block->code[handle + 1] = offset;
+        } else {
+            // Far branch required, reserve space & relocate the code
+            rvjit_put_code(block, "\xCC\xCC\xCC\xCC", 4);
+            memmove(block->code + handle + 6, block->code + handle + 2, offset);
+            block->code[handle + 1] = block->code[handle] + X86_FAR_BRANCH_MASK;
+            block->code[handle] = X86_FAR_BRANCH;
+            write_uint32_le_m(block->code + handle + 2, offset);
+        }
+        return BRANCH_NEW;
+    }
+}
+
+static inline branch_t rvjit_x86_branch(rvjit_block_t* block, uint8_t opcode, regid_t hrs1, regid_t hrs2, branch_t handle, bool target, bool bits_64)
+{
+    if (target) {
+        return rvjit_x86_branch_target(block, handle);
+    } else {
+        rvjit_x86_2reg_op(block, X86_CMP, hrs1, hrs2, bits_64);
+        return rvjit_x86_branch_entry(block, opcode, handle);
+    }
+}
+
+static inline branch_t rvjit_x86_branch_imm(rvjit_block_t* block, uint8_t opcode, regid_t hrs1, int32_t imm, branch_t handle, bool target, bool bits_64)
+{
+    if (target) {
+        return rvjit_x86_branch_target(block, handle);
+    } else {
+        rvjit_x86_r_imm_op(block, X86_CMP_IMM, hrs1, imm, bits_64);
+        return rvjit_x86_branch_entry(block, opcode, handle);
+    }
+}
+
+/*
+ * Multiply/divide internal functions
+ */
+
+// Sign-extend EAX to EDX:EAX
+static inline void rvjit_x86_cdq(rvjit_block_t* block, bool bits_64)
+{
+    if (bits_64) rvjit_put_code(block, "\x48", 1);
+    rvjit_put_code(block, "\x99", 1);
+}
+
+static inline void rvjit_x86_mul(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2, bool bits_64)
+{
+    if (hrds == hrs1) {
+        rvjit_x86_0f_2reg_op(block, X86_IMUL_2REG, hrds, hrs2, bits_64);
+    } else if (hrds == hrs2) {
+        rvjit_x86_0f_2reg_op(block, X86_IMUL_2REG, hrds, hrs1, bits_64);
+    } else {
+        rvjit_x86_mov(block, hrds, hrs1, bits_64);
+        rvjit_x86_0f_2reg_op(block, X86_IMUL_2REG, hrds, hrs2, bits_64);
+    }
+}
+
+// mulh:  X86_IMUL, rem = true
+// mulhu: X86_MUL,  rem = true
+static inline void rvjit_x86_mulh_div_rem(rvjit_block_t* block, uint8_t opcode, bool rem, regid_t hrds, regid_t hrs1, regid_t hrs2, bool bits_64)
+{
+    regid_t output_reg = rem ? X86_EDX : X86_EAX;
+    regid_t second_reg = rem ? X86_EAX : X86_EDX;
+    regid_t s2_reg = hrs2;
+
+    if (hrds != output_reg) rvjit_native_push(block, output_reg);
+    if (hrds != second_reg) rvjit_native_push(block, second_reg);
+
+    if (hrs2 == X86_EAX || hrs2 == X86_EDX) {
+        // Search for any non-clobbering register
+        s2_reg = X86_ECX;
+        while (s2_reg == X86_EAX || s2_reg == X86_EDX || s2_reg == hrs1 || s2_reg == hrs2) s2_reg++;
+        rvjit_native_push(block, s2_reg);
+        rvjit_x86_mov(block, s2_reg, hrs2, bits_64);
+    }
+
+    if (hrs1 != X86_EAX) {
+        rvjit_x86_mov(block, X86_EAX, hrs1, bits_64);
+    }
+
+    if (opcode == X86_DIV) {
+        // On unsigned division, EDX input is zero
+        rvjit_native_zero_reg(block, X86_EDX);
+    } else if (opcode == X86_IDIV) {
+        // On signed division, EDX input is a sign-extension of EAX
+        rvjit_x86_cdq(block, bits_64);
+    }
+
+    rvjit_x86_1reg_op(block, opcode, s2_reg, bits_64);
+
+    if (s2_reg != hrs2) rvjit_native_pop(block, s2_reg);
+    if (hrds != second_reg) rvjit_native_pop(block, second_reg);
+    if (hrds != output_reg) {
+        rvjit_x86_mov(block, hrds, output_reg, bits_64);
+        rvjit_native_pop(block, output_reg);
+    }
+}
+
+static inline void rvjit_x86_mulhsu(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2, bool bits_64)
+{
+    regid_t second_reg = X86_EAX;
+    rvjit_x86_mulh_div_rem(block, X86_MUL, true, hrds, hrs1, hrs2, bits_64);
+    // Search for any non-clobbering register
+    while (second_reg == hrds || second_reg == hrs1 || second_reg == hrs2) second_reg++;
+    rvjit_native_push(block, second_reg);
+    rvjit_x86_2reg_imm_shift_op(block, X86_SRA, second_reg, hrs1, bits_64 ? 63 : 31, bits_64);
+    rvjit_x86_0f_2reg_op(block, X86_IMUL_2REG, second_reg, hrs2, bits_64);
+    rvjit_x86_3reg_op(block, X86_ADD, hrds, hrds, second_reg, bits_64);
+    rvjit_native_pop(block, second_reg);
+}
+
+// div:   X86_IDIV, rem = false
+// divu:  X86_DIV,  rem = false
+// rem:   X86_IDIV, rem = true
+// remu:  X86_DIV,  rem = true
+static inline void rvjit_x86_divu_remu(rvjit_block_t* block, bool rem, regid_t hrds, regid_t hrs1, regid_t hrs2, bool bits_64)
+{
+    branch_t l1 = rvjit_x86_branch_imm(block, X86_BNE, hrs2, 0, BRANCH_NEW, false, bits_64);
+    if (rem) {
+        if (hrds != hrs1) rvjit_x86_mov(block, hrds, hrs1, bits_64);
+    } else {
+        rvjit_native_setreg32s(block, hrds, -1);
+    }
+    branch_t l2 = rvjit_native_jmp(block, BRANCH_NEW, false);
+    rvjit_x86_branch_imm(block, X86_BNE, hrs1, 0, l1, true, bits_64);
+    rvjit_x86_mulh_div_rem(block, X86_DIV, rem, hrds, hrs1, hrs2, bits_64);
+    rvjit_native_jmp(block, l2, true);
+}
+
+static inline void rvjit_x86_div_rem(rvjit_block_t* block, bool rem, regid_t hrds, regid_t hrs1, regid_t hrs2, bool bits_64)
+{
+    regid_t cmp_reg = X86_EAX;
+    branch_t l1;
+
+    // Overflow check (rs1 != 0x80000000... && rs2 != -1)
+    if (bits_64) {
+        // Search for any non-clobbering register
+        //while (cmp_reg == hrds || cmp_reg == hrs1 || cmp_reg == hrs2) cmp_reg++;
+        //rvjit_native_push(block, cmp_reg);
+        cmp_reg = rvjit_claim_hreg(block);
+        rvjit_native_setregw(block, cmp_reg, (size_t)0x8000000000000000ULL);
+        l1 = rvjit_x86_branch(block, X86_BNE, hrs2, cmp_reg, BRANCH_NEW, false, bits_64);
+    } else {
+        l1 = rvjit_x86_branch_imm(block, X86_BNE, hrs2, 0x80000000U, BRANCH_NEW, false, bits_64);
+    }
+
+    branch_t l2 = rvjit_x86_branch_imm(block, X86_BNE, hrs2, -1, BRANCH_NEW, false, bits_64);
+
+    // Overflow check fallthrough
+    if (rem) {
+        rvjit_native_setreg32(block, hrds, 0);
+    } else {
+        if (bits_64) {
+            rvjit_x86_mov(block, hrds, cmp_reg, bits_64);
+        } else {
+            rvjit_native_setreg32(block, hrds, 0x80000000U);
+        }
+    }
+    branch_t l3 = rvjit_native_jmp(block, BRANCH_NEW, false); // goto exit
+
+    // Overflow check pass
+    rvjit_x86_branch(block, X86_BNE, cmp_reg, hrs2, l1, true, bits_64);
+    rvjit_x86_branch_imm(block, X86_BNE, hrs2, -1, l2, true, bits_64);
+
+    // Division by zero check
+    branch_t l4 = rvjit_x86_branch_imm(block, X86_BNE, hrs2, 0, BRANCH_NEW, false, bits_64);
+
+    // Division by zero fallthrough
+    if (rem) {
+        if (hrds != hrs1) rvjit_x86_mov(block, hrds, hrs1, bits_64);
+    } else {
+        rvjit_native_setreg32s(block, hrds, -1);
+    }
+    branch_t l5 = rvjit_native_jmp(block, BRANCH_NEW, false); // goto exit
+
+    // Division by zero check pass
+    rvjit_x86_branch_imm(block, X86_BNE, hrs2, 0, l4, true, bits_64);
+
+    rvjit_x86_mulh_div_rem(block, X86_IDIV, rem, hrds, hrs1, hrs2, bits_64);
+
+    // Exit label
+    rvjit_native_jmp(block, l3, true);
+    rvjit_native_jmp(block, l5, true);
+
+    //if (bits_64) rvjit_native_pop(block, cmp_reg);
+    if (bits_64) rvjit_free_hreg(block, cmp_reg);
+}
+
+/*
+ * Linker routines
+ */
+
+static inline size_t rvjit_x86_cmp_bnez_mem(rvjit_block_t* block, regid_t addr, bool bits_64)
+{
+    uint8_t code[4] = { 0, 0x83, 0x38 | (addr & 0x7), 0, };
+    if (bits_64) code[0] |= X64_REX_W;
+    if (addr >= X64_R8) code[0] |= X64_REX_B;
+    rvjit_put_code(block, code + (code[0] ? 0 : 1), code[0] ? 4 : 3);
+    return code[0] ? 4 : 3;
+}
+
+// Emit jump instruction (may return false if offset cannot be encoded)
+static inline bool rvjit_tail_jmp(rvjit_block_t* block, int32_t offset)
+{
+    uint8_t code[5] = { 0xE9, };
+    write_uint32_le_m(code + 1, ((uint32_t)offset) - 5);
+    rvjit_put_code(block, code, 5);
+    return true;
+}
+
+// Emit patchable ret instruction
+static inline void rvjit_patchable_ret(rvjit_block_t* block)
+{
+    uint8_t code[5] = { 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, };
+    rvjit_put_code(block, code, 5);
+}
+
+// Jump if word pointed to by addr is nonzero (may emit nothing if the offset cannot be encoded)
+// Used to check interrupts in block linkage
+static inline void rvjit_tail_bnez(rvjit_block_t* block, regid_t addr, int32_t offset)
+{
+    size_t cmp_size = rvjit_x86_cmp_bnez_mem(block, addr, false);
+    uint8_t code[6] = { 0x0F, 0x85, };
+    write_uint32_le_m(code + 2, ((uint32_t)offset) - (6 + cmp_size));
+    rvjit_put_code(block, code, 6);
+}
+
+// Patch instruction at addr into ret
+static inline void rvjit_patch_ret(void* addr)
+{
+    *(uint8_t*)addr = 0xC3;
+}
+
+// Patch jump instruction at addr
+static inline bool rvjit_patch_jmp(void* addr, int32_t offset)
+{
+    uint8_t* code = (uint8_t*)addr;
+    code[0] = 0xE9;
+    write_uint32_le_m(code + 1, ((uint32_t)offset) - 5);
+    return true;
+}
+
+// Indirect jump by register
+static inline void rvjit_jmp_reg(rvjit_block_t* block, regid_t reg)
+{
+    uint8_t code[3] = { 0, 0xFF, 0xE0 | (reg & 0x7), };
+    if (reg >= X64_R8) code[0] |= X64_REX_B;
+    rvjit_put_code(block, code + (code[0] ? 0 : 1), code[0] ? 3 : 2);
+}
+
+/*
+ * For shorter block PC updates in RVVM.
+ * Theoretically, this could be done by optimizing the IR into memrefs,
+ * but that's too expensive & complicated for now
+ */
+static inline void rvjit_x86_memref_addi(rvjit_block_t* block, regid_t addr, int32_t offset, int32_t imm, bool bits_64)
+{
+    size_t inst_size = 3;
+    uint8_t code[11] = {0x00, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+    code[2] = addr & 0x7;
+    if (bits_64) code[0] |= X64_REX_W;
+    if (addr >= X64_R8) code[0] |= X64_REX_B;
+    if (offset) {
+        if (x86_is_byte_imm(offset)) {
+            code[inst_size] = offset;
+            code[2] |= 0x40;
+            inst_size++;
+        } else {
+            write_uint32_le_m(code + inst_size, offset);
+            code[2] |= 0x80;
+            inst_size += 4;
+        }
+    }
+    if (x86_is_byte_imm(imm)) {
+        code[inst_size] = imm;
+        code[1] |= 0x2;
+        inst_size++;
+    } else {
+        write_uint32_le_m(code + inst_size, imm);
+        inst_size += 4;
+    }
+    rvjit_put_code(block, code + (code[0] ? 0 : 1), inst_size - (code[0] ? 0 : 1));
+}
+
+/*
+ * RV32
+ */
+static inline void rvjit32_native_neg(rvjit_block_t* block, regid_t hrds, regid_t hrs1)
+{
+    if (hrds != hrs1) rvjit_x86_mov(block, hrds, hrs1, false);
+    rvjit_x86_neg(block, hrds, false);
+}
+
+static inline void rvjit32_native_add(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_x86_3reg_op(block, X86_ADD, hrds, hrs1, hrs2, false);
+}
+
+static inline void rvjit32_native_sub(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_x86_3reg_op(block, X86_SUB, hrds, hrs1, hrs2, false);
+}
+
+static inline void rvjit32_native_or(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_x86_3reg_op(block, X86_OR, hrds, hrs1, hrs2, false);
+}
+
+static inline void rvjit32_native_and(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_x86_3reg_op(block, X86_AND, hrds, hrs1, hrs2, false);
+}
+
+static inline void rvjit32_native_xor(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_x86_3reg_op(block, X86_XOR, hrds, hrs1, hrs2, false);
+}
+
+static inline void rvjit32_native_sra(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_x86_3reg_shift_op(block, X86_SRA, hrds, hrs1, hrs2, false);
+}
+
+static inline void rvjit32_native_srl(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_x86_3reg_shift_op(block, X86_SRL, hrds, hrs1, hrs2, false);
+}
+
+static inline void rvjit32_native_sll(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_x86_3reg_shift_op(block, X86_SLL, hrds, hrs1, hrs2, false);
+}
+
+static inline void rvjit32_native_addi(rvjit_block_t* block, regid_t hrds, regid_t hrs1, int32_t imm)
+{
+    rvjit_x86_2reg_imm_op(block, X86_ADD_IMM, hrds, hrs1, imm, false);
+}
+
+static inline void rvjit32_native_ori(rvjit_block_t* block, regid_t hrds, regid_t hrs1, int32_t imm)
+{
+    rvjit_x86_2reg_imm_op(block, X86_OR_IMM, hrds, hrs1, imm, false);
+}
+
+static inline void rvjit32_native_andi(rvjit_block_t* block, regid_t hrds, regid_t hrs1, int32_t imm)
+{
+    rvjit_x86_2reg_imm_op(block, X86_AND_IMM, hrds, hrs1, imm, false);
+}
+
+static inline void rvjit32_native_xori(rvjit_block_t* block, regid_t hrds, regid_t hrs1, int32_t imm)
+{
+    rvjit_x86_2reg_imm_op(block, X86_XOR_IMM, hrds, hrs1, imm, false);
+}
+
+static inline void rvjit32_native_srai(rvjit_block_t* block, regid_t hrds, regid_t hrs1, uint8_t imm)
+{
+    rvjit_x86_2reg_imm_shift_op(block, X86_SRA, hrds, hrs1, imm, false);
+}
+
+static inline void rvjit32_native_srli(rvjit_block_t* block, regid_t hrds, regid_t hrs1, uint8_t imm)
+{
+    rvjit_x86_2reg_imm_shift_op(block, X86_SRL, hrds, hrs1, imm, false);
+}
+
+static inline void rvjit32_native_slli(rvjit_block_t* block, regid_t hrds, regid_t hrs1, uint8_t imm)
+{
+    rvjit_x86_2reg_imm_shift_op(block, X86_SLL, hrds, hrs1, imm, false);
+}
+
+static inline void rvjit32_native_slti(rvjit_block_t* block, regid_t hrds, regid_t hrs1, int32_t imm)
+{
+    rvjit_x86_2reg_imm_slt_op(block, X86_SETL, hrds, hrs1, imm, false);
+}
+
+static inline void rvjit32_native_sltiu(rvjit_block_t* block, regid_t hrds, regid_t hrs1, int32_t imm)
+{
+    rvjit_x86_2reg_imm_slt_op(block, X86_SETB, hrds, hrs1, imm, false);
+}
+
+static inline void rvjit32_native_slt(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_x86_3reg_slt_op(block, X86_SETL, hrds, hrs1, hrs2, false);
+}
+
+static inline void rvjit32_native_sltu(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_x86_3reg_slt_op(block, X86_SETB, hrds, hrs1, hrs2, false);
+}
+
+static inline void rvjit32_native_lb(rvjit_block_t* block, regid_t dest, regid_t addr, int32_t off)
+{
+    rvjit_x86_lbhu(block, X86_LB, dest, addr, off, false);
+}
+
+static inline void rvjit32_native_lbu(rvjit_block_t* block, regid_t dest, regid_t addr, int32_t off)
+{
+    rvjit_x86_lbhu(block, X86_LBU, dest, addr, off, false);
+}
+
+static inline void rvjit32_native_lh(rvjit_block_t* block, regid_t dest, regid_t addr, int32_t off)
+{
+    rvjit_x86_lbhu(block, X86_LH, dest, addr, off, false);
+}
+
+static inline void rvjit32_native_lhu(rvjit_block_t* block, regid_t dest, regid_t addr, int32_t off)
+{
+    rvjit_x86_lbhu(block, X86_LHU, dest, addr, off, false);
+}
+
+static inline void rvjit32_native_lw(rvjit_block_t* block, regid_t dest, regid_t addr, int32_t off)
+{
+    rvjit_x86_lwdu_sbwd(block, X86_LWU_LD, dest, addr, off, false);
+}
+
+static inline void rvjit32_native_sb(rvjit_block_t* block, regid_t src, regid_t addr, int32_t off)
+{
+    rvjit_x86_sb(block, src, addr, off);
+}
+
+static inline void rvjit32_native_sh(rvjit_block_t* block, regid_t src, regid_t addr, int32_t off)
+{
+    rvjit_x86_sh(block, src, addr, off);
+}
+
+static inline void rvjit32_native_sw(rvjit_block_t* block, regid_t src, regid_t addr, int32_t off)
+{
+    rvjit_x86_lwdu_sbwd(block, X86_SW_SD, src, addr, off, false);
+}
+
+static inline branch_t rvjit32_native_bne(rvjit_block_t* block, regid_t hrs1, regid_t hrs2, branch_t handle, bool target)
+{
+    return rvjit_x86_branch(block, X86_BNE, hrs1, hrs2, handle, target, false);
+}
+
+static inline branch_t rvjit32_native_beq(rvjit_block_t* block, regid_t hrs1, regid_t hrs2, branch_t handle, bool target)
+{
+    return rvjit_x86_branch(block, X86_BEQ, hrs1, hrs2, handle, target, false);
+}
+
+static inline branch_t rvjit32_native_beqz(rvjit_block_t* block, regid_t hrs1, branch_t handle, bool target)
+{
+    return rvjit_x86_branch_imm(block, X86_BEQ, hrs1, 0, handle, target, false);
+}
+
+static inline branch_t rvjit32_native_bnez(rvjit_block_t* block, regid_t hrs1, branch_t handle, bool target)
+{
+    return rvjit_x86_branch_imm(block, X86_BNE, hrs1, 0, handle, target, false);
+}
+
+static inline branch_t rvjit32_native_blt(rvjit_block_t* block, regid_t hrs1, regid_t hrs2, branch_t handle, bool target)
+{
+    return rvjit_x86_branch(block, X86_BLT, hrs1, hrs2, handle, target, false);
+}
+
+static inline branch_t rvjit32_native_bge(rvjit_block_t* block, regid_t hrs1, regid_t hrs2, branch_t handle, bool target)
+{
+    return rvjit_x86_branch(block, X86_BGE, hrs1, hrs2, handle, target, false);
+}
+
+static inline branch_t rvjit32_native_bltu(rvjit_block_t* block, regid_t hrs1, regid_t hrs2, branch_t handle, bool target)
+{
+    return rvjit_x86_branch(block, X86_BLTU, hrs1, hrs2, handle, target, false);
+}
+
+static inline branch_t rvjit32_native_bgeu(rvjit_block_t* block, regid_t hrs1, regid_t hrs2, branch_t handle, bool target)
+{
+    return rvjit_x86_branch(block, X86_BGEU, hrs1, hrs2, handle, target, false);
+}
+
+static inline void rvjit32_native_mul(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_x86_mul(block, hrds, hrs1, hrs2, false);
+}
+
+static inline void rvjit32_native_mulh(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_x86_mulh_div_rem(block, X86_IMUL, true, hrds, hrs1, hrs2, false);
+}
+
+static inline void rvjit32_native_mulhu(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_x86_mulh_div_rem(block, X86_MUL, true, hrds, hrs1, hrs2, false);
+}
+
+static inline void rvjit32_native_mulhsu(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_x86_mulhsu(block, hrds, hrs1, hrs2, false);
+}
+
+static inline void rvjit32_native_div(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_x86_div_rem(block, false, hrds, hrs1, hrs2, false);
+}
+
+static inline void rvjit32_native_divu(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_x86_divu_remu(block, false, hrds, hrs1, hrs2, false);
+}
+
+static inline void rvjit32_native_rem(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_x86_div_rem(block, true, hrds, hrs1, hrs2, false);
+}
+
+static inline void rvjit32_native_remu(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_x86_divu_remu(block, true, hrds, hrs1, hrs2, false);
+}
+
+/*
+ * RV64
+ */
+#ifdef RVJIT_NATIVE_64BIT
+static inline void rvjit64_native_neg(rvjit_block_t* block, regid_t hrds, regid_t hrs1)
+{
+    if (hrds != hrs1) rvjit_x86_mov(block, hrds, hrs1, true);
+    rvjit_x86_neg(block, hrds, true);
+}
+
+static inline void rvjit64_native_sextw(rvjit_block_t* block, regid_t hrds, regid_t hrs1)
+{
+    rvjit_x86_movsxd(block, hrds, hrs1);
+}
+
+static inline void rvjit64_native_add(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_x86_3reg_op(block, X86_ADD, hrds, hrs1, hrs2, true);
+}
+
+static inline void rvjit64_native_addw(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_x86_3reg_op(block, X86_ADD, hrds, hrs1, hrs2, false);
+    rvjit_x86_movsxd(block, hrds, hrds);
+}
+
+static inline void rvjit64_native_sub(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_x86_3reg_op(block, X86_SUB, hrds, hrs1, hrs2, true);
+}
+
+static inline void rvjit64_native_subw(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_x86_3reg_op(block, X86_SUB, hrds, hrs1, hrs2, false);
+    rvjit_x86_movsxd(block, hrds, hrds);
+}
+
+static inline void rvjit64_native_or(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_x86_3reg_op(block, X86_OR, hrds, hrs1, hrs2, true);
+}
+
+static inline void rvjit64_native_and(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_x86_3reg_op(block, X86_AND, hrds, hrs1, hrs2, true);
+}
+
+static inline void rvjit64_native_xor(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_x86_3reg_op(block, X86_XOR, hrds, hrs1, hrs2, true);
+}
+
+static inline void rvjit64_native_sra(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_x86_3reg_shift_op(block, X86_SRA, hrds, hrs1, hrs2, true);
+}
+
+static inline void rvjit64_native_sraw(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_x86_3reg_shift_op(block, X86_SRA, hrds, hrs1, hrs2, false);
+    rvjit_x86_movsxd(block, hrds, hrds);
+}
+
+static inline void rvjit64_native_srl(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_x86_3reg_shift_op(block, X86_SRL, hrds, hrs1, hrs2, true);
+}
+
+static inline void rvjit64_native_srlw(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_x86_3reg_shift_op(block, X86_SRL, hrds, hrs1, hrs2, false);
+    rvjit_x86_movsxd(block, hrds, hrds);
+}
+
+static inline void rvjit64_native_sll(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_x86_3reg_shift_op(block, X86_SLL, hrds, hrs1, hrs2, true);
+}
+
+static inline void rvjit64_native_sllw(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_x86_3reg_shift_op(block, X86_SLL, hrds, hrs1, hrs2, false);
+    rvjit_x86_movsxd(block, hrds, hrds);
+}
+
+static inline void rvjit64_native_addi(rvjit_block_t* block, regid_t hrds, regid_t hrs1, int32_t imm)
+{
+    rvjit_x86_2reg_imm_op(block, X86_ADD_IMM, hrds, hrs1, imm, true);
+}
+
+static inline void rvjit64_native_addiw(rvjit_block_t* block, regid_t hrds, regid_t hrs1, int32_t imm)
+{
+    if (imm) {
+        rvjit_x86_2reg_imm_op(block, X86_ADD_IMM, hrds, hrs1, imm, false);
+        rvjit_x86_movsxd(block, hrds, hrds);
+    } else {
+        rvjit_x86_movsxd(block, hrds, hrs1);
+    }
+}
+
+static inline void rvjit64_native_ori(rvjit_block_t* block, regid_t hrds, regid_t hrs1, int32_t imm)
+{
+    rvjit_x86_2reg_imm_op(block, X86_OR_IMM, hrds, hrs1, imm, true);
+}
+
+static inline void rvjit64_native_andi(rvjit_block_t* block, regid_t hrds, regid_t hrs1, int32_t imm)
+{
+    rvjit_x86_2reg_imm_op(block, X86_AND_IMM, hrds, hrs1, imm, true);
+}
+
+static inline void rvjit64_native_xori(rvjit_block_t* block, regid_t hrds, regid_t hrs1, int32_t imm)
+{
+    rvjit_x86_2reg_imm_op(block, X86_XOR_IMM, hrds, hrs1, imm, true);
+}
+
+static inline void rvjit64_native_srli(rvjit_block_t* block, regid_t hrds, regid_t hrs1, uint8_t imm)
+{
+    rvjit_x86_2reg_imm_shift_op(block, X86_SRL, hrds, hrs1, imm, true);
+}
+
+static inline void rvjit64_native_srliw(rvjit_block_t* block, regid_t hrds, regid_t hrs1, uint8_t imm)
+{
+    if (imm) {
+        rvjit_x86_2reg_imm_shift_op(block, X86_SRL, hrds, hrs1, imm, false);
+        rvjit_x86_movsxd(block, hrds, hrds);
+    } else {
+        rvjit_x86_movsxd(block, hrds, hrs1);
+    }
+}
+
+static inline void rvjit64_native_srai(rvjit_block_t* block, regid_t hrds, regid_t hrs1, uint8_t imm)
+{
+    rvjit_x86_2reg_imm_shift_op(block, X86_SRA, hrds, hrs1, imm, true);
+}
+
+static inline void rvjit64_native_sraiw(rvjit_block_t* block, regid_t hrds, regid_t hrs1, uint8_t imm)
+{
+    if (imm) {
+        rvjit_x86_2reg_imm_shift_op(block, X86_SRA, hrds, hrs1, imm, false);
+        rvjit_x86_movsxd(block, hrds, hrds);
+    } else {
+        rvjit_x86_movsxd(block, hrds, hrs1);
+    }
+}
+
+static inline void rvjit64_native_slli(rvjit_block_t* block, regid_t hrds, regid_t hrs1, uint8_t imm)
+{
+    rvjit_x86_2reg_imm_shift_op(block, X86_SLL, hrds, hrs1, imm, true);
+}
+
+static inline void rvjit64_native_slliw(rvjit_block_t* block, regid_t hrds, regid_t hrs1, uint8_t imm)
+{
+    if (imm) {
+        rvjit_x86_2reg_imm_shift_op(block, X86_SLL, hrds, hrs1, imm, false);
+        rvjit_x86_movsxd(block, hrds, hrds);
+    } else {
+        rvjit_x86_movsxd(block, hrds, hrs1);
+    }
+}
+
+static inline void rvjit64_native_slti(rvjit_block_t* block, regid_t hrds, regid_t hrs1, int32_t imm)
+{
+    rvjit_x86_2reg_imm_slt_op(block, X86_SETL, hrds, hrs1, imm, true);
+}
+
+static inline void rvjit64_native_sltiu(rvjit_block_t* block, regid_t hrds, regid_t hrs1, int32_t imm)
+{
+    rvjit_x86_2reg_imm_slt_op(block, X86_SETB, hrds, hrs1, imm, true);
+}
+
+static inline void rvjit64_native_slt(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_x86_3reg_slt_op(block, X86_SETL, hrds, hrs1, hrs2, true);
+}
+
+static inline void rvjit64_native_sltu(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_x86_3reg_slt_op(block, X86_SETB, hrds, hrs1, hrs2, true);
+}
+
+static inline void rvjit64_native_lb(rvjit_block_t* block, regid_t dest, regid_t addr, int32_t off)
+{
+    rvjit_x86_lbhu(block, X86_LB, dest, addr, off, true);
+}
+
+static inline void rvjit64_native_lbu(rvjit_block_t* block, regid_t dest, regid_t addr, int32_t off)
+{
+    rvjit_x86_lbhu(block, X86_LBU, dest, addr, off, false);
+}
+
+static inline void rvjit64_native_lh(rvjit_block_t* block, regid_t dest, regid_t addr, int32_t off)
+{
+    rvjit_x86_lbhu(block, X86_LH, dest, addr, off, true);
+}
+
+static inline void rvjit64_native_lhu(rvjit_block_t* block, regid_t dest, regid_t addr, int32_t off)
+{
+    rvjit_x86_lbhu(block, X86_LHU, dest, addr, off, false);
+}
+
+static inline void rvjit64_native_lw(rvjit_block_t* block, regid_t dest, regid_t addr, int32_t off)
+{
+    rvjit_x86_lwdu_sbwd(block, X86_LW, dest, addr, off, true);
+}
+
+static inline void rvjit64_native_lwu(rvjit_block_t* block, regid_t dest, regid_t addr, int32_t off)
+{
+    rvjit_x86_lwdu_sbwd(block, X86_LWU_LD, dest, addr, off, false);
+}
+
+static inline void rvjit64_native_ld(rvjit_block_t* block, regid_t dest, regid_t addr, int32_t off)
+{
+    rvjit_x86_lwdu_sbwd(block, X86_LWU_LD, dest, addr, off, true);
+}
+
+static inline void rvjit64_native_sb(rvjit_block_t* block, regid_t src, regid_t addr, int32_t off)
+{
+    rvjit_x86_sb(block, src, addr, off);
+}
+
+static inline void rvjit64_native_sh(rvjit_block_t* block, regid_t src, regid_t addr, int32_t off)
+{
+    rvjit_x86_sh(block, src, addr, off);
+}
+
+static inline void rvjit64_native_sw(rvjit_block_t* block, regid_t src, regid_t addr, int32_t off)
+{
+    rvjit_x86_lwdu_sbwd(block, X86_SW_SD, src, addr, off, false);
+}
+
+static inline void rvjit64_native_sd(rvjit_block_t* block, regid_t src, regid_t addr, int32_t off)
+{
+    rvjit_x86_lwdu_sbwd(block, X86_SW_SD, src, addr, off, true);
+}
+
+static inline branch_t rvjit64_native_bne(rvjit_block_t* block, regid_t hrs1, regid_t hrs2, branch_t handle, bool target)
+{
+    return rvjit_x86_branch(block, X86_BNE, hrs1, hrs2, handle, target, true);
+}
+
+static inline branch_t rvjit64_native_beq(rvjit_block_t* block, regid_t hrs1, regid_t hrs2, branch_t handle, bool target)
+{
+    return rvjit_x86_branch(block, X86_BEQ, hrs1, hrs2, handle, target, true);
+}
+
+static inline branch_t rvjit64_native_beqz(rvjit_block_t* block, regid_t hrs1, branch_t handle, bool target)
+{
+    return rvjit_x86_branch_imm(block, X86_BEQ, hrs1, 0, handle, target, true);
+}
+
+static inline branch_t rvjit64_native_bnez(rvjit_block_t* block, regid_t hrs1, branch_t handle, bool target)
+{
+    return rvjit_x86_branch_imm(block, X86_BNE, hrs1, 0, handle, target, true);
+}
+
+static inline branch_t rvjit64_native_blt(rvjit_block_t* block, regid_t hrs1, regid_t hrs2, branch_t handle, bool target)
+{
+    return rvjit_x86_branch(block, X86_BLT, hrs1, hrs2, handle, target, true);
+}
+
+static inline branch_t rvjit64_native_bge(rvjit_block_t* block, regid_t hrs1, regid_t hrs2, branch_t handle, bool target)
+{
+    return rvjit_x86_branch(block, X86_BGE, hrs1, hrs2, handle, target, true);
+}
+
+static inline branch_t rvjit64_native_bltu(rvjit_block_t* block, regid_t hrs1, regid_t hrs2, branch_t handle, bool target)
+{
+    return rvjit_x86_branch(block, X86_BLTU, hrs1, hrs2, handle, target, true);
+}
+
+static inline branch_t rvjit64_native_bgeu(rvjit_block_t* block, regid_t hrs1, regid_t hrs2, branch_t handle, bool target)
+{
+    return rvjit_x86_branch(block, X86_BGEU, hrs1, hrs2, handle, target, true);
+}
+
+static inline void rvjit64_native_mul(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_x86_mul(block, hrds, hrs1, hrs2, true);
+}
+
+static inline void rvjit64_native_mulh(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_x86_mulh_div_rem(block, X86_IMUL, true, hrds, hrs1, hrs2, true);
+}
+
+static inline void rvjit64_native_mulhu(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_x86_mulh_div_rem(block, X86_MUL, true, hrds, hrs1, hrs2, true);
+}
+
+static inline void rvjit64_native_mulhsu(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_x86_mulhsu(block, hrds, hrs1, hrs2, true);
+}
+
+static inline void rvjit64_native_div(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_x86_div_rem(block, false, hrds, hrs1, hrs2, true);
+}
+
+static inline void rvjit64_native_divu(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_x86_divu_remu(block, false, hrds, hrs1, hrs2, true);
+}
+
+static inline void rvjit64_native_rem(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_x86_div_rem(block, true, hrds, hrs1, hrs2, true);
+}
+
+static inline void rvjit64_native_remu(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_x86_divu_remu(block, true, hrds, hrs1, hrs2, true);
+}
+
+static inline void rvjit64_native_mulw(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_x86_mul(block, hrds, hrs1, hrs2, false);
+    rvjit_x86_movsxd(block, hrds, hrds);
+}
+
+static inline void rvjit64_native_divw(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_x86_div_rem(block, false, hrds, hrs1, hrs2, false);
+    rvjit_x86_movsxd(block, hrds, hrds);
+}
+
+static inline void rvjit64_native_divuw(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_x86_divu_remu(block, false, hrds, hrs1, hrs2, false);
+    rvjit_x86_movsxd(block, hrds, hrds);
+}
+
+static inline void rvjit64_native_remw(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_x86_div_rem(block, true, hrds, hrs1, hrs2, false);
+    rvjit_x86_movsxd(block, hrds, hrds);
+}
+
+static inline void rvjit64_native_remuw(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_x86_divu_remu(block, true, hrds, hrs1, hrs2, false);
+    rvjit_x86_movsxd(block, hrds, hrds);
+}
+
+#endif
+
+#ifdef RVJIT_NATIVE_FPU
+
+#define SSE2_MOVAPSD  0x28
+#define SSE2_UCOMISSD 0x2E
+#define SSE2_COMISSD  0x2F
+#define SSE2_ANDPS    0x54
+#define SSE2_ANDNPS   0x55
+#define SSE2_ORPS     0x56
+#define SSE2_XORPS    0x57
+
+static inline void rvjit_sse2_scalar_2reg_op(rvjit_block_t* block, uint8_t opcode, regid_t dst, regid_t src, bool fpu_d)
+{
+    if (fpu_d) rvjit_put_code(block, "\x66", 1); // SSE2 double-precision prefix
+    rvjit_x86_0f_2reg_op(block, opcode, dst, src, false);
+}
+
+#define SSE2_PCMPEQB 0x74
+#define SSE2_PAND    0xDB
+#define SSE2_PANDN   0xDF
+#define SSE2_POR     0xEB
+#define SSE2_PXOR    0xEF
+
+static inline void rvjit_sse2_simd_2reg_op(rvjit_block_t* block, uint8_t opcode, regid_t dst, regid_t src)
+{
+    rvjit_sse2_scalar_2reg_op(block, opcode, dst, src, true);
+}
+
+#define SSE2_MOV_XMM_GPR 0x6E
+#define SSE2_MOV_GPR_XMM 0x7E
+
+// Bitcast integer register to xmm register
+static inline void rvjit_sse2_mov_xmm_gpr(rvjit_block_t* block, regid_t dst, regid_t src, bool bits_64)
+{
+    rvjit_put_code(block, "\x66", 1); // XMM prefix
+    rvjit_x86_0f_2reg_op(block, SSE2_MOV_XMM_GPR, dst, src, bits_64);
+}
+
+// Bitcast xmm register to integer register
+static inline void rvjit_sse2_mov_gpr_xmm(rvjit_block_t* block, regid_t dst, regid_t src, bool bits_64)
+{
+    rvjit_put_code(block, "\x66", 1); // XMM prefix
+    rvjit_x86_0f_2reg_op(block, SSE2_MOV_GPR_XMM, dst, src, bits_64);
+}
+
+static inline void rvjit_sse2_movapsd(rvjit_block_t* block, regid_t dst, regid_t src, bool fpu_d)
+{
+    rvjit_sse2_scalar_2reg_op(block, SSE2_MOVAPSD, dst, src, fpu_d);
+}
+
+#define SSE2_FP_CVTSI2S 0x2A
+#define SSE2_FP_CVTS2SI 0x2C
+
+#define SSE2_FP_ADD     0x58
+#define SSE2_FP_SUB     0x5C
+#define SSE2_FP_MUL     0x59
+#define SSE2_FP_DIV     0x5E
+#define SSE2_FP_SQRT    0x51
+
+static inline void rvjit_sse2_fp_2reg_op(rvjit_block_t* block, uint8_t opcode, regid_t dst, regid_t src, bool fpu_d)
+{
+    if (fpu_d) {
+        rvjit_put_code(block, "\xF2", 1); // SSE2 Double-precision prefix
+    } else {
+        rvjit_put_code(block, "\xF3", 1); // SSE2 Single-precision prefix
+    }
+    rvjit_x86_0f_2reg_op(block, opcode, dst, src, false);
+}
+
+static inline void rvjit_sse2_fp_3reg_op(rvjit_block_t* block, uint8_t opcode, regid_t hrds, regid_t hrs1, regid_t hrs2, bool fpu_d)
+{
+    if (hrds == hrs1) {
+        rvjit_sse2_fp_2reg_op(block, opcode, hrds, hrs2, fpu_d);
+    } else if (hrds == hrs2) {
+        if (opcode == SSE2_FP_ADD || opcode == SSE2_FP_MUL) {
+            // Reversible operands
+            rvjit_sse2_fp_2reg_op(block, opcode, hrds, hrs1, fpu_d);
+        } else {
+            // TODO Non-reversible operands, need regalloc
+            rvvm_fatal("Unimplemented non-reversible SSE2 FP 3-reg operands");
+        }
+    } else {
+        rvjit_sse2_movapsd(block, hrds, hrs1, fpu_d);
+        rvjit_sse2_fp_2reg_op(block, opcode, hrds, hrs2, fpu_d);
+    }
+}
+
+#define SSE2_FP_LOAD  0x10
+#define SSE2_FP_STORE 0x11
+
+static inline void rvjit_sse2_fp_loadstore(rvjit_block_t* block, uint8_t opcode, regid_t dst, regid_t addr, int32_t off, bool fpu_d)
+{
+    uint8_t code[3] = { 0xF3, 0x0f, opcode, };
+    if (fpu_d) code[0] = 0xF2;
+    rvjit_put_code(block, code, 3);
+    rvjit_x86_memory_ref(block, dst, addr, off);
+}
+
+// FPU intrinsics
+
+static inline void rvjit_native_fadd_s(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_sse2_fp_3reg_op(block, SSE2_FP_ADD, hrds, hrs1, hrs2, false);
+}
+
+static inline void rvjit_native_fsub_s(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_sse2_fp_3reg_op(block, SSE2_FP_SUB, hrds, hrs1, hrs2, false);
+}
+
+static inline void rvjit_native_fmul_s(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_sse2_fp_3reg_op(block, SSE2_FP_MUL, hrds, hrs1, hrs2, false);
+}
+
+static inline void rvjit_native_fdiv_s(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_sse2_fp_3reg_op(block, SSE2_FP_DIV, hrds, hrs1, hrs2, false);
+}
+
+static inline void rvjit_native_fsqrt_s(rvjit_block_t* block, regid_t hrds, regid_t hrs1)
+{
+    rvjit_sse2_fp_2reg_op(block, SSE2_FP_SQRT, hrds, hrs1, false);
+}
+
+// TODO fsgnj, fmin/fmax, fcvt, fcmp, fma
+
+static inline void rvjit_native_fmv_w_x(rvjit_block_t* block, regid_t hrds, regid_t hrs1)
+{
+    rvjit_sse2_mov_xmm_gpr(block, hrds, hrs1, false);
+}
+
+static inline void rvjit_native_fmv_x_w(rvjit_block_t* block, regid_t hrds, regid_t hrs1)
+{
+    rvjit_sse2_mov_gpr_xmm(block, hrds, hrs1, false);
+}
+
+
+
+static inline void rvjit_native_fadd_d(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_sse2_fp_3reg_op(block, SSE2_FP_ADD, hrds, hrs1, hrs2, true);
+}
+
+static inline void rvjit_native_fsub_d(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_sse2_fp_3reg_op(block, SSE2_FP_SUB, hrds, hrs1, hrs2, true);
+}
+
+static inline void rvjit_native_fmul_d(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_sse2_fp_3reg_op(block, SSE2_FP_MUL, hrds, hrs1, hrs2, true);
+}
+
+static inline void rvjit_native_fdiv_d(rvjit_block_t* block, regid_t hrds, regid_t hrs1, regid_t hrs2)
+{
+    rvjit_sse2_fp_3reg_op(block, SSE2_FP_DIV, hrds, hrs1, hrs2, true);
+}
+
+static inline void rvjit_native_fsqrt_d(rvjit_block_t* block, regid_t hrds, regid_t hrs1)
+{
+    rvjit_sse2_fp_2reg_op(block, SSE2_FP_SQRT, hrds, hrs1, true);
+}
+
+// TODO fsgnj, fmin/fmax, fcvt, fcmp, fma
+
+#ifdef RVJIT_NATIVE_64BIT
+
+static inline void rvjit_native_fmv_d_x(rvjit_block_t* block, regid_t hrds, regid_t hrs1)
+{
+    rvjit_sse2_mov_xmm_gpr(block, hrds, hrs1, true);
+}
+
+static inline void rvjit_native_fmv_x_d(rvjit_block_t* block, regid_t hrds, regid_t hrs1)
+{
+    rvjit_sse2_mov_gpr_xmm(block, hrds, hrs1, true);
+}
+
+#endif
+
+#endif
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/rvtimer.c b/app/src/main/java/libengine/RVVM/src/rvtimer.c
new file mode 100644
index 00000000..b7bf61b5
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/rvtimer.c
@@ -0,0 +1,297 @@
+/*
+rvtimer.c - Timers, sleep functions
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+// Needed for clock_gettime() when not passing -std=gnu..
+#define _GNU_SOURCE
+#define _BSD_SOURCE
+#define _DEFAULT_SOURCE
+
+#include "rvtimer.h"
+#include <time.h>
+
+#ifdef __linux__
+#include <sys/prctl.h> // For PR_SET_TIMERSLACK
+#endif
+
+#if defined(__unix__) || defined(__APPLE__) || defined(__HAIKU__)
+#include <sched.h> // For sched_yield()
+#define SCHED_YIELD_IMPL
+#endif
+
+// RVVM internal headers come after system headers because of safe_free()
+#include "atomics.h"
+#include "compiler.h"
+#include "utils.h"
+#include "dlib.h"
+
+#ifdef _WIN32
+// Use QueryPerformanceCounter()
+#include <windows.h>
+
+static uint32_t qpc_crit = 0;
+static uint64_t qpc_off = 0, qpc_last = 0, qpc_freq = 0;
+static uint64_t qpc_last_checked = 0, uit_last_checked = 0;
+
+static BOOL (__stdcall *query_uit)(PULONGLONG) = NULL;
+
+static uint64_t qpc_get_frequency(void)
+{
+    LARGE_INTEGER qpc = {0};
+    QueryPerformanceFrequency(&qpc);
+    if (qpc.QuadPart == 0) {
+        rvvm_fatal("QueryPerformanceFrequency() failed!");
+    }
+    return qpc.QuadPart;
+}
+
+static uint64_t qpc_get_clock(void)
+{
+    LARGE_INTEGER qpc = {0};
+    if (!QueryPerformanceCounter(&qpc)) {
+        rvvm_fatal("QueryPerformanceCounter() failed!");
+    }
+    return qpc.QuadPart;
+}
+
+static uint64_t uit_get_clock(void)
+{
+    ULONGLONG uit = 0;
+    if (query_uit) query_uit(&uit);
+    return uit;
+}
+
+uint64_t rvtimer_clocksource(uint64_t freq)
+{
+    // Read the latest cached timer value from userspace
+    uint64_t qpc_val = atomic_load_uint64_ex(&qpc_last, ATOMIC_ACQUIRE);
+
+    if (!atomic_swap_uint32_ex(&qpc_crit, 1, ATOMIC_ACQUIRE)) {
+        // Claimed the QPC lock, obtain new clock timestamp
+        if (qpc_freq == 0) {
+            // Initialize the clock frequency once
+            qpc_freq = qpc_get_frequency();
+            // Initialize unbiased backup clock if present
+            query_uit = dlib_get_symbol("kernel32.dll", "QueryUnbiasedInterruptTime");
+        }
+
+        uint64_t qpc_new = qpc_get_clock() + qpc_off;
+        if (qpc_new < qpc_val) {
+            // Sometimes TSC drifts back on obscure hardware, Windows doesn't fix this up
+            DO_ONCE(rvvm_warn("Unstable clocksource (backward drift observed)"));
+        } else {
+            if (query_uit) {
+                // Check unbiased backup clock to compensate for suspend & forward jumps
+                uint64_t qpc_delta = qpc_new - qpc_last_checked;
+                if (qpc_delta > qpc_freq) {
+                    uint64_t uit_new = uit_get_clock();
+                    uint64_t uit_delta = (uit_new - uit_last_checked) * qpc_freq / 10000000U;
+                    if (qpc_delta > uit_delta + qpc_freq && qpc_last_checked) {
+                        uint64_t compensate = EVAL_MIN(qpc_delta - uit_delta, qpc_new - qpc_val);
+                        qpc_off -= compensate;
+                        qpc_new -= compensate;
+                    }
+
+                    qpc_last_checked = qpc_new;
+                    uit_last_checked = uit_new;
+                }
+            }
+
+            // Cache the new timer value
+            qpc_val = qpc_new;
+            atomic_store_uint64_ex(&qpc_last, qpc_val, ATOMIC_RELEASE);
+        }
+
+        atomic_store_uint32_ex(&qpc_crit, 0, ATOMIC_RELEASE);
+    }
+
+    return rvtimer_convert_freq(qpc_val, qpc_freq, freq);
+}
+
+#elif defined(__APPLE__)
+// Use mach_absolute_time() on Mac OS
+#include <mach/mach_time.h>
+
+static mach_timebase_info_data_t mach_clk_info = {0};
+static uint64_t mach_clk_freq = 0;
+
+uint64_t rvtimer_clocksource(uint64_t freq)
+{
+    DO_ONCE({
+        mach_timebase_info(&mach_clk_info);
+        if (mach_clk_info.numer == 0 || mach_clk_info.denom == 0) {
+            rvvm_fatal("mach_timebase_info() failed!");
+        }
+        // Calculate Mach timer frequency
+        mach_clk_freq = (mach_clk_info.denom * 1000000000ULL) / mach_clk_info.numer;
+    });
+    return rvtimer_convert_freq(mach_absolute_time(), mach_clk_freq, freq);
+}
+
+#elif defined(CLOCK_REALTIME) || defined(CLOCK_MONOTONIC)
+// Use POSIX clock_gettime(), with a fast monotonic clock if possible
+
+// Use CLOCK_MONOTONIC_COARSE on Serenity for perf reasons
+#if defined(CLOCK_MONOTONIC_COARSE) && defined(__serenity__)
+#define CHOSEN_POSIX_CLOCK CLOCK_MONOTONIC_COARSE
+// Use CLOCK_UPTIME on OpenBSD to skip suspend time
+#elif defined(CLOCK_UPTIME)
+#define CHOSEN_POSIX_CLOCK CLOCK_UPTIME
+// Use CLOCK_MONOTONIC on Linux, FreeBSD, etc
+#elif defined(CLOCK_MONOTONIC)
+#define CHOSEN_POSIX_CLOCK CLOCK_MONOTONIC
+#else
+#define CHOSEN_POSIX_CLOCK CLOCK_REALTIME
+#endif
+
+uint64_t rvtimer_clocksource(uint64_t freq)
+{
+    struct timespec now = {0};
+    clock_gettime(CHOSEN_POSIX_CLOCK, &now);
+    return (now.tv_sec * freq) + (now.tv_nsec * freq / 1000000000ULL);
+}
+
+#else
+// Use time() with no sub-second precision
+#warning No OS support for precise clocksource!
+
+uint64_t rvtimer_clocksource(uint64_t freq)
+{
+    return time(0) * freq;
+}
+
+#endif
+
+void rvtimer_init(rvtimer_t* timer, uint64_t freq)
+{
+    timer->freq = freq;
+    rvtimer_rebase(timer, 0);
+}
+
+uint64_t rvtimer_freq(const rvtimer_t* timer)
+{
+    return timer->freq;
+}
+
+uint64_t rvtimer_get(const rvtimer_t* timer)
+{
+    return rvtimer_clocksource(timer->freq) - atomic_load_uint64_ex(&timer->begin, ATOMIC_RELAXED);
+}
+
+void rvtimer_rebase(rvtimer_t* timer, uint64_t time)
+{
+    atomic_store_uint64(&timer->begin, rvtimer_clocksource(timer->freq) - time);
+}
+
+void rvtimecmp_init(rvtimecmp_t* cmp, rvtimer_t* timer)
+{
+    cmp->timer = timer;
+    rvtimecmp_set(cmp, -1);
+}
+
+void rvtimecmp_set(rvtimecmp_t* cmp, uint64_t timecmp)
+{
+    atomic_store_uint64_ex(&cmp->timecmp, timecmp, ATOMIC_RELAXED);
+}
+
+uint64_t rvtimecmp_get(const rvtimecmp_t* cmp)
+{
+    return atomic_load_uint64_ex(&cmp->timecmp, ATOMIC_RELAXED);
+}
+
+bool rvtimecmp_pending(const rvtimecmp_t* cmp)
+{
+    return rvtimer_get(cmp->timer) >= rvtimecmp_get(cmp);
+}
+
+uint64_t rvtimecmp_delay(const rvtimecmp_t* cmp)
+{
+    uint64_t timer = rvtimer_get(cmp->timer);
+    uint64_t timecmp = rvtimecmp_get(cmp);
+    return (timer < timecmp) ? (timecmp - timer) : 0;
+}
+
+uint64_t rvtimecmp_delay_ns(const rvtimecmp_t* cmp)
+{
+    uint64_t delay = rvtimecmp_delay(cmp);
+    if (delay > 0x400000000ULL) {
+        // Approximate overflow for nanosecond conversion
+        delay = 0x400000000ULL;
+    }
+    return delay * 1000000000ULL / rvtimer_freq(cmp->timer);
+}
+
+#if defined(_WIN32) && !defined(UNDER_CE)
+
+static NTSTATUS (__stdcall *nt_set_timer_resolution)(ULONG, BOOLEAN, PULONG) = NULL;
+static uint32_t low_latency = 0;
+static rvtimer_t latency_timer = {0};
+
+#endif
+
+static void sleep_low_latency_once(void)
+{
+#if defined(_WIN32) && !defined(UNDER_CE)
+    rvtimer_init(&latency_timer, 1000);
+    nt_set_timer_resolution = dlib_get_symbol("ntdll.dll", "NtSetTimerResolution");
+#elif defined(__linux__) && defined(PR_SET_TIMERSLACK)
+    // Slacking off
+    prctl(PR_SET_TIMERSLACK, 1, 0, 0, 0);
+#endif
+}
+
+void sleep_low_latency(bool enable)
+{
+    DO_ONCE(sleep_low_latency_once());
+#if defined(_WIN32) && !defined(UNDER_CE)
+    if (nt_set_timer_resolution && (enable || rvtimer_get(&latency_timer) > 100)) {
+        bool was_enabled = !!atomic_swap_uint32(&low_latency, enable);
+        if (enable != was_enabled) {
+            ULONG cur = 0;
+            nt_set_timer_resolution(enable ? 5000 : 156250, TRUE, &cur);
+            if (enable) {
+                rvtimer_rebase(&latency_timer, 0);
+            }
+        }
+    }
+#else
+    UNUSED(enable);
+#endif
+}
+
+void sleep_ms(uint32_t ms)
+{
+#ifdef _WIN32
+    sleep_low_latency(ms < 15);
+    Sleep(ms);
+
+#elif defined(CHOSEN_POSIX_CLOCK) || defined(__APPLE__)
+    if (ms) {
+        struct timespec ts = { .tv_sec = ms / 1000, .tv_nsec = (ms % 1000) * 1000000, };
+        while (nanosleep(&ts, &ts) < 0);
+        return;
+    }
+#if defined(SCHED_YIELD_IMPL)
+    // Yield this thread time slice, as does Win32 Sleep(0)
+    sched_yield();
+#endif
+
+#else
+    UNUSED(ms);
+    DO_ONCE(rvvm_warn("Unimplemented sleep_ms() for current platform!"));
+#endif
+}
diff --git a/app/src/main/java/libengine/RVVM/src/rvtimer.h b/app/src/main/java/libengine/RVVM/src/rvtimer.h
new file mode 100644
index 00000000..17bcee41
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/rvtimer.h
@@ -0,0 +1,101 @@
+/*
+rvtimer.h - Timers, sleep functions
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef RVVM_RVTIMER_H
+#define RVVM_RVTIMER_H
+
+#include "compiler.h"
+#include "rvvm_types.h"
+
+typedef struct {
+    // Those fields are internal use only
+    uint64_t begin;
+    uint64_t freq;
+} rvtimer_t;
+
+typedef struct {
+    // Those fields are internal use only
+    uint64_t timecmp;
+    rvtimer_t* timer;
+} rvtimecmp_t;
+
+// Convert between frequencies without overflow
+static inline uint64_t rvtimer_convert_freq(uint64_t clk, uint64_t src_freq, uint64_t dst_freq)
+{
+#ifdef INT128_SUPPORT
+    // Fast path when no overflow (Just mul + div on x86_64 with the overflow check)
+    if (likely(!((uint128_t)clk * (uint128_t)dst_freq >> 64))) {
+        return clk * dst_freq / src_freq;
+    }
+#endif
+    uint64_t freq_rem = clk % src_freq;
+    return (clk / src_freq * dst_freq) + (freq_rem * dst_freq / src_freq);
+}
+
+// Get global clocksource with the specified frequency
+uint64_t rvtimer_clocksource(uint64_t freq);
+
+/*
+ * Timer
+ */
+
+// Initialize the timer and the clocksource
+void rvtimer_init(rvtimer_t* timer, uint64_t freq);
+
+// Get timer frequency
+uint64_t rvtimer_freq(const rvtimer_t* timer);
+
+// Get current timer value
+uint64_t rvtimer_get(const rvtimer_t* timer);
+
+// Rebase the clocksource by time field
+void rvtimer_rebase(rvtimer_t* timer, uint64_t time);
+
+/*
+ * Timer comparators
+ */
+
+// Init timer comparator
+void rvtimecmp_init(rvtimecmp_t* cmp, rvtimer_t* timer);
+
+// Set comparator timestamp
+void rvtimecmp_set(rvtimecmp_t* cmp, uint64_t timecmp);
+
+// Get comparator timestamp
+uint64_t rvtimecmp_get(const rvtimecmp_t* cmp);
+
+// Check if we have a pending timer interrupt. Updates on it's own
+bool rvtimecmp_pending(const rvtimecmp_t* cmp);
+
+// Get delay until the timer interrupt (In timer frequency)
+uint64_t rvtimecmp_delay(const rvtimecmp_t* cmp);
+
+// Get delay until the timer interrupt (In nanoseconds)
+uint64_t rvtimecmp_delay_ns(const rvtimecmp_t* cmp);
+
+/*
+ * Sleep
+ */
+
+// Set expected sleep latency (Internal use)
+void sleep_low_latency(bool enable);
+
+// Sleep for N ms
+void sleep_ms(uint32_t ms);
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/rvvm.c b/app/src/main/java/libengine/RVVM/src/rvvm.c
new file mode 100644
index 00000000..71f1dbf2
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/rvvm.c
@@ -0,0 +1,915 @@
+/*
+rvvm.c - RISC-V Virtual Machine
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "rvvm.h"
+#include "rvvm_isolation.h"
+#include "riscv_hart.h"
+#include "riscv_mmu.h"
+#include "riscv_cpu.h"
+#include "vector.h"
+#include "utils.h"
+#include "mem_ops.h"
+#include "threading.h"
+#include "spinlock.h"
+#include "elf_load.h"
+#include "stacktrace.h"
+
+static spinlock_t global_lock = SPINLOCK_INIT;
+static vector_t(rvvm_machine_t*) global_machines = {0};
+static bool global_manual = false;
+
+static spinlock_t eventloop_lock = SPINLOCK_INIT;
+static cond_var_t* eventloop_cond = NULL;
+static thread_ctx_t* eventloop_thread = NULL;
+
+#ifdef USE_FDT
+static void rvvm_init_fdt(rvvm_machine_t* machine)
+{
+    machine->fdt = fdt_node_create(NULL);
+    fdt_node_add_prop_u32(machine->fdt, "#address-cells", 2);
+    fdt_node_add_prop_u32(machine->fdt, "#size-cells", 2);
+    fdt_node_add_prop_str(machine->fdt, "model", "RVVM v"RVVM_VERSION);
+    fdt_node_add_prop(machine->fdt, "compatible", "lekkit,rvvm\0riscv-virtio\0", 25);
+
+    struct fdt_node* chosen = fdt_node_create("chosen");
+    uint8_t rng_buffer[64] = {0};
+    rvvm_randombytes(rng_buffer, sizeof(rng_buffer));
+    fdt_node_add_prop(chosen, "rng-seed", rng_buffer, sizeof(rng_buffer));
+    fdt_node_add_child(machine->fdt, chosen);
+
+    struct fdt_node* memory = fdt_node_create_reg("memory", machine->mem.begin);
+    fdt_node_add_prop_str(memory, "device_type", "memory");
+    fdt_node_add_prop_reg(memory, "reg", machine->mem.begin, machine->mem.size);
+    fdt_node_add_child(machine->fdt, memory);
+
+    struct fdt_node* cpus = fdt_node_create("cpus");
+    fdt_node_add_prop_u32(cpus, "#address-cells", 1);
+    fdt_node_add_prop_u32(cpus, "#size-cells", 0);
+    fdt_node_add_prop_u32(cpus, "timebase-frequency", 10000000);
+
+    struct fdt_node* cpu_map = fdt_node_create("cpu-map");
+    struct fdt_node* cluster = fdt_node_create("cluster0");
+
+    // Attach all the nodes to the root node before getting phandles
+    fdt_node_add_child(machine->fdt, cpus);
+
+    vector_foreach(machine->harts, i) {
+        struct fdt_node* cpu = fdt_node_create_reg("cpu", i);
+
+        fdt_node_add_prop_str(cpu, "device_type", "cpu");
+        fdt_node_add_prop_u32(cpu, "reg", i);
+        fdt_node_add_prop(cpu, "compatible", "lekkit,rvvm\0riscv\0", 18);
+        fdt_node_add_prop_u32(cpu, "clock-frequency", 3000000000);
+        fdt_node_add_prop_u32(cpu, "riscv,cboz-block-size", 64);
+        fdt_node_add_prop_u32(cpu, "riscv,cbom-block-size", 64);
+#ifdef USE_RV64
+        if (vector_at(machine->harts, i)->rv64) {
+#ifdef USE_FPU
+            fdt_node_add_prop_str(cpu, "riscv,isa", "rv64imafdcb_zicsr_zifencei_zkr_zicboz_zicbom_svadu_sstc");
+#else
+            fdt_node_add_prop_str(cpu, "riscv,isa", "rv64imacb_zicsr_zifencei_zkr_zicboz_zicbom_svadu_sstc");
+#endif
+            fdt_node_add_prop_str(cpu, "mmu-type", "riscv,sv39");
+        } else {
+#endif
+#ifdef USE_FPU
+            fdt_node_add_prop_str(cpu, "riscv,isa", "rv32imafdcb_zicsr_zifencei_zkr_zicboz_zicbom_svadu_sstc");
+#else
+            fdt_node_add_prop_str(cpu, "riscv,isa", "rv32imacb_zicsr_zifencei_zkr_zicboz_zicbom_svadu_sstc");
+#endif
+            fdt_node_add_prop_str(cpu, "mmu-type", "riscv,sv32");
+#ifdef USE_RV64
+        }
+#endif
+
+        fdt_node_add_prop_str(cpu, "status", "okay");
+
+        struct fdt_node* clic = fdt_node_create("interrupt-controller");
+        fdt_node_add_prop_u32(clic, "#interrupt-cells", 1);
+        fdt_node_add_prop(clic, "interrupt-controller", NULL, 0);
+        fdt_node_add_prop_str(clic, "compatible", "riscv,cpu-intc");
+        fdt_node_add_child(cpu, clic);
+
+        fdt_node_add_child(cpus, cpu);
+
+        char core_name[32] = "core";
+        int_to_str_dec(core_name + 4, 20, i);
+        struct fdt_node* core = fdt_node_create(core_name);
+        fdt_node_add_prop_u32(core, "cpu", fdt_node_get_phandle(cpu));
+        fdt_node_add_child(cluster, core);
+    }
+
+    fdt_node_add_child(cpu_map, cluster);
+    fdt_node_add_child(cpus, cpu_map);
+
+    struct fdt_node* soc = fdt_node_create("soc");
+    fdt_node_add_prop_u32(soc, "#address-cells", 2);
+    fdt_node_add_prop_u32(soc, "#size-cells", 2);
+    fdt_node_add_prop_str(soc, "compatible", "simple-bus");
+    fdt_node_add_prop(soc, "ranges", NULL, 0);
+
+    fdt_node_add_child(machine->fdt, soc);
+    machine->fdt_soc = soc;
+}
+
+static void rvvm_prepare_fdt(rvvm_machine_t* machine)
+{
+    if (rvvm_get_opt(machine, RVVM_OPT_HW_IMITATE)) {
+        fdt_node_add_prop_str(machine->fdt, "model", "PlasmaArc Five");
+        fdt_node_add_prop_str(machine->fdt, "compatible", "lekkit,arc7xx");
+
+        vector_foreach(machine->harts, i) {
+            struct fdt_node* cpus = fdt_node_find(machine->fdt, "cpus");
+            struct fdt_node* cpu = fdt_node_find_reg(cpus, "cpu", i);
+            fdt_node_add_prop(cpu, "compatible", "lekkit,arc7xx\0riscv\0", 20);
+        }
+    }
+}
+#endif
+
+#define RVVM_POWER_OFF   0
+#define RVVM_POWER_ON    1
+#define RVVM_POWER_RESET 2
+
+static size_t rvvm_dtb_addr(rvvm_machine_t* machine, size_t dtb_size)
+{
+    return align_size_down(machine->mem.size > dtb_size ? machine->mem.size - dtb_size : 0, 8);
+}
+
+static rvvm_addr_t rvvm_pass_dtb(rvvm_machine_t* machine)
+{
+    if (rvvm_get_opt(machine, RVVM_OPT_DTB_ADDR)) {
+        // API user manually passes DTB
+        return rvvm_get_opt(machine, RVVM_OPT_DTB_ADDR);
+    } else if (machine->dtb_file) {
+        // Load DTB from file
+        uint32_t dtb_size = rvfilesize(machine->dtb_file);
+        size_t dtb_off = rvvm_dtb_addr(machine, dtb_size);
+        if (dtb_size < machine->mem.size) {
+            rvread(machine->dtb_file, machine->mem.data + dtb_off, machine->mem.size - dtb_off, 0);
+            rvvm_info("Loaded DTB at 0x%08"PRIxXLEN", size %u", machine->mem.begin + dtb_off, dtb_size);
+            return machine->mem.begin + dtb_off;
+        }
+    } else {
+        // Generate DTB
+#ifdef USE_FDT
+        rvvm_prepare_fdt(machine);
+        uint32_t dtb_size = fdt_size(machine->fdt);
+        size_t dtb_off = rvvm_dtb_addr(machine, dtb_size);
+        if (fdt_serialize(machine->fdt, machine->mem.data + dtb_off, machine->mem.size - dtb_off, 0)) {
+            rvvm_info("Generated DTB at 0x%08"PRIxXLEN", size %u", (phys_addr_t)(machine->mem.begin + dtb_off), dtb_size);
+            return machine->mem.begin + dtb_off;
+        }
+#else
+        rvvm_error("This build doesn't support FDT generation");
+        return 0;
+#endif
+    }
+
+    rvvm_error("Device tree does not fit in RAM!");
+    return 0;
+}
+
+static void rvvm_reset_machine_state(rvvm_machine_t* machine)
+{
+    atomic_store_uint32(&machine->power_state, RVVM_POWER_ON);
+
+    // Reset devices
+    vector_foreach(machine->mmio_devs, i) {
+        rvvm_mmio_dev_t* dev = vector_at(machine->mmio_devs, i);
+        if (dev->type && dev->type->reset) dev->type->reset(dev);
+    }
+    // Load bootrom, kernel, dtb into RAM if needed
+    bool elf = !rvvm_get_opt(machine, RVVM_OPT_HW_IMITATE);
+    if (machine->bootrom_file) {
+        bin_objcopy(machine->bootrom_file, machine->mem.data, machine->mem.size, elf);
+    }
+    if (machine->kernel_file) {
+        size_t kernel_offset = machine->rv64 ? 0x200000 : 0x400000;
+        size_t kernel_size = machine->mem.size > kernel_offset ? machine->mem.size - kernel_offset : 0;
+        bin_objcopy(machine->kernel_file, machine->mem.data + kernel_offset, kernel_size, elf);
+    }
+    rvvm_addr_t dtb_addr = rvvm_pass_dtb(machine);
+    // Reset CPUs
+    rvtimer_init(&machine->timer, 10000000); // 10 MHz timer
+    vector_foreach(machine->harts, i) {
+        rvvm_hart_t* vm = vector_at(machine->harts, i);
+        // a0 register & mhartid csr contain hart ID
+        vm->csr.hartid = i;
+        vm->registers[REGISTER_X10] = i;
+        // a1 register contains FDT address
+        vm->registers[REGISTER_X11] = dtb_addr;
+        // Jump to RESET_PC
+        vm->registers[REGISTER_PC] = rvvm_get_opt(machine, RVVM_OPT_RESET_PC);
+        riscv_switch_priv(vm, PRIVILEGE_MACHINE);
+        riscv_jit_flush_cache(vm);
+    }
+}
+
+static void* rvvm_eventloop(void* manual)
+{
+    if (!manual && rvvm_getarg_int("noisolation") < 1) {
+        rvvm_restrict_this_thread();
+    }
+    /*
+     * The eventloop runs in a separate thread if needed,
+     * and returns on any machine shutdown if ran manually.
+     */
+    while (true) {
+        spin_lock(&global_lock);
+        if (vector_size(global_machines) == 0 || global_manual == !manual) {
+            spin_unlock(&global_lock);
+            break;
+        }
+
+        vector_foreach_back(global_machines, m) {
+            rvvm_machine_t* machine = vector_at(global_machines, m);
+            uint32_t power_state = atomic_load_uint32(&machine->power_state);
+
+            if (power_state == RVVM_POWER_ON) {
+                vector_foreach(machine->harts, i) {
+                    rvvm_hart_t* vm = vector_at(machine->harts, i);
+                    // Сheck hart timer interrupts
+                    riscv_hart_check_timer(vector_at(machine->harts, i));
+                    if (rvvm_get_opt(machine, RVVM_OPT_MAX_CPU_CENT) < 100) {
+                        uint32_t preempt = 10 - ((10 * rvvm_get_opt(machine, RVVM_OPT_MAX_CPU_CENT) + 9) / 100);
+                        riscv_hart_preempt(vm, preempt);
+                    }
+                }
+
+                vector_foreach(machine->mmio_devs, i) {
+                    rvvm_mmio_dev_t* dev = vector_at(machine->mmio_devs, i);
+                    if (dev->type && dev->type->update) {
+                        // Update device
+                        dev->type->update(dev);
+                    }
+                }
+            } else {
+                // The machine was shut down or reset
+                vector_foreach(machine->harts, i) {
+                    riscv_hart_pause(vector_at(machine->harts, i));
+                }
+                // Call reset/poweroff handler
+                if (power_state == RVVM_POWER_RESET) {
+                    rvvm_info("Machine %p resetting", machine);
+                    rvvm_reset_machine_state(machine);
+                    vector_foreach(machine->harts, i) {
+                        riscv_hart_spawn(vector_at(machine->harts, i));
+                    }
+                } else {
+                    rvvm_info("Machine %p shutting down", machine);
+                    atomic_store_uint32(&machine->running, false);
+                    vector_erase(global_machines, m);
+                    if (manual) {
+                        spin_unlock(&global_lock);
+                        return NULL;
+                    }
+                }
+            }
+        }
+        spin_unlock(&global_lock);
+        condvar_wait(eventloop_cond, 16);
+    }
+
+    return NULL;
+}
+
+static void rvvm_reconfigure_eventloop(void)
+{
+    spin_lock(&global_lock);
+    bool needs_cond = global_manual || vector_size(global_machines);
+    bool needs_thread = !global_manual && vector_size(global_machines);
+    spin_unlock(&global_lock);
+
+    spin_lock(&eventloop_lock);
+    if (!needs_thread && eventloop_thread) {
+        condvar_wake(eventloop_cond);
+        thread_join(eventloop_thread);
+        eventloop_thread = NULL;
+    }
+
+    if (!needs_cond && eventloop_cond) {
+        condvar_free(eventloop_cond);
+        eventloop_cond = NULL;
+    }
+
+    if (needs_cond && !eventloop_cond) {
+        eventloop_cond = condvar_create();
+    }
+
+    if (needs_thread && !eventloop_thread) {
+        eventloop_thread = thread_create(rvvm_eventloop, NULL);
+    }
+    spin_unlock(&eventloop_lock);
+}
+
+PUBLIC bool rvvm_mmio_none(rvvm_mmio_dev_t* dev, void* dest, size_t offset, uint8_t size)
+{
+    UNUSED(dev);
+    UNUSED(offset);
+    memset(dest, 0, size);
+    return true;
+}
+
+PUBLIC rvvm_machine_t* rvvm_create_machine(rvvm_addr_t mem_base, size_t mem_size, size_t hart_count, bool rv64)
+{
+    stacktrace_init();
+#ifndef USE_RV64
+    if (rv64) {
+        rvvm_error("RV64 is disabled in this RVVM build");
+        return NULL;
+    }
+#endif
+    if (hart_count == 0) {
+        rvvm_error("Creating machine with no harts at all... What are you even??");
+        return NULL;
+    }
+    if (hart_count > 1024) {
+        rvvm_error("Invalid machine core count");
+        return NULL;
+    }
+    if (!rv64 && mem_size > (1U << 30)) {
+        // Workaround for SBI/Linux hangs on incorrect machine config
+        rvvm_warn("Creating RV32 machine with >1G of RAM is likely to break, fixing");
+        mem_size = 1U << 30;
+    }
+
+    rvvm_machine_t* machine = safe_new_obj(rvvm_machine_t);
+    machine->rv64 = rv64;
+    if (!riscv_init_ram(&machine->mem, mem_base, mem_size)) {
+        free(machine);
+        return NULL;
+    }
+
+    // Default options
+#ifdef USE_JIT
+    rvvm_set_opt(machine, RVVM_OPT_JIT, !rvvm_has_arg("nojit"));
+    rvvm_set_opt(machine, RVVM_OPT_JIT_HARVARD, rvvm_has_arg("rvjit_harvard"));
+    if (rvvm_getarg_size("jitcache")) {
+        rvvm_set_opt(machine, RVVM_OPT_JIT_CACHE, rvvm_getarg_size("jitcache"));
+    } else {
+        size_t jit_cache = 16 << 20;
+        if (mem_size >= (512U << 20)) jit_cache = 32 << 20;
+        if (mem_size >= (1U << 30))   jit_cache = 64 << 20;
+        // Default 16M-64M JIT cache per hart (depends on RAM)
+        rvvm_set_opt(machine, RVVM_OPT_JIT_CACHE, jit_cache);
+    }
+#endif
+    rvvm_set_opt(machine, RVVM_OPT_MAX_CPU_CENT, 100);
+    rvvm_set_opt(machine, RVVM_OPT_RESET_PC, mem_base);
+
+    for (size_t i=0; i<hart_count; ++i) {
+        vector_push_back(machine->harts, riscv_hart_init(machine));
+    }
+#ifdef USE_FDT
+    rvvm_init_fdt(machine);
+#endif
+    return machine;
+}
+
+PUBLIC bool rvvm_write_ram(rvvm_machine_t* machine, rvvm_addr_t dest, const void* src, size_t size)
+{
+    if (dest < machine->mem.begin
+    || (dest - machine->mem.begin + size) > machine->mem.size) return false;
+    memcpy(machine->mem.data + (dest - machine->mem.begin), src, size);
+    riscv_jit_mark_dirty_mem(machine, dest, size);
+    return true;
+}
+
+PUBLIC bool rvvm_read_ram(rvvm_machine_t* machine, void* dest, rvvm_addr_t src, size_t size)
+{
+    if (src < machine->mem.begin
+    || (src - machine->mem.begin + size) > machine->mem.size) return false;
+    memcpy(dest, machine->mem.data + (src - machine->mem.begin), size);
+    return true;
+}
+
+PUBLIC void* rvvm_get_dma_ptr(rvvm_machine_t* machine, rvvm_addr_t addr, size_t size)
+{
+    if (addr < machine->mem.begin
+    || (addr - machine->mem.begin + size) > machine->mem.size) return NULL;
+    riscv_jit_mark_dirty_mem(machine, addr, size);
+    return machine->mem.data + (addr - machine->mem.begin);
+}
+
+PUBLIC void rvvm_flush_icache(rvvm_machine_t* machine, rvvm_addr_t addr, size_t size)
+{
+    // WIP, issue a total cache flush on all harts
+    // Needs improvements in RVJIT
+    UNUSED(addr);
+    UNUSED(size);
+    spin_lock(&global_lock);
+    vector_foreach(machine->harts, i) {
+        riscv_jit_flush_cache(vector_at(machine->harts, i));
+    }
+    spin_unlock(&global_lock);
+}
+
+PUBLIC plic_ctx_t* rvvm_get_plic(rvvm_machine_t* machine)
+{
+    return machine->plic;
+}
+
+PUBLIC void rvvm_set_plic(rvvm_machine_t* machine, plic_ctx_t* plic)
+{
+    if (plic) machine->plic = plic;
+}
+
+PUBLIC pci_bus_t* rvvm_get_pci_bus(rvvm_machine_t* machine)
+{
+    return machine->pci_bus;
+}
+
+PUBLIC void rvvm_set_pci_bus(rvvm_machine_t* machine, pci_bus_t* pci_bus)
+{
+    if (pci_bus) machine->pci_bus = pci_bus;
+}
+
+PUBLIC i2c_bus_t* rvvm_get_i2c_bus(rvvm_machine_t* machine)
+{
+    return machine->i2c_bus;
+}
+
+PUBLIC void rvvm_set_i2c_bus(rvvm_machine_t* machine, i2c_bus_t* i2c_bus)
+{
+    if (i2c_bus) machine->i2c_bus = i2c_bus;
+}
+
+PUBLIC struct fdt_node* rvvm_get_fdt_root(rvvm_machine_t* machine)
+{
+#ifdef USE_FDT
+    return machine->fdt;
+#else
+    UNUSED(machine);
+    return NULL;
+#endif
+}
+
+PUBLIC struct fdt_node* rvvm_get_fdt_soc(rvvm_machine_t* machine)
+{
+#ifdef USE_FDT
+    return machine->fdt_soc;
+#else
+    UNUSED(machine);
+    return NULL;
+#endif
+}
+
+PUBLIC void rvvm_set_cmdline(rvvm_machine_t* machine, const char* str)
+{
+#ifdef USE_FDT
+    free(machine->cmdline);
+    machine->cmdline = NULL;
+    rvvm_append_cmdline(machine, str);
+#else
+    UNUSED(machine);
+    UNUSED(str);
+#endif
+}
+
+PUBLIC void rvvm_append_cmdline(rvvm_machine_t* machine, const char* str)
+{
+#ifdef USE_FDT
+    size_t cmd_len = machine->cmdline ? rvvm_strlen(machine->cmdline) : 0;
+    size_t append_len = rvvm_strlen(str);
+    char* tmp = safe_new_arr(char, cmd_len + append_len + (cmd_len ? 2 : 1));
+    if (cmd_len) {
+        memcpy(tmp, machine->cmdline, cmd_len);
+        tmp[cmd_len++] = ' ';
+    }
+    memcpy(tmp + cmd_len, str, append_len);
+    free(machine->cmdline);
+    machine->cmdline = tmp;
+    struct fdt_node* chosen = fdt_node_find(machine->fdt, "chosen");
+    fdt_node_add_prop_str(chosen, "bootargs", machine->cmdline);
+#else
+    UNUSED(machine);
+    UNUSED(str);
+#endif
+}
+
+PUBLIC rvvm_addr_t rvvm_get_opt(rvvm_machine_t* machine, uint32_t opt)
+{
+    if (opt < RVVM_MAX_OPTS) {
+        return atomic_load_uint64_ex(&machine->opts[opt], ATOMIC_RELAXED);
+    }
+    switch (opt) {
+        case RVVM_OPT_MEM_BASE: return machine->mem.begin;
+        case RVVM_OPT_MEM_SIZE: return machine->mem.size;
+        case RVVM_OPT_HART_COUNT: return vector_size(machine->harts);
+    }
+    return 0;
+}
+
+PUBLIC bool rvvm_set_opt(rvvm_machine_t* machine, uint32_t opt, rvvm_addr_t val)
+{
+    if (opt >= RVVM_MAX_OPTS) return false;
+    atomic_store_uint64_ex(&machine->opts[opt], val, ATOMIC_RELAXED);
+    return true;
+}
+
+static bool file_reopen_check_size(rvfile_t** dest, const char* path, size_t size)
+{
+    rvclose(*dest);
+    if (path) {
+        *dest = rvopen(path, 0);
+        if (*dest == NULL) {
+            rvvm_error("Could not open file %s", path);
+            return false;
+        }
+        if (rvfilesize(*dest) > size) {
+            rvvm_error("File %s doesn't fit in RAM", path);
+            rvclose(*dest);
+            *dest = NULL;
+            return false;
+        }
+    } else {
+        *dest = NULL;
+    }
+    return true;
+}
+
+PUBLIC bool rvvm_load_bootrom(rvvm_machine_t* machine, const char* path)
+{
+    return file_reopen_check_size(&machine->bootrom_file, path, machine->mem.size);
+}
+
+PUBLIC bool rvvm_load_kernel(rvvm_machine_t* machine, const char* path)
+{
+    size_t kernel_offset = machine->rv64 ? 0x200000 : 0x400000;
+    size_t kernel_size = machine->mem.size > kernel_offset ? machine->mem.size - kernel_offset : 0;
+    return file_reopen_check_size(&machine->kernel_file, path, kernel_size);
+}
+
+PUBLIC bool rvvm_load_dtb(rvvm_machine_t* machine, const char* path)
+{
+    return file_reopen_check_size(&machine->dtb_file, path, machine->mem.size >> 1);
+}
+
+PUBLIC bool rvvm_dump_dtb(rvvm_machine_t* machine, const char* path)
+{
+#ifdef USE_FDT
+    rvfile_t* file = rvopen(path, RVFILE_RW | RVFILE_CREAT | RVFILE_TRUNC);
+    if (file) {
+        size_t size = fdt_size(rvvm_get_fdt_root(machine));
+        void* buffer = safe_calloc(size, 1);
+        size = fdt_serialize(rvvm_get_fdt_root(machine), buffer, size, 0);
+        rvwrite(file, buffer, size, 0);
+        rvclose(file);
+        free(buffer);
+        return true;
+    }
+#else
+    UNUSED(machine);
+    UNUSED(path);
+    rvvm_error("This build doesn't support FDT generation");
+#endif
+    return false;
+}
+
+PUBLIC bool rvvm_start_machine(rvvm_machine_t* machine)
+{
+    if (atomic_swap_uint32(&machine->running, true)) {
+        return false;
+    }
+
+    spin_lock(&global_lock);
+
+    if (!rvvm_machine_powered(machine)) {
+        rvvm_reset_machine_state(machine);
+    }
+
+    vector_foreach(machine->harts, i) {
+        riscv_hart_prepare(vector_at(machine->harts, i));
+    }
+    vector_foreach(machine->harts, i) {
+        riscv_hart_spawn(vector_at(machine->harts, i));
+    }
+
+    // Register the machine as running
+    vector_push_back(global_machines, machine);
+    spin_unlock(&global_lock);
+
+    rvvm_reconfigure_eventloop();
+    return true;
+}
+
+PUBLIC bool rvvm_pause_machine(rvvm_machine_t* machine)
+{
+    if (!atomic_swap_uint32(&machine->running, false)) {
+        return false;
+    }
+
+    spin_lock(&global_lock);
+
+    vector_foreach(machine->harts, i) {
+        riscv_hart_pause(vector_at(machine->harts, i));
+    }
+
+    vector_foreach_back(global_machines, i) {
+        if (vector_at(global_machines, i) == machine) {
+            vector_erase(global_machines, i);
+            break;
+        }
+    }
+    spin_unlock(&global_lock);
+
+    rvvm_reconfigure_eventloop();
+    return true;
+}
+
+PUBLIC void rvvm_reset_machine(rvvm_machine_t* machine, bool reset)
+{
+    // Handled by eventloop
+    atomic_store_uint32(&machine->power_state, reset ? RVVM_POWER_RESET : RVVM_POWER_OFF);
+
+    // For singlethreaded VMs, returns from riscv_hart_run()
+    if (vector_size(machine->harts) == 1) {
+        riscv_hart_queue_pause(vector_at(machine->harts, 0));
+    }
+    condvar_wake(eventloop_cond);
+}
+
+PUBLIC bool rvvm_machine_powered(rvvm_machine_t* machine)
+{
+    return atomic_load_uint32(&machine->power_state) != RVVM_POWER_OFF;
+}
+
+PUBLIC bool rvvm_machine_running(rvvm_machine_t* machine)
+{
+    return atomic_load_uint32(&machine->running);
+}
+
+static void rvvm_mmio_free(rvvm_mmio_dev_t* dev)
+{
+    rvvm_info("Removing MMIO device \"%s\"", dev->type ? dev->type->name : "null");
+    rvvm_cleanup_mmio_desc(dev);
+    free(dev);
+}
+
+PUBLIC void rvvm_free_machine(rvvm_machine_t* machine)
+{
+    rvvm_pause_machine(machine);
+
+    // Shut down the eventloop if needed
+    rvvm_reconfigure_eventloop();
+
+    // Clean up devices in reversed order, something may reference older devices
+    vector_foreach_back(machine->mmio_devs, i) {
+        rvvm_mmio_free(vector_at(machine->mmio_devs, i));
+    }
+
+    vector_foreach(machine->harts, i) {
+        riscv_hart_free(vector_at(machine->harts, i));
+    }
+
+    vector_free(machine->harts);
+    vector_free(machine->mmio_devs);
+    riscv_free_ram(&machine->mem);
+    rvclose(machine->bootrom_file);
+    rvclose(machine->kernel_file);
+    rvclose(machine->dtb_file);
+#ifdef USE_FDT
+    fdt_node_free(machine->fdt);
+    free(machine->cmdline);
+#endif
+    free(machine);
+}
+
+// Returns addr if zone is free
+static rvvm_addr_t rvvm_mmio_zone_check(rvvm_machine_t* machine, rvvm_addr_t addr, size_t size)
+{
+    if (addr >= machine->mem.begin && (addr + size) <= (machine->mem.begin + machine->mem.size)) {
+        addr = machine->mem.begin + machine->mem.size;
+    }
+
+    vector_foreach(machine->mmio_devs, i) {
+        rvvm_mmio_dev_t* dev = vector_at(machine->mmio_devs, i);
+        if (addr >= dev->addr && (addr + size) <= (dev->addr + dev->size)) {
+            addr = dev->addr + dev->size;
+        }
+    }
+
+    return addr;
+}
+
+// Regions of size 0 are ignored (those are non-IO placeholders)
+PUBLIC rvvm_addr_t rvvm_mmio_zone_auto(rvvm_machine_t* machine, rvvm_addr_t addr, size_t size)
+{
+    if (size) {
+        rvvm_addr_t tmp = addr;
+        do {
+            addr = tmp;
+            tmp = rvvm_mmio_zone_check(machine, addr, size);
+        } while (tmp != addr);
+    }
+    return addr;
+}
+
+PUBLIC rvvm_mmio_dev_t* rvvm_attach_mmio(rvvm_machine_t* machine, const rvvm_mmio_dev_t* mmio_desc)
+{
+    rvvm_mmio_dev_t* dev = safe_new_obj(rvvm_mmio_dev_t);
+    memcpy(dev, mmio_desc, sizeof(rvvm_mmio_dev_t));
+    dev->machine = machine;
+
+    // Normalize access properties: Power of two, default 1 - 8 bytes
+    dev->min_op_size = dev->min_op_size ? bit_next_pow2(dev->min_op_size) : 1;
+    dev->max_op_size = dev->max_op_size ? bit_next_pow2(dev->max_op_size) : 8;
+
+    if (dev->min_op_size > dev->max_op_size || dev->min_op_size > 8) {
+        rvvm_warn("MMIO device \"%s\" has invalid op sizes: min %u, max %u",
+                  dev->type ? dev->type->name : "null", dev->min_op_size, dev->max_op_size);
+        rvvm_mmio_free(dev);
+        return NULL;
+    }
+    if (rvvm_mmio_zone_auto(machine, dev->addr, dev->size) != dev->addr) {
+        rvvm_warn("Cannot attach MMIO device \"%s\" to occupied region 0x%08"PRIx64"",
+                  dev->type ? dev->type->name : "null", dev->addr);
+        rvvm_mmio_free(dev);
+        return NULL;
+    }
+    if (dev->mapping && ((dev->addr & 0xFFF) || (((size_t)dev->mapping) & 0xFFF))) {
+        // Misaligned mappings harm performance when used with KVM or shadow pagetable accel
+        rvvm_warn("MMIO device \"%s\" has misaligned mapping, expect lower perf",
+                  dev->type ? dev->type->name : "null");
+    }
+
+    rvvm_info("Attached MMIO device at 0x%08"PRIx64", type \"%s\"",
+              dev->addr, dev->type ? dev->type->name : "null");
+
+    bool was_running = rvvm_pause_machine(machine);
+    vector_push_back(machine->mmio_devs, dev);
+    if (was_running) rvvm_start_machine(machine);
+    return dev;
+}
+
+PUBLIC void rvvm_remove_mmio(rvvm_mmio_dev_t* mmio_dev)
+{
+    if (mmio_dev == NULL) return;
+
+    rvvm_machine_t* machine = mmio_dev->machine;
+    bool was_running = rvvm_pause_machine(machine);
+
+    // Remove from machine device list
+    vector_foreach_back(machine->mmio_devs, i) {
+        if (vector_at(machine->mmio_devs, i) == mmio_dev) {
+            vector_erase(machine->mmio_devs, i);
+        }
+    }
+
+    // It's a shared memory mapping, flush each hart TLB
+    if (mmio_dev->mapping) {
+        vector_foreach(machine->harts, i) {
+            rvvm_hart_t* vm = vector_at(machine->harts, i);
+            riscv_tlb_flush(vm);
+        }
+    }
+
+    if (was_running) rvvm_start_machine(machine);
+
+    rvvm_mmio_free(mmio_dev);
+}
+
+PUBLIC void rvvm_cleanup_mmio_desc(const rvvm_mmio_dev_t* mmio_desc)
+{
+    // Either device implements it's own cleanup routine, or we free it's data buffer
+    rvvm_mmio_dev_t tmp_dev = *mmio_desc;
+    if (tmp_dev.type && tmp_dev.type->remove) {
+        tmp_dev.type->remove(&tmp_dev);
+    } else {
+        free(tmp_dev.data);
+    }
+}
+
+static void rvvm_set_manual_eventloop(bool manual)
+{
+    spin_lock(&global_lock);
+    global_manual = manual;
+    spin_unlock(&global_lock);
+    rvvm_reconfigure_eventloop();
+}
+
+PUBLIC void rvvm_run_eventloop(void)
+{
+    rvvm_set_manual_eventloop(true);
+    rvvm_eventloop((void*)(size_t)1);
+    rvvm_set_manual_eventloop(false);
+}
+
+//
+// Userland emulation API (WIP)
+//
+
+PUBLIC rvvm_machine_t* rvvm_create_userland(bool rv64)
+{
+    rvvm_machine_t* machine = safe_new_obj(rvvm_machine_t);
+    // Bypass entire process memory except the NULL page
+    // RVVM expects mem.data to be non-NULL, let's leave that for now
+    machine->mem.begin = 0x1000;
+    machine->mem.size = (phys_addr_t)-0x1000ULL;
+    machine->mem.data = (void*)0x1000;
+    machine->rv64 = rv64;
+    // I don't know what time CSR frequency userspace expects...
+    rvtimer_init(&machine->timer, 1000000);
+#ifdef USE_JIT
+    rvvm_set_opt(machine, RVVM_OPT_JIT, true);
+    rvvm_set_opt(machine, RVVM_OPT_JIT_HARVARD, true);
+    rvvm_set_opt(machine, RVVM_OPT_JIT_CACHE, 16 << 20);
+#endif
+    return machine;
+}
+
+PUBLIC rvvm_hart_t* rvvm_create_user_thread(rvvm_machine_t* machine)
+{
+    rvvm_hart_t* thread = riscv_hart_init(machine);
+    riscv_hart_prepare(thread);
+#ifdef USE_FPU
+    // Initialize FPU by writing to status CSR
+    maxlen_t mstatus = (FS_INITIAL << 13);
+    riscv_csr_op(thread, 0x300, &mstatus, CSR_SETBITS);
+#endif
+#ifdef USE_JIT
+    // Enable pointer optimization
+    rvjit_set_native_ptrs(&thread->jit, true);
+#endif
+    riscv_switch_priv(thread, PRIVILEGE_USER);
+    spin_lock(&global_lock);
+    vector_push_back(machine->harts, thread);
+    spin_unlock(&global_lock);
+    return thread;
+}
+
+PUBLIC void rvvm_free_user_thread(rvvm_hart_t* thread)
+{
+    spin_lock(&global_lock);
+    vector_foreach(thread->machine->harts, i) {
+        if (vector_at(thread->machine->harts, i) == thread) {
+            vector_erase(thread->machine->harts, i);
+            riscv_hart_free(thread);
+            spin_unlock(&global_lock);
+            return;
+        }
+    }
+    rvvm_fatal("Corrupted userland context!");
+}
+
+PUBLIC rvvm_addr_t rvvm_run_user_thread(rvvm_hart_t* thread)
+{
+    return riscv_hart_run_userland(thread);
+}
+
+PUBLIC rvvm_addr_t rvvm_read_cpu_reg(rvvm_hart_t* thread, size_t reg_id)
+{
+    if (reg_id < (RVVM_REGID_X0 + 32)) {
+        return thread->registers[reg_id - RVVM_REGID_X0];
+#ifdef USE_FPU
+    } else if (reg_id < (RVVM_REGID_F0 + 32)) {
+        rvvm_addr_t ret;
+        memcpy(&ret, &thread->fpu_registers[reg_id - RVVM_REGID_F0], sizeof(ret));
+        return ret;
+#endif
+    } else if (reg_id == RVVM_REGID_PC) {
+        return thread->registers[REGISTER_PC];
+    } else if (reg_id == RVVM_REGID_CAUSE) {
+        return thread->csr.cause[PRIVILEGE_USER];
+    } else if (reg_id == RVVM_REGID_TVAL) {
+        return thread->csr.tval[PRIVILEGE_USER];
+    } else {
+        rvvm_warn("Unknown register %d in rvvm_read_cpu_reg()!", (uint32_t)reg_id);
+        return 0;
+    }
+}
+
+PUBLIC void rvvm_write_cpu_reg(rvvm_hart_t* thread, size_t reg_id, rvvm_addr_t reg)
+{
+    if (reg_id < (RVVM_REGID_X0 + 32)) {
+        thread->registers[reg_id - RVVM_REGID_X0] = reg;
+#ifdef USE_FPU
+    } else if (reg_id < (RVVM_REGID_F0 + 32)) {
+        memcpy(&thread->fpu_registers[reg_id - RVVM_REGID_F0], &reg, sizeof(reg));
+#endif
+    } else if (reg_id == RVVM_REGID_PC) {
+        thread->registers[REGISTER_PC] = reg;
+    } else if (reg_id == RVVM_REGID_CAUSE) {
+        thread->csr.cause[PRIVILEGE_USER] = reg;
+    } else if (reg_id == RVVM_REGID_TVAL) {
+        thread->csr.tval[PRIVILEGE_USER] = reg;
+    } else {
+        rvvm_warn("Unknown register %d in rvvm_write_cpu_reg()!", (uint32_t)reg_id);
+    }
+}
diff --git a/app/src/main/java/libengine/RVVM/src/rvvm.h b/app/src/main/java/libengine/RVVM/src/rvvm.h
new file mode 100644
index 00000000..6952a664
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/rvvm.h
@@ -0,0 +1,252 @@
+/*
+rvvm.h - The RISC-V Virtual Machine
+Copyright (C) 2021  LekKit <github.com/LekKit>
+                    cerg2010cerg2010 <github.com/cerg2010cerg2010>
+                    Mr0maks <mr.maks0443@gmail.com>
+                    KotB <github.com/0xCatPKG>
+                    X547 <github.com/X547>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef RVVM_H
+#define RVVM_H
+
+#include "rvvmlib.h"
+#include "rvvm_types.h"
+#include "compiler.h"
+#include "utils.h"
+#include "vector.h"
+#include "rvtimer.h"
+#include "threading.h"
+#include "blk_io.h"
+#include "fdtlib.h"
+
+#ifdef USE_JIT
+#include "rvjit/rvjit.h"
+#endif
+
+#define TLB_SIZE 256  // Always nonzero, power of 2 (32, 64..)
+BUILD_ASSERT(TLB_SIZE && !((TLB_SIZE - 1) & TLB_SIZE));
+
+#define REGISTER_ZERO 0
+#define REGISTER_X0   0
+#define REGISTER_X1   1
+#define REGISTER_X2   2
+#define REGISTER_X3   3
+#define REGISTER_X4   4
+#define REGISTER_X5   5
+#define REGISTER_X6   6
+#define REGISTER_X7   7
+#define REGISTER_X8   8
+#define REGISTER_X9   9
+#define REGISTER_X10  10
+#define REGISTER_X11  11
+#define REGISTER_X12  12
+#define REGISTER_X13  13
+#define REGISTER_X14  14
+#define REGISTER_X15  15
+#define REGISTER_X16  16
+#define REGISTER_X17  17
+#define REGISTER_X18  18
+#define REGISTER_X19  19
+#define REGISTER_X20  20
+#define REGISTER_X21  21
+#define REGISTER_X22  22
+#define REGISTER_X23  23
+#define REGISTER_X24  24
+#define REGISTER_X25  25
+#define REGISTER_X26  26
+#define REGISTER_X27  27
+#define REGISTER_X28  28
+#define REGISTER_X29  29
+#define REGISTER_X30  30
+#define REGISTER_X31  31
+#define REGISTER_PC   32
+
+#define REGISTERS_MAX 33
+#define FPU_REGISTERS_MAX 32
+
+#define PRIVILEGE_USER       0
+#define PRIVILEGE_SUPERVISOR 1 // VS-mode supervisor
+#define PRIVILEGE_HYPERVISOR 2 // HS-mode supervisor
+#define PRIVILEGE_MACHINE    3
+
+#define PRIVILEGES_MAX       4
+
+#define INTERRUPT_USOFTWARE    0x0
+#define INTERRUPT_SSOFTWARE    0x1
+#define INTERRUPT_MSOFTWARE    0x3
+#define INTERRUPT_UTIMER       0x4
+#define INTERRUPT_STIMER       0x5
+#define INTERRUPT_MTIMER       0x7
+#define INTERRUPT_UEXTERNAL    0x8
+#define INTERRUPT_SEXTERNAL    0x9
+#define INTERRUPT_MEXTERNAL    0xB
+
+#define TRAP_INSTR_MISALIGN    0x0
+#define TRAP_INSTR_FETCH       0x1
+#define TRAP_ILL_INSTR         0x2
+#define TRAP_BREAKPOINT        0x3
+#define TRAP_LOAD_MISALIGN     0x4
+#define TRAP_LOAD_FAULT        0x5
+#define TRAP_STORE_MISALIGN    0x6
+#define TRAP_STORE_FAULT       0x7
+#define TRAP_ENVCALL_UMODE     0x8
+#define TRAP_ENVCALL_SMODE     0x9
+#define TRAP_ENVCALL_MMODE     0xB
+#define TRAP_INSTR_PAGEFAULT   0xC
+#define TRAP_LOAD_PAGEFAULT    0xD
+#define TRAP_STORE_PAGEFAULT   0xF
+
+/*
+ * Address translation cache
+ * In future, it would be nice to verify if cache-line alignment
+ * gives any profit (entries scattered between cachelines waste L1)
+ */
+typedef struct {
+    // Pointer to page (with vaddr subtracted? faster tlb translation)
+    size_t ptr;
+    // Make entry size a power of 2 (32 or 16 bytes)
+#if !defined(HOST_64BIT) && defined(USE_RV64)
+    size_t align;
+#endif
+    // Virtual page number per each op type (vaddr >> 12)
+    virt_addr_t r;
+    virt_addr_t w;
+    virt_addr_t e;
+#if defined(HOST_64BIT) && !defined(USE_RV64)
+    virt_addr_t align[3];
+#endif
+} rvvm_tlb_entry_t;
+
+#ifdef USE_JIT
+typedef struct {
+    // Pointer to code block
+    rvjit_func_t block;
+#if !defined(HOST_64BIT) && defined(USE_RV64)
+    size_t align;
+#endif
+    // Virtual PC of this entry
+    virt_addr_t pc;
+#if defined(HOST_64BIT) && !defined(USE_RV64)
+    virt_addr_t align;
+#endif
+} rvvm_jtlb_entry_t;
+#endif
+
+typedef struct {
+    phys_addr_t begin; // First usable address in physical memory
+    phys_addr_t size;  // Memory amount (since the region may be empty)
+    vmptr_t data;      // Pointer to memory data
+} rvvm_ram_t;
+
+struct rvvm_hart_t {
+    uint32_t wait_event;
+    maxlen_t registers[REGISTERS_MAX];
+#ifdef USE_FPU
+    double fpu_registers[FPU_REGISTERS_MAX];
+#endif
+
+    // We want short offsets from vmptr to tlb
+    rvvm_tlb_entry_t tlb[TLB_SIZE];
+#ifdef USE_JIT
+    rvvm_jtlb_entry_t jtlb[TLB_SIZE];
+#endif
+    rvvm_ram_t mem;
+    rvvm_machine_t* machine;
+    phys_addr_t root_page_table;
+    uint8_t mmu_mode;
+    uint8_t priv_mode;
+    bool rv64;
+    bool trap;
+    maxlen_t trap_pc;
+
+    bool userland;
+
+    uint32_t lrsc;
+    maxlen_t lrsc_cas;
+
+    struct {
+        maxlen_t hartid;
+        maxlen_t isa;
+        maxlen_t status;
+        maxlen_t fcsr;
+
+        maxlen_t ie;
+        maxlen_t ip;
+
+        maxlen_t edeleg[PRIVILEGES_MAX];
+        maxlen_t ideleg[PRIVILEGES_MAX];
+        maxlen_t tvec[PRIVILEGES_MAX];
+        maxlen_t scratch[PRIVILEGES_MAX];
+        maxlen_t epc[PRIVILEGES_MAX];
+        maxlen_t cause[PRIVILEGES_MAX];
+        maxlen_t tval[PRIVILEGES_MAX];
+        maxlen_t counteren[PRIVILEGES_MAX];
+        uint64_t envcfg[PRIVILEGES_MAX];
+        uint64_t mseccfg;
+    } csr;
+
+#ifdef USE_JIT
+    rvjit_block_t jit;
+    bool jit_enabled;
+    bool jit_compiling;
+    bool block_ends;
+    bool ldst_trace;
+#endif
+
+    thread_ctx_t* thread;
+    cond_var_t* wfi_cond;
+
+    rvtimecmp_t mtimecmp;
+    rvtimecmp_t stimecmp;
+
+    uint64_t pending_irqs;
+    uint32_t pending_events;
+    uint32_t preempt_ms;
+
+    // Cacheline alignment
+    uint8_t align[64];
+};
+
+struct rvvm_machine_t {
+    rvvm_ram_t mem;
+    vector_t(rvvm_hart_t*) harts;
+    vector_t(rvvm_mmio_dev_t*) mmio_devs;
+    rvtimer_t timer;
+
+    uint32_t running;
+    uint32_t power_state;
+    bool rv64;
+
+    rvfile_t* bootrom_file;
+    rvfile_t* kernel_file;
+    rvfile_t* dtb_file;
+
+    plic_ctx_t* plic;
+    pci_bus_t*  pci_bus;
+    i2c_bus_t*  i2c_bus;
+
+    rvvm_addr_t opts[RVVM_MAX_OPTS];
+#ifdef USE_FDT
+    // FDT nodes for device tree generation
+    struct fdt_node* fdt;
+    struct fdt_node* fdt_soc;
+    // Kernel cmdline
+    char* cmdline;
+#endif
+};
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/rvvm_isolation.c b/app/src/main/java/libengine/RVVM/src/rvvm_isolation.c
new file mode 100644
index 00000000..23765751
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/rvvm_isolation.c
@@ -0,0 +1,567 @@
+/*
+rvvm_isolation.c - Process & thread isolation
+Copyright (C) 2024  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+// Needed for pledge() and possibly other stuff
+#define _GNU_SOURCE
+#define _BSD_SOURCE
+#define _DEFAULT_SOURCE
+
+#include "rvvm_isolation.h"
+#include "utils.h"
+#include "compiler.h"
+
+#if defined(__SANITIZE_ADDRESS__) || defined(__SANITIZE_THREAD__) || defined(__SANITIZE_MEMORY)
+#define SANITIZERS_PRESENT
+#endif
+
+#ifdef USE_ISOLATION
+
+#if defined(__linux__) || defined(__OpenBSD__) || defined(__FreeBSD__)
+#include <stddef.h>
+#include <string.h>
+#include <errno.h>
+#include <unistd.h>
+#include <pwd.h>
+#define ISOLATION_DROP_ROOT_IMPL
+#endif
+
+#if defined(__linux__) && CHECK_INCLUDE(sys/prctl.h)
+#include <sys/prctl.h>
+#define ISOLATION_PRCTL_IMPL
+#endif
+
+#if defined(__linux__) && CHECK_INCLUDE(linux/seccomp.h) && CHECK_INCLUDE(sys/prctl.h)
+#include <sys/mman.h>
+#include <sys/prctl.h>
+#include <linux/bpf.h>
+#include <linux/filter.h>
+#include <linux/seccomp.h>
+#include <linux/unistd.h> // __NR_*
+#define ISOLATION_SECCOMP_IMPL
+#endif
+
+#if defined(__OpenBSD__)
+#include <unistd.h>
+#define ISOLATION_PLEDGE_IMPL
+#endif
+
+#endif
+
+// Drop all the capabilities of the calling thread, prevent privilege escalation
+static void drop_thread_caps(void)
+{
+#ifdef ISOLATION_PRCTL_IMPL
+#ifdef PR_SET_NO_NEW_PRIVS
+    // Prevent privilege escalation via setuid etc
+    if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) && errno != ENOSYS) {
+        DO_ONCE(rvvm_warn("Failed to set PR_SET_NO_NEW_PRIVS!"));
+    }
+#endif
+
+#ifdef PR_CAPBSET_DROP
+    // Drop all capabilities
+    for (int cap = 0; cap < 64; ++cap) {
+        UNUSED(!prctl(PR_CAPBSET_DROP, cap, 0, 0, 0));
+    }
+#endif
+#endif
+}
+
+// Drop from root user to nobody
+static void drop_root_user(void)
+{
+#ifdef ISOLATION_DROP_ROOT_IMPL
+    /*
+     * On Linux, UID/GID are per-thread properties and the raw
+     * setuid syscall only applies new UID to the calling thread.
+     *
+     * Glibc broadcasts a signal to all existing threads to
+     * implement a POSIX-compliant setuid(), however this opens
+     * a whole new can of worms - an already isolated thread
+     * can't setuid() anymore - so glibc aborts the process...
+     *
+     * Currently it's fixed by dropping root before any kind of
+     * isolation happens, and it's done under a DO_ONCE() construct
+     * to prevent race conditions.
+     */
+    DO_ONCE({
+        if (getuid() == 0) {
+            // We are root for whatever reason, drop to nobody
+            char buffer[256] = {0};
+            struct passwd pwd = {0};
+            struct passwd* result = NULL;
+            rvvm_info("Dropping from root user to nobody");
+            if (getpwnam_r("nobody", &pwd, buffer, sizeof(buffer), &result)
+            || setresgid(pwd.pw_gid, pwd.pw_gid, pwd.pw_gid)
+            || setresuid(pwd.pw_uid, pwd.pw_uid, pwd.pw_uid)) {
+                rvvm_fatal("Failed to drop root privileges!");
+            }
+            UNUSED(!chdir("/"));
+        }
+    });
+#endif
+}
+
+#if defined(ISOLATION_SECCOMP_IMPL) && !defined(SANITIZERS_PRESENT)
+
+#define BPF_SECCOMP_ALLOW_SYSCALL(syscall) \
+        BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, syscall, 0, 1), \
+        BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW), \
+
+#define BPF_SECCOMP_BLOCK_SYSCALL(syscall) \
+        BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, syscall, 0, 1), \
+        BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_TRAP), \
+
+#define BPF_SECCOMP_BLOCK_RWX_MMAN(syscall) \
+        BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, syscall, 0, 5), \
+        BPF_STMT(BPF_LD + BPF_W + BPF_ABS, offsetof(struct seccomp_data, args[2])), \
+        BPF_STMT(BPF_ALU + BPF_AND + BPF_K, ~(PROT_READ | PROT_WRITE)), \
+        BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, 0, 1, 0), \
+        BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_TRAP), \
+        BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW), \
+
+static void seccomp_setup_syscall_filter(bool all_threads) {
+    /*
+     * Let's just hope this won't blow up out of nowhere.
+     *
+     * Many syscalls are covered in #ifdef - some of them
+     * are arch-specific (off64 syscalls for 32-bit arches,
+     * __NR_riscv_flush_icache for RISC-V, etc).
+     *
+     * This also allows backward compatibility with older
+     * build systems - most of such syscalls are going to be
+     * omitted by the libc when getting ENOSYS.
+     */
+    struct sock_filter filter[] = {
+        BPF_STMT(BPF_LD + BPF_W + BPF_ABS, offsetof(struct seccomp_data, nr)),
+
+#ifdef __NR_mmap2
+        BPF_SECCOMP_BLOCK_RWX_MMAN(__NR_mmap2) // i386-specific
+#endif
+        BPF_SECCOMP_BLOCK_RWX_MMAN(__NR_mmap)
+        BPF_SECCOMP_BLOCK_RWX_MMAN(__NR_mprotect)
+
+        // Fast path exit for frequent syscalls
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_sched_yield)
+#ifdef __NR_futex
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_futex)
+#endif
+#ifdef __NR_futex_time64
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_futex_time64)
+#endif
+#ifdef __NR_futex_wake
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_futex_wake)
+#endif
+#ifdef __NR_futex_wait
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_futex_wait)
+#endif
+#ifdef __NR_futex_requeue
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_futex_requeue)
+#endif
+#ifdef __NR_futex_waitv
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_futex_waitv)
+#endif
+
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_pread64)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_pwrite64)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_sendto)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_recvfrom)
+#ifdef __NR_epoll_wait
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_epoll_wait)
+#endif
+#ifdef __NR_epoll_pwait
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_epoll_pwait)
+#endif
+#ifdef __NR_epoll_pwait2
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_epoll_pwait2)
+#endif
+#ifdef __NR_epoll_ctl
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_epoll_ctl)
+#endif
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_clock_gettime)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_nanosleep)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_read)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_write)
+
+        // Allow operations on already open fds
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_close)
+#ifdef __NR_fstat
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_fstat)
+#endif
+#ifdef __NR_fstat64
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_fstat64)
+#endif
+#ifdef __NR_poll
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_poll)
+#endif
+#ifdef __NR__llseek
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR__llseek)
+#endif
+#ifdef __NR_lseek
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_lseek)
+#endif
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_munmap)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_brk)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_rt_sigaction)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_rt_sigprocmask)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_rt_sigreturn)
+
+        // TODO: Research what malicious stuff can ioctl() do
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_ioctl)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_readv)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_writev)
+#ifdef __NR_pipe
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_pipe)
+#endif
+#ifdef __NR_select
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_select)
+#endif
+#ifdef __NR__newselect
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR__newselect)
+#endif
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_mremap)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_msync)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_mincore)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_madvise)
+#ifdef __NR_dup
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_dup)
+#endif
+#ifdef __NR_dup2
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_dup2)
+#endif
+#ifdef __NR_pause
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_pause)
+#endif
+#ifdef __NR_getitimer
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_getitimer)
+#endif
+#ifdef __NR_alarm
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_alarm)
+#endif
+#ifdef __NR_setitimer
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_setitimer)
+#endif
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_getpid)
+#ifdef __NR_sendfile
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_sendfile)
+#endif
+#ifdef __NR_sendfile64
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_sendfile64)
+#endif
+
+        // Allow networking
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_socket)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_connect)
+#ifdef __NR_accept
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_accept)
+#endif
+#ifdef __NR_socketcall
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_socketcall)
+#endif
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_sendmsg)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_recvmsg)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_shutdown)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_bind)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_listen)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_getsockname)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_getpeername)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_socketpair)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_setsockopt)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_getsockopt)
+
+        // sys_clone() may be used for fork(), but all our isolation
+        // is inherited anyways
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_clone)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_exit)
+#ifdef __NR_wait4
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_wait4)
+#endif
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_uname)
+#ifdef __NR_shmctl
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_shmctl)
+#endif
+#ifdef __NR_shmdt
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_shmdt)
+#endif
+#ifdef __NR_fcntl
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_fcntl)
+#endif
+#ifdef __NR_fcntl64
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_fcntl64)
+#endif
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_fsync)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_fdatasync)
+#ifdef __NR_ftruncate
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_ftruncate)
+#endif
+#ifdef __NR_ftruncate64
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_ftruncate64)
+#endif
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_gettimeofday)
+#ifdef __NR_getrlimit
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_getrlimit)
+#endif
+#ifdef __NR_setrlimit
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_setrlimit)
+#endif
+#ifdef __NR_ugetrlimit
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_ugetrlimit)
+#endif
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_getrusage)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_sysinfo)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_times)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_getuid)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_getgid)
+#ifdef __NR_geteuid
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_geteuid)
+#endif
+#ifdef __NR_getegid
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_getegid)
+#endif
+#ifdef __NR_getppid
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_getppid)
+#endif
+#ifdef __NR_getpgrp
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_getpgrp)
+#endif
+#ifdef __NR_getgroups
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_getgroups)
+#endif
+#ifdef __NR_getresuid
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_getresuid)
+#endif
+#ifdef __NR_getresgid
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_getresgid)
+#endif
+#ifdef __NR_getsid
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_getsid)
+#endif
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_rt_sigpending)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_rt_sigtimedwait)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_rt_sigqueueinfo)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_rt_sigsuspend)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_sigaltstack)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_sync)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_gettid)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_readahead)
+#ifdef __NR_time
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_time)
+#endif
+#ifdef __NR_sched_setaffinity
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_sched_setaffinity)
+#endif
+#ifdef __NR_sched_getaffinity
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_sched_getaffinity)
+#endif
+#ifdef __NR_set_thread_area
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_set_thread_area)
+#endif
+#ifdef __NR_get_thread_area
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_get_thread_area)
+#endif
+#ifdef __NR_epoll_create
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_epoll_create)
+#endif
+#ifdef __NR_epoll_ctl_old
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_epoll_ctl_old)
+#endif
+#ifdef __NR_epoll_wait_old
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_epoll_wait_old)
+#endif
+#ifdef __NR_set_tid_address
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_set_tid_address)
+#endif
+#ifdef __NR_restart_syscall
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_restart_syscall)
+#endif
+#ifdef __NR_fadvise64
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_fadvise64)
+#endif
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_timer_create)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_timer_settime)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_timer_gettime)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_timer_getoverrun)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_timer_delete)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_clock_getres)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_clock_nanosleep)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_exit_group)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_tgkill)
+#ifdef __NR_waitid
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_waitid)
+#endif
+#ifdef __NR_migrate_pages
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_migrate_pages)
+#endif
+#ifdef __NR_pselect6
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_pselect6)
+#endif
+#ifdef __NR_pselect6_time64
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_pselect6_time64)
+#endif
+#ifdef __NR_ppoll
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_ppoll)
+#endif
+#ifdef __NR_set_robust_list
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_set_robust_list)
+#endif
+#ifdef __NR_get_robust_list
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_get_robust_list)
+#endif
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_splice)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_tee)
+#ifdef __NR_sync_file_range
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_sync_file_range)
+#endif
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_vmsplice)
+#ifdef __NR_move_pages
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_move_pages)
+#endif
+#ifdef __NR_signalfd
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_signalfd)
+#endif
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_timerfd_create)
+#ifdef __NR_eventfd
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_eventfd)
+#endif
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_fallocate)
+#ifdef __NR_timerfd_settime
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_timerfd_settime)
+#endif
+#ifdef __NR_timerfd_gettime
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_timerfd_gettime)
+#endif
+#ifdef __NR_accept4
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_accept4)
+#endif
+#ifdef __NR_signalfd4
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_signalfd4)
+#endif
+#ifdef __NR_eventfd2
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_eventfd2)
+#endif
+#ifdef __NR_epoll_create1
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_epoll_create1)
+#endif
+#ifdef __NR_dup3
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_dup3)
+#endif
+#ifdef __NR_pipe2
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_pipe2)
+#endif
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_preadv)
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_pwritev)
+#ifdef __NR_rt_tgsigqueueinfo
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_rt_tgsigqueueinfo)
+#endif
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_recvmmsg)
+#ifdef __NR_prlimit64
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_prlimit64)
+#endif
+#ifdef __NR_syncfs
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_syncfs)
+#endif
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_sendmmsg)
+#ifdef __NR_getcpu
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_getcpu)
+#endif
+#ifdef __NR_getrandom
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_getrandom)
+#endif
+#ifdef __NR_memfd_create
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_memfd_create)
+#endif
+#ifdef __NR_membarrier
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_membarrier)
+#endif
+#ifdef __NR_copy_file_range
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_copy_file_range)
+#endif
+#ifdef __NR_preadv2
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_preadv2)
+#endif
+#ifdef __NR_pwritev2
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_pwritev2)
+#endif
+#ifdef __NR_rseq
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_rseq)
+#endif
+#ifdef __NR_io_uring_setup
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_io_uring_setup)
+#endif
+#ifdef __NR_io_uring_enter
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_io_uring_enter)
+#endif
+#ifdef __NR_io_uring_register
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_io_uring_register)
+#endif
+#ifdef __NR_cachestat
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_cachestat)
+#endif
+
+        // Arch-specific syscalls
+#ifdef __NR_riscv_flush_icache
+        BPF_SECCOMP_ALLOW_SYSCALL(__NR_riscv_flush_icache)
+#elif defined(__riscv)
+        // Allow icache flush if no definition is provided
+        BPF_SECCOMP_ALLOW_SYSCALL(259)
+#endif
+
+        // Return ENOSYS for everything not allowed here
+        BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ERRNO | (ENOSYS & SECCOMP_RET_DATA)),
+        //BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_TRAP),
+    };
+
+    struct sock_fprog prog = {
+        .filter = filter,
+        .len = STATIC_ARRAY_SIZE(filter),
+    };
+
+    int flags = all_threads ? SECCOMP_FILTER_FLAG_TSYNC : 0;
+
+    if (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog, flags) && errno != ENOSYS) {
+        // Seccomp not available on this system
+        DO_ONCE(rvvm_info("Failed to enforce seccomp syscall filter: %s!", strerror(errno)));
+    }
+}
+
+#endif
+
+void rvvm_restrict_this_thread(void)
+{
+    drop_root_user();
+    drop_thread_caps();
+#if defined(ISOLATION_SECCOMP_IMPL) && !defined(SANITIZERS_PRESENT)
+    seccomp_setup_syscall_filter(false);
+#endif
+    // No per-thread pledge on OpenBSD :c
+}
+
+PUBLIC void rvvm_restrict_process(void)
+{
+    drop_root_user();
+    drop_thread_caps();
+#if defined(SANITIZERS_PRESENT)
+    DO_ONCE(rvvm_info("Sanitizers are present, disabling isolation"));
+#elif defined(ISOLATION_SECCOMP_IMPL)
+    seccomp_setup_syscall_filter(true);
+#elif defined(ISOLATION_PLEDGE_IMPL)
+    if (pledge("stdio inet tty ioctl dns audio drm vmm error", "")) {
+        DO_ONCE(rvvm_warn("Failed to enforce pledge: %s!", strerror(errno)));
+    }
+#endif
+}
diff --git a/app/src/main/java/libengine/RVVM/src/rvvm_isolation.h b/app/src/main/java/libengine/RVVM/src/rvvm_isolation.h
new file mode 100644
index 00000000..e25f5cff
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/rvvm_isolation.h
@@ -0,0 +1,63 @@
+/*
+rvvm_isolation.h - Process & thread isolation
+Copyright (C) 2024  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef RVVM_ISOLATION_H
+#define RVVM_ISOLATION_H
+
+#include "rvvmlib.h"
+
+/*
+ * Restrict the calling thread from:
+ * - Accessing the filesystem
+ * - Accessing PID namespace, killing processes
+ * - Accessing IPC namespace
+ * - Forking, executing new programs
+ *
+ * Additionally, all capabilities of the calling are dropped,
+ * and suid privilege escalation is no longer possible.
+ *
+ * This is expected to be applied to all RVVM-owned threads
+ * (vCPU, threadpool, event dispatch thread) without affecting
+ * the process as a whole.
+ */
+void rvvm_restrict_this_thread(void);
+
+/*
+ * Apply same restrictions as cap_restrict_this_thread() to the whole process.
+ *
+ * Additionally, drop to nobody if we're root.
+ *
+ * NOTE: We can't implicitly enforce this in librvvm as we never know
+ * when it's safe to do so. It's up to the API user to decide.
+ */
+PUBLIC void rvvm_restrict_process(void);
+
+/*
+ * Possible TODO for further librvvm isolation: Implement process-wide filesystem restrictions
+ * - Read-only access to /etc, /usr, ... etc system dirs
+ * - Read-only access to any hidden .file in $HOME (Prevent messing with .bashrc, .profile etc)
+ * - Read-only access to ~/.local/bin, ~/.local/lib
+ * - No access to ~/.gnupg, ~/.ssh, ~/.pki, other critical user data like crypto wallets, browser profiles and such
+ *
+ * This in theory could be applied to any process which uses librvvm, with an opt-out mechanism
+ *
+ * Easily doable through OpenBSD pledge, however Linux Landlock is per-thread only,
+ * which significantly complicates the implementation.
+ */
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/rvvm_types.h b/app/src/main/java/libengine/RVVM/src/rvvm_types.h
new file mode 100644
index 00000000..4fedeb34
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/rvvm_types.h
@@ -0,0 +1,73 @@
+/*
+rvvm_types.c - RVVM integer types
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef RVVM_TYPES_H
+#define RVVM_TYPES_H
+
+#include <stdbool.h>
+#include <stdint.h>
+#include <stddef.h>
+
+#include <inttypes.h>
+
+// Fix for MSVCRT printf specifier
+#if defined(_WIN32) && defined(PRIx64)
+#undef PRIx64
+#define PRIx64 "I64x"
+#endif
+
+#ifndef PRIx64
+#define PRIx64 "llx"
+#endif
+
+#ifndef PRIx32
+#define PRIx32 "x"
+#endif
+
+#ifdef __SIZEOF_INT128__
+#define INT128_SUPPORT 1
+typedef unsigned __int128 uint128_t;
+typedef __int128 int128_t;
+#endif
+
+// Max XLEN/SXLEN values
+#ifdef USE_RV64
+typedef uint64_t maxlen_t;
+typedef int64_t smaxlen_t;
+#define MAX_XLEN 64
+#define MAX_SHAMT_BITS 6
+#define PRIxXLEN PRIx64
+#else
+typedef uint32_t maxlen_t;
+typedef int32_t smaxlen_t;
+#define MAX_XLEN 32
+#define MAX_SHAMT_BITS 5
+#define PRIxXLEN PRIx32
+#endif
+
+typedef double fmaxlen_t;
+
+// Distinguish between virtual and physical addresses
+typedef maxlen_t virt_addr_t;
+typedef maxlen_t phys_addr_t;
+
+typedef uint8_t regid_t;  // Register index
+typedef uint8_t bitcnt_t; // Bits count
+typedef uint8_t* vmptr_t; // Pointer to VM memory
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/rvvm_user.c b/app/src/main/java/libengine/RVVM/src/rvvm_user.c
new file mode 100644
index 00000000..b7f176d9
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/rvvm_user.c
@@ -0,0 +1,1803 @@
+/*
+rvvm_user.c - RVVM Linux binary emulator
+Copyright (C) 2024  LekKit <github.com/LekKit>
+              2023  nebulka1
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+/*
+ * This thing is hugely WIP, altho it runs static binaries fairly well.
+ * With dynamic binaries, it usually either crashes in ld-linux.so, or
+ * in random executable locations... Debugging this is a nightmare.
+ *
+ * Upon debugging this thing, I figured it would be a good idea to remove
+ * CPU/syscall emulation out of the equation, so simply test a combination
+ * of ELF loader + stack setup thingy. So there is a native x86_64 jump_start()
+ * implementation to do exactly that
+ *
+ * Some helpful resources:
+ *   https://jborza.com/post/2021-05-11-riscv-linux-syscalls/
+ *   https://gpages.juszkiewicz.com.pl/syscalls-table/syscalls.html
+ *
+ * Now if we ever get this to work, here are some interesting further goals:
+ *
+ * - Implement some kind of fake /usr overlay so you can still run RISC-V
+ *   binaries without chroot, and without putting RISC-V libs into your system
+ *
+ * - Allow to run Linux binaries on non-Linux host to some degree. The ELF
+ *   loader runs even on Windows (lol), so do the rest of RVVM abstractions.
+ *   So maybe for many simple syscalls we can do exactly that, at least on Mac/BSD..
+ *
+ * - Ask some guys that use qemu-user for build system purposes to try out rvvm-user :D
+ *   With some local JIT patches rvvm-user already beats qemu-user on statically
+ *   built benches
+ */
+
+#define _FILE_OFFSET_BITS 64
+#define _LARGEFILE64_SOURCE
+#define _GNU_SOURCE
+#define _BSD_SOURCE
+#define _DEFAULT_SOURCE
+
+//#define RVVM_USER_TEST
+//#define RVVM_USER_TEST_X86
+//#define RVVM_USER_TEST_RISCV
+
+// Guard this for now
+#if defined(RVVM_USER_TEST)
+
+#include <stdio.h>
+
+#include <errno.h>
+#include <unistd.h>
+
+#include <time.h>     // clock_gettime(), etc
+#include <signal.h>   // sigaction(), etc
+
+#include <sys/types.h>
+#include <sys/param.h>
+
+#include <sys/time.h> // setitimer()
+
+// File stuff
+#include <dirent.h>    // readdir(), etc
+#include <sys/file.h>  // fcntl(), flock(), fallocate(), openat()
+#include <sys/uio.h>   // readv(), writev()
+#include <sys/stat.h>  // mknodat(), mkdirat(), fchmod(), fchmodat(), fstatat(), fstat(), umask(), statx()
+#include <sys/mount.h> // struct statfs
+
+// VMA manipulation
+#include <sys/mman.h> // mmap(), munmap(), mprotect()
+#include <sys/shm.h>  // shmget(), shmctl(), shmat(), shmdt()
+
+// Sockets
+#include <sys/socket.h>
+#include <sys/ioctl.h>  // ioctl()
+#include <sys/select.h> // select()
+#include <poll.h>       // poll()
+
+// Misc
+#include <sys/times.h>    // times()
+#include <sys/wait.h>     // wait4()
+#include <sys/resource.h> // getrusage()
+#include <grp.h>          // setgroups()
+
+// Linux-specific stuff
+#ifdef __linux__
+#include <sys/eventfd.h> // eventfd()
+#include <sys/epoll.h>   // epoll_create1(), etc
+#include <sys/sysinfo.h> // sysinfo()
+#include <sys/fsuid.h>   // setfsuid(), setfsgid()
+#include <sys/vfs.h>     // struct statfs
+
+// Put syscall headers here
+#include <linux/futex.h> // FUTEX_*
+#include <sys/syscall.h> // SYS_*
+#include <unistd.h>
+#endif
+
+#include "rvvmlib.h"
+#include "elf_load.h"
+#include "mem_ops.h"
+#include "utils.h"
+#include "blk_io.h"
+#include "threading.h"
+#include "vma_ops.h"
+#include "spinlock.h"
+#include "rvtimer.h"
+#include "stacktrace.h"
+
+#define RVVM_USER_RISCV64
+
+#ifdef RVVM_USER_RISCV64
+typedef uint64_t uapi_size_t;
+typedef uint64_t uapi_ulong_t;
+typedef int64_t  uapi_long_t;
+#else
+typedef uint32_t uapi_size_t;
+typedef uint32_t uapi_ulong_t;
+typedef int32_t  uapi_long_t;
+#endif
+
+#define UAPI_PATH_MAX 4096
+
+#define UAPI_EPERM   1
+#define UAPI_ENOENT  2
+#define UAPI_EINTR   4
+#define UAPI_EIO     5
+#define UAPI_EBADF   9
+#define UAPI_EAGAIN  11
+#define UAPI_ENOMEM  12
+#define UAPI_EACCESS 13
+#define UAPI_EFAULT  14
+#define UAPI_EBUSY   16
+#define UAPI_EEXIST  17
+#define UAPI_EINVAL  22
+#define UAPI_ENOSYS  38
+
+// RISC-V UAPI struct definitions & conversions
+struct uapi_new_utsname {
+    char sysname[65];
+    char nodename[65];
+    char release[65];
+    char version[65];
+    char machine[65];
+    char domainname[65];
+};
+
+struct uapi_stat {
+    uapi_ulong_t dev;
+    uapi_ulong_t ino;
+    uint32_t     mode;
+    uint32_t     nlink;
+    uint32_t     uid;
+    uint32_t     gid;
+    uapi_ulong_t rdev;
+    uapi_ulong_t pad1;
+    uapi_long_t  size;
+    int32_t      blksize;
+    int32_t      pad2;
+    uapi_long_t  blocks;
+    uapi_long_t  atime;
+    uapi_ulong_t atime_nsec;
+    uapi_long_t  mtime;
+    uapi_ulong_t mtime_nsec;
+    uapi_long_t  ctime;
+    uapi_ulong_t ctime_nsec;
+    uint32_t     unused4;
+    uint32_t     unused5;
+};
+
+struct uapi_statfs64 {
+    uapi_size_t type;
+    uapi_size_t bsize;
+    uint64_t blocks;
+    uint64_t bfree;
+    uint64_t bavail;
+    uint64_t files;
+    uint64_t ffree;
+    struct {
+        int32_t val[2];
+    } fsid;
+    uapi_size_t namelen;
+    uapi_size_t frsize;
+    uapi_size_t flags;
+    uapi_size_t spare[4];
+};
+
+struct uapi_sigaction {
+    uapi_size_t  handler;
+    uapi_ulong_t mask;
+    uapi_ulong_t flags;
+};
+
+struct uapi_sigaltstack {
+    uapi_size_t sp;
+    int32_t flags;
+    uapi_size_t size;
+};
+
+struct uapi_sched_param {
+    int32_t sched_priority;
+};
+
+struct uapi_cap_data_struct {
+    uint32_t effective;
+    uint32_t permitted;
+    uint32_t inheritable;
+};
+
+union uapi_epoll_data {
+    uapi_size_t ptr;
+    int32_t     fd;
+    uint32_t    u32;
+    uint64_t    u64;
+};
+
+struct uapi_epoll_event {
+    uint32_t event;
+    union uapi_epoll_data data;
+};
+
+struct uapi_timeval32 {
+    uapi_long_t tv_sec;
+    uapi_long_t tv_usec;
+};
+
+struct uapi_timespec32 {
+    uapi_long_t tv_sec;
+    uapi_long_t tv_nsec;
+};
+
+struct uapi_timespec {
+    uint64_t tv_sec;
+    uint64_t tv_nsec;
+};
+
+struct uapi_pollfd {
+    int32_t  fd;
+    uint16_t events;
+    uint16_t revents;
+};
+
+struct uapi_linux_dirent64 {
+    uint64_t d_ino;
+    int64_t  d_off;
+    uint16_t d_reclen;
+    uint8_t  d_type;
+    char     d_name[0];
+};
+
+#ifdef __riscv
+
+BUILD_ASSERT(sizeof(struct uapi_stat) == sizeof(struct stat));
+BUILD_ASSERT(sizeof(struct uapi_statfs64) == sizeof(struct statfs));
+
+#endif
+
+static void uapi_stat_convert(struct uapi_stat* dst, const struct stat* src)
+{
+    dst->dev = src->st_dev;
+    dst->ino = src->st_ino;
+    dst->mode = src->st_mode;
+    dst->nlink = src->st_nlink;
+    dst->uid = src->st_uid;
+    dst->gid = src->st_gid;
+    dst->rdev = src->st_rdev;
+    dst->pad1 = 0;
+    dst->size = src->st_size;
+    dst->blksize = src->st_blksize;
+    dst->pad2 = 0;
+    dst->blocks = src->st_blocks;
+    dst->atime = src->st_atime;
+    dst->atime_nsec = 0;
+    dst->mtime = src->st_mtime;
+    dst->mtime_nsec = 0;
+    dst->ctime = src->st_ctime;
+    dst->ctime_nsec = 0;
+}
+
+static void uapi_statfs64_convert(struct uapi_statfs64* dst, const struct statfs* src)
+{
+    dst->type = src->f_type;
+    dst->bsize = src->f_bsize;
+    dst->blocks = src->f_blocks;
+    dst->bfree = src->f_bfree;
+    dst->bavail = src->f_bavail;
+    dst->files = src->f_files;
+    dst->ffree = src->f_ffree;
+    memcpy(&dst->fsid, &src->f_fsid, sizeof(dst->fsid));
+    dst->namelen = 256;
+    dst->frsize = src->f_bsize;
+    dst->flags = src->f_flags;
+}
+
+/*
+static void uapi_sigaction_convert(struct uapi_sigaction* dst, const struct sigaction* src)
+{
+    dst->handler = src->sa_handler;
+    dst->flags = src->sa_flags;
+    memcpy(&dst->mask, &src->sa_flags, sizeof(dst->mask));
+}
+*/
+
+static rvvm_machine_t* userland; // Emulated RVVM process context
+
+// Short cast rvvm_addr_t -> void*
+static void* to_ptr(rvvm_addr_t addr)
+{
+    return (void*)(size_t)addr;
+}
+
+// Short cast rvvm_addr_t -> const char*
+static const char* to_str(rvvm_addr_t addr)
+{
+    return (const char*)(size_t)addr;
+}
+
+// Return last errno like a syscall interface
+static int last_errno(void)
+{
+    // TODO: Host->Guest errno conversion
+    return -errno;
+}
+
+// Return negative values on -1 error like a syscall interface does
+static rvvm_addr_t errno_ret(int64_t val)
+{
+    if (val == -1) {
+        return last_errno();
+    } else {
+        return val;
+    }
+}
+
+// This is for debugging sake
+static elf_desc_t elf = {
+    .base = NULL,
+};
+static elf_desc_t interp = {
+    .base = NULL,
+};
+
+static bool proc_mem_readable(const void* addr, size_t size)
+{
+    static int fd = 0;
+    DO_ONCE({
+        fd = vma_anon_memfd(4096);
+        if (fd < 0) rvvm_fatal("Failed to create memfd!");
+    });
+    return write(fd, addr, size) == (ssize_t)size;
+}
+
+#ifndef __riscv
+static char* prefix_path = "/home/lekkit/stuff/userland/debian";
+#else
+static char* prefix_path = NULL;
+#endif
+
+static bool fake_root = true;
+
+static bool path_bypass(const char* path)
+{
+    return prefix_path == NULL
+        || rvvm_strfind(path, "/dev") == path
+        || rvvm_strfind(path, "/sys") == path
+        || rvvm_strfind(path, "/proc") == path
+        || rvvm_strfind(path, "/tmp") == path
+        || rvvm_strfind(path, "/var/tmp") == path;
+}
+
+static bool path_wrapped(const char* path)
+{
+    return prefix_path == NULL
+        || rvvm_strfind(path, prefix_path) == path
+        || path_bypass(path);
+}
+
+static const char* wrap_path(char* buffer, const char* path)
+{
+    if (prefix_path && path) {
+        if (path_bypass(path)) {
+            return path;
+        }
+
+        if (rvvm_strfind(path, "/") == path) {
+            size_t prefix_len = rvvm_strlcpy(buffer, prefix_path, UAPI_PATH_MAX);
+            rvvm_strlcpy(buffer + prefix_len, path, UAPI_PATH_MAX - prefix_len);
+            return buffer;
+        }
+    }
+    return path;
+}
+
+static size_t unwrap_path(char* buffer, const char* path, size_t size)
+{
+    if (prefix_path && rvvm_strfind(path, prefix_path) == path) {
+        size_t len = rvvm_strlen(prefix_path) + 1;
+        size_t off = rvvm_strlcpy(buffer, "/", size);
+        return rvvm_strlcpy(buffer + off, path + len, size - off);
+    }
+
+    return rvvm_strlcpy(buffer, path, UAPI_PATH_MAX);
+}
+
+static struct uapi_sigaction siga[64] = {0};
+
+void sig_handler(int signal)
+{
+    rvvm_info("Received signal %d", signal);
+}
+
+typedef struct {
+    rvvm_hart_t* cpu;
+    uint32_t* child_settid;
+    uint32_t* child_cleartid;
+    uint32_t tid;
+} rvvm_user_thread_t;
+
+// Main execution loop (Run the user CPU, handle syscalls)
+static void* rvvm_user_thread_wrap(void* arg);
+
+#define BRK_HEAP_SIZE 0x40000000
+
+static spinlock_t brk_lock = {0};
+static uint8_t* brk_buffer = NULL;
+static uint8_t* brk_ptr = NULL;
+
+// We can't touch the native brk heap since it would likely blow up the process
+static void* rvvm_sys_brk(void* addr)
+{
+    uint8_t* brk_new = addr;
+    uint8_t* brk_ret = NULL;
+    DO_ONCE({
+        brk_buffer = vma_alloc(NULL, BRK_HEAP_SIZE, VMA_RDWR);
+        brk_ptr = brk_buffer;
+    });
+
+    spin_lock(&brk_lock);
+    if (brk_new >= brk_buffer && brk_new < (brk_buffer + BRK_HEAP_SIZE)) {
+        if (brk_new > brk_ptr) {
+            // Newly allocated brk memory should be zeroed
+            memset(brk_ptr, 0, brk_new - brk_ptr);
+        }
+        brk_ptr = brk_new;
+    } else if (brk_new) {
+        rvvm_warn("invalid brk %p, current %p, off %ld!", brk_new, brk_ptr, brk_new - brk_buffer);
+    }
+    brk_ret = brk_ptr;
+    spin_unlock(&brk_lock);
+    return brk_ret;
+}
+
+#define UAPI_CLONE_VM             0x00000100
+#define UAPI_CLONE_VFORK          0x00004000
+#define UAPI_CLONE_SETTLS         0x00080000
+#define UAPI_CLONE_PARENT_SETTID  0x00100000
+#define UAPI_CLONE_CHILD_CLEARTID 0x00200000
+#define UAPI_CLONE_CHILD_SETTID   0x01000000
+
+#define UAPI_CLONE_INVALID_THREAD_FLAGS 0x7E02F000
+
+// long sys_clone(unsigned long flags, void *stack, int *parent_tid, unsigned long tls, int *child_tid);
+static int rvvm_sys_clone(rvvm_hart_t* cpu, uint32_t flags, size_t stack, uint32_t* parent_tid, size_t tls, uint32_t* child_tid)
+{
+    if ((flags & UAPI_CLONE_VM) && !(flags & UAPI_CLONE_VFORK)) {
+        if (flags & UAPI_CLONE_INVALID_THREAD_FLAGS) {
+            rvvm_warn("sys_clone(): Invalid flags %x", flags);
+            return -UAPI_EINVAL;
+        }
+
+        rvvm_user_thread_t* thread = safe_new_obj(rvvm_user_thread_t);
+        thread->cpu = rvvm_create_user_thread(userland);
+
+        // Clone all CPU state
+        for (size_t i=1; i<32; ++i) {
+            rvvm_write_cpu_reg(thread->cpu, RVVM_REGID_X0 + i, rvvm_read_cpu_reg(cpu, RVVM_REGID_X0 + i));
+        }
+        for (size_t i=0; i<32; ++i) {
+            rvvm_write_cpu_reg(thread->cpu, RVVM_REGID_F0 + i, rvvm_read_cpu_reg(cpu, RVVM_REGID_F0 + i));
+        }
+
+        // Land after syscall entry
+        rvvm_write_cpu_reg(thread->cpu, RVVM_REGID_PC, rvvm_read_cpu_reg(cpu, RVVM_REGID_PC) + 4);
+
+        // Set guest stack pointer
+        rvvm_write_cpu_reg(thread->cpu, RVVM_REGID_X0 + 2, stack);
+
+        if (flags & UAPI_CLONE_SETTLS) {
+            // Set guest TLS register
+            rvvm_write_cpu_reg(thread->cpu, RVVM_REGID_X0 + 4, tls);
+        }
+
+        // Return 0 in cloned thread
+        rvvm_write_cpu_reg(thread->cpu, RVVM_REGID_X0 + 10, 0); // a0
+
+        // Spawn the thread using portable RVVM thread facilities
+        thread_detach(thread_create_ex(rvvm_user_thread_wrap, thread, 0));
+
+        uint32_t tid = atomic_load_uint32(&thread->tid);
+        while (!tid) {
+            sleep_ms(0);
+            tid = atomic_load_uint32(&thread->tid);
+        }
+
+        if ((flags & UAPI_CLONE_PARENT_SETTID) && parent_tid) {
+            atomic_store_uint32(parent_tid, tid);
+        }
+
+        if (flags & UAPI_CLONE_CHILD_SETTID) {
+            thread->child_settid = child_tid;
+        }
+
+        if (flags & UAPI_CLONE_CHILD_CLEARTID) {
+            thread->child_cleartid = child_tid;
+        }
+
+        return tid;
+    } else {
+        // Emulate vfork via fork too
+        return fork();
+    }
+}
+
+#define UAPI_FUTEX_CMD_MASK    0x3F
+#define UAPI_FUTEX_WAIT        0x0
+#define UAPI_FUTEX_WAKE        0x1
+#define UAPI_FUTEX_WAIT_BITSET 0x9
+#define UAPI_FUTEX_WAKE_BITSET 0xA
+
+static int rvvm_sys_futex(uint32_t* addr, int futex_op, uint32_t val, size_t val2, uint32_t* uaddr2, uint32_t val3)
+{
+#if defined(__linux__)
+    return errno_ret(syscall(SYS_futex, addr, futex_op, val, val2, uaddr2, val3));
+#else
+    UNUSED(val2); UNUSED(uaddr2); UNUSED(val3);
+    switch (futex_op & UAPI_FUTEX_CMD_MASK) {
+        case UAPI_FUTEX_WAIT:
+        case UAPI_FUTEX_WAIT_BITSET:
+            if (atomic_load_uint32(addr) == val) {
+                sleep_ms(1);
+            }
+            return 0;
+        case UAPI_FUTEX_WAKE:
+        case UAPI_FUTEX_WAKE_BITSET:
+            return 0;
+    }
+    rvvm_warn("Unimplemented futex op %x", futex_op);
+    return -UAPI_EINVAL;
+#endif
+}
+
+static struct timeval* uapi_ts32_to_timeval(struct timeval* tv, const struct uapi_timespec32* ts32)
+{
+    if (ts32) {
+        tv->tv_sec = ts32->tv_sec;
+        tv->tv_usec = ts32->tv_nsec / 1000;
+        return tv;
+    }
+    return NULL;
+}
+
+static int rvvm_sys_select_time32(int nfds, void* rfds, void* wfds, void* efds, const struct uapi_timespec32* ts32)
+{
+    // TODO: fd_set conversion
+    struct timeval tv = {0};
+    return errno_ret(select(nfds, rfds, wfds, efds, uapi_ts32_to_timeval(&tv, ts32)));
+}
+
+static int rvvm_sys_poll_time32(void* pfds, size_t npfds, const struct uapi_timespec32* ts32)
+{
+    // TODO: struct pollfd conversion
+    int timeout = -1;
+    if (ts32) {
+        timeout = (ts32->tv_sec * 1000) + (ts32->tv_nsec / 1000000);
+    }
+    return errno_ret(poll(pfds, npfds, timeout));
+}
+
+static int64_t rvvm_sys_getdents64(int fd, void* dirp, size_t size)
+{
+    int64_t ret = 0;
+    ret = errno_ret(syscall(SYS_getdents64, fd, dirp, size));
+    //rvvm_warn("getdents64(%d, %p, %ld) -> %ld (%s)", fd, dirp, size, ret, (ret < 0) ? strerror(errno) : "Success");
+    return ret;
+    DIR* dir = fdopendir(dup(fd));
+    if (dir) {
+        struct dirent* dent = NULL;
+        while ((dent = readdir(dir))) {
+            size_t name_len = rvvm_strlen(dent->d_name);
+            size_t dirent_size = sizeof(struct uapi_linux_dirent64) + name_len + 1;
+            if (dirent_size <= size) {
+                struct uapi_linux_dirent64* dirent = dirp;
+                dirent->d_ino = dent->d_ino;
+                dirent->d_off = dirent_size;
+                dirent->d_reclen = dirent_size;
+                // TODO: Figure d_type somehow?
+                dirent->d_type = 0;
+                memcpy(dirent->d_name, dent->d_name, name_len);
+                dirent->d_name[name_len] = 0;
+
+                ret += dirent_size;
+                size -= dirent_size;
+                dirp = ((uint8_t*)dirp) + dirent_size;
+            } else {
+                closedir(dir);
+
+                return ret;
+            }
+        }
+        closedir(dir);
+        return ret;
+    } else {
+        return -UAPI_ENOENT;
+    }
+}
+
+#define UAPI_PROT_READ  0x1
+#define UAPI_PROT_WRITE 0x2
+#define UAPI_PROT_EXEC  0x4
+
+#define UAPI_MAP_SHARED          0x000001
+#define UAPI_MAP_PRIVATE         0x000002
+#define UAPI_MAP_FIXED           0x000010
+#define UAPI_MAP_ANON            0x000020
+#define UAPI_MAP_FIXED_NOREPLACE 0x100000
+
+#define UAPI_MAP_ILLEGAL         0xE00000
+
+#ifndef MAP_ANON
+#define MAP_ANON MAP_ANONYMOUS
+#endif
+
+static spinlock_t mmap_lock = {0};
+
+static inline int rvvm_sys_prot(int prot)
+{
+    int ret = PROT_NONE;
+    if (prot & UAPI_PROT_READ)  ret |= PROT_READ;
+    if (prot & UAPI_PROT_WRITE) ret |= PROT_WRITE;
+    // No real PROT_EXEC, since rvvm-user reads code when translating
+    if (prot & UAPI_PROT_EXEC)  ret |= PROT_READ;
+    return ret;
+}
+
+static rvvm_addr_t rvvm_sys_mmap(void* addr, size_t size, int prot, int flags, int fd, uint64_t offset)
+{
+    int mmap_flags = 0;
+    if (flags & UAPI_MAP_ILLEGAL) {
+        return -UAPI_EINVAL;
+    }
+
+    spin_lock(&mmap_lock);
+    if (flags & UAPI_MAP_SHARED) mmap_flags |= MAP_SHARED;
+    if (flags & UAPI_MAP_PRIVATE) mmap_flags |= MAP_PRIVATE;
+    if (flags & UAPI_MAP_ANON) mmap_flags |= MAP_ANON;
+
+    if (flags & UAPI_MAP_FIXED_NOREPLACE) {
+#ifdef __linux__
+        mmap_flags |= MAP_FIXED_NOREPLACE;
+#else
+        mmap_flags |= MAP_FIXED;
+#endif
+    }
+
+    if (flags & UAPI_MAP_FIXED) {
+        // This flag has destructive semantics...
+        mmap_flags |= MAP_FIXED;
+#ifndef __linux__
+        munmap(addr, size);
+#endif
+    }
+
+    rvvm_addr_t ret = errno_ret((size_t)mmap(addr, size, rvvm_sys_prot(prot), mmap_flags, fd, offset));
+    spin_unlock(&mmap_lock);
+    return ret;
+}
+
+static int rvvm_sys_munmap(void* addr, size_t size)
+{
+    spin_lock(&mmap_lock);
+    rvvm_addr_t ret = errno_ret(munmap(addr, size));
+    spin_unlock(&mmap_lock);
+    return ret;
+}
+
+extern uint64_t __thread_selfid(void);
+
+static int rvvm_sys_gettid(void)
+{
+#if defined(__APPLE__)
+    return __thread_selfid();
+#else
+    return gettid();
+#endif
+}
+
+static int fake_uid = 0;
+static int fake_gid = 0;
+
+static int rvvm_sys_getuid(void)
+{
+    if (fake_root) return fake_uid;
+    return errno_ret(getuid());
+}
+
+static int rvvm_sys_getgid(void)
+{
+    if (fake_root) return fake_gid;
+    return errno_ret(getgid());
+}
+
+static int rvvm_sys_setuid(int uid)
+{
+    if (fake_root) {
+        fake_uid = uid;
+        return 0;
+    }
+    return errno_ret(setuid(uid));
+}
+
+static int rvvm_sys_setgid(int gid)
+{
+    if (fake_root) {
+        fake_gid = gid;
+        return 0;
+    }
+    return errno_ret(setgid(gid));
+}
+
+static int rvvm_sys_getresuid(int* ruid, int* euid, int* suid)
+{
+    if (ruid) *ruid = rvvm_sys_getuid();
+    if (euid) *euid = rvvm_sys_getuid();
+    if (suid) *suid = rvvm_sys_getuid();
+    return 0;
+}
+
+static int rvvm_sys_getresgid(int* rgid, int* egid, int* sgid)
+{
+    if (rgid) *rgid = rvvm_sys_getgid();
+    if (egid) *egid = rvvm_sys_getgid();
+    if (sgid) *sgid = rvvm_sys_getgid();
+    return 0;
+}
+
+static rvvm_addr_t rvvm_sys_getcwd(char* buffer, size_t size)
+{
+    char tmp[UAPI_PATH_MAX] = {0};
+    if (!getcwd(tmp, size)) {
+        return last_errno();
+    }
+    return unwrap_path(buffer, tmp, size);
+}
+
+static rvvm_addr_t rvvm_sys_readlinkat(int dirfd, const char* pathname, char* buffer, size_t size)
+{
+    char tmp[UAPI_PATH_MAX] = {0};
+    if (readlinkat(dirfd, wrap_path(tmp, pathname), tmp, size) < 0) {
+        return last_errno();
+    }
+    return unwrap_path(buffer, tmp, size);
+}
+
+//#define rvvm_info(...) rvvm_warn(__VA_ARGS__);
+//#define rvvm_info(...)
+
+static void* rvvm_user_thread_wrap(void* arg)
+{
+    rvvm_user_thread_t* thread = arg;
+    rvvm_hart_t* cpu = thread->cpu;
+    bool running = true;
+
+    char path_buf[UAPI_PATH_MAX] = {0};
+    char path_buf1[UAPI_PATH_MAX] = {0};
+
+    // Set up thread tid, child_tid
+    atomic_store_uint32(&thread->tid, rvvm_sys_gettid());
+    if (thread->child_settid) {
+        atomic_store_uint32(thread->child_settid, atomic_load_uint32(&thread->tid));
+    }
+
+    while (running) {
+        rvvm_addr_t cause = rvvm_run_user_thread(cpu);
+        if (cause == 8) {
+            // Handle syscall trap
+            rvvm_addr_t a0 = rvvm_read_cpu_reg(cpu, RVVM_REGID_X0 + 10);
+            rvvm_addr_t a1 = rvvm_read_cpu_reg(cpu, RVVM_REGID_X0 + 11);
+            rvvm_addr_t a2 = rvvm_read_cpu_reg(cpu, RVVM_REGID_X0 + 12);
+            rvvm_addr_t a3 = rvvm_read_cpu_reg(cpu, RVVM_REGID_X0 + 13);
+            rvvm_addr_t a4 = rvvm_read_cpu_reg(cpu, RVVM_REGID_X0 + 14);
+            rvvm_addr_t a5 = rvvm_read_cpu_reg(cpu, RVVM_REGID_X0 + 15);
+            rvvm_addr_t a7 = rvvm_read_cpu_reg(cpu, RVVM_REGID_X0 + 17);
+            switch (a7) {
+                case 17: { // getcwd
+                    rvvm_info("sys_getcwd(%lx, %lx)", a0, a1);
+                    a0 = rvvm_sys_getcwd(to_ptr(a0), a1);
+                    break;
+                }
+#ifdef __linux__
+                case 19: // eventfd2
+                    rvvm_info("sys_eventfd2(%lx, %lx)", a0, a1);
+                    a0 = errno_ret(eventfd(a0, a1));
+                    break;
+                case 20: // epoll_create1
+                    rvvm_info("sys_epoll_create1(%lx)", a0);
+                    a0 = errno_ret(epoll_create1(a0));
+                    break;
+                case 21: // epoll_ctl
+                    // TODO struct conversion
+                    rvvm_info("sys_epoll_ctl(%lx, %lx, %lx, %lx)", a0, a1, a2, a3);
+                    a0 = errno_ret(epoll_ctl(a0, a1, a2, to_ptr(a3)));
+                    break;
+                case 22: // epoll_pwait
+                    // TODO struct conversion
+                    rvvm_info("sys_epoll_pwait(%lx, %lx, %lx, %lx, %lx, %lx)", a0, a1, a2, a3, a4, a5);
+                    a0 = errno_ret(epoll_wait(a0, to_ptr(a1), a2, a3));
+                    break;
+#endif
+                case 23: // dup
+                    rvvm_info("sys_dup(%ld)", a0);
+                    a0 = errno_ret(dup(a0));
+                    break;
+                case 24: // dup3
+                    rvvm_info("sys_dup3(%ld, %ld, %lx)", a0, a1, a2);
+                    a0 = errno_ret(dup2(a0, a1));
+                    break;
+                case 25: // fcntl64
+                    rvvm_info("sys_fcntl64(%ld, %lx, %lx)", a0, a1, a2);
+                    a0 = errno_ret(fcntl(a0, a1, a2));
+                    break;
+                case 29: // ioctl
+                    // TODO: I sure hope not many ioctl() interfaces need struct conversion...
+                    rvvm_info("sys_ioctl(%ld, %lx, %lx)", a0, a1, a2);
+                    a0 = errno_ret(ioctl(a0, a1, a2));
+                    break;
+                case 32: // flock
+                    rvvm_info("sys_flock(%ld, %lx)", a0, a1);
+                    a0 = errno_ret(flock(a0, a1));
+                    break;
+                case 33: // mknodat
+                    rvvm_info("sys_mknodat(%ld, %s, %lx, %lx)", a0, to_str(a1), a2, a3);
+                    a0 = errno_ret(mknodat(a0, wrap_path(path_buf, to_str(a1)), a2, a3));
+                    break;
+                case 34: // mkdirat
+                    rvvm_info("sys_mkdirat(%ld, %s, %lx)", a0, to_str(a1), a2);
+                    a0 = errno_ret(mkdirat(a0, wrap_path(path_buf, to_str(a1)), a2));
+                    break;
+                case 35: // unlinkat
+                    rvvm_info("sys_unlinkat(%ld, %s, %lx)", a0, to_str(a1), a2);
+                    a0 = errno_ret(unlinkat(a0, wrap_path(path_buf, to_str(a1)), a2));
+                    break;
+                case 36: // symlinkat
+                    rvvm_info("sys_symlinkat(%s, %ld, %s)", to_str(a0), a1, to_str(a2));
+                    a0 = errno_ret(symlinkat(wrap_path(path_buf, to_str(a0)), a1,
+                                             wrap_path(path_buf1, to_str(a2))));
+                    break;
+                case 37: // linkat
+                    rvvm_info("sys_linkat(%ld, %s, %ld, %s, %lx)", a0, to_str(a1), a2, to_str(a3), a4);
+                    a0 = errno_ret(linkat(a0, wrap_path(path_buf, to_str(a1)),
+                                          a2, wrap_path(path_buf1, to_str(a3)), a4));
+                    break;
+                case 43: { // statfs64
+                    struct statfs stfs = {0};
+                    rvvm_info("sys_statfs64(%s, %lx, %lx)", to_str(a0), a1, a2);
+                    a0 = errno_ret(statfs(wrap_path(path_buf, to_str(a0)), &stfs));
+                    uapi_statfs64_convert(to_ptr(a1), &stfs);
+                    break;
+                }
+                case 44: { // fstatfs64
+                    struct statfs stfs = {0};
+                    rvvm_info("sys_fstatfs64(%ld, %lx, %lx)", a0, a1, a2);
+                    a0 = errno_ret(fstatfs(a0, &stfs));
+                    uapi_statfs64_convert(to_ptr(a1), &stfs);
+                    break;
+                }
+                case 45: // truncate64
+                    rvvm_info("sys_truncate64(%s, %lx)", to_str(a0), a1);
+                    a0 = errno_ret(truncate(wrap_path(path_buf, to_str(a0)), a1));
+                    break;
+                case 46: // ftruncate64
+                    rvvm_info("sys_ftruncate64(%ld, %lx)", a0, a1);
+                    a0 = errno_ret(ftruncate(a0, a1));
+                    break;
+#ifdef __linux__
+                case 47: // fallocate
+                    rvvm_info("sys_fallocate(%ld, %lx, %lx, %lx)", a0, a1, a2, a3);
+                    a0 = errno_ret(fallocate(a0, a1, a2, a3));
+                    break;
+#endif
+                case 48: // faccessat
+                    rvvm_info("sys_faccessat(%ld, %s, %lx)", a0, to_str(a1), a2);
+                    a0 = errno_ret(faccessat(a0, wrap_path(path_buf, to_str(a1)), a2, 0));
+                    break;
+                case 49: // chdir
+                    rvvm_info("sys_chdir(%s)", to_str(a0));
+                    a0 = errno_ret(chdir(wrap_path(path_buf, to_str(a0))));
+                    break;
+                case 50: // fchdir
+                    rvvm_info("sys_fchdir(%ld)", a0);
+                    a0 = errno_ret(fchdir(a0));
+                    break;
+                case 52: // fchmod
+                    rvvm_info("sys_fchmodat(%ld, %lx)", a0, a1);
+                    a0 = errno_ret(fchmod(a0, a1));
+                    break;
+                case 53: // fchmodat
+                    rvvm_info("sys_fchmodat(%ld, %s, %lx)", a0, to_str(a1), a2);
+                    a0 = errno_ret(fchmodat(a0, wrap_path(path_buf, to_str(a1)), a2, 0));
+                    break;
+                case 54: // fchownat
+                    if (fake_root) {
+                        a0 = 0;
+                    } else {
+                        rvvm_info("sys_fchownat(%ld, %s, %lx, %lx, %lx)", a0, to_str(a1), a2, a3, a4);
+                        a0 = errno_ret(fchownat(a0, wrap_path(path_buf, to_str(a1)), a2, a3, a4));
+                    }
+                    break;
+                case 55: // fchown
+                    if (fake_root) {
+                        a0 = 0;
+                    } else {
+                        rvvm_info("sys_fchownat(%ld, %lx, %lx)", a0, a1, a2);
+                        a0 = errno_ret(fchown(a0, a1, a2));
+                    }
+                    break;
+                case 56: // openat
+                    rvvm_info("sys_openat(%ld, %s, %lx, %lx)", a0, to_str(a1), a2, a3);
+                    a0 = errno_ret(openat(a0, wrap_path(path_buf, to_str(a1)), a2, a3));
+                    break;
+                case 57: // close
+                    a0 = errno_ret(close(a0));
+                    break;
+                case 59: // pipe2
+                    rvvm_info("sys_pipe2(%lx, %lx)", a0, a1);
+                    a0 = errno_ret(pipe(to_ptr(a0)));
+                    break;
+                case 61: // getdents64
+                    a0 = rvvm_sys_getdents64(a0, to_ptr(a1), a2);
+                    break;
+                case 62: // lseek
+                    a0 = errno_ret(lseek(a0, a1, a2));
+                    break;
+                case 63: // read
+                    a0 = errno_ret(read(a0, to_ptr(a1), a2));
+                    break;
+                case 64: // write
+                    a0 = errno_ret(write(a0, to_ptr(a1), a2));
+                    break;
+                case 65: // readv
+                    // TODO: struct conversion(?)
+                    a0 = errno_ret(readv(a0, to_ptr(a1), a2));
+                    break;
+                case 66: // writev
+                    // TODO: struct conversion(?)
+                    a0 = errno_ret(writev(a0, to_ptr(a1), a2));
+                    break;
+                case 67: // pread64
+                    a0 = errno_ret(pread(a0, to_ptr(a1), a2, a3));
+                    break;
+                case 68: // pwrite64
+                    a0 = errno_ret(pwrite(a0, to_ptr(a1), a2, a3));
+                    break;
+                case 72: // pselect6_time32
+                    a0 = rvvm_sys_select_time32(a0, to_ptr(a1), to_ptr(a2), to_ptr(a3), to_ptr(a4));
+                    break;
+                case 73: // ppoll_time32
+                    a0 = rvvm_sys_poll_time32(to_ptr(a0), a1, to_ptr(a2));
+                    break;
+                case 78: // readlinkat
+                    rvvm_info("sys_readlinkat(%ld, %s, %lx, %lx)", a0, to_str(a1), a2, a3);
+                    a0 = rvvm_sys_readlinkat(a0, to_str(a1), to_ptr(a2), a3);
+                    break;
+                case 79: { // newfstatat
+                    struct stat st = {0};
+                    rvvm_info("sys_newfstatat(%ld, %s, %lx, %lx)", a0, to_str(a1), a2, a3);
+                    a0 = errno_ret(fstatat(a0, wrap_path(path_buf, to_str(a1)), &st, a3));
+                    uapi_stat_convert(to_ptr(a2), &st);
+                    break;
+                }
+                case 80: { // newfstat
+                    struct stat st = {0};
+                    rvvm_info("sys_newfstat(%ld, %lx)", a0, a1);
+                    a0 = errno_ret(fstat(a0, &st));
+                    uapi_stat_convert(to_ptr(a1), &st);
+                    break;
+                }
+                case 82: // fsync
+                    a0 = errno_ret(fsync(a0));
+                    break;
+                case 83: // fdatasync
+                    a0 = errno_ret(fsync(a0));
+                    break;
+                case 88: // utimensat - ignore
+                    a0 = 0;
+                    break;
+                case 90: // capget - stub
+                    if (a1) {
+                        struct uapi_cap_data_struct* cap = to_ptr(a1);
+                        memset(cap, 0, sizeof(*cap));
+                    }
+                    a0 = 0;
+                    break;
+                case 91: // capset - ignore
+                    a0 = 0;
+                    break;
+                case 93: // exit
+                    running = false;
+                    break;
+                case 94: // exit_group
+                    _Exit(a0);
+                    break;
+                case 96: // set_tid_address
+                    thread->child_cleartid = to_ptr(a0);
+                    a0 = atomic_load_uint32(&thread->tid);
+                    break;
+                case 98: // futex
+                    a0 = rvvm_sys_futex(to_ptr(a0), a1, a2, a3, to_ptr(a4), a5);
+                    break;
+                case 99: // set_robust_list
+                    // TODO: Implement this
+                    rvvm_info("sys_set_robust_list(%lx, %lx)", a0, a1);
+                    a0 = 0;
+                    break;
+                case 101: // nanosleep
+                    // TODO: Struct conversion
+                    a0 = errno_ret(nanosleep(to_ptr(a0), to_ptr(a1)));
+                    break;
+                case 103: // setitimer
+                    rvvm_info("sys_setitimer(%lx, %lx, %lx)", a0, a1, a2);
+                    a0 = errno_ret(setitimer(a0, to_ptr(a1), to_ptr(a2)));
+                    break;
+                case 113: // clock_gettime
+                    // TODO: Struct conversion!
+                    rvvm_info("sys_clock_gettime(%lx, %lx)", a0, a1);
+                    a0 = errno_ret(clock_gettime(a0, to_ptr(a1)));
+                    break;
+                case 114: // clock_getres
+                    rvvm_info("sys_clock_getres(%lx, %lx)", a0, a1);
+                    a0 = errno_ret(clock_getres(a0, to_ptr(a1)));
+                    break;
+#ifdef __linux__
+                case 115: // clock_nanosleep
+                    // TODO: struct conversion?
+                    rvvm_info("sys_clock_nanosleep(%lx, %lx, %lx, %lx)", a0, a1, a2, a3);
+                    a0 = errno_ret(clock_nanosleep(a0, a1, to_ptr(a2), to_ptr(a3)));
+                    break;
+#endif
+                case 118: // sched_setparam - ignore
+                case 119: // sched_setscheduler - ignore
+                case 120: // sched_getscheduler - ignore
+                    a0 = 0;
+                    break;
+                case 121: // sched_getparam - stub
+                    if (a1) {
+                        struct uapi_sched_param* param = to_ptr(a1);
+                        memset(param, 0, sizeof(*param));
+                    }
+                    a0 = 0;
+                    break;
+                case 122: // sched_setaffinity - ignore
+                    a0 = 0;
+                    break;
+                case 123: // sched_getaffinity - stub
+                    if (a2 && a1) {
+                        memset(to_ptr(a2), 0, a1);
+                        *(uint8_t*)to_ptr(a2) = 1;
+                    }
+                    a0 = 0;
+                    break;
+                case 124: // sched_yield
+                    sleep_ms(0);
+                    a0 = 0;
+                    break;
+                case 125: // sched_get_priority_max - ignore
+                case 126: // sched_get_priority_min - ignore
+                    a0 = 0;
+                    break;
+                case 129: // kill
+                    rvvm_warn("sys_kill(%lx, %lx)", a0, a1);
+                    a0 = errno_ret(kill(a0, a1));
+                    break;
+#ifdef __linux__
+                case 130: // tkill
+                    rvvm_warn("sys_tkill(%lx, %lx)", a0, a1);
+                    a0 = errno_ret(tgkill(getpid(), a0, a1));
+                    break;
+                case 131: // tgkill
+                    rvvm_warn("sys_tgkill(%lx, %lx, %ld)", a0, a1, a2);
+                    a0 = errno_ret(tgkill(a0, a1, a2));
+                    break;
+#endif
+                case 134: { // rt_sigaction
+                    struct sigaction sa = {0};
+                    rvvm_info("sys_rt_sigaction(%ld, %lx, %lx, %lx)", a0, a1, a2, a3);
+                    if (a0 < STATIC_ARRAY_SIZE(siga)) {
+                        if (a2) memcpy(to_ptr(a2), &siga[a0], a3);
+                        if (a1) {
+                            memcpy(&siga[a0], to_ptr(a1), a3);
+
+                            // Register a shim signal handler
+                            if (a0 != 11) {
+                                memcpy(&sa.sa_mask, &siga[a0].mask, 8);
+                                sa.sa_flags = siga[a0].flags & ~SA_SIGINFO;
+                                sa.sa_handler = to_ptr(siga[a0].handler);
+                                if (sa.sa_handler != SIG_DFL && sa.sa_handler != SIG_IGN) {
+                                    sa.sa_handler = sig_handler;
+                                }
+                                sigaction(a0, &sa, NULL);
+                            }
+                        }
+                        a0 = 0;
+                    } else {
+                        a0 = -UAPI_EINVAL;
+                    }
+                    break;
+                }
+                case 135: // rt_sigprocmask
+                    rvvm_info("sys_rt_sigprocmask(%ld, %lx, %lx, %lx)", a0, a1, a2, a3);
+                    a0 = errno_ret(sigprocmask(a0, to_ptr(a1), to_ptr(a2)));
+                    break;
+                case 137: // rt_sigtimedwait_time32
+                    // TODO: Signal handling
+                    sleep_ms(-1);
+                    a0 = 0;
+                    break;
+                case 140: // setpriority - ignore
+                    a0 = 0;
+                    break;
+                case 144: // setgid
+                    a0 = rvvm_sys_setgid(a0);
+                    break;
+                case 146: // setuid
+                    a0 = rvvm_sys_setuid(a0);
+                    break;
+                case 147: // setresuid - semi stub
+                    a0 = rvvm_sys_setuid(a0);
+                    break;
+                case 148: // getresuid - semi stub
+                    a0 = rvvm_sys_getresuid(to_ptr(a0), to_ptr(a1), to_ptr(a2));
+                    break;
+                case 149: // setresgid - semi stub
+                    a0 = rvvm_sys_setgid(a0);
+                    break;
+                case 150: // getresgid - semi stub
+                    a0 = rvvm_sys_getresgid(to_ptr(a0), to_ptr(a1), to_ptr(a2));
+                    break;
+                case 151: // setfsuid - ignore
+                    a0 = rvvm_sys_getuid();
+                    break;
+                case 152: // setfsgid - ignore
+                    a0 = rvvm_sys_getgid();
+                    break;
+                case 153: // times
+                    // TODO: Struct conversion!
+                    rvvm_info("sys_times(%lx)", a0);
+                    a0 = errno_ret(times(to_ptr(a0)));
+                    break;
+#ifdef __linux__
+                case 154: // setpgid
+                    rvvm_info("sys_setpgid(%lx, %lx)", a0, a1);
+                    a0 = errno_ret(setpgid(a0, a1));
+                    break;
+                case 155: // getpgid
+                    rvvm_info("sys_getpgid(%lx)", a0);
+                    a0 = errno_ret(getpgid(a0));
+                    break;
+#endif
+                case 157: // setsid
+                    rvvm_info("sys_setsid()");
+                    a0 = errno_ret(setsid());
+                    break;
+                case 158: // getgroups
+                    rvvm_warn("sys_getgroups(%lx, %lx)", a0, a1);
+                    a0 = errno_ret(getgroups(a0, to_ptr(a1)));
+                    break;
+                case 159: // setgroups
+                    if (fake_root) {
+                        a0 = 0;
+                    } else {
+                        a0 = errno_ret(setgroups(a0, to_ptr(a1)));
+                    }
+                    break;
+                case 160: // newuname
+                    rvvm_info("sys_newuname(%lx)", a0);
+                    if (a0) {
+                        // Just lie about the host details
+                        struct uapi_new_utsname name = {
+                            .sysname = "Linux",
+                            .nodename = "rvvm-user",
+                            .release = "6.6.6",
+                            .version = "RVVM " RVVM_VERSION,
+                            .machine = "riscv64",
+                        };
+                        memcpy(to_ptr(a0), &name, sizeof(name));
+                        a0 = 0;
+                    }
+                    break;
+                case 165: // getrusage
+                    rvvm_info("sys_getrusage(%lx, %lx)", a0, a1);
+                    a0 = errno_ret(getrusage(a0, to_ptr(a1)));
+                    break;
+                case 166: // umask
+                    rvvm_info("sys_umask(%lx)", a0);
+                    a0 = errno_ret(umask(a0));
+                    break;
+                case 167: // prctl
+                    rvvm_info("sys_prctl(%lx, %lx, %lx, %lx, %lx)", a0, a1, a2, a3, a4);
+                    //a0 = errno_ret(prctl(a0, a1, a2, a3, a4));
+                    a0 = 0;
+                    break;
+                case 172: // getpid
+                    a0 = errno_ret(getpid());
+                    break;
+                case 173: // getppid
+                    a0 = errno_ret(getppid());
+                    break;
+                case 174: // getuid
+                    a0 = rvvm_sys_getuid();
+                    break;
+                case 175: // geteuid - semi stub
+                    a0 = rvvm_sys_getuid();
+                    break;
+                case 176: // getgid
+                    a0 = rvvm_sys_getgid();
+                    break;
+                case 177: // getegid - semi stub
+                    a0 = rvvm_sys_getgid();
+                    break;
+                case 178: // gettid
+                    a0 = thread->tid;
+                    break;
+#ifdef __linux__
+                case 179: // sysinfo
+                    // TODO: struct conversion(?)
+                    rvvm_info("sys_sysinfo(%lx)", a0);
+                    a0 = errno_ret(sysinfo(to_ptr(a0)));
+                    break;
+#endif
+                case 194: // shmget
+                    rvvm_info("sys_shmget(%lx, %lx, %lx)", a0, a1, a2);
+                    a0 = errno_ret(shmget(a0, a1, a2));
+                    break;
+                case 195: // shmctl
+                    // TODO: struct conversion?
+                    rvvm_info("sys_shmctl(%ld, %lx, %lx)", a0, a1, a2);
+                    a0 = errno_ret(shmctl(a0, a1, to_ptr(a2)));
+                    break;
+                case 196: // shmat
+                    rvvm_info("sys_shmat(%ld, %lx, %lx)", a0, a1, a2);
+                    a0 = errno_ret((size_t)shmat(a0, to_ptr(a1), a2));
+                    break;
+                case 197: // shmdt
+                    rvvm_info("sys_shmdt(%lx)", a0);
+                    a0 = errno_ret(shmdt(to_ptr(a0)));
+                    break;
+                case 198: // socket
+                    rvvm_info("sys_socket(%lx, %lx, %lx)", a0, a1, a2);
+                    a0 = errno_ret(socket(a0, a1, a2));
+                    break;
+                case 199: // socketpair
+                    rvvm_info("sys_socketpair(%lx, %lx, %lx, %lx)", a0, a1, a2, a3);
+                    a0 = errno_ret(socketpair(a0, a1, a2, to_ptr(a3)));
+                    break;
+                case 200: // bind
+                    // TODO struct conversion
+                    rvvm_info("sys_bind(%ld, %lx, %lx)", a0, a1, a2);
+                    a0 = errno_ret(bind(a0, to_ptr(a1), a2));
+                    break;
+                case 201: // listen
+                    rvvm_info("sys_listen(%ld, %lx)", a0, a1);
+                    a0 = errno_ret(listen(a0, a1));
+                    break;
+                case 202: // accept
+                    // TODO: struct conversion(?)
+                    rvvm_info("sys_accept(%ld, %lx, %lx)", a0, a1, a2);
+                    a0 = errno_ret(accept(a0, to_ptr(a1), to_ptr(a2)));
+                    break;
+                case 203: // connect
+                    // TODO: struct conversion(?)
+                    rvvm_info("sys_connect(%ld, %lx, %lx)", a0, a1, a2);
+                    a0 = errno_ret(connect(a0, to_ptr(a1), a2));
+                    break;
+                case 204: // getsockname
+                    // TODO: struct conversion(?)
+                    rvvm_info("sys_getsockname(%ld, %lx, %lx)", a0, a1, a2);
+                    a0 = errno_ret(getsockname(a0, to_ptr(a1), to_ptr(a2)));
+                    break;
+                case 205: // getpeername
+                    // TODO: struct conversion(?)
+                    rvvm_info("sys_getpeername(%ld, %lx, %lx)", a0, a1, a2);
+                    a0 = errno_ret(getpeername(a0, to_ptr(a1), to_ptr(a2)));
+                    break;
+                case 206: // sendto
+                    // TODO: struct conversion(?)
+                    rvvm_info("sys_sendto(%ld, %lx, %lx, %lx, %lx, %lx)", a0, a1, a2, a3, a4, a5);
+                    a0 = errno_ret(sendto(a0, to_ptr(a1), a2, a3, to_ptr(a4), a5));
+                    break;
+                case 207: // recvfrom
+                    // TODO: struct conversion(?)
+                    rvvm_info("sys_recvfrom(%ld, %lx, %lx, %lx, %lx, %lx)", a0, a1, a2, a3, a4, a5);
+                    a0 = errno_ret(recvfrom(a0, to_ptr(a1), a2, a3, to_ptr(a4), to_ptr(a5)));
+                    break;
+                case 208: // setsockopt
+                    rvvm_info("sys_setsockopt(%ld, %lx, %lx, %lx, %lx)", a0, a1, a2, a3, a4);
+                    a0 = errno_ret(setsockopt(a0, a1, a2, to_ptr(a3), a4));
+                    break;
+                case 209: // getsockopt
+                    rvvm_info("sys_getsockopt(%ld, %lx, %lx, %lx, %lx)", a0, a1, a2, a3, a4);
+                    a0 = errno_ret(getsockopt(a0, a1, a2, to_ptr(a3), to_ptr(a4)));
+                    break;
+                case 210: // shutdown
+                    rvvm_info("sys_shutdown(%ld, %lx)", a0, a1);
+                    a0 = errno_ret(shutdown(a0, a1));
+                    break;
+                case 211: // sendmsg
+                    // TODO: struct conversion(?)
+                    rvvm_info("sys_sendmsg(%ld, %lx, %lx)", a0, a1, a2);
+                    a0 = errno_ret(sendmsg(a0, to_ptr(a1), a2));
+                    break;
+                case 212: // recvmsg
+                    // TODO: struct conversion(?)
+                    rvvm_info("sys_recvmsg(%ld, %lx, %lx)", a0, a1, a2);
+                    a0 = errno_ret(recvmsg(a0, to_ptr(a1), a2));
+                    break;
+                case 214: // brk
+                    rvvm_info("sys_brk(%lx)", a0);
+                    a0 = (size_t)rvvm_sys_brk(to_ptr(a0));
+                    break;
+                case 215: // munmap
+                    rvvm_info("sys_munmap(%lx, %lx)", a0, a1);
+                    a0 = rvvm_sys_munmap(to_ptr(a0), a1);
+                    break;
+#ifdef __linux__
+                case 216: // mremap
+                    rvvm_info("sys_mremap(%lx, %lx, %lx, %lx, %lx)", a0, a1, a2, a3, a4);
+                    a0 = errno_ret((size_t)mremap(to_ptr(a0), a1, a2, a3, to_ptr(a4)));
+                    break;
+#endif
+                case 220: // clone
+                    rvvm_info("sys_clone(%lx, %lx, %lx, %lx, %lx)", a0, a1, a2, a3, a4);
+                    a0 = rvvm_sys_clone(cpu, a0, a1, to_ptr(a2), a3, to_ptr(a4));
+                    break;
+                case 221: { // execve
+                    rvvm_info("sys_execve(%lx, %lx, %lx)", a0, a1, a2);
+                    if (access(wrap_path(path_buf, to_str(a0)), F_OK)) {
+                        a0 = -ENOENT;
+                        break;
+                    }
+                    char** orig_argv = to_ptr(a1);
+                    char* new_argv[256] = {"/proc/self/exe", "-user", 0};
+                    for (size_t i=2; i<255 && orig_argv[i - 2]; ++i) new_argv[i] = orig_argv[i - 2];
+                    new_argv[2] = to_ptr(a0);
+                    a0 = errno_ret(execve("/proc/self/exe", new_argv, to_ptr(a2)));
+                    break;
+                }
+                case 222: // mmap
+                    a0 = rvvm_sys_mmap(to_ptr(a0), a1, a2, a3, a4, a5);
+                    break;
+                case 223: // fadvise64_64 - ignore
+                    a0 = 0;
+                    break;
+                case 226: // mprotect
+                    a0 = errno_ret(mprotect(to_ptr(a0), a1, a2));
+                    break;
+#ifdef __linux__
+                case 233: // madvise
+                    rvvm_info("sys_madvise(%lx, %lx, %lx)", a0, a1, a2);
+                    a0 = errno_ret(madvise(to_ptr(a0), a1, a2));
+                    break;
+                case 242: // accept4
+                    // TODO: struct conversion(?)
+                    rvvm_info("sys_accept4(%ld, %lx, %lx, %lx)", a0, a1, a2, a3);
+                    a0 = errno_ret(accept4(a0, to_ptr(a1), to_ptr(a2), a3));
+                    break;
+#endif
+                case 258: // riscv_hwprobe
+                    a0 = -UAPI_ENOSYS;
+                    break;
+                case 259: // riscv_flush_icache
+                    //rvvm_warn("riscv_flush_icache(%lx, %lx, %lx)", a0, a1, a2);
+                    rvvm_flush_icache(userland, a0, a1 - a0);
+                    a0 = 0;
+                    break;
+                case 260: // wait4
+                    // TODO: Struct conversion
+                    rvvm_info("sys_wait4(%lx, %lx, %lx, %lx)", a0, a1, a2, a3);
+                    a0 = errno_ret(wait4(a0, to_ptr(a1), a2, to_ptr(a3)));
+                    break;
+                case 261: // prlimit64 - stub
+                    rvvm_info("sys_prlimit64(%lx, %lx, %lx, %lx)", a0, a1, a2, a3);
+                    //a0 = errno_ret(prlimit(a0, a1, to_ptr(a2), to_ptr(a3)));
+                    a0 = -UAPI_EINVAL;
+                    break;
+#ifdef __linux__
+                case 269: // sendmmsg
+                    // TODO: Struct conversion
+                    rvvm_info("sys_sendmmsg(%ld, %lx, %lx, %lx)", a0, a1, a2, a3);
+                    a0 = errno_ret(sendmmsg(a0, to_ptr(a1), a2, a3));
+                    break;
+#endif
+                case 276: // renameat2
+                    rvvm_info("sys_renameat2(%ld, %s, %ld, %s, %lx)", a0, to_str(a1), a2, to_str(a3), a4);
+                    a0 = errno_ret(renameat(a0, wrap_path(path_buf, to_str(a1)),
+                                            a2, wrap_path(path_buf1, to_str(a3))));
+                    break;
+                case 277: // seccomp - stub
+                    // Hitler SHOT HIMSELF after seeing this...
+                    a0 = 0;
+                    break;
+                case 278: // getrandom
+                    rvvm_randombytes(to_ptr(a0), a1);
+                    a0 = a1;
+                    break;
+#ifdef __linux__
+                case 279: // memfd_create
+                    rvvm_info("sys_memfd_create(%s, %lx)", to_str(a0), a1);
+                    a0 = errno_ret(memfd_create(to_str(a0), a1));
+                    break;
+                case 291: // statx
+                    // TODO: Struct conversion!
+                    rvvm_info("sys_statx(%ld, %s, %lx, %lx, %lx)", a0, to_str(a1), a2, a3, a4);
+                    a0 = errno_ret(statx(a0, wrap_path(path_buf, to_str(a1)), a2, a3, to_ptr(a4)));
+                    break;
+#endif
+                case 435: // clone3
+                    // FUCK THIS FUCKING SYSCALL FOR NOW
+                    a0 = -UAPI_ENOSYS;
+                    break;
+                case 436: // close_range - ignore
+                    a0 = -UAPI_ENOSYS;
+                    break;
+                case 439: // faccessat2
+                    rvvm_info("sys_faccessat2(%ld, %s, %lx, %lx)", a0, to_str(a1), a2, a3);
+                    a0 = errno_ret(faccessat(a0, wrap_path(path_buf, to_str(a1)), a2, a3));
+                    break;
+                default:
+#ifndef __riscv
+                    rvvm_error("Unknown syscall %ld!", a7);
+                    a0 = -UAPI_ENOSYS;
+#else
+                    a0 = errno_ret(syscall(a7, a0, a1, a2, a3, a4, a5));
+#endif
+                    break;
+            }
+            if ((int64_t)a0 < 0) {
+                //rvvm_warn("Syscall %ld failed: %ld", a7, a0);
+            }
+            rvvm_info("  -> %lx", a0);
+            rvvm_write_cpu_reg(cpu, RVVM_REGID_X0 + 10, a0);
+            rvvm_write_cpu_reg(cpu, RVVM_REGID_PC, rvvm_read_cpu_reg(cpu, RVVM_REGID_PC) + 4);
+        } else {
+            // Boom!
+            rvvm_warn("Exception %lx (tval %lx) at PC %lx, SP %lx",
+                      rvvm_read_cpu_reg(cpu, RVVM_REGID_CAUSE),
+                      rvvm_read_cpu_reg(cpu, RVVM_REGID_TVAL),
+                      rvvm_read_cpu_reg(cpu, RVVM_REGID_PC),
+                      rvvm_read_cpu_reg(cpu, RVVM_REGID_X0 + 2));
+            for (uint32_t i=0; i<32; ++i) {
+                rvvm_warn("X%d: %016lx", i, rvvm_read_cpu_reg(cpu, RVVM_REGID_X0 + i));
+            }
+
+            rvvm_addr_t pc = rvvm_read_cpu_reg(cpu, RVVM_REGID_PC);
+            rvvm_addr_t pc_al = EVAL_MAX(pc - 16, pc & ~0xFFF);
+
+            rvvm_warn("Backtrace:");
+            void **fp = NULL;
+            void** next_fp = (void*)rvvm_read_cpu_reg(cpu, RVVM_REGID_X0 + 8);
+            do {
+                rvvm_warn(" PC %lx", pc);
+                if (pc >= (size_t)elf.base && pc < (size_t)elf.base + elf.buf_size) {
+                    rvvm_warn("  @ Main binary, reloc: %lx", pc - (size_t)elf.base);
+                }
+                if (pc >= (size_t)interp.base && pc < (size_t)interp.base + interp.buf_size) {
+                    rvvm_warn("  @ Interpreter, reloc: %lx)", pc - (size_t)interp.base);
+                }
+                if (next_fp <= fp) break;
+                if (!proc_mem_readable(fp, 8)) {
+                    rvvm_warn(" * * * Frame pointer points to inaccessible memory!");
+                    break;
+                }
+                next_fp = fp[-2];
+                rvvm_warn("Next FP: %p", next_fp);
+                pc = (size_t)fp[-1];
+                fp = next_fp;
+            } while (true);
+
+            if (proc_mem_readable((void*)pc_al, 32)) {
+                rvvm_warn("Instruction bytes around PC:");
+                for (size_t i=0; i<32; ++i) {
+                    printf("%02x", *(uint8_t*)(pc_al + i));
+                }
+                printf("\n");
+                for (size_t i=0; i<32; ++i) {
+                    printf("%s", (pc_al + i == pc) ? "^ " : "  ");
+                }
+                printf("\n");
+            } else {
+                rvvm_warn(" * * * PC points to inaccessible memory!");
+            }
+
+            break;
+        }
+    }
+
+    if (thread->child_cleartid) {
+        atomic_store_uint32(thread->child_cleartid, 0);
+        rvvm_sys_futex(thread->child_cleartid, UAPI_FUTEX_WAKE, 1, 0, NULL, 0);
+    }
+
+    rvvm_free_user_thread(cpu);
+    free(thread);
+    return NULL;
+}
+
+// Jump into _start after setting up the context
+static void jump_start(void* entry, void* stack_top)
+{
+#ifdef RVVM_USER_TEST_RISCV
+    register size_t a0 __asm__("a0") = (size_t) entry;
+    register size_t sp __asm__("sp") = (size_t) stack_top;
+
+    __asm__ __volatile__(
+        "jr a0;"
+        :
+        : "r" (a0), "r" (sp)
+        :
+    );
+#elif defined(RVVM_USER_TEST_X86)
+    register size_t rax __asm__("rax") = (size_t) entry;
+    register size_t rsp __asm__("rsp") = (size_t) stack_top;
+    register size_t rdx __asm__("rdx") = (size_t) &exit; // Why do we even need to pass this?
+
+    __asm__ __volatile__(
+        "jmp *%0;"
+        :
+        : "r" (rax), "r" (rsp), "r" (rdx)
+        :
+    );
+#else
+    userland = rvvm_create_userland(true);
+    rvvm_user_thread_t* thread = safe_new_obj(rvvm_user_thread_t);
+    thread->cpu = rvvm_create_user_thread(userland);
+
+    rvvm_write_cpu_reg(thread->cpu, RVVM_REGID_X0 + 2, (size_t)stack_top);
+    rvvm_write_cpu_reg(thread->cpu, RVVM_REGID_PC,     (size_t)entry);
+
+    rvvm_user_thread_wrap(thread);
+
+    rvvm_free_machine(userland);
+#endif
+}
+
+// Describes the executable to be ran
+typedef struct {
+    // Self explanatory
+    size_t argc;
+    char** argv;
+    char** envp;
+
+    size_t base;         // Main ELF base address (relocation)
+    size_t entry;        // Main ELF entry point
+    size_t interp_base;  // ELF interpreter (aka linker usually) base address
+    size_t interp_entry; // ELF interpreter entry point
+    size_t phdr;         // Address of ELF PHDR section
+    size_t phnum;        // Number of PHDRs
+} exec_desc_t;
+
+/*
+ * Guest process stack setup routines
+ */
+
+static void* stack_put_mem(uint8_t* stack, const void* mem, size_t len)
+{
+    stack -= len;
+    memcpy(stack, mem, len);
+    return stack;
+}
+
+static void* stack_put_size(void* stack, uapi_size_t val)
+{
+    return stack_put_mem(stack, &val, sizeof(val));
+}
+
+static void* stack_put_str(void* stack, const char* str)
+{
+    return stack_put_mem(stack, str, rvvm_strlen(str) + 1);
+}
+
+#define UAPI_AT_NULL           0
+#define UAPI_AT_IGNORE         1
+#define UAPI_AT_EXECFD         2
+#define UAPI_AT_PHDR           3
+#define UAPI_AT_PHENT          4
+#define UAPI_AT_PHNUM          5
+#define UAPI_AT_PAGESZ         6
+#define UAPI_AT_BASE           7
+#define UAPI_AT_FLAGS          8
+#define UAPI_AT_ENTRY          9
+#define UAPI_AT_NOTELF        10
+#define UAPI_AT_UID           11
+#define UAPI_AT_EUID          12
+#define UAPI_AT_GID           13
+#define UAPI_AT_EGID          14
+#define UAPI_AT_PLATFORM      15
+#define UAPI_AT_HWCAP         16
+#define UAPI_AT_CLKTCK        17
+#define UAPI_AT_SECURE        23
+#define UAPI_AT_BASE_PLATFORM 24
+#define UAPI_AT_RANDOM        25
+#define UAPI_AT_EXECFN        31
+#define UAPI_AT_SYSINFO_EHDR  33 // vDSO location; RISC-V specific!
+
+static char* rvvm_user_init_stack(void* stack, exec_desc_t* desc)
+{
+    /*
+     * Stack layout (upside down):
+     * 1. argc (guest size_t)
+     * 2. string pointers: argv, 0, envp, 0
+     * 3. auxv
+     * 4. padding
+     * 5. random bytes (16)
+     * 6. string data: argv, envp
+     * 7. string data: execfn
+     * 8. null (guest size_t)
+     */
+
+    // 8. null
+    stack = stack_put_size(stack, 0);
+
+    // 7. string data: execfn
+    stack = stack_put_str(stack, desc->argv[0]);
+    char* execfn = stack;
+
+    // 6. string data: argv, envp
+    size_t envc = 0;
+    while (desc->envp[envc]) envc++;
+
+    size_t string_num = desc->argc + envc + 2;
+    uapi_size_t* string_ptrs = safe_new_arr(uapi_size_t, string_num);
+
+    for (size_t i = envc; i--;) {
+        stack = stack_put_str(stack, desc->envp[i]);
+        string_ptrs[desc->argc + 1 + i] = (size_t)stack;
+    }
+
+    for (size_t i = desc->argc; i--;) {
+        stack = stack_put_str(stack, desc->argv[i]);
+        string_ptrs[i] = (size_t)stack;
+    }
+
+    // 5. random bytes
+    char rng_buf[16] = {0};
+    rvvm_randombytes(rng_buf, sizeof(rng_buf));
+    stack = stack_put_mem(stack, rng_buf, sizeof(rng_buf));
+    char* random_bytes = stack;
+
+    // 4. align to 16 bytes
+    stack = (char*)align_size_down((size_t)stack, 16);
+
+    // 3. auxv, then null
+    uapi_size_t auxv[] = {
+        // TODO: UAPI_AT_EXECFD
+        UAPI_AT_PHDR,          desc->phdr,
+        UAPI_AT_PHENT,         56,
+        UAPI_AT_PHNUM,         desc->phnum,
+        UAPI_AT_PAGESZ,        0x1000,
+        UAPI_AT_BASE,          desc->interp_base,
+        UAPI_AT_FLAGS,         0,
+        UAPI_AT_ENTRY,         desc->entry,
+        UAPI_AT_UID,           getuid(),
+        UAPI_AT_EUID,          getuid(),
+        UAPI_AT_GID,           getgid(),
+        UAPI_AT_EGID,          getgid(),
+        UAPI_AT_PLATFORM,      0,
+        UAPI_AT_HWCAP,         0x112d,
+        UAPI_AT_CLKTCK,        100,
+        UAPI_AT_SECURE,        0,
+        UAPI_AT_BASE_PLATFORM, 0,
+        UAPI_AT_RANDOM,        (size_t)random_bytes,
+        UAPI_AT_EXECFN,        (size_t)execfn,
+        UAPI_AT_NULL,
+    };
+    stack = stack_put_mem(stack, auxv, sizeof(auxv));
+
+    // 2. string pointers
+    stack = stack_put_mem(stack, string_ptrs, sizeof(uapi_size_t) * string_num);
+    free(string_ptrs);
+
+    // 1. argc
+    stack = stack_put_size(stack, desc->argc);
+
+    return stack;
+}
+
+#define STACK_SIZE 0x800000
+
+extern char** environ;
+
+/*
+static char* default_envp[] = {
+    "LANG=en_US.UTF-8",
+    "TERM=xterm-256color",
+    "DISPLAY=:0",
+    "XDG_RUNTIME_DIR=/run/user/1000",
+    NULL,
+};
+*/
+
+int rvvm_user_linux(int argc, char** argv, char** envp)
+{
+    char path_buf[UAPI_PATH_MAX] = {0};
+    stacktrace_init();
+    /*elf_desc_t elf = {
+        .base = NULL,
+    };
+    elf_desc_t interp = {
+        .base = NULL,
+    };*/
+    rvfile_t* file = rvopen(wrap_path(path_buf, argv[0]), 0);
+    bool success = file && elf_load_file(file, &elf);
+    rvclose(file);
+    if (!success) {
+        rvvm_error("Failed to load ELF %s", argv[0]);
+        return -1;
+    }
+    rvvm_info("Loaded ELF %s at base %lx, entry %lx,\n%ld PHDRs at %lx",
+              argv[0], (size_t)elf.base, elf.entry, elf.phnum, elf.phdr);
+
+    if (elf.interp_path) {
+        rvvm_info("ELF interpreter at %s", elf.interp_path);
+        file = rvopen(wrap_path(path_buf, elf.interp_path), 0);
+        success = file && elf_load_file(file, &interp);
+        rvclose(file);
+        if (!success) {
+            rvvm_error("Failed to load interpreter %s", elf.interp_path);
+            return -1;
+        }
+        rvvm_info("Loaded interpreter %s at base %lx, entry %lx,\n%ld PHDRs at %lx",
+                  elf.interp_path, (size_t)interp.base, interp.entry, interp.phnum, interp.phdr);
+    }
+
+    if (envp == NULL) {
+        envp = environ;
+    }
+
+    getcwd(path_buf, sizeof(path_buf));
+    if (!path_wrapped(path_buf)) {
+        chdir(prefix_path);
+    }
+
+    //rvvm_set_loglevel(LOG_INFO);
+
+    exec_desc_t desc = {
+        .argc = argc,
+        .argv = argv,
+        .envp = envp,
+        .base = (size_t)elf.base,
+        .entry = elf.entry,
+        .interp_base = (size_t)interp.base,
+        .interp_entry = interp.entry,
+        .phdr = elf.phdr,
+        .phnum = elf.phnum,
+    };
+
+    uint8_t* stack_buffer = safe_calloc(STACK_SIZE, 1);
+    void* stack_top = rvvm_user_init_stack(stack_buffer + STACK_SIZE, &desc);
+
+    rvvm_info("Stack top at %p", stack_top);
+
+    if (elf.interp_path) {
+        jump_start((void*)interp.entry, stack_top);
+    } else {
+        jump_start((void*)elf.entry, stack_top);
+    }
+
+    free(stack_buffer);
+    return 0;
+}
+
+#else
+
+#include "utils.h"
+
+int rvvm_user_linux(int argc, char** argv, char** envp)
+{
+    UNUSED(argc); UNUSED(argv); UNUSED(envp);
+    rvvm_warn("Userland emulation not available, define RVVM_USER_TEST");
+    return -1;
+}
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/rvvm_user.h b/app/src/main/java/libengine/RVVM/src/rvvm_user.h
new file mode 100644
index 00000000..26384e27
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/rvvm_user.h
@@ -0,0 +1,25 @@
+/*
+rvvm_user.h - RVVM Linux binary emulator
+Copyright (C) 2024  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef RVVM_USER_H
+#define RVVM_USER_H
+
+// Just call this like main(), envp may be NULL
+int rvvm_user_linux(int argc, char** argv, char** envp);
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/rvvmlib.h b/app/src/main/java/libengine/RVVM/src/rvvmlib.h
new file mode 100644
index 00000000..ce5f1872
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/rvvmlib.h
@@ -0,0 +1,295 @@
+/*
+rvvmlib.h - RISC-V Virtual Machine Public API
+Copyright (C) 2021  LekKit <github.com/LekKit>
+                    cerg2010cerg2010 <github.com/cerg2010cerg2010>
+                    Mr0maks <mr.maks0443@gmail.com>
+                    KotB <github.com/0xCatPKG>
+                    X547 <github.com/X547>
+
+This Source Code Form is subject to the terms of the Mozilla Public
+License, v. 2.0. If a copy of the MPL was not distributed with this
+file, You can obtain one at https://mozilla.org/MPL/2.0/.
+
+Alternatively, the contents of this file may be used under the terms
+of the GNU General Public License as published by the Free Software
+Foundation, either version 3 of the License, or any later version.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef RVVMLIB_H
+#define RVVMLIB_H
+
+#ifdef __cplusplus
+#define RVVM_EXTERN_C_BEGIN extern "C" {
+#define RVVM_EXTERN_C_END }
+#else
+#define RVVM_EXTERN_C_BEGIN
+#define RVVM_EXTERN_C_END
+#endif
+
+RVVM_EXTERN_C_BEGIN
+
+#include <stdint.h>
+#include <stddef.h>
+#include <stdbool.h>
+
+#if defined(_WIN32) && defined(RVVMLIB_SHARED)
+#define PUBLIC __declspec(dllimport)
+#elif defined(_WIN32) && defined(USE_LIB)
+#define PUBLIC __declspec(dllexport)
+#elif __GNUC__ >= 4 && (defined(RVVMLIB_SHARED) || defined(USE_LIB))
+#define PUBLIC __attribute__((visibility("default")))
+#else
+// It's a static lib or rvvm-cli
+#define PUBLIC
+#endif
+
+#ifndef RVVM_VERSION
+//! Version string
+#define RVVM_VERSION "0.7-git"
+#endif
+
+//! Increments on each API/ABI breakage
+#define RVVM_ABI_VERSION 7
+
+//! Default memory base address
+#define RVVM_DEFAULT_MEMBASE 0x80000000
+
+/*
+ * Configurable machine options
+ */
+
+#define RVVM_OPT_NONE           0
+#define RVVM_OPT_JIT            1 //!< Enable JIT
+#define RVVM_OPT_JIT_CACHE      2 //!< Amount of per-core JIT cache (In bytes)
+#define RVVM_OPT_JIT_HARVARD    3 //!< No dirty code tracking, explicit ifence, slower
+#define RVVM_OPT_VERBOSITY      4 //!< Verbosity level of internal logic
+#define RVVM_OPT_HW_IMITATE     5 //!< Imitate traits or identity of physical hardware
+#define RVVM_OPT_MAX_CPU_CENT   6 //!< Max CPU load % per guest/host CPUs
+#define RVVM_OPT_RESET_PC       7 //!< Physical jump address at reset, defaults to mem_base
+#define RVVM_OPT_DTB_ADDR       8 //!< Pass DTB address if non-zero, omits FDT generation
+#define RVVM_MAX_OPTS           9
+
+/*
+ * Readonly or special machine options
+ */
+
+#define RVVM_OPT_MEM_BASE       0x80000001U //!< Physical RAM base address
+#define RVVM_OPT_MEM_SIZE       0x80000002U //!< Physical RAM size
+#define RVVM_OPT_HART_COUNT     0x80000003U //!< Amount of harts
+
+//! Physical memory address or similar opaque type
+typedef uint64_t rvvm_addr_t;
+
+//! Machine handle
+typedef struct rvvm_machine_t rvvm_machine_t;
+
+//! MMIO region handle
+typedef struct rvvm_mmio_dev_t rvvm_mmio_dev_t;
+
+//! FDT node for Device Tree generation
+struct fdt_node;
+
+typedef struct plic    plic_ctx_t;
+typedef struct pci_bus pci_bus_t;
+typedef struct i2c_bus i2c_bus_t;
+
+//! MMIO device-type specific information and handlers
+typedef struct {
+    //! Called to free device state (LIFO order), dev->data is simply freed if this is NULL
+    void (*remove)(rvvm_mmio_dev_t* dev);
+
+    //! Called periodically from event thread
+    void (*update)(rvvm_mmio_dev_t* dev);
+
+    //! Called on machine reset
+    void (*reset)(rvvm_mmio_dev_t* dev);
+
+    /*
+     * TODO
+     * void (*suspend)(rvvm_mmio_dev_t* dev, rvvm_state_t* state);
+     * void (*resume)(rvvm_mmio_dev_t* dev, rvvm_state_t* state);
+     */
+
+    const char* name; //!< Human-readable device name
+} rvvm_mmio_type_t;
+
+//! MMIO read/write handler, offset is always aligned to operation size
+typedef bool (*rvvm_mmio_handler_t)(rvvm_mmio_dev_t* dev, void* dest, size_t offset, uint8_t size);
+
+//! Dummy MMIO read/write: Reads zeros, ignores writes, never faults
+PUBLIC bool rvvm_mmio_none(rvvm_mmio_dev_t* dev, void* dest, size_t offset, uint8_t size);
+
+//! MMIO region description
+struct rvvm_mmio_dev_t {
+    rvvm_addr_t addr;        //!< MMIO region address in machine physical memory
+    size_t      size;        //!< MMIO region size, zero means a device placeholder
+    void*       data;        //!< Device-specific data pointer, freed on removal if type->remove is NULL
+    void*       mapping;     //!< Directly mapped host memory region, read/write called on dirtying if non-NULL
+    rvvm_machine_t* machine; //!< Owner machine handle
+
+    //! Device class specific operations & info, may be NULL
+    const rvvm_mmio_type_t* type;
+
+    //! Called on MMIO region read if non-NULL
+    rvvm_mmio_handler_t read;
+
+    //! Called on MMIO region write if non-NULL
+    rvvm_mmio_handler_t write;
+
+    uint8_t min_op_size; //!< Minimum MMIO operation size allowed
+    uint8_t max_op_size; //!< Maximum MMIO operation size allowed
+};
+
+/*
+ * Machine API
+ */
+
+//! \brief Creates a new virtual machine
+//! \param mem_base   Memory base address, usually RVVM_DEFAULT_MEMBASE
+//! \param mem_size   Amount of memory (in bytes), should be page-aligned
+//! \param hart_count Amount of HARTs (cores)
+//! \param rv64       Enables 64-bit RISC-V, otherwise 32-bit machine is created
+//! \return Valid machine handle, or NULL on failure
+PUBLIC rvvm_machine_t* rvvm_create_machine(rvvm_addr_t mem_base, size_t mem_size, size_t hart_count, bool rv64);
+
+//! \brief  Writes data to machine physical memory
+PUBLIC bool rvvm_write_ram(rvvm_machine_t* machine, rvvm_addr_t dest, const void* src, size_t size);
+
+//! \brief  Reads data from machine physical memory
+PUBLIC bool rvvm_read_ram(rvvm_machine_t* machine, void* dest, rvvm_addr_t src, size_t size);
+
+//! \brief  Directly access machine physical memory (DMA)
+//! \return Pointer to machine DMA region, or NULL on failure
+PUBLIC void* rvvm_get_dma_ptr(rvvm_machine_t* machine, rvvm_addr_t addr, size_t size);
+
+/*
+ * Get/Set default PLIC, PCI bus for this machine
+ * Newly created ones are selected automatically
+ */
+PUBLIC plic_ctx_t* rvvm_get_plic(rvvm_machine_t* machine);
+PUBLIC void        rvvm_set_plic(rvvm_machine_t* machine, plic_ctx_t* plic);
+PUBLIC pci_bus_t*  rvvm_get_pci_bus(rvvm_machine_t* machine);
+PUBLIC void        rvvm_set_pci_bus(rvvm_machine_t* machine, pci_bus_t* pci_bus);
+PUBLIC i2c_bus_t*  rvvm_get_i2c_bus(rvvm_machine_t* machine);
+PUBLIC void        rvvm_set_i2c_bus(rvvm_machine_t* machine, i2c_bus_t* i2c_bus);
+
+//! \brief Get root FDT node for FDT generation
+PUBLIC struct fdt_node* rvvm_get_fdt_root(rvvm_machine_t* machine);
+
+//! \brief Get /soc FDT node for FDT generation
+PUBLIC struct fdt_node* rvvm_get_fdt_soc(rvvm_machine_t* machine);
+
+//! \brief Set a kernel cmdline for a manually loaded kernel
+PUBLIC void rvvm_set_cmdline(rvvm_machine_t* machine, const char* str);
+
+//! \brief Append to the kernel cmdline for a manually loaded kernel
+PUBLIC void rvvm_append_cmdline(rvvm_machine_t* machine, const char* str);
+
+//! \brief Load M-mode firmware (bootrom), which is executed from RAM base on reset
+PUBLIC bool rvvm_load_bootrom(rvvm_machine_t* machine, const char* path);
+
+//! \brief Load S-mode payload (kernel), which is usually the next stage after OpenSBI
+PUBLIC bool rvvm_load_kernel(rvvm_machine_t* machine, const char* path);
+
+//! \brief Load a custom Device Tree blob, which is passed to guest at reset.
+PUBLIC bool rvvm_load_dtb(rvvm_machine_t* machine, const char* path);
+
+//! \brief Dump generated Device Tree to a file
+PUBLIC bool rvvm_dump_dtb(rvvm_machine_t* machine, const char* path);
+
+//! \brief Get machine option value
+PUBLIC rvvm_addr_t rvvm_get_opt(rvvm_machine_t* machine, uint32_t opt);
+
+//! \brief Set machine option
+PUBLIC bool rvvm_set_opt(rvvm_machine_t* machine, uint32_t opt, rvvm_addr_t val);
+
+//! \brief  Powers up or resumes a paused machine
+//! \return Machine start success, false if it was already running
+PUBLIC bool rvvm_start_machine(rvvm_machine_t* machine);
+
+//! \brief  Pauses the machine, stops the vCPUs
+//! \return Machine pause success, false if it wasn't running
+PUBLIC bool rvvm_pause_machine(rvvm_machine_t* machine);
+
+//! \brief  Reset the machine (Continues running if it was powered)
+PUBLIC void rvvm_reset_machine(rvvm_machine_t* machine, bool reset);
+
+//! \brief  Returns true if the machine is running and not paused
+PUBLIC bool rvvm_machine_running(rvvm_machine_t* machine);
+
+//! \brief  Returns true if the machine is powered on (Even when it's paused)
+PUBLIC bool rvvm_machine_powered(rvvm_machine_t* machine);
+
+//! \brief   Complete cleanup (Frees memory, attached devices, other structures)
+//! \warning After return, none of the handles previously attached to this machine are valid
+PUBLIC void rvvm_free_machine(rvvm_machine_t* machine);
+
+//! \brief  Get usable MMIO zone
+//! \return Usable region in physical memory, which is equal to addr if possible
+PUBLIC rvvm_addr_t rvvm_mmio_zone_auto(rvvm_machine_t* machine, rvvm_addr_t addr, size_t size);
+
+//! \brief   Attach MMIO device to the machine by it's description, free it's state on failure
+//! \param   mmio MMIO region description, doesn't need to be kept
+//! \return  Valid MMIO region handle, or NULL on failure
+//! \warning Dereferencing rvvm_mmio_dev_t* is only safe when machine is paused/powered off
+PUBLIC rvvm_mmio_dev_t* rvvm_attach_mmio(rvvm_machine_t* machine, const rvvm_mmio_dev_t* mmio_desc);
+
+//! \brief Detach MMIO device from the owning machine, free it's state
+PUBLIC void rvvm_remove_mmio(rvvm_mmio_dev_t* mmio_dev);
+
+//! \brief Clean up MMIO description state without ever attaching it to any machine
+PUBLIC void rvvm_cleanup_mmio_desc(const rvvm_mmio_dev_t* mmio_desc);
+
+//! \brief Run the event loop in the calling thread, returns when any machine stops
+PUBLIC void rvvm_run_eventloop(void);
+
+/*
+ * Userland Emulation API (WIP)
+ */
+
+//! Thread handle
+typedef struct rvvm_hart_t rvvm_hart_t;
+
+//! Base X0 register index
+#define RVVM_REGID_X0    0
+
+//! Base F0 FPU register index, FPU regs are operated in binary form
+#define RVVM_REGID_F0    32
+
+//! Program counter register
+#define RVVM_REGID_PC    1024
+
+//! CSR cause register
+#define RVVM_REGID_CAUSE 1025
+
+//! CSR tval register
+#define RVVM_REGID_TVAL  1026
+
+//! \brief Create a userland process context
+PUBLIC rvvm_machine_t* rvvm_create_userland(bool rv64);
+
+//! \brief Flush instruction cache for a specified memory range
+PUBLIC void rvvm_flush_icache(rvvm_machine_t* machine, rvvm_addr_t addr, size_t size);
+
+//! \brief Create userland process thread
+PUBLIC rvvm_hart_t* rvvm_create_user_thread(rvvm_machine_t* machine);
+
+//! \brief Destroy userland process thread
+PUBLIC void rvvm_free_user_thread(rvvm_hart_t* thread);
+
+//! \brief  Run a userland thread until a trap happens.
+//! \return Returns trap cause. PC points to faulty instruction upon return.
+PUBLIC rvvm_addr_t rvvm_run_user_thread(rvvm_hart_t* thread);
+
+//! \brief Read thread context register
+PUBLIC rvvm_addr_t rvvm_read_cpu_reg(rvvm_hart_t* thread, size_t reg_id);
+
+//! \brief Write thread context register
+PUBLIC void rvvm_write_cpu_reg(rvvm_hart_t* thread, size_t reg_id, rvvm_addr_t reg);
+
+RVVM_EXTERN_C_END
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/spinlock.c b/app/src/main/java/libengine/RVVM/src/spinlock.c
new file mode 100644
index 00000000..63f5320c
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/spinlock.c
@@ -0,0 +1,112 @@
+/*
+spinlock.c - Hybrid Spinlock
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "spinlock.h"
+#include "stacktrace.h"
+#include "threading.h"
+#include "rvtimer.h"
+#include "utils.h"
+
+// Maximum allowed lock time, warns and recovers the lock upon expiration
+#define SPINLOCK_MAX_MS 5000
+
+// Attemts to claim the lock before blocking in the kernel
+#define SPINLOCK_RETRIES 60
+
+static cond_var_t* global_cond;
+
+static void spin_deinit(void)
+{
+    cond_var_t* cond = global_cond;
+    global_cond = NULL;
+    // Make sure no use-after-free happens on running threads
+    atomic_fence();
+    condvar_free(cond);
+}
+
+static void spin_cond_init(void)
+{
+    DO_ONCE ({
+        global_cond = condvar_create();
+        call_at_deinit(spin_deinit);
+    });
+}
+
+static void spin_lock_debug_report(spinlock_t* lock)
+{
+#ifdef USE_SPINLOCK_DEBUG
+    rvvm_warn("The lock was previously held at %s", lock->location);
+#else
+    UNUSED(lock);
+#endif
+#ifdef RVVM_VERSION
+    rvvm_warn("Version: RVVM v"RVVM_VERSION);
+#endif
+    stacktrace_print();
+}
+
+slow_path void spin_lock_wait(spinlock_t* lock, const char* location)
+{
+    for (size_t i=0; i<SPINLOCK_RETRIES; ++i) {
+        // Read lock flag until there's any chance to grab it
+        // Improves performance due to cacheline bouncing elimination
+        if (atomic_load_uint32_ex(&lock->flag, ATOMIC_ACQUIRE) == 0) {
+            if (spin_try_lock_real(lock, location)) return;
+        }
+    }
+
+    spin_cond_init();
+
+    rvtimer_t timer = {0};
+    rvtimer_init(&timer, 1000);
+    do {
+        uint32_t flag = atomic_load_uint32_ex(&lock->flag, ATOMIC_ACQUIRE);
+        if (flag == 0 && spin_try_lock_real(lock, location)) {
+            // Succesfully grabbed the lock
+            return;
+        }
+        // Someone else grabbed the lock, indicate that we are still waiting
+        if (flag != 2 && !atomic_cas_uint32(&lock->flag, 1, 2)) {
+            // Failed to indicate lock as waiting, retry grabbing
+            continue;
+        }
+        // Wait upon wakeup from lock owner
+        bool woken = condvar_wait(global_cond, 10);
+        if (woken || flag != 2) {
+            // Reset deadlock timer upon noticing any forward progress
+            rvtimer_init(&timer, 1000);
+        }
+    } while (location == NULL || rvtimer_get(&timer) < SPINLOCK_MAX_MS);
+
+    rvvm_warn("Possible deadlock at %s", location);
+
+    spin_lock_debug_report(lock);
+
+    rvvm_warn("Attempting to recover execution...\n * * * * * * *\n");
+}
+
+slow_path void spin_lock_wake(spinlock_t* lock, uint32_t prev)
+{
+    if (prev) {
+        spin_cond_init();
+        condvar_wake_all(global_cond);
+    } else {
+        rvvm_warn("Unlock of a non-locked lock!");
+        spin_lock_debug_report(lock);
+    }
+}
diff --git a/app/src/main/java/libengine/RVVM/src/spinlock.h b/app/src/main/java/libengine/RVVM/src/spinlock.h
new file mode 100644
index 00000000..0967ff5f
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/spinlock.h
@@ -0,0 +1,96 @@
+/*
+spinlock.h - Hybrid Spinlock
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef RVVM_SPINLOCK_H
+#define RVVM_SPINLOCK_H
+
+#include <stddef.h>
+#include "atomics.h"
+
+typedef struct {
+    uint32_t flag;
+#ifdef USE_SPINLOCK_DEBUG
+    const char* location;
+#endif
+} spinlock_t;
+
+// Internal locking operations
+slow_path void spin_lock_wait(spinlock_t* lock, const char* location);
+slow_path void spin_lock_wake(spinlock_t* lock, uint32_t prev);
+
+// Static initialization
+#define SPINLOCK_INIT {0}
+
+// Initialize a lock
+static inline void spin_init(spinlock_t* lock)
+{
+    atomic_store_uint32(&lock->flag, 0);
+#ifdef USE_SPINLOCK_DEBUG
+    lock->location = NULL;
+#endif
+}
+
+// Try to claim the lock, returns true on success
+static forceinline bool spin_try_lock_real(spinlock_t* lock, const char* location)
+{
+    bool ret = atomic_cas_uint32_ex(&lock->flag, 0, 1, false, ATOMIC_ACQUIRE, ATOMIC_ACQUIRE);
+#ifdef USE_SPINLOCK_DEBUG
+    if (likely(ret)) lock->location = location;
+#else
+    UNUSED(location);
+#endif
+    return ret;
+}
+
+// Perform locking on small critical section
+// Reports a deadlock upon waiting for too long
+static forceinline void spin_lock_real(spinlock_t* lock, const char* location)
+{
+    if (unlikely(!spin_try_lock_real(lock, location))) {
+        spin_lock_wait(lock, location);
+    }
+}
+
+// Perform locking around heavy operation, wait indefinitely
+static forceinline void spin_lock_slow_real(spinlock_t* lock, const char* location)
+{
+    if (unlikely(!spin_try_lock_real(lock, location))) {
+        spin_lock_wait(lock, NULL);
+    }
+}
+
+#ifdef USE_SPINLOCK_DEBUG
+#define spin_try_lock(lock) spin_try_lock_real(lock, SOURCE_LINE)
+#define spin_lock(lock) spin_lock_real(lock, SOURCE_LINE)
+#define spin_lock_slow(lock) spin_lock_slow_real(lock, SOURCE_LINE)
+#else
+#define spin_try_lock(lock) spin_try_lock_real(lock, NULL)
+#define spin_lock(lock) spin_lock_real(lock, NULL)
+#define spin_lock_slow(lock) spin_lock_slow_real(lock, NULL)
+#endif
+
+// Release the lock
+static forceinline void spin_unlock(spinlock_t* lock)
+{
+    uint32_t prev = atomic_swap_uint32_ex(&lock->flag, 0, ATOMIC_RELEASE);
+    if (unlikely(prev != 1)) {
+        spin_lock_wake(lock, prev);
+    }
+}
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/stacktrace.c b/app/src/main/java/libengine/RVVM/src/stacktrace.c
new file mode 100644
index 00000000..8845f066
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/stacktrace.c
@@ -0,0 +1,149 @@
+/*
+stacktrace.c - Stacktrace (Using dynamically loaded libbacktrace)
+Copyright (C) 2024  LekKit <github.com/LekKit>
+
+This Source Code Form is subject to the terms of the Mozilla Public
+License, v. 2.0. If a copy of the MPL was not distributed with this
+file, You can obtain one at https://mozilla.org/MPL/2.0/.
+
+Alternatively, the contents of this file may be used under the terms
+of the GNU General Public License as published by the Free Software
+Foundation, either version 3 of the License, or any later version.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "stacktrace.h"
+
+#include <stddef.h>
+#include <stdint.h>
+#include <stdio.h>
+
+#if (defined(__unix__) || defined(__APPLE__) || defined(__MINGW32__)) \
+ && !defined(NO_STACKTRACE) && !defined(UNDER_CE) && !defined(__SANITIZE_ADDRESS__)
+#define SIGNAL_IMPL
+#include <stdlib.h>
+#include <signal.h>
+#ifndef SIGBUS
+#define SIGBUS 10
+#endif
+#endif
+
+// RVVM internal headers come after system headers because of safe_free()
+#include "compiler.h"
+#include "utils.h"
+#include "dlib.h"
+
+/*
+ * libbacktrace boilerplace
+ */
+
+struct backtrace_state;
+
+typedef void (*backtrace_error_callback)(void* data, const char* msg, int errnum);
+typedef int (*backtrace_full_callback)(void* data, uintptr_t pc, const char* filename, int lineno, const char* function);
+
+static struct backtrace_state* (*backtrace_create_state)(const char* filename, int threaded,
+                                                         backtrace_error_callback error_callback, void *data) = NULL;
+static int (*backtrace_full)(struct backtrace_state *state, int skip, backtrace_full_callback callback,
+                             backtrace_error_callback error_callback, void *data) = NULL;
+static void (*backtrace_print)(struct backtrace_state *state, int skip, FILE* file) = NULL;
+
+static struct backtrace_state* bt_state = NULL;
+
+static void backtrace_dummy_error(void* data, const char* msg, int errnum)
+{
+    UNUSED(data); UNUSED(msg); UNUSED(errnum);
+}
+
+static int backtrace_dummy_callback(void* data, uintptr_t pc, const char* filename, int lineno, const char* function)
+{
+    UNUSED(data); UNUSED(pc); UNUSED(filename); UNUSED(lineno); UNUSED(function);
+    return 0;
+}
+
+/*
+ * Fatal signal stacktraces
+ */
+
+#ifdef SIGNAL_IMPL
+
+static void signal_handler(int sig)
+{
+    switch (sig) {
+        case SIGSEGV:
+            rvvm_warn("Fatal signal: Segmentation fault!");
+            break;
+        case SIGBUS:
+            rvvm_warn("Fatal signal: Bus fault - Address is non-canonic or misaligned!");
+            break;
+        case SIGILL:
+            rvvm_warn("Fatal signal: Illegal instruction!");
+            break;
+        case SIGFPE:
+            rvvm_warn("Fatal signal: Division by zero!");
+            break;
+        default:
+            rvvm_warn("Fatal signal %d", sig);
+            break;
+    }
+    rvvm_warn("Stacktrace:");
+    stacktrace_print();
+    _Exit(-sig);
+}
+
+static void set_signal_handler(int sig)
+{
+    void* prev = signal(sig, signal_handler);
+    if (prev != NULL && prev != (void*)SIG_IGN) {
+        // Signal already used
+        signal(sig, prev);
+    }
+}
+
+#endif
+
+static void backtrace_init_once(void)
+{
+    if (rvvm_has_arg("no_stacktrace")) {
+        return;
+    }
+
+    dlib_ctx_t* libbt = dlib_open("backtrace", DLIB_NAME_PROBE);
+
+    backtrace_create_state = dlib_resolve(libbt, "backtrace_create_state");
+    backtrace_full = dlib_resolve(libbt, "backtrace_full");
+    backtrace_print = dlib_resolve(libbt, "backtrace_print");
+
+    dlib_close(libbt);
+
+    if (backtrace_create_state) {
+        bt_state = backtrace_create_state(NULL, true, backtrace_dummy_error, NULL);
+    }
+    if (backtrace_full && bt_state) {
+        // Preload backtracing data, isolation is enabled later on
+        backtrace_full(bt_state, 0, backtrace_dummy_callback, backtrace_dummy_error, NULL);
+
+#ifdef SIGNAL_IMPL
+        set_signal_handler(SIGSEGV);
+        set_signal_handler(SIGBUS);
+        set_signal_handler(SIGILL);
+        set_signal_handler(SIGFPE);
+#endif
+    }
+}
+
+void stacktrace_init(void)
+{
+    DO_ONCE(backtrace_init_once());
+}
+
+void stacktrace_print(void)
+{
+    stacktrace_init();
+    if (backtrace_print && bt_state) {
+        backtrace_print(bt_state, 0, stderr);
+
+    }
+}
diff --git a/app/src/main/java/libengine/RVVM/src/stacktrace.h b/app/src/main/java/libengine/RVVM/src/stacktrace.h
new file mode 100644
index 00000000..bf078988
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/stacktrace.h
@@ -0,0 +1,24 @@
+/*
+stacktrace.h - Stacktrace
+Copyright (C) 2024  LekKit <github.com/LekKit>
+
+This Source Code Form is subject to the terms of the Mozilla Public
+License, v. 2.0. If a copy of the MPL was not distributed with this
+file, You can obtain one at https://mozilla.org/MPL/2.0/.
+
+Alternatively, the contents of this file may be used under the terms
+of the GNU General Public License as published by the Free Software
+Foundation, either version 3 of the License, or any later version.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef RVVM_STACKTRACE_H
+#define RVVM_STACKTRACE_H
+
+void stacktrace_init(void);
+
+void stacktrace_print(void);
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/threading.c b/app/src/main/java/libengine/RVVM/src/threading.c
new file mode 100644
index 00000000..68696e00
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/threading.c
@@ -0,0 +1,515 @@
+/*
+threading.c - Threading, Conditional variables, Task offloading
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+// Needed for pthread_condattr_setclock(),
+// pthread_cond_timedwait_relative_np() when not passing -std=gnu..
+#define _GNU_SOURCE
+#define _BSD_SOURCE
+#define _DEFAULT_SOURCE
+
+#include "threading.h"
+
+#ifdef _WIN32
+#include <windows.h>
+
+#else
+#include <pthread.h>
+#include <time.h>
+
+#if !defined(__APPLE__) && !defined(HAVE_PTHREAD_COND_TIMEDWAIT_RELATIVE)
+#if defined(CLOCK_MONOTONIC)
+#define CHOSEN_COND_CLOCK CLOCK_MONOTONIC
+#else
+#include <sys/time.h> // For gettimeofday()
+#endif
+
+static void condvar_fill_timespec(struct timespec* ts)
+{
+#ifdef CHOSEN_COND_CLOCK
+    clock_gettime(CHOSEN_COND_CLOCK, ts);
+#else
+    // Some targets lack clock_gettime(), use gettimeofday()
+    struct timeval tv = {0};
+    gettimeofday(&tv, NULL);
+    ts->tv_sec  = tv.tv_sec;
+    ts->tv_nsec = tv.tv_usec * 1000;
+#endif
+}
+
+#endif
+#endif
+
+// RVVM internal headers come after system headers because of safe_free()
+#include "atomics.h"
+#include "rvtimer.h"
+#include "utils.h"
+#include "dlib.h"
+
+#define COND_FLAG_SIGNALED 0x1
+
+struct thread_ctx {
+#ifdef _WIN32
+    HANDLE handle;
+#else
+    pthread_t pthread;
+#endif
+};
+
+struct cond_var {
+    uint32_t flag;
+    uint32_t waiters;
+#ifdef _WIN32
+    HANDLE event;
+    HANDLE timer;
+#else
+    pthread_cond_t cond;
+    pthread_mutex_t lock;
+#endif
+};
+
+#if defined(_WIN32) && !defined(HOST_64BIT)
+// Wrap our function call to hide calling convention details
+typedef struct { thread_func_t func; void* arg; } thread_win32_wrap_t;
+static __stdcall DWORD thread_win32_wrap(void* arg)
+{
+    thread_win32_wrap_t wrap = *(thread_win32_wrap_t*)arg;
+    free(arg);
+    return (DWORD)(size_t)wrap.func(wrap.arg);
+}
+#endif
+
+thread_ctx_t* thread_create_ex(thread_func_t func, void* arg, uint32_t stack_size)
+{
+    thread_ctx_t* thread = safe_new_obj(thread_ctx_t);
+#ifdef _WIN32
+#if !defined(HOST_64BIT)
+    void* entry = thread_win32_wrap;
+    thread_win32_wrap_t* wrap = safe_new_obj(thread_win32_wrap_t);
+    wrap->func = func;
+    wrap->arg = arg;
+    arg = wrap;
+#else
+    void* entry = func;
+#endif
+    thread->handle = CreateThread(NULL, stack_size, entry, arg, STACK_SIZE_PARAM_IS_A_RESERVATION, NULL);
+    if (thread->handle) return thread;
+#else
+    pthread_attr_t thread_attr = {0};
+    pthread_attr_t* pass_attr = &thread_attr;
+    if (pthread_attr_init(pass_attr)) {
+        pass_attr = NULL;
+    } else if (stack_size) {
+        pthread_attr_setstacksize(pass_attr, stack_size);
+    }
+    int ret = pthread_create(&thread->pthread, pass_attr, func, arg);
+    if (pass_attr) {
+        pthread_attr_destroy(pass_attr);
+    }
+    if (ret == 0) {
+        return thread;
+    }
+#endif
+    rvvm_warn("Failed to spawn thread!");
+    free(thread);
+    return NULL;
+}
+
+thread_ctx_t* thread_create(thread_func_t func, void* arg)
+{
+    return thread_create_ex(func, arg, 65536);
+}
+
+void* thread_join(thread_ctx_t* thread)
+{
+    void* ret = NULL;
+    if (thread == NULL) return NULL;
+#ifdef _WIN32
+    DWORD ltmp = 0;
+    WaitForSingleObject(thread->handle, INFINITE);
+    GetExitCodeThread(thread->handle, &ltmp);
+    CloseHandle(thread->handle);
+    ret = (void*)(size_t)ltmp;
+#else
+    pthread_join(thread->pthread, &ret);
+#endif
+    free(thread);
+    return ret;
+}
+
+bool thread_detach(thread_ctx_t* thread)
+{
+    bool ret = false;
+    if (thread == NULL) return false;
+#ifdef _WIN32
+    ret = CloseHandle(thread->handle);
+#else
+    ret = pthread_detach(thread->pthread) == 0;
+#endif
+    free(thread);
+    return ret;
+}
+
+cond_var_t* condvar_create(void)
+{
+    cond_var_t* cond = safe_new_obj(cond_var_t);
+#ifdef _WIN32
+#ifndef UNDER_CE
+    static HANDLE (__stdcall *create_waitable_timer)(LPSECURITY_ATTRIBUTES, LPCWSTR, DWORD, DWORD) = NULL;
+    DO_ONCE ({
+        create_waitable_timer = dlib_get_symbol("kernel32.dll", "CreateWaitableTimerExW");
+    });
+    if (create_waitable_timer) {
+        // Create a high resolution, manual reset waitable timer (Win10 1803+)
+        cond->timer = create_waitable_timer(NULL, NULL, 0x3, TIMER_ALL_ACCESS);
+    }
+#endif
+    cond->event = CreateEventW(NULL, FALSE, FALSE, NULL);
+    if (cond->event) return cond;
+#elif defined(CHOSEN_COND_CLOCK)
+    pthread_condattr_t cond_attr = {0};
+    if (pthread_condattr_init(&cond_attr) == 0
+     && pthread_condattr_setclock(&cond_attr, CHOSEN_COND_CLOCK) == 0
+     && pthread_cond_init(&cond->cond, &cond_attr)  == 0
+     && pthread_mutex_init(&cond->lock, NULL) == 0) {
+        pthread_condattr_destroy(&cond_attr);
+        return cond;
+    }
+#else
+    if (pthread_cond_init(&cond->cond, NULL)  == 0
+     && pthread_mutex_init(&cond->lock, NULL) == 0) {
+        return cond;
+    }
+#endif
+    rvvm_warn("Failed to create conditional variable!");
+    condvar_free(cond);
+    return NULL;
+}
+
+bool condvar_wait(cond_var_t* cond, uint64_t timeout_ms)
+{
+    uint64_t timeout_ns = CONDVAR_INFINITE;
+    if (timeout_ms != CONDVAR_INFINITE) timeout_ns = timeout_ms * 1000000;
+    return condvar_wait_ns(cond, timeout_ns);
+}
+
+static inline bool condvar_try_consume_signal(cond_var_t* cond)
+{
+    return (atomic_load_uint32(&cond->flag) & COND_FLAG_SIGNALED)
+        && (atomic_and_uint32(&cond->flag, ~COND_FLAG_SIGNALED) & COND_FLAG_SIGNALED);
+}
+
+bool condvar_wait_ns(cond_var_t* cond, uint64_t timeout_ns)
+{
+    bool ret = false;
+    if (!cond) return false;
+
+    // Fast-path exit on an already signaled condvar (atomic_load is cheaper than RMW)
+    if (condvar_try_consume_signal(cond)) {
+        return true;
+    }
+
+    // Mark that a thread is about to be waiting here, otherwise wake may set signal
+    // too late be consumed, but not see any waiters and so a wakeup event may be lost.
+    uint32_t waiters = atomic_add_uint32(&cond->waiters, 1);
+    UNUSED(waiters);
+
+    // Try to consume a signal again, since condvar_wake() could have been called
+    // in-between the fast-path exit and waiter marking.
+    if (condvar_try_consume_signal(cond)) {
+        atomic_sub_uint32(&cond->waiters, 1);
+        return true;
+    }
+
+    sleep_low_latency(timeout_ns < 15000000);
+
+#ifdef _WIN32
+    if (timeout_ns == CONDVAR_INFINITE) {
+        ret = WaitForSingleObject(cond->event, INFINITE) == WAIT_OBJECT_0;
+#ifndef UNDER_CE
+    } else if (timeout_ns < 15000000 && cond->timer && !waiters) {
+        // Nanosecond precision timeout using high-resolution WaitableTimer
+        LARGE_INTEGER delay = { .QuadPart = -(timeout_ns / 100ULL), };
+        HANDLE handles[2] = { cond->event, cond->timer };
+        SetWaitableTimer(handles[1], &delay, 0, NULL, NULL, false);
+        ret = WaitForMultipleObjects(2, handles, FALSE, INFINITE) == WAIT_OBJECT_0;
+#endif
+    } else {
+        // Coarse ms precision timeout
+        ret = WaitForSingleObject(cond->event, EVAL_MAX(timeout_ns / 1000000, 1)) == WAIT_OBJECT_0;
+    }
+#else
+    pthread_mutex_lock(&cond->lock);
+    if (!condvar_try_consume_signal(cond)) {
+        if (timeout_ns == CONDVAR_INFINITE) {
+            ret = pthread_cond_wait(&cond->cond, &cond->lock) == 0;
+        } else {
+#if defined(__APPLE__) || defined(HAVE_PTHREAD_COND_TIMEDWAIT_RELATIVE)
+            struct timespec ts = { .tv_sec = timeout_ns / 1000000000, .tv_nsec = timeout_ns % 1000000000, };
+            ret = pthread_cond_timedwait_relative_np(&cond->cond, &cond->lock, &ts) == 0;
+#else
+            struct timespec ts = {0};
+            condvar_fill_timespec(&ts);
+            // Properly handle timespec addition without an overflow
+            timeout_ns += ts.tv_nsec;
+            ts.tv_sec += timeout_ns / 1000000000;
+            ts.tv_nsec = timeout_ns % 1000000000;
+            ret = pthread_cond_timedwait(&cond->cond, &cond->lock, &ts) == 0;
+#endif
+        }
+    }
+    pthread_mutex_unlock(&cond->lock);
+#endif
+    if (condvar_try_consume_signal(cond)) ret = true;
+    atomic_sub_uint32(&cond->waiters, 1);
+    return ret;
+}
+
+bool condvar_wake(cond_var_t* cond)
+{
+    if (!cond) return false;
+    // Signal the condition
+    atomic_or_uint32(&cond->flag, COND_FLAG_SIGNALED);
+    // Omit syscall if there are no waiters
+    if (!condvar_waiters(cond)) return false;
+#ifdef _WIN32
+    SetEvent(cond->event);
+#else
+    pthread_mutex_lock(&cond->lock);
+    pthread_mutex_unlock(&cond->lock);
+    // We aren't required to signal under the lock, but it should be taken anyways
+    // to prevent lost wakeup between cond->flag check and waiting on pthread_cond
+    pthread_cond_signal(&cond->cond);
+#endif
+    return true;
+}
+
+bool condvar_wake_all(cond_var_t* cond)
+{
+    if (!cond) return false;
+    atomic_or_uint32(&cond->flag, COND_FLAG_SIGNALED);
+    if (!condvar_waiters(cond)) return false;
+#ifdef _WIN32
+    for (uint32_t i=condvar_waiters(cond); i--;) {
+        condvar_wake(cond);
+    }
+#else
+    pthread_mutex_lock(&cond->lock);
+    pthread_mutex_unlock(&cond->lock);
+    pthread_cond_broadcast(&cond->cond);
+#endif
+    return true;
+}
+
+uint32_t condvar_waiters(cond_var_t* cond)
+{
+    if (!cond) return 0;
+    return atomic_load_uint32(&cond->waiters);
+}
+
+void condvar_free(cond_var_t* cond)
+{
+    if (!cond) return;
+    uint32_t waiters = condvar_waiters(cond);
+    if (waiters) rvvm_warn("Destroying a condvar with %u waiters!", waiters);
+#ifdef _WIN32
+    if (cond->event) CloseHandle(cond->event);
+    if (cond->timer) CloseHandle(cond->timer);
+#else
+    pthread_cond_destroy(&cond->cond);
+    pthread_mutex_destroy(&cond->lock);
+#endif
+    free(cond);
+}
+
+// Threadpool task offloading
+
+#define WORKER_THREADS 4
+#define WORKQUEUE_SIZE 2048
+#define WORKQUEUE_MASK (WORKQUEUE_SIZE - 1)
+
+BUILD_ASSERT(!(WORKQUEUE_SIZE & WORKQUEUE_MASK));
+
+typedef struct {
+    uint32_t seq;
+    uint32_t flags;
+    thread_func_t func;
+    void* arg[THREAD_MAX_VA_ARGS];
+} task_item_t;
+
+typedef struct {
+    task_item_t tasks[WORKQUEUE_SIZE];
+    char pad0[64];
+    uint32_t head;
+    char pad1[64];
+    uint32_t tail;
+    char pad2[64];
+} work_queue_t;
+
+static uint32_t      pool_run;
+static uint32_t      pool_shut;
+static work_queue_t  pool_wq;
+static cond_var_t*   pool_cond;
+static thread_ctx_t* pool_threads[WORKER_THREADS];
+
+static void workqueue_init(work_queue_t* wq)
+{
+    for (size_t seq = 0; seq < WORKQUEUE_SIZE; ++seq) {
+        atomic_store_uint32(&wq->tasks[seq].seq, seq);
+    }
+}
+
+static bool workqueue_try_perform(work_queue_t* wq)
+{
+    uint32_t tail = atomic_load_uint32_ex(&wq->tail, ATOMIC_RELAXED);
+    while (true) {
+        task_item_t* task_ptr = &wq->tasks[tail & WORKQUEUE_MASK];
+        uint32_t seq = atomic_load_uint32_ex(&task_ptr->seq, ATOMIC_ACQUIRE);
+        int32_t diff = (int32_t)seq - (int32_t)(tail + 1);
+        if (diff == 0) {
+            // This is a filled task slot
+            if (atomic_cas_uint32_ex(&wq->tail, tail, tail + 1, true, ATOMIC_RELAXED, ATOMIC_RELAXED)) {
+                // We claimed the slot
+                task_item_t task = wq->tasks[tail & WORKQUEUE_MASK];
+
+                // Mark task slot as reusable
+                atomic_store_uint32_ex(&task_ptr->seq, tail + WORKQUEUE_MASK + 1, ATOMIC_RELEASE);
+
+                // Run the task
+                if (task.flags & 2) {
+                    ((thread_func_va_t)(void*)task.func)((void**)task.arg);
+                } else {
+                    task.func(task.arg[0]);
+                }
+                return true;
+            }
+        } else if (diff < 0) {
+            // Queue is empty
+            return false;
+        } else {
+            // Another consumer stole our task slot, reload the tail pointer
+            tail = atomic_load_uint32_ex(&wq->tail, ATOMIC_RELAXED);
+        }
+
+        // Yield this thread timeslice
+        sleep_ms(0);
+    }
+}
+
+static bool workqueue_submit(work_queue_t* wq, thread_func_t func, void** arg, unsigned arg_count, bool va)
+{
+    uint32_t head = atomic_load_uint32_ex(&wq->head, ATOMIC_RELAXED);
+    while (true) {
+        task_item_t* task_ptr = &wq->tasks[head & WORKQUEUE_MASK];
+        uint32_t seq = atomic_load_uint32_ex(&task_ptr->seq, ATOMIC_ACQUIRE);
+        int32_t diff = (int32_t)seq - (int32_t)head;
+        if (diff == 0) {
+            // This is an empty task slot
+            if (atomic_cas_uint32_ex(&wq->head, head, head + 1, true, ATOMIC_RELAXED, ATOMIC_RELAXED)) {
+                // We claimed the slot, fill it with data
+                task_ptr->func = func;
+                for (size_t i=0; i<arg_count; ++i) task_ptr->arg[i] = arg[i];
+                task_ptr->flags = (va ? 2 : 0);
+                // Mark the slot as filled
+                atomic_store_uint32_ex(&task_ptr->seq, head + 1, ATOMIC_RELEASE);
+                return true;
+            }
+        } else if (diff < 0) {
+            // Queue is full
+            return false;
+        } else {
+            // Another producer stole our task slot, reload the head pointer
+            head = atomic_load_uint32_ex(&wq->head, ATOMIC_RELAXED);
+        }
+
+        // Yield this thread timeslice
+        sleep_ms(0);
+    }
+    return false;
+}
+
+static void thread_workers_terminate(void)
+{
+    atomic_store_uint32(&pool_run, 0);
+    // Wake & shut down all threads properly
+    while (atomic_load_uint32(&pool_shut) != WORKER_THREADS) {
+        condvar_wake_all(pool_cond);
+        sleep_ms(1);
+    }
+    for (size_t i=0; i<WORKER_THREADS; ++i) {
+        thread_join(pool_threads[i]);
+        pool_threads[i] = NULL;
+    }
+    condvar_free(pool_cond);
+    pool_cond = NULL;
+}
+
+static void* threadpool_worker(void* ptr)
+{
+    while (atomic_load_uint32_ex(&pool_run, ATOMIC_RELAXED)) {
+        while (workqueue_try_perform(&pool_wq));
+        condvar_wait(pool_cond, CONDVAR_INFINITE);
+    }
+    atomic_add_uint32(&pool_shut, 1);
+    return ptr;
+}
+
+static void threadpool_init(void)
+{
+    atomic_store_uint32(&pool_shut, 0);
+    atomic_store_uint32(&pool_run, 1);
+    workqueue_init(&pool_wq);
+    pool_cond = condvar_create();
+    for (size_t i=0; i<WORKER_THREADS; ++i) {
+        pool_threads[i] = thread_create(threadpool_worker, NULL);
+    }
+    call_at_deinit(thread_workers_terminate);
+}
+
+static bool thread_queue_task(thread_func_t func, void** arg, unsigned arg_count, bool va)
+{
+    DO_ONCE(threadpool_init());
+
+    if (workqueue_submit(&pool_wq, func, arg, arg_count, va)) {
+        //if (condvar_waiters(pool_cond) == WORKER_THREADS)
+        condvar_wake(pool_cond);
+        return true;
+    }
+
+    // Still not queued!
+    // Assuming entire threadpool is busy, just do a blocking task
+    DO_ONCE(rvvm_warn("Blocking on workqueue task %p", func));
+    return false;
+}
+
+void thread_create_task(thread_func_t func, void* arg)
+{
+    if (!thread_queue_task(func, &arg, 1, false)) {
+        func(arg);
+    }
+}
+
+void thread_create_task_va(thread_func_va_t func, void** args, unsigned arg_count)
+{
+    if (arg_count == 0 || arg_count > THREAD_MAX_VA_ARGS) {
+        rvvm_warn("Invalid arg count in thread_create_task_va()!");
+        return;
+    }
+    if (!thread_queue_task((thread_func_t)(void*)func, args, arg_count, true)) {
+        func(args);
+    }
+}
diff --git a/app/src/main/java/libengine/RVVM/src/threading.h b/app/src/main/java/libengine/RVVM/src/threading.h
new file mode 100644
index 00000000..0b12b607
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/threading.h
@@ -0,0 +1,54 @@
+/*
+threading.h - Threading, Conditional variables, Task offloading
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef THREADING_H
+#define THREADING_H
+
+#include <stdint.h>
+#include <stdbool.h>
+
+typedef struct thread_ctx thread_ctx_t;
+typedef struct cond_var cond_var_t;
+
+typedef void* (*thread_func_t)(void*);
+typedef void* (*thread_func_va_t)(void**);
+
+// Threading
+thread_ctx_t* thread_create_ex(thread_func_t func, void* arg, uint32_t stack_size);
+thread_ctx_t* thread_create(thread_func_t func, void* arg);
+void*         thread_join(thread_ctx_t* handle);
+bool          thread_detach(thread_ctx_t* handle);
+
+#define CONDVAR_INFINITE ((uint64_t)-1)
+
+// Conditional variables
+cond_var_t* condvar_create(void);
+bool        condvar_wait(cond_var_t* cond, uint64_t timeout_ms);
+bool        condvar_wait_ns(cond_var_t* cond, uint64_t timeout_ns);
+bool        condvar_wake(cond_var_t* cond);
+bool        condvar_wake_all(cond_var_t* cond);
+uint32_t    condvar_waiters(cond_var_t* cond);
+void        condvar_free(cond_var_t* cond);
+
+#define THREAD_MAX_VA_ARGS 8
+
+// Execute task in threadpool
+void thread_create_task(thread_func_t func, void* arg);
+void thread_create_task_va(thread_func_va_t func, void** args, unsigned arg_count);
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/utils.c b/app/src/main/java/libengine/RVVM/src/utils.c
new file mode 100644
index 00000000..682afefe
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/utils.c
@@ -0,0 +1,440 @@
+/*
+utils.с - Util functions
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "utils.h"
+#include "rvtimer.h"
+#include "vector.h"
+#include "spinlock.h"
+#include "stacktrace.h"
+
+#include <stdarg.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+
+static int loglevel = LOG_WARN;
+
+static int argc = 0;
+static const char** argv = NULL;
+
+
+size_t rvvm_strlen(const char* string)
+{
+    size_t i = 0;
+    while (string[i]) i++;
+    return i;
+}
+
+size_t rvvm_strnlen(const char* string, size_t size)
+{
+    size_t i = 0;
+    while (i < size && string[i]) i++;
+    return i;
+}
+
+bool rvvm_strcmp(const char* s1, const char* s2)
+{
+    size_t i = 0;
+    while (s1[i] && s1[i] == s2[i]) i++;
+    return s1[i] == s2[i];
+}
+
+size_t rvvm_strlcpy(char* dst, const char* src, size_t size)
+{
+    size_t i = 0;
+    while (i + 1 < size && src[i]) {
+        dst[i] = src[i];
+        i++;
+    }
+    if (size) dst[i] = 0;
+    return i;
+}
+
+const char* rvvm_strfind(const char* string, const char* pattern)
+{
+    while (*string) {
+        const char* tmp = string;
+        const char* pat = pattern;
+        while (*tmp && *tmp == *pat) {
+            tmp++;
+            pat++;
+        }
+        if (!(*pat)) return string;
+        string++;
+    }
+    return NULL;
+}
+
+void rvvm_set_loglevel(int level)
+{
+    loglevel = level;
+}
+
+static bool log_has_colors(void)
+{
+    return getenv("TERM") != NULL;
+}
+
+static void log_print(const char* prefix, const char* fmt, va_list args)
+{
+    char buffer[256] = {0};
+    size_t pos = rvvm_strlcpy(buffer, prefix, sizeof(buffer));
+    size_t vsp_size = sizeof(buffer) - EVAL_MIN(pos + 6, sizeof(buffer));
+    if (vsp_size > 1) {
+        int tmp = vsnprintf(buffer + pos, vsp_size, fmt, args);
+        if (tmp > 0) pos += EVAL_MIN(vsp_size - 1, (size_t)tmp);
+    }
+    rvvm_strlcpy(buffer + pos, log_has_colors() ? "\033[0m\n" : "\n", sizeof(buffer) - pos);
+    fputs(buffer, stderr);
+}
+
+PRINT_FORMAT void rvvm_info(const char* str, ...)
+{
+    if (loglevel < LOG_INFO) return;
+    va_list args;
+    va_start(args, str);
+    log_print(log_has_colors() ? "\033[33;1mINFO\033[37;1m: " : "INFO: ", str, args);
+    va_end(args);
+}
+
+PRINT_FORMAT void rvvm_warn(const char* str, ...)
+{
+    if (loglevel < LOG_WARN) return;
+    va_list args;
+    va_start(args, str);
+    log_print(log_has_colors() ? "\033[31;1mWARN\033[37;1m: " : "WARN: ", str, args);
+    va_end(args);
+}
+
+PRINT_FORMAT void rvvm_error(const char* str, ...)
+{
+    if (loglevel < LOG_ERROR) return;
+    va_list args;
+    va_start(args, str);
+    log_print(log_has_colors() ? "\033[31;1mERROR\033[37;1m: " : "ERROR: ", str, args);
+    va_end(args);
+}
+
+PRINT_FORMAT void rvvm_fatal(const char* str, ...)
+{
+    va_list args;
+    va_start(args, str);
+    log_print(log_has_colors() ? "\033[31;1mFATAL\033[37;1m: " : "FATAL: ", str, args);
+    va_end(args);
+    stacktrace_print();
+    abort();
+}
+
+SAFE_MALLOC void* safe_malloc(size_t size)
+{
+    void* ret = malloc(size);
+    if (unlikely(!size)) rvvm_warn("Suspicious 0-byte allocation");
+    if (unlikely(ret == NULL)) {
+        rvvm_fatal("Out of memory!");
+    }
+    return ret;
+}
+
+SAFE_CALLOC void* safe_calloc(size_t size, size_t n)
+{
+    void* ret = calloc(size, n);
+    if (unlikely(!size || !n)) rvvm_warn("Suspicious 0-byte allocation");
+    if (unlikely(ret == NULL)) {
+        rvvm_fatal("Out of memory!");
+    }
+    // Fence zeroing of allocated memory
+    atomic_fence_ex(ATOMIC_RELEASE);
+    return ret;
+}
+
+SAFE_REALLOC void* safe_realloc(void* ptr, size_t size)
+{
+    void* ret = realloc(ptr, size);
+    if (unlikely(!size)) rvvm_warn("Suspicious 0-byte allocation");
+    if (unlikely(ret == NULL)) {
+        rvvm_fatal("Out of memory!");
+    }
+    return ret;
+}
+
+NOINLINE void do_once_finalize(uint32_t* ticket)
+{
+    while (atomic_load_uint32_ex(ticket, ATOMIC_ACQUIRE) != 2) {
+        sleep_ms(1);
+    }
+}
+
+typedef void (*deinit_func_t)(void);
+static vector_t(deinit_func_t) deinit_funcs = {0};
+static spinlock_t deinit_lock = {0};
+static bool deinit_happened = false;
+
+void call_at_deinit(void (*function)(void))
+{
+    bool call_func = false;
+
+    while (!spin_try_lock(&deinit_lock)) sleep_ms(1);
+    if (!deinit_happened) {
+        vector_push_back(deinit_funcs, function);
+    } else {
+        call_func = true;
+    }
+    spin_unlock(&deinit_lock);
+
+    if (call_func) {
+        function();
+    }
+}
+
+static deinit_func_t dequeue_func(void)
+{
+    deinit_func_t ret = NULL;
+
+    while (!spin_try_lock(&deinit_lock)) sleep_ms(1);
+    deinit_happened = true;
+    if (vector_size(deinit_funcs) == 0) {
+        vector_free(deinit_funcs);
+    } else {
+        size_t end = vector_size(deinit_funcs) - 1;
+        ret = vector_at(deinit_funcs, end);
+        vector_erase(deinit_funcs, end);
+    }
+    spin_unlock(&deinit_lock);
+    return ret;
+}
+
+GNU_DESTRUCTOR static void full_deinit(void)
+{
+    rvvm_info("Fully deinitializing librvvm");
+    while (true) {
+        deinit_func_t func = dequeue_func();
+        if (func) {
+            func();
+        } else {
+            break;
+        }
+    }
+}
+
+static inline char digit_symbol(uint32_t val)
+{
+    if (val < 10) return '0' + val;
+    if (val < 36) return 'a' + val - 10;
+    return '?';
+}
+
+static inline uint32_t digit_value(char digit)
+{
+    if (digit >= '0' && digit <= '9') return digit - '0';
+    if (digit >= 'A' && digit <= 'Z') return digit - 'A' + 10;
+    if (digit >= 'a' && digit <= 'z') return digit - 'a' + 10;
+    return -1;
+}
+
+size_t uint_to_str_base(char* str, size_t size, uint64_t val, uint8_t base)
+{
+    size_t len = 0;
+    if (base >= 2 && base <= 36) do {
+        if (len + 1 >= size) {
+            len = 0;
+            break;
+        }
+        str[len++] = digit_symbol(val % base);
+        val /= base;
+    } while (val);
+    // Reverse the string
+    for (size_t i=0; i<len / 2; ++i) {
+        char tmp = str[i];
+        str[i] = str[len - i - 1];
+        str[len - i - 1] = tmp;
+    }
+    if (size) str[len] = 0;
+    return len;
+}
+
+uint64_t str_to_uint_base(const char* str, size_t* len, uint8_t base)
+{
+    uint64_t val = 0;
+    size_t size = 0;
+    if (base == 0) {
+        base = 10;
+        if (str[0] == '0') {
+            base = 8; // Octal literal
+            if (str[1] == 'o' || str[1] == 'O') {
+                size = 2;
+            } else if (str[1] == 'x' || str[1] == 'X') {
+                base = 16; // Hex literal
+                size = 2;
+            } else if (str[1] == 'b' || str[1] == 'B') {
+                base = 2; // Binary literal
+                size = 2;
+            }
+        }
+    }
+    if (len) len[0] = 0;
+    if (base >= 2 && base <= 36) while (digit_value(str[size]) < base) {
+        val *= base;
+        val += digit_value(str[size++]);
+        if (len) len[0] = size;
+    }
+    return val;
+}
+
+size_t int_to_str_base(char* str, size_t size, int64_t val, uint8_t base)
+{
+    size_t off = (val < 0 && size) ? 1 : 0;
+    size_t len = uint_to_str_base(str + off, size - off, off ? -val : val, base);
+    if (!len) {
+        if (size) str[0] = 0;
+    } else if (off) {
+        str[0] = '-';
+        len += off;
+    }
+    return len;
+}
+
+int64_t str_to_int_base(const char* str, size_t* len, uint8_t base)
+{
+    bool neg = (str[0] == '-');
+    uint64_t val = str_to_uint_base(str + neg, len, base);
+    if (neg && len && len[0]) len[0]++;
+    return neg ? -val : val;
+}
+
+size_t int_to_str_dec(char* str, size_t size, int64_t val)
+{
+    return int_to_str_base(str, size, val, 10);
+}
+
+int64_t str_to_int_dec(const char* str)
+{
+    return str_to_int_base(str, NULL, 0);
+}
+
+void rvvm_set_args(int new_argc, const char** new_argv)
+{
+    argc = new_argc;
+    argv = new_argv;
+
+    if (rvvm_has_arg("v") || rvvm_has_arg("verbose")) {
+        rvvm_set_loglevel(LOG_INFO);
+    }
+}
+
+bool rvvm_has_arg(const char* arg)
+{
+    size_t offset, j;
+    for (int i = 0; i < argc; i++) {
+        if (argv[i] == NULL) return false;
+        if (argv[i][0] == '-') {
+            offset = (argv[i][1] == '-') ? 2 : 1;
+            j = 0;
+            while (arg[j]
+               && argv[i][j + offset]
+               && argv[i][j + offset] != '='
+               && argv[i][j + offset] == arg[j]) j++;
+            if (arg[j] == 0 && (argv[i][j + offset] == 0 || argv[i][j + offset] == '=')) {
+                return true;
+            }
+        }
+    }
+    return false;
+}
+
+const char* rvvm_getarg(const char* arg)
+{
+    size_t offset, j;
+    for (int i = 0; i < argc; i++) {
+        if (argv[i] == NULL) return NULL;
+        if (argv[i][0] == '-') {
+            offset = (argv[i][1] == '-') ? 2 : 1;
+            j = 0;
+            while (arg[j]
+                && argv[i][j + offset]
+                && argv[i][j + offset] != '='
+                && argv[i][j + offset] == arg[j]) j++;
+            if (arg[j] == 0 && (argv[i][j + offset] == 0 || argv[i][j + offset] == '=')) {
+                if (argv[i + 1] != NULL && argv[i + 1][0] != '-') {
+                    return argv[i + 1];
+                }
+            }
+            if (argv[i][j + offset] == '=') {
+                offset += j+1;
+                return argv[i]+offset;
+            }
+        }
+    }
+    return NULL;
+}
+
+bool rvvm_getarg_bool(const char* arg)
+{
+    const char* argvalue = rvvm_getarg(arg);
+    if (argvalue == NULL) return false;
+    if (rvvm_strcmp("on", argvalue)
+     || rvvm_strcmp("true", argvalue)
+     || rvvm_strcmp("y", argvalue)
+     || rvvm_strcmp("1", argvalue)) return true;
+    return false;
+}
+
+int rvvm_getarg_int(const char* arg)
+{
+    const char* argvalue = rvvm_getarg(arg);
+    if (argvalue == NULL) return 0;
+    return str_to_int_dec(argvalue);
+}
+
+uint64_t rvvm_getarg_size(const char* arg)
+{
+    const char* argvalue = rvvm_getarg(arg);
+    if (argvalue == NULL) return 0;
+    return ((uint64_t)str_to_int_dec(argvalue)) << mem_suffix_shift(argvalue[rvvm_strlen(argvalue)-1]);
+}
+
+void rvvm_randombytes(void* buffer, size_t size)
+{
+    // Xorshift RNG seeded by precise timer
+    static uint64_t seed = 0;
+    uint8_t* bytes = buffer;
+    size_t size_rem = size & 0x7;
+    size -= size_rem;
+    seed += rvtimer_clocksource(1000000000ULL);
+    for (size_t i=0; i<size; i += 8) {
+        seed ^= (seed >> 17);
+        seed ^= (seed << 21);
+        seed ^= (seed << 28);
+        seed ^= (seed >> 49);
+        memcpy(bytes + i, &seed, 8);
+    }
+    seed ^= (seed >> 17);
+    seed ^= (seed << 21);
+    seed ^= (seed << 28);
+    seed ^= (seed >> 49);
+    memcpy(bytes + size, &seed, size_rem);
+}
+
+void rvvm_randomserial(char* serial, size_t size)
+{
+    rvvm_randombytes(serial, size);
+    for (size_t i=0; i<size; ++i) {
+        size_t c = ((uint8_t*)serial)[i] % ('Z' - 'A' + 10);
+        if (c <= 9) serial[i] = '0' + c;
+        else serial[i] = 'A' + c - 10;
+    }
+}
diff --git a/app/src/main/java/libengine/RVVM/src/utils.h b/app/src/main/java/libengine/RVVM/src/utils.h
new file mode 100644
index 00000000..d99ed81b
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/utils.h
@@ -0,0 +1,152 @@
+/*
+utils.h - Util functions
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef RVVM_UTILS_H
+#define RVVM_UTILS_H
+
+#include "compiler.h"
+#include "atomics.h"
+#include <stddef.h>
+#include <stdlib.h>
+#include <stdbool.h>
+
+#define LOG_ERROR 1
+#define LOG_WARN  2
+#define LOG_INFO  3
+
+#if GNU_ATTRIBUTE(__format__)
+#define PRINT_FORMAT __attribute__((__format__(printf, 1, 2)))
+#else
+#define PRINT_FORMAT
+#endif
+
+#if GNU_ATTRIBUTE(__returns_nonnull__) && GNU_ATTRIBUTE(__warn_unused_result__) && GNU_ATTRIBUTE(__alloc_size__)
+#define SAFE_MALLOC  __attribute__((__returns_nonnull__, __warn_unused_result__, __malloc__, __alloc_size__(1)))
+#define SAFE_CALLOC  __attribute__((__returns_nonnull__, __warn_unused_result__, __malloc__, __alloc_size__(1, 2)))
+#define SAFE_REALLOC __attribute__((__returns_nonnull__, __warn_unused_result__, __alloc_size__(2)))
+#else
+#define SAFE_MALLOC
+#define SAFE_CALLOC
+#define SAFE_REALLOC
+#endif
+
+void rvvm_set_loglevel(int level);
+
+// Logging functions (controlled by loglevel)
+PRINT_FORMAT void rvvm_info(const char* str, ...);
+PRINT_FORMAT void rvvm_warn(const char* str, ...);
+PRINT_FORMAT void rvvm_error(const char* str, ...);
+PRINT_FORMAT void rvvm_fatal(const char* str, ...); // Aborts the process
+
+// These never return NULL
+SAFE_MALLOC void* safe_malloc(size_t size);
+SAFE_CALLOC void* safe_calloc(size_t size, size_t n);
+SAFE_REALLOC void* safe_realloc(void* ptr, size_t size);
+
+// Safe object allocation with type checking & zeroing
+#define safe_new_obj(type) ((type*)safe_calloc(1, sizeof(type)))
+#define safe_new_arr(type, size) ((type*)safe_calloc(size, sizeof(type)))
+
+#define default_free(ptr) (free)(ptr)
+
+#define safe_free(ptr) \
+do { \
+    default_free(ptr); \
+    ptr = NULL; \
+} while(0)
+
+// Implicitly NULL freed pointer to prevent use-after-free
+#define free(ptr) safe_free(ptr)
+
+NOINLINE void do_once_finalize(uint32_t* ticket);
+
+// Run a function only once upon reaching this, for lazy init, etc
+#define DO_ONCE(expr) \
+do { \
+    static uint32_t already_done_once = 0; \
+    if (unlikely(atomic_load_uint32_ex(&already_done_once, ATOMIC_RELAXED) != 2)) { \
+        if (atomic_cas_uint32(&already_done_once, 0, 1)) { \
+            expr; \
+            atomic_store_uint32_ex(&already_done_once, 2, ATOMIC_RELEASE); \
+        } \
+        do_once_finalize(&already_done_once); \
+    } \
+} while (0)
+
+// Evaluate max/min value
+#define EVAL_MAX(a, b) ((a) > (b) ? (a) : (b))
+#define EVAL_MIN(a, b) ((a) < (b) ? (a) : (b))
+
+// Compute length of a static array
+#define STATIC_ARRAY_SIZE(arr) (sizeof(arr) / sizeof(*(arr)))
+
+static inline size_t align_size_up(size_t x, size_t align)
+{
+    return (x + (align - 1)) & ~(align - 1);
+}
+
+static inline size_t align_size_down(size_t x, size_t align)
+{
+    return x & ~(align - 1);
+}
+
+void call_at_deinit(void (*function)(void));
+
+// Portable strtol/ltostr replacement
+size_t   uint_to_str_base(char* str, size_t size, uint64_t val, uint8_t base);
+uint64_t str_to_uint_base(const char* str, size_t* len, uint8_t base);
+size_t   int_to_str_base(char* str, size_t size, int64_t val, uint8_t base);
+int64_t  str_to_int_base(const char* str, size_t* len, uint8_t base);
+size_t   int_to_str_dec(char* str, size_t size, int64_t val);
+int64_t  str_to_int_dec(const char* str);
+
+// Global argparser
+void rvvm_set_args(int new_argc, const char** new_argv);
+bool rvvm_has_arg(const char* arg);
+const char* rvvm_getarg(const char* arg);
+bool rvvm_getarg_bool(const char* arg);
+int rvvm_getarg_int(const char* arg);
+uint64_t rvvm_getarg_size(const char* arg);
+
+// Portable & safer string.h replacement
+size_t      rvvm_strlen(const char* string);
+size_t      rvvm_strnlen(const char* string, size_t size);
+bool        rvvm_strcmp(const char* s1, const char* s2);
+size_t      rvvm_strlcpy(char* dst, const char* src, size_t size);
+const char* rvvm_strfind(const char* string, const char* pattern);
+
+static inline size_t mem_suffix_shift(char suffix)
+{
+    switch (suffix) {
+        case 'k': return 10;
+        case 'K': return 10;
+        case 'm': return 20;
+        case 'M': return 20;
+        case 'g': return 30;
+        case 'G': return 30;
+        default: return 0;
+    }
+}
+
+// Generate random bytes
+void rvvm_randombytes(void* buffer, size_t size);
+
+// Generate random serial number (0-9, A-Z)
+void rvvm_randomserial(char* serial, size_t size);
+
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/vector.h b/app/src/main/java/libengine/RVVM/src/vector.h
new file mode 100644
index 00000000..fb61040d
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/vector.h
@@ -0,0 +1,109 @@
+/*
+vector.h - Vector Container
+Copyright (C) 2021  LekKit <github.com/LekKit>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef VECTOR_H
+#define VECTOR_H
+
+#include <stddef.h>
+#include <string.h>
+#include "utils.h"
+
+#define vector_t(type) struct {type* data; size_t size; size_t count;}
+
+// Empty vectors do not preallocate memory
+// This allows static initialization & conserves memory
+#define VECTOR_INIT {0}
+
+// Grow factor: 1.5 (Better memory reusage), initial capacity: 2
+#define VECTOR_GROW(vec) \
+    if ((vec).count >= (vec).size) { \
+        (vec).size += (vec).size >> 1; \
+        if ((vec).size == 0) (vec).size = 2; \
+        (vec).data = safe_realloc((vec).data, (vec).size * sizeof(*(vec).data)); \
+    }
+
+#define vector_init(vec) \
+do { \
+    (vec).data = NULL; \
+    (vec).size = 0; \
+    (vec).count = 0; \
+} while(0)
+
+// May be called multiple times, the vector is empty yet reusable afterwards
+// Semantically identical to clear(), but also frees memory
+#define vector_free(vec) \
+do { \
+    free((vec).data); \
+    (vec).data = NULL; \
+    (vec).size = 0; \
+    (vec).count = 0; \
+} while(0)
+
+#define vector_clear(vec) do { (vec).count = 0; } while(0)
+
+#define vector_size(vec) (vec).count
+
+#define vector_capacity(vec) (vec).size
+
+#define vector_at(vec, pos) (vec).data[pos]
+
+#define vector_push_back(vec, val) \
+do { \
+    VECTOR_GROW(vec); \
+    (vec).data[(vec).count++] = val; \
+} while(0)
+
+#define vector_insert(vec, pos, val) \
+do { \
+    VECTOR_GROW(vec); \
+    for (size_t _vec_i=(vec).count; _vec_i>pos; --_vec_i) (vec).data[_vec_i] = (vec).data[_vec_i-1]; \
+    (vec).data[pos] = val; \
+    (vec).count++; \
+} while(0)
+
+#define vector_emplace_back(vec) \
+do { \
+    VECTOR_GROW(vec); \
+    memset(&(vec).data[(vec).count++], 0, sizeof(*(vec).data)); \
+} while(0)
+
+#define vector_emplace(vec, pos) \
+do { \
+    VECTOR_GROW(vec); \
+    for (size_t _vec_i=(vec).count; _vec_i>pos; --_vec_i) (vec).data[_vec_i] = (vec).data[_vec_i-1]; \
+    memset(&(vec).data[pos], 0, sizeof(*(vec).data)); \
+    (vec).count++; \
+} while(0)
+
+#define vector_erase(vec, pos) \
+do { \
+    if (pos < (vec).count) { \
+        (vec).count--; \
+        for (size_t _vec_i=pos; _vec_i<(vec).count; ++_vec_i) (vec).data[_vec_i] = (vec).data[_vec_i+1]; \
+    } \
+} while(0)
+
+// Be sure to break loop after vector_erase() since it invalidates forward iterators
+#define vector_foreach(vec, iter) \
+    for (size_t iter=0; iter<(vec).count; ++iter)
+
+// Iterates the vector in reversed order, which is safe for vector_erase()
+#define vector_foreach_back(vec, iter) \
+    for (size_t iter=(vec).count; iter--;)
+        
+#endif
diff --git a/app/src/main/java/libengine/RVVM/src/vma_ops.c b/app/src/main/java/libengine/RVVM/src/vma_ops.c
new file mode 100644
index 00000000..862cec44
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/vma_ops.c
@@ -0,0 +1,403 @@
+/*
+vma_ops.c - Virtual memory area operations
+Copyright (C) 2023  LekKit <github.com/LekKit>
+
+This Source Code Form is subject to the terms of the Mozilla Public
+License, v. 2.0. If a copy of the MPL was not distributed with this
+file, You can obtain one at https://mozilla.org/MPL/2.0/.
+
+Alternatively, the contents of this file may be used under the terms
+of the GNU General Public License as published by the Free Software
+Foundation, either version 3 of the License, or any later version.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+// Needed for syscall() when not passing -std=gnu..
+#define _GNU_SOURCE
+#define _BSD_SOURCE
+#define _DEFAULT_SOURCE
+
+#include "vma_ops.h"
+
+#ifdef _WIN32
+#define VMA_WIN32_IMPL
+#include <windows.h>
+
+static inline DWORD vma_native_flags(uint32_t flags)
+{
+    switch (flags & VMA_RWX) {
+        case VMA_EXEC: return PAGE_EXECUTE;
+        case VMA_READ: return PAGE_READONLY;
+        case VMA_RDEX: return PAGE_EXECUTE_READ;
+        case VMA_RDWR: return PAGE_READWRITE;
+        case VMA_RWX:  return PAGE_EXECUTE_READWRITE;
+    }
+    return PAGE_NOACCESS;
+}
+
+#elif defined(__unix__) || defined(__APPLE__) || defined(__HAIKU__)
+#define VMA_MMAP_IMPL
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <fcntl.h>
+#ifdef __linux__
+// For memfd_create()
+#include <sys/syscall.h>
+#include <signal.h>
+#endif
+#ifdef __serenity__
+// For anon_create()
+#include <serenity.h>
+#endif
+#ifndef MAP_ANON
+#define MAP_ANON MAP_ANONYMOUS
+#endif
+#ifndef O_NOFOLLOW
+#define O_NOFOLLOW 0
+#endif
+#ifndef O_CLOEXEC
+#define O_CLOEXEC 0
+#endif
+#define MAP_VMA_ANON (MAP_PRIVATE | MAP_ANON)
+
+#if defined(MAP_JIT) && __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ >= 101400
+#define MAP_VMA_JIT (MAP_VMA_ANON | MAP_JIT)
+#else
+#define MAP_VMA_JIT MAP_VMA_ANON
+#endif
+
+static inline int vma_native_flags(uint32_t flags)
+{
+    int mmap_flags = 0;
+    if (flags & VMA_EXEC)  mmap_flags |= PROT_EXEC;
+    if (flags & VMA_READ)  mmap_flags |= PROT_READ;
+    if (flags & VMA_WRITE) mmap_flags |= PROT_WRITE;
+    return mmap_flags ? mmap_flags : PROT_NONE;
+}
+
+#else
+#include <stdlib.h>
+#warning No native VMA support!
+
+#endif
+
+// RVVM internal headers come after system headers because of safe_free()
+#include "mem_ops.h"
+#include "utils.h"
+
+static size_t host_pagesize = 0;
+
+size_t vma_page_size(void)
+{
+    if (!host_pagesize) {
+#if defined(VMA_WIN32_IMPL)
+        SYSTEM_INFO info = { .dwPageSize = 0x1000, };
+        GetSystemInfo(&info);
+        host_pagesize = info.dwPageSize;
+#elif defined(VMA_MMAP_IMPL)
+        host_pagesize = sysconf(_SC_PAGESIZE);
+#else
+        // Non-paging fallback via malloc/free, disable alignment
+        host_pagesize = 1;
+#endif
+    }
+    return host_pagesize;
+}
+
+static inline size_t vma_page_mask(void)
+{
+    return vma_page_size() - 1;
+}
+
+// Align VMA size/address to page boundaries
+static inline size_t size_to_page(size_t size)
+{
+    return (size + vma_page_mask()) & (~vma_page_mask());
+}
+
+static inline void* ptr_to_page(void* ptr)
+{
+    return (void*)(size_t)(((size_t)ptr) & (~vma_page_mask()));
+}
+
+static inline size_t ptrsize_to_page(void* ptr, size_t size)
+{
+    return size_to_page(size + (((size_t)ptr) & vma_page_mask()));
+}
+
+int vma_anon_memfd(size_t size)
+{
+    int memfd = -1;
+#if defined(VMA_MMAP_IMPL)
+#if defined(__NR_memfd_create)
+    // If we are running on older kernel, should return -ENOSYS
+    signal(SIGSYS, SIG_IGN);
+    memfd = syscall(__NR_memfd_create, "vma_anon", 1);
+#elif defined(__FreeBSD__)
+    memfd = shm_open(SHM_ANON, O_RDWR | O_CLOEXEC, 0);
+#elif defined(__OpenBSD__)
+    char shm_temp_file[] = "/tmp/tmpXXXXXXXXXX_vma_anon";
+    memfd = shm_mkstemp(shm_temp_file);
+    if (shm_unlink(shm_temp_file) < 0) {
+        close(memfd);
+        memfd = -1;
+    }
+#elif defined(__serenity__)
+    memfd = anon_create(size, O_CLOEXEC);
+    if (memfd >= 0) return memfd;
+#else
+    rvvm_info("No VMA memfd support for this platform");
+#endif
+
+#if !defined(ANDROID) && !defined(__ANDROID__) && !defined(__serenity__)
+    if (memfd < 0) {
+        char shm_file[] = "/shm-vma-anon-XXXXXXXX";
+        rvvm_randomserial(shm_file + 14, 8);
+        rvvm_info("Falling back to VMA shmem");
+        memfd = shm_open(shm_file, O_RDWR | O_CREAT | O_EXCL | O_CLOEXEC | O_NOFOLLOW, 0600);
+        if (memfd >= 0 && shm_unlink(shm_file) < 0) {
+            close(memfd);
+            memfd = -1;
+        }
+    }
+#endif
+
+    if (memfd < 0) {
+        char path[256] = {0};
+        const char* xdg = getenv("XDG_RUNTIME_DIR");
+        rvvm_info("Falling back to VMA file mapping, may lower perf");
+        if (xdg) {
+            size_t off = rvvm_strlcpy(path, xdg, sizeof(path));
+            off += rvvm_strlcpy(path + off, "/vma-anon-XXXXXXXX", sizeof(path) - off);
+            rvvm_randomserial(path + off - 8, 8);
+            if (off < 250) {
+                memfd = open(path, O_RDWR | O_CREAT | O_EXCL | O_CLOEXEC | O_NOFOLLOW, 0600);
+            } else rvvm_warn("XDG_RUNTIME_DIR path too long!");
+        }
+        if (memfd < 0) {
+            size_t off = rvvm_strlcpy(path, "/var/tmp/vma-anon-XXXXXXXX", sizeof(path));
+            rvvm_randomserial(path + off - 8, 8);
+            memfd = open(path, O_RDWR | O_CREAT | O_EXCL | O_CLOEXEC | O_NOFOLLOW, 0600);
+        }
+        if (memfd < 0) {
+            size_t off = rvvm_strlcpy(path, "/tmp/vma-anon-XXXXXXXX", sizeof(path));
+            rvvm_randomserial(path + off - 8, 8);
+            memfd = open(path, O_RDWR | O_CREAT | O_EXCL | O_CLOEXEC | O_NOFOLLOW, 0600);
+        }
+        if (memfd >= 0 && unlink(path) < 0) {
+            close(memfd);
+            memfd = -1;
+        }
+    }
+    // Resize anon FD
+    if (memfd >= 0 && ftruncate(memfd, size) < 0) {
+        close(memfd);
+        memfd = -1;
+    }
+#else
+    UNUSED(size);
+    rvvm_warn("anonymous memfd is not supported!");
+#endif
+    return memfd;
+}
+
+void* vma_alloc(void* addr, size_t size, uint32_t flags)
+{
+    size_t ptr_diff = ((size_t)addr) & vma_page_mask();
+    size = ptrsize_to_page(addr, size);
+    addr = ptr_to_page(addr);
+
+#if defined(VMA_WIN32_IMPL)
+    uint8_t* ret = VirtualAlloc(addr, size, MEM_COMMIT | MEM_RESERVE, vma_native_flags(flags));
+#elif defined(VMA_MMAP_IMPL)
+    int mmap_flags = (flags & VMA_EXEC) ? MAP_VMA_JIT : MAP_VMA_ANON;
+#if defined(MAP_FIXED_NOREPLACE)
+    if (flags & VMA_FIXED) mmap_flags |= MAP_FIXED_NOREPLACE;
+#elif defined(MAP_FIXED) && !defined(__linux__)
+    if (flags & VMA_FIXED) mmap_flags |= MAP_FIXED;
+#endif
+    uint8_t* ret = mmap(addr, size, vma_native_flags(flags), mmap_flags, -1, 0);
+    if (ret == MAP_FAILED) ret = NULL;
+#if defined(__linux__) && defined(MADV_MERGEABLE)
+    if (ret && (flags & VMA_KSM)) madvise(ret, size, MADV_MERGEABLE);
+#endif
+#if defined(__linux__) && defined(MADV_HUGEPAGE)
+    if (ret && (flags & VMA_THP)) madvise(ret, size, MADV_HUGEPAGE);
+#endif
+#else
+    if (flags & (VMA_EXEC | VMA_FIXED)) return NULL;
+    uint8_t* ret = calloc(size, 1);
+#endif
+
+    if ((flags & VMA_FIXED) && ret && ret != addr) {
+        vma_free(ret, size);
+        ret = NULL;
+    }
+
+    return ret ? (ret + ptr_diff) : NULL;
+}
+
+bool vma_multi_mmap(void** rw, void** exec, size_t size)
+{
+    size = size_to_page(size);
+#ifdef VMA_MMAP_IMPL
+    int memfd = vma_anon_memfd(size);
+    if (memfd < 0) {
+        rvvm_warn("VMA memfd creation failed");
+        return false;
+    }
+    *rw = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, memfd, 0);
+    if (*rw != MAP_FAILED) {
+        *exec = mmap(NULL, size, PROT_READ | PROT_EXEC, MAP_SHARED, memfd, 0);
+        if (*exec == MAP_FAILED) {
+            munmap(*rw, size);
+            *exec = NULL;
+        }
+    } else {
+        *rw = NULL;
+        *exec = NULL;
+    }
+    close(memfd);
+
+    return *exec != NULL;
+#else
+    UNUSED(rw);
+    UNUSED(exec);
+    UNUSED(size);
+    return false;
+#endif
+}
+
+// Resize VMA
+void* vma_remap(void* addr, size_t old_size, size_t new_size, uint32_t flags)
+{
+    size_t ptr_diff = ((size_t)addr) & vma_page_mask();
+    uint8_t* ret = ptr_to_page(addr);
+    old_size = ptrsize_to_page(addr, old_size);
+    new_size = ptrsize_to_page(addr, new_size);
+    addr = ret;
+
+    if (new_size == old_size) return addr;
+
+#if defined(VMA_MMAP_IMPL) && defined(__linux__) && defined(MREMAP_MAYMOVE)
+    ret = mremap(addr, old_size, new_size, (flags & VMA_FIXED) ? 0 : MREMAP_MAYMOVE);
+    if (ret == MAP_FAILED) ret = NULL;
+#elif defined(VMA_MMAP_IMPL) || defined(VMA_WIN32_IMPL)
+    if (new_size < old_size) {
+        // Shrink the mapping by unmapping at the end
+        if (!vma_free(((uint8_t*)addr) + new_size, old_size - new_size)) {
+            ret = NULL;
+        }
+    } else if (new_size > old_size) {
+        // Grow the mapping by mapping additional pages at the end
+        if (!vma_alloc(((uint8_t*)addr) + old_size, new_size - old_size, flags | VMA_FIXED)) {
+            ret = NULL;
+        }
+    }
+    if (ret == NULL && !(flags & VMA_FIXED)) {
+        // Just copy the data into a completely new mapping
+        ret = vma_alloc(NULL, new_size, flags);
+        if (ret) {
+            memcpy(ret, addr, EVAL_MIN(old_size, new_size));
+            vma_free(addr, old_size);
+        }
+    }
+#else
+    if (flags & VMA_FIXED) {
+        if (new_size > old_size) ret = NULL;
+    } else {
+        ret = realloc(addr, new_size);
+    }
+#endif
+
+    return ret ? (ret + ptr_diff) : NULL;
+}
+
+bool vma_protect(void* addr, size_t size, uint32_t flags)
+{
+    size = ptrsize_to_page(addr, size);
+    addr = ptr_to_page(addr);
+
+#if defined(VMA_WIN32_IMPL)
+    DWORD old;
+    return VirtualProtect(addr, size, vma_native_flags(flags), &old);
+#elif defined(VMA_MMAP_IMPL)
+    return mprotect(addr, size, vma_native_flags(flags)) == 0;
+#else
+    UNUSED(addr);
+    UNUSED(size);
+    return flags == VMA_RDWR;
+#endif
+}
+
+bool vma_clean(void* addr, size_t size, bool lazy)
+{
+    size = ptrsize_to_page(addr, size);
+    addr = ptr_to_page(addr);
+
+#if defined(VMA_WIN32_IMPL)
+    if (lazy) {
+        return VirtualAlloc(addr, size, MEM_RESET, PAGE_NOACCESS);
+    } else {
+        MEMORY_BASIC_INFORMATION mbi = {0};
+        if (!VirtualQuery(addr, &mbi, sizeof(mbi))) return false;
+        if (!VirtualFree(addr, size, MEM_DECOMMIT)) return false;
+        if (!VirtualAlloc(addr, size, MEM_COMMIT, mbi.Protect)) {
+            rvvm_fatal("VirtualAlloc() failed on decommited segment");
+        }
+        return true;
+    }
+#elif defined(VMA_MMAP_IMPL)
+#if defined(__linux__) && defined(MADV_DONTNEED)
+    return madvise(addr, size, MADV_DONTNEED) == 0;
+#endif
+#ifdef MADV_FREE
+    return madvise(addr, size, MADV_FREE) == 0 && lazy;
+#endif
+#endif
+
+    return addr && size && lazy;
+}
+
+bool vma_pageout(void* addr, size_t size, bool lazy)
+{
+    size = ptrsize_to_page(addr, size);
+    addr = ptr_to_page(addr);
+
+    if (!lazy) {
+#if defined(VMA_WIN32_IMPL) && !defined(UNDER_CE)
+        return VirtualUnlock(addr, size) || GetLastError() == ERROR_NOT_LOCKED;
+#elif defined(VMA_MMAP_IMPL) && defined(__linux__) && defined(MADV_PAGEOUT)
+        return madvise(addr, size, MADV_PAGEOUT) == 0;
+#endif
+    }
+
+#if defined(VMA_MMAP_IMPL) && defined(__linux__) && defined(MADV_COLD)
+    madvise(addr, size, MADV_COLD);
+#elif defined(VMA_MMAP_IMPL) && defined(__FreeBSD__) && defined(MADV_DONTNEED)
+    madvise(addr, size, MADV_DONTNEED);
+#endif
+
+    return lazy;
+}
+
+bool vma_free(void* addr, size_t size)
+{
+    if (!addr || !size) return false;
+    size = ptrsize_to_page(addr, size);
+    addr = ptr_to_page(addr);
+
+#if defined(VMA_WIN32_IMPL)
+    //VirtualFree(addr, size, MEM_DECOMMIT);
+    UNUSED(size);
+    return VirtualFree(addr, 0, MEM_RELEASE);
+#elif defined(VMA_MMAP_IMPL)
+    return munmap(addr, size) == 0;
+#else
+    free(addr);
+    return true;
+#endif
+}
diff --git a/app/src/main/java/libengine/RVVM/src/vma_ops.h b/app/src/main/java/libengine/RVVM/src/vma_ops.h
new file mode 100644
index 00000000..f9c032db
--- /dev/null
+++ b/app/src/main/java/libengine/RVVM/src/vma_ops.h
@@ -0,0 +1,63 @@
+/*
+vma_ops.h - Virtual memory area operations
+Copyright (C) 2023  LekKit <github.com/LekKit>
+
+This Source Code Form is subject to the terms of the Mozilla Public
+License, v. 2.0. If a copy of the MPL was not distributed with this
+file, You can obtain one at https://mozilla.org/MPL/2.0/.
+
+Alternatively, the contents of this file may be used under the terms
+of the GNU General Public License as published by the Free Software
+Foundation, either version 3 of the License, or any later version.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef VMA_OPS_H
+#define VMA_OPS_H
+
+#include <stdint.h>
+#include <stdbool.h>
+#include <stddef.h>
+
+#define VMA_NONE  0x0
+#define VMA_EXEC  0x1
+#define VMA_WRITE 0x2
+#define VMA_READ  0x4
+#define VMA_RDWR  (VMA_READ | VMA_WRITE)
+#define VMA_RDEX  (VMA_READ | VMA_EXEC)
+#define VMA_RWX   (VMA_READ | VMA_WRITE | VMA_EXEC)
+
+#define VMA_FIXED 0x8  // Forcefully map into occupied zone
+#define VMA_THP   0x10 // Transparent hugepages
+#define VMA_KSM   0x20 // Kernel same-page merging
+
+// Get host page size
+size_t vma_page_size(void);
+
+// Create anonymous memory-backed FD (POSIX only!)
+int vma_anon_memfd(size_t size);
+
+// Allocate VMA, force needed address using VMA_FIXED
+void* vma_alloc(void* addr, size_t size, uint32_t flags);
+
+// Create separate RW/exec VMAs (For W^X JIT)
+bool  vma_multi_mmap(void** rw, void** exec, size_t size);
+
+// Resize VMA, pass VMA_FIXED to make sure it stays in place
+void* vma_remap(void* addr, size_t old_size, size_t new_size, uint32_t flags);
+
+// Change VMA protection flags
+bool  vma_protect(void* addr, size_t size, uint32_t flags);
+
+// Hint to free (zero-fill) underlying memory, VMA is still intact
+bool  vma_clean(void* addr, size_t size, bool lazy);
+
+// Hint to pageout memory, data is kept intact
+bool  vma_pageout(void* addr, size_t size, bool lazy);
+
+// Unmap the VMA
+bool  vma_free(void* addr, size_t size);
+
+#endif
diff --git a/app/src/main/java/libengine/native.cpp b/app/src/main/java/libengine/native.cpp
new file mode 100644
index 00000000..faca3417
--- /dev/null
+++ b/app/src/main/java/libengine/native.cpp
@@ -0,0 +1,206 @@
+#include <string>
+#include "AppInstanceAndroidBase.h"
+#include "DiligentLog/Log.h"
+#include "DiligentLog/Primitives/interface/Errors.hpp"
+
+//MultiTouch multiTouch;
+
+struct Renderer : AppInstanceAndroidBase {
+    void onEglSetup(JNIEnv *jenv, jobject classInstance, jstring name, jstring signature) override {
+      AppInstanceAndroidBase::onEglSetup(jenv, classInstance, name, signature);
+    }
+    void onEglTearDown() override {
+      destroyResources();
+      AppInstanceAndroidBase::onEglTearDown();
+    }
+    void surfaceChanged(int w, int h) {
+      
+    }
+    void onDraw() {
+      swapBuffers();
+    }
+    //bool onTouchEvent(MultiTouch & touchEvent);
+    void swapBuffers() override {
+      AppInstanceAndroidBase::swapBuffers();
+    }
+    void destroyResources() {
+    }
+    ~Renderer() {
+      destroyResources();
+    }
+};
+
+#define APP(jlong) reinterpret_cast<Renderer*>(jlong)
+#define JLONG(ptr) reinterpret_cast<jlong>(ptr)
+
+extern "C" JNIEXPORT jlong JNICALL
+Java_smallville7123_graphical_tool_kit_DiligentEngineView_00024DiligentEngineRenderer_createNativeInstance (
+        JNIEnv * env, jobject thiz
+)
+{
+    // multiTouch.setMaxSupportedTouches(10);
+    LOG_ERROR_MESSAGE("CREATE APP");
+    return JLONG(new Renderer());
+}
+
+extern "C" JNIEXPORT void JNICALL
+Java_smallville7123_graphical_tool_kit_DiligentEngineView_00024DiligentEngineRenderer_destroyNativeInstance (
+        JNIEnv * env, jobject thiz, jlong instance
+)
+{
+    LOG_ERROR_MESSAGE("DESTROY APP");
+    delete APP(instance);
+}
+
+extern "C" JNIEXPORT void JNICALL
+Java_smallville7123_graphical_tool_kit_DiligentEngineView_00024DiligentEngineRenderer_onEglSetup (
+        JNIEnv * env, jobject thiz, jlong instance, jobject class_instance, jstring name,
+        jstring signature
+)
+{
+    LOG_ERROR_MESSAGE("EGL SETUP");
+    APP(instance)->onEglSetup(env, class_instance, name, signature);
+}
+
+extern "C" JNIEXPORT void JNICALL
+Java_smallville7123_graphical_tool_kit_DiligentEngineView_00024DiligentEngineRenderer_surfaceChanged (
+        JNIEnv * env, jobject thiz, jlong instance, jint w, jint h
+)
+{
+    LOG_ERROR_MESSAGE("EGL SURFACE CHANGE");
+    APP(instance)->surfaceChanged(w, h);
+}
+
+extern "C" JNIEXPORT void JNICALL
+Java_smallville7123_graphical_tool_kit_DiligentEngineView_00024DiligentEngineRenderer_addTouch__JFF(
+        JNIEnv * env, jobject thiz,
+        jlong identifier, jfloat x, jfloat y
+)
+{
+    //multiTouch.addTouch(identifier, x, y);
+}
+
+extern "C" JNIEXPORT void JNICALL
+Java_smallville7123_graphical_tool_kit_DiligentEngineView_00024DiligentEngineRenderer_addTouch__JFFF (
+        JNIEnv * env, jobject thiz,
+        jlong identifier, jfloat x, jfloat y, jfloat size
+)
+{
+    //multiTouch.addTouch(identifier, x, y, size);
+}
+
+extern "C" JNIEXPORT void JNICALL
+Java_smallville7123_graphical_tool_kit_DiligentEngineView_00024DiligentEngineRenderer_addTouch__JFFFF (
+        JNIEnv * env, jobject thiz,
+        jlong identifier, jfloat x, jfloat y, jfloat size, jfloat pressure
+)
+{
+    //multiTouch.addTouch(identifier, x, y, size, pressure);
+}
+
+extern "C" JNIEXPORT void JNICALL
+Java_smallville7123_graphical_tool_kit_DiligentEngineView_00024DiligentEngineRenderer_moveTouch__JFF (
+        JNIEnv * env, jobject thiz,
+        jlong identifier, jfloat x, jfloat y
+)
+{
+    //multiTouch.moveTouch(identifier, x, y);
+}
+
+extern "C" JNIEXPORT void JNICALL
+Java_smallville7123_graphical_tool_kit_DiligentEngineView_00024DiligentEngineRenderer_moveTouch__JFFF (
+        JNIEnv * env, jobject thiz,
+        jlong identifier, jfloat x, jfloat y, jfloat size
+)
+{
+    //multiTouch.moveTouch(identifier, x, y, size);
+}
+
+extern "C" JNIEXPORT void JNICALL
+Java_smallville7123_graphical_tool_kit_DiligentEngineView_00024DiligentEngineRenderer_moveTouch__JFFFF (
+        JNIEnv * env, jobject thiz,
+        jlong identifier, jfloat x, jfloat y, jfloat size, jfloat pressure
+)
+{
+    //multiTouch.moveTouch(identifier, x, y, size, pressure);
+}
+
+extern "C" JNIEXPORT void JNICALL
+Java_smallville7123_graphical_tool_kit_DiligentEngineView_00024DiligentEngineRenderer_removeTouch__JFF (
+        JNIEnv * env, jobject thiz,
+        jlong identifier, jfloat x, jfloat y
+)
+{
+    //multiTouch.removeTouch(identifier, x, y);
+}
+
+extern "C" JNIEXPORT void JNICALL
+Java_smallville7123_graphical_tool_kit_DiligentEngineView_00024DiligentEngineRenderer_removeTouch__JFFF (
+        JNIEnv * env, jobject thiz,
+        jlong identifier, jfloat x, jfloat y, jfloat size
+)
+{
+    //multiTouch.removeTouch(identifier, x, y, size);
+}
+
+extern "C" JNIEXPORT void JNICALL
+Java_smallville7123_graphical_tool_kit_DiligentEngineView_00024DiligentEngineRenderer_removeTouch__JFFFF (
+        JNIEnv * env, jobject thiz,
+        jlong identifier, jfloat x, jfloat y, jfloat size, jfloat pressure
+)
+{
+    //multiTouch.removeTouch(identifier, x, y, size, pressure);
+}
+
+extern "C" JNIEXPORT void JNICALL
+Java_smallville7123_graphical_tool_kit_DiligentEngineView_00024DiligentEngineRenderer_cancelTouch__JFF (
+        JNIEnv * env, jobject thiz,
+        jlong identifier, jfloat x, jfloat y
+)
+{
+    //multiTouch.cancelTouch(identifier, x, y);
+}
+
+extern "C" JNIEXPORT void JNICALL
+Java_smallville7123_graphical_tool_kit_DiligentEngineView_00024DiligentEngineRenderer_cancelTouch__JFFF (
+        JNIEnv * env, jobject thiz,
+        jlong identifier, jfloat x, jfloat y, jfloat size
+)
+{
+    //multiTouch.cancelTouch(identifier, x, y, size);
+}
+
+extern "C" JNIEXPORT void JNICALL
+Java_smallville7123_graphical_tool_kit_DiligentEngineView_00024DiligentEngineRenderer_cancelTouch__JFFFF (
+        JNIEnv * env, jobject thiz,
+        jlong identifier, jfloat x, jfloat y, jfloat size, jfloat pressure
+)
+{
+    //multiTouch.cancelTouch(identifier, x, y, size, pressure);
+}
+
+extern "C" JNIEXPORT jboolean JNICALL
+Java_smallville7123_graphical_tool_kit_DiligentEngineView_00024DiligentEngineRenderer_onTouchEvent (
+        JNIEnv * env, jobject thiz, jlong instance
+)
+{
+    //return APP(instance)->onTouchEvent(multiTouch);
+    return false;
+}
+
+extern "C" JNIEXPORT void JNICALL
+Java_smallville7123_graphical_tool_kit_DiligentEngineView_00024DiligentEngineRenderer_onDraw (
+        JNIEnv * env, jobject thiz, jlong instance
+)
+{
+    APP(instance)->onDraw();
+}
+
+extern "C" JNIEXPORT void JNICALL
+Java_smallville7123_graphical_tool_kit_DiligentEngineView_00024DiligentEngineRenderer_onEglTearDown (
+        JNIEnv * env, jobject thiz, jlong instance
+)
+{
+    LOG_ERROR_MESSAGE("EGL TEAR DOWN");
+    APP(instance)->onEglTearDown();
+}
diff --git a/app/src/main/java/linux/kernel/MainActivity.kt b/app/src/main/java/linux/kernel/MainActivity.kt
new file mode 100644
index 00000000..a6ba31a8
--- /dev/null
+++ b/app/src/main/java/linux/kernel/MainActivity.kt
@@ -0,0 +1,184 @@
+package linux.kernel
+
+// proot -
+// https://github.com/bilbilaki/Tiny-Vterm/blob/main/vterm/src/main/java/com/vectras/vterm/Terminal.java
+
+import alpine.term.TerminalController
+import alpine.term.terminal_view.TerminalView
+import android.content.res.AssetManager
+import android.os.Bundle
+import android.view.ContextMenu
+import android.view.ContextMenu.ContextMenuInfo
+import android.view.Menu
+import android.view.MenuItem
+import android.view.View
+import android.widget.Button
+import androidx.appcompat.app.AppCompatActivity
+import liblayout.Builder
+import liblayout.UiThread
+import smallville7123.graphical.tool.kit.DiligentEngineView
+import java.io.*
+
+class MainActivity : AppCompatActivity() {
+
+    var terminalController : TerminalController? = null
+    var engineView : DiligentEngineView? = null
+    
+    inner class assetsManager {
+
+        fun copyAssetFolder(assetManager: AssetManager): Boolean = copyAssetFolder(assetManager, null, ASSETS)
+    
+        fun copyAssetFolder(
+            assetManager: AssetManager,
+            toPath: String
+        ): Boolean = copyAssetFolder(assetManager, null, toPath)
+    
+        fun copyAssetFolder(
+            assetManager: AssetManager,
+            fromAssetPath: String?,
+            toPath: String
+        ): Boolean {
+            val files: Array<String>? =
+                assetManager.list(if (fromAssetPath.isNullOrBlank()) "" else fromAssetPath)
+            if (files == null) return false else if (files.isEmpty()) return false
+            Log.i(LOG_TAG, "obtained a list of assets")
+            File(toPath).mkdirs()
+            var res = true
+            files.forEach {
+                // attempting to open a directory will return a filenotfound exception
+                var f = ""
+                f = if (fromAssetPath.isNullOrBlank()) it
+                else "$fromAssetPath/$it"
+                res = try {
+                    val dummy = assetManager.open(f)
+                    // if this point has been reached, we found a file
+                    dummy.close()
+                    res and copyAsset(assetManager, f, "$toPath/$it")
+                } catch (e: IOException) {
+                    // we didnt find a file, assume it must be a folder
+                    res and copyAssetFolder(assetManager, f, "$toPath/$it")
+                }
+            }
+            return res
+        }
+    
+        fun copyAsset(
+            assetManager: AssetManager,
+            fromAssetPath: String, toPath: String
+        ): Boolean {
+            var `in`: InputStream? = null
+            var out: OutputStream? = null
+            Log.i(LOG_TAG, "copying \"$fromAssetPath\" to \"$toPath\"")
+            try {
+                `in` = assetManager.open(fromAssetPath)
+            } catch (e: Exception) {
+                e.printStackTrace()
+                return false
+            }
+            File(toPath).createNewFile()
+            out = FileOutputStream(toPath)
+            copyFile(`in`!!, out)
+            `in`.close()
+            `in` = null
+            out.flush()
+            out.close()
+            out = null
+            return true
+        }
+    
+        @Throws(IOException::class)
+        fun copyFile(`in`: InputStream, out: OutputStream) {
+            val buffer = ByteArray(1024)
+            var read = `in`.read(buffer)
+            while (read != -1) {
+                out.write(buffer, 0, read)
+                read = `in`.read(buffer)
+            }
+        }
+    }
+
+
+    override fun onCreate(savedInstanceState: Bundle?) {
+        super.onCreate(savedInstanceState)
+        
+        val filesDir = activity.filesDir.absolutePath;
+        val ASSETS = "$filesDir/ASSETS"
+        val CACHE = "$filesDir/CACHE"
+        Log.i(LOG_TAG, "copying assets folder")
+        assetsManager().copyAssetFolder(activity.assets)
+        val binDir = "$ASSETS/usr/bin"
+        if (File(binDir).exists()) {
+            Chmod.main(arrayOf("-R", "a=rwx", binDir))
+        }
+
+        if (File("$ASSETS/rvvm").exists()) {
+            Chmod.main(arrayOf("-R", "a=rwx", "$ASSETS/rvvm"))
+        }
+
+        // If this method is called more than once with the same library name
+        // the second and subsequent calls are ignored.
+
+        // set log view
+        setContentView(R.layout.slide_out_terminal)
+
+        // obtain log view instance
+        terminalController = TerminalController()
+        terminalController!!.onCreate(this, findViewById<TerminalView>(R.id.terminal_view))
+
+        engineView = DiligentEngineView(this)
+
+        when(terminalController!!.terminalContainer.visibility) {
+            View.INVISIBLE -> findViewById<Button>(R.id.toggle_terminal).setText(R.string.Show_LogTerminal)
+            else -> findViewById<Button>(R.id.toggle_terminal).setText(R.string.Hide_LogTerminal)
+        }
+
+        findViewById<Button>(R.id.toggle_terminal).setOnClickListener {
+            terminalController!!.onClick(findViewById<Button>(R.id.toggle_terminal))
+        }
+
+        Builder(this, findViewById<View>(R.id.mainView))
+            .row().column { engineView!! }
+            .build()
+    }
+
+    override fun onStart() {
+        super.onStart()
+        terminalController!!.onStart()
+    }
+
+    override fun onResume() {
+        super.onResume()
+        engineView!!.onResume();
+    }
+
+    override fun onPause() {
+        super.onPause()
+        engineView!!.onPause();
+    }
+
+    override fun onStop() {
+        super.onStop()
+        terminalController!!.onStop()
+    }
+
+    override fun onDestroy() {
+        terminalController!!.onDestroy()
+        super.onDestroy()
+    }
+
+    override fun onCreateContextMenu(
+        menu: ContextMenu?,
+        v: View?,
+        menuInfo: ContextMenuInfo?
+    ) {
+        terminalController!!.onCreateContextMenu(menu, v, menuInfo)
+    }
+
+    override fun onContextItemSelected(item: MenuItem?): Boolean {
+        return terminalController!!.onContextItemSelected(item) || super.onContextItemSelected(item)
+    }
+
+    override fun onBackPressed() {
+        if (!terminalController!!.onBackPressed()) super.onBackPressed()
+    }
+}
diff --git a/app/src/main/java/media/player/pro/UpdatingTextView.kt b/app/src/main/java/linux/kernel/UpdatingTextView.kt
similarity index 98%
rename from app/src/main/java/media/player/pro/UpdatingTextView.kt
rename to app/src/main/java/linux/kernel/UpdatingTextView.kt
index 229660a3..5d569e14 100644
--- a/app/src/main/java/media/player/pro/UpdatingTextView.kt
+++ b/app/src/main/java/linux/kernel/UpdatingTextView.kt
@@ -1,4 +1,4 @@
-package media.player.pro
+package linux.kernel
 
 import android.content.Context
 import android.graphics.Canvas
diff --git a/app/src/main/java/media/player/pro/MainActivity.kt b/app/src/main/java/media/player/pro/MainActivity.kt
deleted file mode 100644
index 68bc1f72..00000000
--- a/app/src/main/java/media/player/pro/MainActivity.kt
+++ /dev/null
@@ -1,170 +0,0 @@
-package media.player.pro
-
-import alpine.term.TerminalController
-import alpine.term.terminal_view.TerminalView
-import android.os.Bundle
-import android.view.ContextMenu
-import android.view.ContextMenu.ContextMenuInfo
-import android.view.Menu
-import android.view.MenuItem
-import android.view.View
-import android.widget.Button
-import androidx.appcompat.app.AppCompatActivity
-import liblayout.Builder
-import liblayout.UiThread
-import libmedia.Media
-
-class MainActivity : AppCompatActivity() {
-
-    var media: Media? = null
-    var terminalController: TerminalController? = null
-
-
-    override fun onCreate(savedInstanceState: Bundle?) {
-        super.onCreate(savedInstanceState)
-
-        // If this method is called more than once with the same library name
-        // the second and subsequent calls are ignored.
-
-        // set log view
-        setContentView(R.layout.slide_out_terminal)
-
-        // obtain log view instance
-        terminalController = TerminalController()
-        terminalController!!.onCreate(this, findViewById<TerminalView>(R.id.terminal_view))
-
-        when(terminalController!!.terminalContainer.visibility) {
-            View.INVISIBLE -> findViewById<Button>(R.id.toggle_terminal).setText(R.string.Show_LogTerminal)
-            else -> findViewById<Button>(R.id.toggle_terminal).setText(R.string.Hide_LogTerminal)
-        }
-
-        findViewById<Button>(R.id.toggle_terminal).setOnClickListener {
-            terminalController!!.onClick(findViewById<Button>(R.id.toggle_terminal))
-        }
-
-        media = Media(this).also {
-            it.init()
-            it.loadMediaAssetAsFile("00001313_48000.raw")
-            it.loop(true)
-        }
-
-        Builder(this, findViewById<View>(R.id.mainView))
-            .row().height(80)
-            .column {
-                media!!.WaveformView(
-                    context = this,
-                    height = it.sizeFromTop,
-                    width = it.sizeFromLeft,
-                    media = media!!
-                )
-            }
-            .row().height(10).column {
-                UpdatingTextView(this).also {
-                    it.addOnFirstDrawAction {
-                        it.text = "Time:                      0\n" +
-                                "current frame :                0\n" +
-                                "Audio Timing NANO :            0\n" +
-                                "Audio Timing MICRO:            0\n" +
-                                "Audio Timing MILLI:            0\n" +
-                                "Audio Timing Format NANO :     0\n" +
-                                "Audio Timing Format MICRO:     0\n" +
-                                "Audio Timing Format MILLI:     0\n" +
-                                "Audio Timing Chrono NANO :     0\n" +
-                                "Audio Timing Chrono MICRO:     0\n" +
-                                "Audio Timing Chrono MILLI:     0\n" +
-                                "underruns:                     0\n" +
-                                "buffer size:                   0\n" +
-                                "buffer capacity:               0\n" +
-                                "frame bursts in buffer:        0\n" +
-                                "frames per burst:              0"
-                    }
-                    it.addOnDrawAction {
-                        it.text = "Time:                      ${media!!.Oboe_getCurrentTime()}\n" +
-                                "current frame :                ${media!!.Oboe_getCurrentFrame()}\n" +
-                                "Audio Timing NANO :            ${media!!.Oboe_getAudioTimingNANO()}\n" +
-                                "Audio Timing MICRO:            ${media!!.Oboe_getAudioTimingMICRO()}\n" +
-                                "Audio Timing MILLI:            ${media!!.Oboe_getAudioTimingMILLI()}\n" +
-                                "Audio Timing Format NANO :     ${media!!.Oboe_getAudioTimingFormatNANO()}\n" +
-                                "Audio Timing Format MICRO:     ${media!!.Oboe_getAudioTimingFormatMICRO()}\n" +
-                                "Audio Timing Format MILLI:     ${media!!.Oboe_getAudioTimingFormatMILLI()}\n" +
-                                "Audio Timing Chrono NANO :     ${media!!.Oboe_getAudioTimingChronoNANO()}\n" +
-                                "Audio Timing Chrono MICRO:     ${media!!.Oboe_getAudioTimingChronoMICRO()}\n" +
-                                "Audio Timing Chrono MILLI:     ${media!!.Oboe_getAudioTimingChronoMILLI()}\n" +
-                                "underruns:                     ${media!!.Oboe_underrunCount()}\n" +
-                                "buffer size:                   ${media!!.Oboe_bufferSize()}\n" +
-                                "buffer capacity:               ${media!!.Oboe_bufferCapacity()}\n" +
-                                "frame bursts in buffer:        ${
-                                media!!.Oboe_bufferCapacity() / media!!.Oboe_framesPerBurst()
-                                }\n" +
-                                "frames per burst:              ${media!!.Oboe_framesPerBurst()}"
-                    }
-                }
-            }
-            .row().height(10)
-            .column {
-                Button(this).also {
-                    media!!.Listner.play = {
-                        it.text = "playing"
-                    }
-                    media!!.Listner.pause = {
-                        it.text = "paused"
-                    }
-                    media!!.Listner.stop = {
-                        it.text = "stopped"
-                    }
-                    it.setOnClickListener {
-                        if (media!!.isPlaying) media!!.pause()
-                        else media!!.play()
-                    }
-                    when {
-                        media!!.isPlaying -> it.text = "playing"
-                        media!!.isPaused -> it.text = "paused"
-                        media!!.isStopped -> it.text = "stopped"
-                    }
-                }
-            }
-            .build()
-    }
-
-    override fun onStart() {
-        super.onStart()
-        terminalController!!.onStart()
-    }
-
-    override fun onResume() {
-        super.onResume()
-        media!!.foreground()
-    }
-
-    override fun onPause() {
-        super.onPause()
-        media!!.background()
-    }
-
-    override fun onStop() {
-        super.onStop()
-        terminalController!!.onStop()
-    }
-
-    override fun onDestroy() {
-        media!!.destroy()
-        terminalController!!.onDestroy()
-        super.onDestroy()
-    }
-
-    override fun onCreateContextMenu(
-        menu: ContextMenu?,
-        v: View?,
-        menuInfo: ContextMenuInfo?
-    ) {
-        terminalController!!.onCreateContextMenu(menu, v, menuInfo)
-    }
-
-    override fun onContextItemSelected(item: MenuItem?): Boolean {
-        return terminalController!!.onContextItemSelected(item) || super.onContextItemSelected(item)
-    }
-
-    override fun onBackPressed() {
-        if (!terminalController!!.onBackPressed()) super.onBackPressed()
-    }
-}
diff --git a/app/src/main/java/smallville7123/EGLSurfaceView_EGLTextureView/EGLSurfaceView.java b/app/src/main/java/smallville7123/EGLSurfaceView_EGLTextureView/EGLSurfaceView.java
new file mode 100644
index 00000000..4271209e
--- /dev/null
+++ b/app/src/main/java/smallville7123/EGLSurfaceView_EGLTextureView/EGLSurfaceView.java
@@ -0,0 +1,2426 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package smallville7123.EGLSurfaceView_EGLTextureView;
+
+import android.content.Context;
+import android.content.pm.ConfigurationInfo;
+import android.graphics.PixelFormat;
+import android.opengl.EGL14;
+import android.opengl.EGLExt;
+import android.opengl.GLDebugHelper;
+import android.os.SystemClock;
+import android.text.TextUtils;
+import android.util.AttributeSet;
+import android.util.Log;
+import android.view.Choreographer;
+import android.view.Surface;
+import android.view.SurfaceHolder;
+import android.view.SurfaceView;
+
+import androidx.annotation.CallSuper;
+import androidx.annotation.NonNull;
+
+import java.io.BufferedReader;
+import java.io.InputStreamReader;
+import java.io.Writer;
+import java.lang.ref.WeakReference;
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Map;
+
+import javax.microedition.khronos.egl.EGL10;
+import javax.microedition.khronos.egl.EGL11;
+import javax.microedition.khronos.egl.EGLConfig;
+import javax.microedition.khronos.egl.EGLContext;
+import javax.microedition.khronos.egl.EGLDisplay;
+import javax.microedition.khronos.egl.EGLSurface;
+import javax.microedition.khronos.opengles.GL;
+import javax.microedition.khronos.opengles.GL10;
+
+/**
+ * An implementation of SurfaceView that uses the dedicated surface for
+ * displaying OpenGL rendering.
+ * <p>
+ * A EGLSurfaceView provides the following features:
+ * <p>
+ * <ul>
+ * <li>Manages a surface, which is a special piece of memory that can be
+ * composited into the Android view system.
+ * <li>Manages an EGL display, which enables OpenGL to render into a surface.
+ * <li>Accepts a user-provided Renderer object that does the actual rendering.
+ * <li>Renders on a dedicated thread to decouple rendering performance from the
+ * UI thread.
+ * <li>Supports both on-demand and continuous rendering.
+ * <li>Optionally wraps, traces, and/or error-checks the renderer's OpenGL calls.
+ * </ul>
+ *
+ * <div class="special reference">
+ * <h3>Developer Guides</h3>
+ * <p>For more information about how to use OpenGL, read the
+ * <a href="{@docRoot}guide/topics/graphics/opengl.html">OpenGL</a> developer guide.</p>
+ * </div>
+ *
+ * <h3>Using EGLSurfaceView</h3>
+ * <p>
+ * Typically you use EGLSurfaceView by subclassing it and overriding one or more of the
+ * View system input event methods. If your application does not need to override event
+ * methods then EGLSurfaceView can be used as-is. For the most part
+ * EGLSurfaceView behavior is customized by calling "set" methods rather than by subclassing.
+ * For example, unlike a regular View, drawing is delegated to a separate Renderer object which
+ * is registered with the EGLSurfaceView
+ * using the {@link #setRenderer(Renderer)} call.
+ * <p>
+ * <h3>Initializing EGLSurfaceView</h3>
+ * All you have to do to initialize a EGLSurfaceView is call {@link #setRenderer(Renderer)}.
+ * However, if desired, you can modify the default behavior of EGLSurfaceView by calling one or
+ * more of these methods before calling setRenderer:
+ * <ul>
+ * <li>{@link #setDebugFlags(int)}
+ * <li>{@link #setEGLConfigChooser(boolean)}
+ * <li>{@link #setEGLConfigChooser(EGLConfigChooser)}
+ * <li>{@link #setEGLConfigChooser(int, int, int, int, int, int)}
+ * <li>{@link #setGLWrapper(GLWrapper)}
+ * </ul>
+ * <p>
+ * <h4>Specifying the android.view.Surface</h4>
+ * By default EGLSurfaceView will create a PixelFormat.RGB_888 format surface. If a translucent
+ * surface is required, call getHolder().setFormat(PixelFormat.TRANSLUCENT).
+ * The exact format of a TRANSLUCENT surface is device dependent, but it will be
+ * a 32-bit-per-pixel surface with 8 bits per component.
+ * <p>
+ * <h4>Choosing an EGL Configuration</h4>
+ * A given Android device may support multiple EGLConfig rendering configurations.
+ * The available configurations may differ in how may channels of data are present, as
+ * well as how many bits are allocated to each channel. Therefore, the first thing
+ * EGLSurfaceView has to do when starting to render is choose what EGLConfig to use.
+ * <p>
+ * By default EGLSurfaceView chooses a EGLConfig that has an RGB_888 pixel format,
+ * with at least a 16-bit depth buffer and no stencil.
+ * <p>
+ * If you would prefer a different EGLConfig
+ * you can override the default behavior by calling one of the
+ * setEGLConfigChooser methods.
+ * <p>
+ * <h4>Debug Behavior</h4>
+ * You can optionally modify the behavior of EGLSurfaceView by calling
+ * one or more of the debugging methods {@link #setDebugFlags(int)},
+ * and {@link #setGLWrapper}. These methods may be called before and/or after setRenderer, but
+ * typically they are called before setRenderer so that they take effect immediately.
+ * <p>
+ * <h4>Setting a Renderer</h4>
+ * Finally, you must call {@link #setRenderer} to register a {@link Renderer}.
+ * The renderer is
+ * responsible for doing the actual OpenGL rendering.
+ * <p>
+ * <h3>Rendering Mode</h3>
+ * Once the renderer is set, you can control whether the renderer draws
+ * continuously or on-demand by calling
+ * {@link #setRenderMode}. The default is continuous rendering.
+ * <p>
+ * <h3>Activity Life-cycle</h3>
+ * A EGLSurfaceView must be notified when the activity is paused and resumed. EGLSurfaceView clients
+ * are required to call {@link #onPause()} when the activity pauses and
+ * {@link #onResume()} when the activity resumes. These calls allow EGLSurfaceView to
+ * pause and resume the rendering thread, and also allow EGLSurfaceView to release and recreate
+ * the OpenGL display.
+ * <p>
+ * <h3>Handling events</h3>
+ * <p>
+ * To handle an event you will typically subclass EGLSurfaceView and override the
+ * appropriate method, just as you would with any other View. However, when handling
+ * the event, you may need to communicate with the Renderer object
+ * that's running in the rendering thread. You can do this using any
+ * standard Java cross-thread communication mechanism. In addition,
+ * one relatively easy way to communicate with your renderer is
+ * to call
+ * {@link #queueEvent(Runnable)}. For example:
+ * <pre class="prettyprint">
+ * class MyEGLSurfaceView extends EGLSurfaceView {
+ *
+ *     private MyRenderer mMyRenderer;
+ *
+ *     public void start() {
+ *         mMyRenderer = ...;
+ *         setRenderer(mMyRenderer);
+ *     }
+ *
+ *     public boolean onKeyDown(int keyCode, KeyEvent event) {
+ *         if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {
+ *             queueEvent(new Runnable() {
+ *                 // This method will be called on the rendering
+ *                 // thread:
+ *                 public void run() {
+ *                     mMyRenderer.handleDpadCenter();
+ *                 }});
+ *             return true;
+ *         }
+ *         return super.onKeyDown(keyCode, event);
+ *     }
+ * }
+ * </pre>
+ *
+ */
+public class EGLSurfaceView extends SurfaceView implements SurfaceHolder.Callback {
+    private final static String TAG = "EGLSurfaceView";
+
+    private final static boolean LOG_ATTACH_DETACH = false;
+    private final static boolean LOG_THREADS = false;
+    private final static boolean LOG_PAUSE_RESUME = false;
+    private final static boolean LOG_SURFACE = false;
+    private final static boolean LOG_RENDERER = false;
+    private final static boolean LOG_RENDERER_DRAW_FRAME = false;
+    private final static boolean LOG_EGL = false;
+    /**
+     * The renderer only renders
+     * when the surface is created, or when {@link #requestRender} is called.
+     *
+     * @see #getRenderMode()
+     * @see #setRenderMode(int)
+     * @see #requestRender()
+     */
+    public final static int RENDERMODE_WHEN_DIRTY = 0;
+    /**
+     * The renderer is called
+     * continuously to re-render the scene.
+     *
+     * @see #getRenderMode()
+     * @see #setRenderMode(int)
+     */
+    public final static int RENDERMODE_CONTINUOUSLY = 1;
+
+    /**
+     * Check glError() after every GL call and throw an exception if glError indicates
+     * that an error has occurred. This can be used to help track down which OpenGL ES call
+     * is causing an error.
+     *
+     * @see #getDebugFlags
+     * @see #setDebugFlags
+     */
+    public final static int DEBUG_CHECK_GL_ERROR = 1;
+
+    /**
+     * Log GL calls to the system log at "verbose" level with tag "EGLSurfaceView".
+     *
+     * @see #getDebugFlags
+     * @see #setDebugFlags
+     */
+    public final static int DEBUG_LOG_GL_CALLS = 2;
+
+    /**
+     * Standard View constructor. In order to render something, you
+     * must call {@link #setRenderer} to register a renderer.
+     */
+    public EGLSurfaceView(Context context) {
+        super(context);
+        init();
+    }
+
+    /**
+     * Standard View constructor. In order to render something, you
+     * must call {@link #setRenderer} to register a renderer.
+     */
+    public EGLSurfaceView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        init();
+    }
+
+    @Override
+    @CallSuper
+    protected void finalize() throws Throwable {
+        try {
+            if (mGLThread != null) {
+                // GLThread may still be running if this view was never
+                // attached to a window.
+                mGLThread.requestExitAndWait();
+            }
+        } finally {
+            super.finalize();
+        }
+    }
+
+    private class Methods {
+        private final Class<EGLSurfaceView> clazz;
+        Method swapBuffersMethod;
+        String swapBuffersName;
+        String swapBuffersSignature;
+        Methods() {
+            clazz = EGLSurfaceView.class;
+            try {
+                swapBuffersMethod = clazz.getDeclaredMethod("swapBuffers");
+            } catch (NoSuchMethodException e) {
+                throw new RuntimeException("cannot find own methods");
+            }
+            swapBuffersName = swapBuffersMethod.getName();
+            swapBuffersSignature = "()V";
+        }
+    }
+
+    private Methods methods;
+
+    public enum METHOD {
+        SWAP_BUFFERS
+    }
+
+    public final String getJavaNameForJNI(METHOD METHOD) {
+        switch (METHOD) {
+            case SWAP_BUFFERS:
+                return methods.swapBuffersName;
+        }
+        return null;
+    }
+
+    public final String getJavaSignatureForJNI(METHOD METHOD) {
+        switch (METHOD) {
+            case SWAP_BUFFERS:
+                return methods.swapBuffersSignature;
+        }
+        return null;
+    }
+
+    private final Choreographer choreographer = Choreographer.getInstance();
+    private final Object VSYNC_LOCK = new Object();
+    private boolean vsynced;
+    private boolean shouldSwap;
+
+    /**
+     * Requests that the render thread swaps its buffers
+     * <br><br>
+     * The buffers will be swapped either when the current draw completes,
+     * or when the next draw completes
+     * <br><br>
+     * Subsequent calls in the same frame has no effect
+     * <br><br>
+     * This may be called from any thread
+     * <br><br>
+     * <br><br>
+     * Ensures that the render thread calls:
+     * <code>eglSwapBuffers(EGLDisplay, EGLSurface)</code>
+     * <br><br>
+     * <br><br>
+     * If you need to call this method from jni,
+     * please adapt your code to use the following
+     * <br><br>
+     *     Java:
+     * <pre class="prettyprint">
+     * {@literal @Override}
+     * public class Example extends EGLSurfaceView {
+     *     // ...
+     *     class ExampleRenderer implements Renderer {
+     *         native long createNativeInstance();
+     *         native void onEglSetup(long instance, Object classInstance, String name, String signature);
+     *         native void surfaceChanged(long instance, int w, int h);
+     *         native void onDraw(long instance);
+     *         native void onEglTearDown(long instance);
+     *         long nativeInstance;
+     *
+     *         ExampleRenderer() {
+     *             System.loadLibrary("YourNativeLibrary");
+     *             nativeInstance = createNativeInstance();
+     *         }
+     *
+     *         {@literal @Override}
+     *         public void onEglSetup() {
+     *             onEglSetup(nativeInstance, Example.this,
+     *                     getJavaNameForJNI(METHOD.SWAP_BUFFERS),
+     *                     getJavaSignatureForJNI(METHOD.SWAP_BUFFERS)
+     *             );
+     *         }
+     *
+     *         {@literal @Override}
+     *         public void onEglTearDown() {
+     *             onEglTearDown(nativeInstance);
+     *         }
+     *
+     *         {@literal @Override}
+     *         public void onSurfaceChanged(GL10 gl, int width, int height) {
+     *             surfaceChanged(nativeInstance, width, height);
+     *         }
+     *
+     *         {@literal @Override}
+     *         public void onDrawFrame(GL10 gl) {
+     *             onDraw(nativeInstance);
+     *         }
+     *     }
+     * }
+     * </pre>
+     *     Jni Header file:
+     * <pre class="prettyprint">
+     * class Example {
+     *     class JVM_MANAGER {
+     *     public:
+     *         JavaVM * jvm;
+     *         JNIEnv* jenv;
+     *         JavaVMAttachArgs jvmArgs;
+     *         bool needsToDetach;
+     *
+     *         JVM_MANAGER();
+     *         bool getJVM(JNIEnv * env);
+     *         bool attachJVM();
+     *         void detachJVM();
+     *
+     *         template <typename J, typename O> O globalRef(J j, O o) {
+     *             return reinterpret_cast<O>(j->NewGlobalRef(o));
+     *         }
+     *     };
+     *
+     *
+     *     JVM_MANAGER jvmManager;
+     *     jobject jObject;
+     *     jclass jClass;
+     *     jmethodID jSwapBuffers;
+     * }
+     * </pre>
+     *     Jni CPP file:
+     * <pre class="prettyprint">
+     * Example::JVM_MANAGER::JVM_MANAGER() {
+     *     jvm = nullptr;
+     *     jenv = nullptr;
+     *     needsToDetach = false;
+     *     jvmArgs.version = JNI_VERSION_1_6;
+     * }
+     *
+     * bool Example::JVM_MANAGER::getJVM(JNIEnv *env) {
+     *     return env->GetJavaVM(&jvm) == JNI_OK;
+     * }
+     *
+     * bool Example::JVM_MANAGER::attachJVM() {
+     *     // checks if current env needs attaching or it is already attached
+     *     jint res = jvm->GetEnv((void**)&jenv, JNI_VERSION_1_6);
+     *     if (res == JNI_EDETACHED) {
+     *         // Supported but not attached yet, needs to call AttachCurrentThread
+     *         res = jvm->AttachCurrentThread(&jenv, &jvmArgs);
+     *         if (res == JNI_OK) {
+     *             needsToDetach = true;
+     *         } else {
+     *             // Failed to attach, cancel
+     *             return false;
+     *         }
+     *     } else if (JNI_OK == res) {
+     *         // Current thread already attached, do not attach 'again' (just to save the attachedHere flag)
+     *         // We make sure to keep attached = 0
+     *         needsToDetach = false;
+     *     } else {
+     *         // JNI_EVERSION, specified version is not supported cancel this..
+     *         return false;
+     *     }
+     *     return true;
+     * }
+     *
+     * void Example::JVM_MANAGER::detachJVM() {
+     *     if (needsToDetach) {
+     *         jvm->DetachCurrentThread();
+     *     }
+     * }
+     * 
+     * Example::Example(JNIEnv *jenv, jobject classInstance, jstring name, jstring signature) {
+     *     if (!jvmManager.getJVM(jenv)) {
+     *         // failed to get JavaVM
+     *         return;
+     *     }
+     *     if (!jvmManager.attachJVM()) {
+     *         // failed to attach JVM
+     *         return;
+     *     }
+     *     jObject = jvmManager.globalRef(jenv, classInstance);
+     *     jClass = jvmManager.globalRef(jenv, jenv->GetObjectClass(jObject));
+     *     jboolean isCopy1, isCopy2;
+     *
+     *     if (name == nullptr) {
+     *          // cannot use a null name (0x0)
+     *         return;
+     *     }
+     *
+     *     if (signature == nullptr) {
+     *         // cannot use a null signature (0x0)
+     *         return;
+     *     }
+     *
+     *     const char * n = jvmManager.jenv->GetStringUTFChars(name, &isCopy1);
+     *     if (n == nullptr) {
+     *         // cannot get UTF chars from name
+     *         return;
+     *     }
+     *
+     *     const char * s = jvmManager.jenv->GetStringUTFChars(signature, &isCopy2);
+     *     if (s == nullptr) {
+     *         // cannot get UTF chars from signature
+     *         jvmManager.jenv->ReleaseStringUTFChars(name, n);
+     *         return;
+     *     }
+     *
+     *     jSwapBuffers = jvmManager.jenv->GetMethodID(jClass, n, s);
+     *
+     *     jvmManager.jenv->ReleaseStringUTFChars(name, n);
+     *     jvmManager.jenv->ReleaseStringUTFChars(name, s);
+     *
+     *     if (jSwapBuffers == nullptr) {
+     *         // cannot find method with name 'name', and signature 'signature'
+     *     }
+     * }
+     *
+     * Example::~Example() {
+     *     jvmManager.jenv->DeleteGlobalRef(jClass);
+     *     jvmManager.jenv->DeleteGlobalRef(jObject);
+     *     jvmManager.detachJVM();
+     * }
+     *
+     * void Example::swapBuffers() {
+     *     if (jSwapBuffers != nullptr) {
+     *         jvmManager.jenv->CallVoidMethod(jObject, jSwapBuffers);
+     *     }
+     * }
+     * </pre>
+     */
+    protected final void swapBuffers() {
+        synchronized (VSYNC_LOCK) {
+            if (!shouldSwap) {
+                shouldSwap = true;
+            }
+        }
+    }
+
+    @CallSuper
+    protected void init() {
+        shouldSwap = false;
+
+        // provides info for jni to java
+        methods = new Methods();
+
+        choreographer.postFrameCallback(
+                new Choreographer.FrameCallback() {
+                    /**
+                     * Called when a new display frame is being rendered.
+                     * <p>
+                     * This method provides the time in nanoseconds when the frame started being rendered.
+                     * The frame time provides a stable time base for synchronizing animations
+                     * and drawing.  It should be used instead of {@link SystemClock#uptimeMillis()}
+                     * or {@link System#nanoTime()} for animations and drawing in the UI.  Using the frame
+                     * time helps to reduce inter-frame jitter because the frame time is fixed at the time
+                     * the frame was scheduled to start, regardless of when the animations or drawing
+                     * callback actually runs.  All callbacks that run as part of rendering a frame will
+                     * observe the same frame time so using the frame time also helps to synchronize effects
+                     * that are performed by different callbacks.
+                     * </p><p>
+                     * Please note that the framework already takes care to process animations and
+                     * drawing using the frame time as a stable time base.  Most applications should
+                     * not need to use the frame time information directly.
+                     * </p>
+                     *
+                     * @param frameTimeNanos The time in nanoseconds when the frame started being rendered,
+                     *                       in the {@link System#nanoTime()} timebase.  Divide this value by {@code 1000000}
+                     *                       to convert it to the {@link SystemClock#uptimeMillis()} time base.
+                     */
+                    @Override
+                    public void doFrame(long frameTimeNanos) {
+                        synchronized (VSYNC_LOCK) {
+                            vsynced = true;
+                            mGLThread.requestRender();
+                        }
+                        choreographer.postFrameCallback(this);
+                    }
+                }
+        );
+        super.getHolder().addCallback(this);
+    }
+
+    /**
+     * Set the glWrapper. If the glWrapper is not null, its
+     * {@link GLWrapper#wrap(GL)} method is called
+     * whenever a surface is created. A GLWrapper can be used to wrap
+     * the GL object that's passed to the renderer. Wrapping a GL
+     * object enables examining and modifying the behavior of the
+     * GL calls made by the renderer.
+     * <p>
+     * Wrapping is typically used for debugging purposes.
+     * <p>
+     * The default value is null.
+     * @param glWrapper the new GLWrapper
+     */
+    public void setGLWrapper(GLWrapper glWrapper) {
+        mGLWrapper = glWrapper;
+    }
+
+    /**
+     * Set the debug flags to a new value. The value is
+     * constructed by OR-together zero or more
+     * of the DEBUG_CHECK_* constants. The debug flags take effect
+     * whenever a surface is created. The default value is zero.
+     * @param debugFlags the new debug flags
+     * @see #DEBUG_CHECK_GL_ERROR
+     * @see #DEBUG_LOG_GL_CALLS
+     */
+    public void setDebugFlags(int debugFlags) {
+        mDebugFlags = debugFlags;
+    }
+
+    /**
+     * Get the current value of the debug flags.
+     * @return the current value of the debug flags.
+     */
+    public int getDebugFlags() {
+        return mDebugFlags;
+    }
+
+    /**
+     * Control whether the EGL context is preserved when the EGLSurfaceView is paused and
+     * resumed.
+     * <p>
+     * If set to true, then the EGL context may be preserved when the EGLSurfaceView is paused.
+     * Whether the EGL context is actually preserved or not depends upon whether the
+     * Android device that the program is running on can support an arbitrary number of EGL
+     * contexts or not. Devices that can only support a limited number of EGL contexts must
+     * release the  EGL context in order to allow multiple applications to share the GPU.
+     * <p>
+     * If set to false, the EGL context will be released when the EGLSurfaceView is paused,
+     * and recreated when the EGLSurfaceView is resumed.
+     * <p>
+     *
+     * The default is false.
+     *
+     * @param preserveOnPause preserve the EGL context when paused
+     */
+    public void setPreserveEGLContextOnPause(boolean preserveOnPause) {
+        mPreserveEGLContextOnPause = preserveOnPause;
+    }
+
+    /**
+     * @return true if the EGL context will be preserved when paused
+     */
+    public boolean getPreserveEGLContextOnPause() {
+        return mPreserveEGLContextOnPause;
+    }
+
+    /**
+     * Set the renderer associated with this view. Also starts the thread that
+     * will call the renderer, which in turn causes the rendering to start.
+     * <p>This method should be called once and only once in the life-cycle of
+     * a EGLSurfaceView.
+     * <p>The following EGLSurfaceView methods can only be called <em>before</em>
+     * setRenderer is called:
+     * <ul>
+     * <li>{@link #setEGLConfigChooser(boolean)}
+     * <li>{@link #setEGLConfigChooser(EGLConfigChooser)}
+     * <li>{@link #setEGLConfigChooser(int, int, int, int, int, int)}
+     * </ul>
+     * <p>
+     * The following EGLSurfaceView methods can only be called <em>after</em>
+     * setRenderer is called:
+     * <ul>
+     * <li>{@link #getRenderMode()}
+     * <li>{@link #onPause()}
+     * <li>{@link #onResume()}
+     * <li>{@link #queueEvent(Runnable)}
+     * <li>{@link #swapBuffers()}
+     * <li>{@link #setRenderMode(int)}
+     * </ul>
+     *
+     * @param renderer the renderer to use to perform OpenGL drawing.
+     */
+    public void setRenderer(Renderer renderer) {
+        checkRenderThreadState();
+        if (mEGLConfigChooser == null) {
+            mEGLConfigChooser = new SimpleEGLConfigChooser(true);
+        }
+        if (mEGLContextFactory == null) {
+            mEGLContextFactory = new DefaultContextFactory();
+        }
+        if (mEGLWindowSurfaceFactory == null) {
+            mEGLWindowSurfaceFactory = new DefaultWindowSurfaceFactory();
+        }
+        mRenderer = renderer;
+        mGLThread = new GLThread(mThisWeakRef);
+        mGLThread.start();
+    }
+
+    /**
+     * Install a custom EGLContextFactory.
+     * <p>If this method is
+     * called, it must be called before {@link #setRenderer(Renderer)}
+     * is called.
+     * <p>
+     * If this method is not called, then by default
+     * a context will be created with no shared context and
+     * with a null attribute list.
+     */
+    public void setEGLContextFactory(EGLContextFactory factory) {
+        checkRenderThreadState();
+        mEGLContextFactory = factory;
+    }
+
+    /**
+     * Install a custom EGLWindowSurfaceFactory.
+     * <p>If this method is
+     * called, it must be called before {@link #setRenderer(Renderer)}
+     * is called.
+     * <p>
+     * If this method is not called, then by default
+     * a window surface will be created with a null attribute list.
+     */
+    public void setEGLWindowSurfaceFactory(EGLWindowSurfaceFactory factory) {
+        checkRenderThreadState();
+        mEGLWindowSurfaceFactory = factory;
+    }
+
+    /**
+     * Install a custom EGLConfigChooser.
+     * <p>If this method is
+     * called, it must be called before {@link #setRenderer(Renderer)}
+     * is called.
+     * <p>
+     * If no setEGLConfigChooser method is called, then by default the
+     * view will choose an EGLConfig that is compatible with the current
+     * android.view.Surface, with a depth buffer depth of
+     * at least 16 bits.
+     * @param configChooser
+     */
+    public void setEGLConfigChooser(EGLConfigChooser configChooser) {
+        checkRenderThreadState();
+        mEGLConfigChooser = configChooser;
+    }
+
+    /**
+     * Install a config chooser which will choose a config
+     * as close to 16-bit RGB as possible, with or without an optional depth
+     * buffer as close to 16-bits as possible.
+     * <p>If this method is
+     * called, it must be called before {@link #setRenderer(Renderer)}
+     * is called.
+     * <p>
+     * If no setEGLConfigChooser method is called, then by default the
+     * view will choose an RGB_888 surface with a depth buffer depth of
+     * at least 16 bits.
+     *
+     * @param needDepth
+     */
+    public void setEGLConfigChooser(boolean needDepth) {
+        setEGLConfigChooser(new SimpleEGLConfigChooser(needDepth));
+    }
+
+    /**
+     * Install a config chooser which will choose a config
+     * with at least the specified depthSize and stencilSize,
+     * and exactly the specified redSize, greenSize, blueSize and alphaSize.
+     * <p>If this method is
+     * called, it must be called before {@link #setRenderer(Renderer)}
+     * is called.
+     * <p>
+     * If no setEGLConfigChooser method is called, then by default the
+     * view will choose an RGB_888 surface with a depth buffer depth of
+     * at least 16 bits.
+     *
+     */
+    public void setEGLConfigChooser(int redSize, int greenSize, int blueSize,
+                                    int alphaSize, int depthSize, int stencilSize) {
+        setEGLConfigChooser(new ComponentSizeChooser(redSize, greenSize,
+                blueSize, alphaSize, depthSize, stencilSize));
+    }
+
+    /**
+     * Inform the default EGLContextFactory and default EGLConfigChooser
+     * which EGLContext client version to pick.
+     * <p>Use this method to create an OpenGL ES 2.0-compatible context.
+     * Example:
+     * <pre class="prettyprint">
+     *     public MyView(Context context) {
+     *         super(context);
+     *         setEGLContextClientVersion(2); // Pick an OpenGL ES 2.0 context.
+     *         setRenderer(new MyRenderer());
+     *     }
+     * </pre>
+     * <p>Note: Activities which require OpenGL ES 2.0 should indicate this by
+     * setting @lt;uses-feature android:glEsVersion="0x00020000" /> in the activity's
+     * AndroidManifest.xml file.
+     * <p>If this method is called, it must be called before {@link #setRenderer(Renderer)}
+     * is called.
+     * <p>This method only affects the behavior of the default EGLContexFactory and the
+     * default EGLConfigChooser. If
+     * {@link #setEGLContextFactory(EGLContextFactory)} has been called, then the supplied
+     * EGLContextFactory is responsible for creating an OpenGL ES 2.0-compatible context.
+     * If
+     * {@link #setEGLConfigChooser(EGLConfigChooser)} has been called, then the supplied
+     * EGLConfigChooser is responsible for choosing an OpenGL ES 2.0-compatible config.
+     * @param version The EGLContext client version to choose. Use 2 for OpenGL ES 2.0
+     */
+    public void setEGLContextClientVersion(int version) {
+        checkRenderThreadState();
+        mEGLContextClientVersion = version;
+    }
+
+    int mRendermode;
+
+    /**
+     * Set the rendering mode. When renderMode is
+     * RENDERMODE_CONTINUOUSLY, the renderer is called
+     * repeatedly to re-render the scene. When renderMode
+     * is RENDERMODE_WHEN_DIRTY, the renderer only rendered when the surface
+     * is created, or when {@link #swapBuffers} is called. Defaults to RENDERMODE_CONTINUOUSLY.
+     * <p>
+     * Using RENDERMODE_WHEN_DIRTY can improve battery life and overall system performance
+     * by allowing the GPU and CPU to idle when the view does not need to be updated.
+     * <p>
+     * This method can only be called after {@link #setRenderer(Renderer)}
+     * <p>
+     *
+     * @deprecated This has no effect on rendering.
+     * @param renderMode one of the RENDERMODE_X constants
+     * @see #RENDERMODE_CONTINUOUSLY
+     * @see #RENDERMODE_WHEN_DIRTY
+     */
+    public void setRenderMode(int renderMode) {
+        mRendermode = renderMode;
+    }
+
+    /**
+     * Get the current rendering mode. May be called
+     * from any thread. Must not be called before a renderer has been set.
+     *
+     * @deprecated This has no effect on rendering.
+     * @return the current rendering mode.
+     * @see #RENDERMODE_CONTINUOUSLY
+     * @see #RENDERMODE_WHEN_DIRTY
+     */
+    public int getRenderMode() {
+        return mRendermode;
+    }
+
+    /**
+     * Request that the renderer render a frame.
+     * This method is typically used when the render mode has been set to
+     * {@link #RENDERMODE_WHEN_DIRTY}, so that frames are only rendered on demand.
+     * May be called
+     * from any thread. Must not be called before a renderer has been set.
+     * <br><br>
+     * this calls {@link #swapBuffers}
+     * @see #swapBuffers
+     */
+    public void requestRender() {
+        swapBuffers();
+    }
+
+    /**
+     * This is called immediately after the surface is first created.
+     * Implementations of this should start up whatever rendering code
+     * they desire.  Note that only one thread can ever draw into
+     * a {@link Surface}, so you should not draw into the Surface here
+     * if your normal rendering will be in another thread.
+     *
+     * @param holder The SurfaceHolder whose surface is being created.
+     */
+    @Override
+    final public void surfaceCreated(@NonNull SurfaceHolder holder) {
+        mGLThread.surfaceCreated();
+    }
+
+    /**
+     * This is called immediately after any structural changes (format or
+     * size) have been made to the surface.  You should at this point update
+     * the imagery in the surface.  This method is always called at least
+     * once, after {@link #surfaceCreated}.
+     *
+     * @param holder The SurfaceHolder whose surface has changed.
+     * @param format The new {@link PixelFormat} of the surface.
+     * @param width  The new width of the surface.
+     * @param height The new height of the surface.
+     */
+    @Override
+    final public void surfaceChanged(@NonNull SurfaceHolder holder, int format, int width, int height) {
+        mGLThread.onWindowResize(width, height);
+    }
+
+    /**
+     * This is called immediately before a surface is being destroyed. After
+     * returning from this call, you should no longer try to access this
+     * surface.  If you have a rendering thread that directly accesses
+     * the surface, you must ensure that thread is no longer touching the
+     * Surface before returning from this function.
+     *
+     * @param holder The SurfaceHolder whose surface is being destroyed.
+     */
+    @Override
+    final public void surfaceDestroyed(@NonNull SurfaceHolder holder) {
+        // Surface will be destroyed when we return
+        mGLThread.surfaceDestroyed();
+        if(null != mRenderer) {
+            mRenderer.onSurfaceDestroyed();
+        }
+    }
+
+    /**
+     * Inform the view that the activity is paused. The owner of this view must
+     * call this method when the activity is paused. Calling this method will
+     * pause the rendering thread.
+     * Must not be called before a renderer has been set.
+     */
+    @CallSuper
+    public void onPause() {
+        mGLThread.onPause();
+    }
+
+    /**
+     * Inform the view that the activity is resumed. The owner of this view must
+     * call this method when the activity is resumed. Calling this method will
+     * recreate the OpenGL display and resume the rendering
+     * thread.
+     * Must not be called before a renderer has been set.
+     */
+    @CallSuper
+    public void onResume() {
+        mGLThread.onResume();
+    }
+
+    /**
+     * Queue a runnable to be run on the GL rendering thread. This can be used
+     * to communicate with the Renderer on the rendering thread.
+     * Must not be called before a renderer has been set.
+     * @param r the runnable to be run on the GL rendering thread.
+     */
+    @CallSuper
+    public void queueEvent(Runnable r) {
+        mGLThread.queueEvent(r);
+    }
+
+    /**
+     * This method is used as part of the View class and is not normally
+     * called or subclassed by clients of EGLSurfaceView.
+     */
+    @Override
+    @CallSuper
+    protected void onAttachedToWindow() {
+        super.onAttachedToWindow();
+        if (LOG_ATTACH_DETACH) {
+            Log.d(TAG, "onAttachedToWindow reattach =" + mDetached);
+        }
+        if (mDetached && (mRenderer != null)) {
+            mGLThread = new GLThread(mThisWeakRef);
+            mGLThread.start();
+        }
+        mDetached = false;
+    }
+
+    @Override
+    @CallSuper
+    protected void onDetachedFromWindow() {
+        if (LOG_ATTACH_DETACH) {
+            Log.d(TAG, "onDetachedFromWindow");
+        }
+        if (mGLThread != null) {
+            mGLThread.requestExitAndWait();
+        }
+        mDetached = true;
+        super.onDetachedFromWindow();
+    }
+
+    // ----------------------------------------------------------------------
+
+    /**
+     * An interface used to wrap a GL interface.
+     * <p>Typically
+     * used for implementing debugging and tracing on top of the default
+     * GL interface. You would typically use this by creating your own class
+     * that implemented all the GL methods by delegating to another GL instance.
+     * Then you could add your own behavior before or after calling the
+     * delegate. All the GLWrapper would do was instantiate and return the
+     * wrapper GL instance:
+     * <pre class="prettyprint">
+     * class MyGLWrapper implements GLWrapper {
+     *     GL wrap(GL gl) {
+     *         return new MyGLImplementation(gl);
+     *     }
+     *     static class MyGLImplementation implements GL,GL10,GL11,... {
+     *         ...
+     *     }
+     * }
+     * </pre>
+     * @see #setGLWrapper(GLWrapper)
+     */
+    public interface GLWrapper {
+        /**
+         * Wraps a gl interface in another gl interface.
+         * @param gl a GL interface that is to be wrapped.
+         * @return either the input argument or another GL object that wraps the input argument.
+         */
+        GL wrap(GL gl);
+    }
+
+    /**
+     * A generic renderer interface.
+     * <p>
+     * The renderer is responsible for making OpenGL calls to render a frame.
+     * <p>
+     * EGLSurfaceView clients typically create their own classes that implement
+     * this interface, and then call {@link EGLSurfaceView#setRenderer} to
+     * register the renderer with the EGLSurfaceView.
+     * <p>
+     *
+     * <div class="special reference">
+     * <h3>Developer Guides</h3>
+     * <p>For more information about how to use OpenGL, read the
+     * <a href="{@docRoot}guide/topics/graphics/opengl.html">OpenGL</a> developer guide.</p>
+     * </div>
+     *
+     * <h3>Threading</h3>
+     * The renderer will be called on a separate thread, so that rendering
+     * performance is decoupled from the UI thread. Clients typically need to
+     * communicate with the renderer from the UI thread, because that's where
+     * input events are received. Clients can communicate using any of the
+     * standard Java techniques for cross-thread communication, or they can
+     * use the {@link EGLSurfaceView#queueEvent(Runnable)} convenience method.
+     * <p>
+     * <h3>EGL Context Lost</h3>
+     * There are situations where the EGL rendering context will be lost. This
+     * typically happens when device wakes up after going to sleep. When
+     * the EGL context is lost, all OpenGL resources (such as textures) that are
+     * associated with that context will be automatically deleted. In order to
+     * keep rendering correctly, a renderer must recreate any lost resources
+     * that it still needs. The {@link #onSurfaceCreated(GL10, EGLConfig)} method
+     * is a convenient place to do this.
+     *
+     *
+     * @see #setRenderer(Renderer)
+     */
+    public interface Renderer {
+        /**
+         * Called when the surface is created or recreated.
+         * <p>
+         * Called when the rendering thread
+         * starts and whenever the EGL context is lost. The EGL context will typically
+         * be lost when the Android device awakes after going to sleep.
+         * <p>
+         * Since this method is called at the beginning of rendering, as well as
+         * every time the EGL context is lost, this method is a convenient place to put
+         * code to create resources that need to be created when the rendering
+         * starts, and that need to be recreated when the EGL context is lost.
+         * Textures are an example of a resource that you might want to create
+         * here.
+         * <p>
+         * Note that when the EGL context is lost, all OpenGL resources associated
+         * with that context will be automatically deleted. You do not need to call
+         * the corresponding "glDelete" methods such as glDeleteTextures to
+         * manually delete these lost resources.
+         * <p>
+         * @param gl the GL interface. Use <code>instanceof</code> to
+         * test if the interface supports GL11 or higher interfaces.
+         * @param config the EGLConfig of the created surface. Can be used
+         * to create matching pbuffers.
+         */
+        default void onSurfaceCreated(GL10 gl, EGLConfig config) {}
+
+        /**
+         * Called when the surface changed size.
+         * <p>
+         * Called after the surface is created and whenever
+         * the OpenGL ES surface size changes.
+         * <p>
+         * Typically you will set your viewport here. If your camera
+         * is fixed then you could also set your projection matrix here:
+         * <pre class="prettyprint">
+         * void onSurfaceChanged(GL10 gl, int width, int height) {
+         *     gl.glViewport(0, 0, width, height);
+         *     // for a fixed camera, set the projection too
+         *     float ratio = (float) width / height;
+         *     gl.glMatrixMode(GL10.GL_PROJECTION);
+         *     gl.glLoadIdentity();
+         *     gl.glFrustumf(-ratio, ratio, -1, 1, 1, 10);
+         * }
+         * </pre>
+         * @param gl the GL interface. Use <code>instanceof</code> to
+         * test if the interface supports GL11 or higher interfaces.
+         * @param width surface width
+         * @param height surface height
+         */
+        void onSurfaceChanged(GL10 gl, int width, int height);
+
+        /**
+         * Called to draw the current frame.
+         * <p>
+         * This method is responsible for drawing the current frame.
+         * <p>
+         * The implementation of this method typically looks like this:
+         * <pre class="prettyprint">
+         * void onDrawFrame(GL10 gl) {
+         *     gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
+         *     //... other gl calls to render the scene ...
+         *     swapBuffers();
+         * }
+         * </pre>
+         * @param gl the GL interface. Use <code>instanceof</code> to
+         * test if the interface supports GL11 or higher interfaces.
+         *
+         * @implSpec you must call {@link #swapBuffers()} to draw anything
+         * @see #swapBuffers()
+         */
+        void onDrawFrame(GL10 gl);
+
+        default void onSurfaceDestroyed() {}
+
+        /**
+         * Called when the EGL context is made current
+         */
+        default void onEglSetup() {}
+
+        /**
+         * Called before the EGL context is lost
+         */
+        default void onEglTearDown() {}
+
+    }
+
+    /**
+     * An interface for customizing the eglCreateContext and eglDestroyContext calls.
+     * <p>
+     * This interface must be implemented by clients wishing to call
+     * {@link EGLSurfaceView#setEGLContextFactory(EGLContextFactory)}
+     */
+    public interface EGLContextFactory {
+        EGLContext createContext(EGL10 egl, EGLDisplay display, EGLConfig eglConfig);
+        void destroyContext(EGL10 egl, EGLDisplay display, EGLContext context);
+    }
+
+    private class DefaultContextFactory implements EGLContextFactory {
+        private int EGL_CONTEXT_CLIENT_VERSION = 0x3098;
+
+        public EGLContext createContext(EGL10 egl, EGLDisplay display, EGLConfig config) {
+            int[] attrib_list = {EGL_CONTEXT_CLIENT_VERSION, mEGLContextClientVersion,
+                    EGL10.EGL_NONE };
+
+            return egl.eglCreateContext(display, config, EGL10.EGL_NO_CONTEXT,
+                    mEGLContextClientVersion != 0 ? attrib_list : null);
+        }
+
+        public void destroyContext(EGL10 egl, EGLDisplay display,
+                                   EGLContext context) {
+            if (!egl.eglDestroyContext(display, context)) {
+                Log.e("DefaultContextFactory", "display:" + display + " context: " + context);
+                if (LOG_THREADS) {
+                    Log.i("DefaultContextFactory", "tid=" + Thread.currentThread().getId());
+                }
+                EglHelper.throwEglException("eglDestroyContex", egl.eglGetError());
+            }
+        }
+    }
+
+    /**
+     * An interface for customizing the eglCreateWindowSurface and eglDestroySurface calls.
+     * <p>
+     * This interface must be implemented by clients wishing to call
+     * {@link EGLSurfaceView#setEGLWindowSurfaceFactory(EGLWindowSurfaceFactory)}
+     */
+    public interface EGLWindowSurfaceFactory {
+        /**
+         *  @return null if the surface cannot be constructed.
+         */
+        EGLSurface createWindowSurface(EGL10 egl, EGLDisplay display, EGLConfig config,
+                                       Object nativeWindow);
+        void destroySurface(EGL10 egl, EGLDisplay display, EGLSurface surface);
+    }
+
+    private static class DefaultWindowSurfaceFactory implements EGLWindowSurfaceFactory {
+
+        public EGLSurface createWindowSurface(EGL10 egl, EGLDisplay display,
+                                              EGLConfig config, Object nativeWindow) {
+            EGLSurface result = null;
+            try {
+                result = egl.eglCreateWindowSurface(display, config, nativeWindow, null);
+            } catch (IllegalArgumentException e) {
+                // This exception indicates that the surface flinger surface
+                // is not valid. This can happen if the surface flinger surface has
+                // been torn down, but the application has not yet been
+                // notified via SurfaceHolder.Callback.surfaceDestroyed.
+                // In theory the application should be notified first,
+                // but in practice sometimes it is not. See b/4588890
+                Log.e(TAG, "eglCreateWindowSurface", e);
+            }
+            return result;
+        }
+
+        public void destroySurface(EGL10 egl, EGLDisplay display,
+                                   EGLSurface surface) {
+            egl.eglDestroySurface(display, surface);
+        }
+    }
+
+    /**
+     * An interface for choosing an EGLConfig configuration from a list of
+     * potential configurations.
+     * <p>
+     * This interface must be implemented by clients wishing to call
+     * {@link EGLSurfaceView#setEGLConfigChooser(EGLConfigChooser)}
+     */
+    public interface EGLConfigChooser {
+        /**
+         * Choose a configuration from the list. Implementors typically
+         * implement this method by calling
+         * {@link EGL10#eglChooseConfig} and iterating through the results. Please consult the
+         * EGL specification available from The Khronos Group to learn how to call eglChooseConfig.
+         * @param egl the EGL10 for the current display.
+         * @param display the current display.
+         * @return the chosen configuration.
+         */
+        EGLConfig chooseConfig(EGL10 egl, EGLDisplay display);
+    }
+
+    private abstract class BaseConfigChooser
+            implements EGLConfigChooser {
+        public BaseConfigChooser(int[] configSpec) {
+            mConfigSpec = filterConfigSpec(configSpec);
+        }
+
+        public EGLConfig chooseConfig(EGL10 egl, EGLDisplay display) {
+            int[] num_config = new int[1];
+            if (!egl.eglChooseConfig(display, mConfigSpec, null, 0,
+                    num_config)) {
+                throw new IllegalArgumentException("eglChooseConfig failed");
+            }
+
+            int numConfigs = num_config[0];
+
+            if (numConfigs <= 0) {
+                throw new IllegalArgumentException(
+                        "No configs match configSpec");
+            }
+
+            EGLConfig[] configs = new EGLConfig[numConfigs];
+            if (!egl.eglChooseConfig(display, mConfigSpec, configs, numConfigs,
+                    num_config)) {
+                throw new IllegalArgumentException("eglChooseConfig#2 failed");
+            }
+            EGLConfig config = chooseConfig(egl, display, configs);
+            if (config == null) {
+                throw new IllegalArgumentException("No config chosen");
+            }
+            return config;
+        }
+
+        abstract EGLConfig chooseConfig(EGL10 egl, EGLDisplay display,
+                                        EGLConfig[] configs);
+
+        protected int[] mConfigSpec;
+
+        private int[] filterConfigSpec(int[] configSpec) {
+            if (mEGLContextClientVersion != 2 && mEGLContextClientVersion != 3) {
+                return configSpec;
+            }
+            /* We know none of the subclasses define EGL_RENDERABLE_TYPE.
+             * And we know the configSpec is well formed.
+             */
+            int len = configSpec.length;
+            int[] newConfigSpec = new int[len + 2];
+            System.arraycopy(configSpec, 0, newConfigSpec, 0, len-1);
+            newConfigSpec[len-1] = EGL10.EGL_RENDERABLE_TYPE;
+            if (mEGLContextClientVersion == 2) {
+                newConfigSpec[len] = EGL14.EGL_OPENGL_ES2_BIT;  /* EGL_OPENGL_ES2_BIT */
+            } else {
+                newConfigSpec[len] = EGLExt.EGL_OPENGL_ES3_BIT_KHR; /* EGL_OPENGL_ES3_BIT_KHR */
+            }
+            newConfigSpec[len+1] = EGL10.EGL_NONE;
+            return newConfigSpec;
+        }
+    }
+
+    /**
+     * Choose a configuration with exactly the specified r,g,b,a sizes,
+     * and at least the specified depth and stencil sizes.
+     */
+    private class ComponentSizeChooser extends BaseConfigChooser {
+        public ComponentSizeChooser(int redSize, int greenSize, int blueSize,
+                                    int alphaSize, int depthSize, int stencilSize) {
+            super(new int[] {
+                    EGL10.EGL_RED_SIZE, redSize,
+                    EGL10.EGL_GREEN_SIZE, greenSize,
+                    EGL10.EGL_BLUE_SIZE, blueSize,
+                    EGL10.EGL_ALPHA_SIZE, alphaSize,
+                    EGL10.EGL_DEPTH_SIZE, depthSize,
+                    EGL10.EGL_STENCIL_SIZE, stencilSize,
+                    EGL10.EGL_NONE});
+            mValue = new int[1];
+            mRedSize = redSize;
+            mGreenSize = greenSize;
+            mBlueSize = blueSize;
+            mAlphaSize = alphaSize;
+            mDepthSize = depthSize;
+            mStencilSize = stencilSize;
+        }
+
+        @Override
+        public EGLConfig chooseConfig(EGL10 egl, EGLDisplay display,
+                                      EGLConfig[] configs) {
+            for (EGLConfig config : configs) {
+                int d = findConfigAttrib(egl, display, config,
+                        EGL10.EGL_DEPTH_SIZE, 0);
+                int s = findConfigAttrib(egl, display, config,
+                        EGL10.EGL_STENCIL_SIZE, 0);
+                if ((d >= mDepthSize) && (s >= mStencilSize)) {
+                    int r = findConfigAttrib(egl, display, config,
+                            EGL10.EGL_RED_SIZE, 0);
+                    int g = findConfigAttrib(egl, display, config,
+                            EGL10.EGL_GREEN_SIZE, 0);
+                    int b = findConfigAttrib(egl, display, config,
+                            EGL10.EGL_BLUE_SIZE, 0);
+                    int a = findConfigAttrib(egl, display, config,
+                            EGL10.EGL_ALPHA_SIZE, 0);
+                    if ((r == mRedSize) && (g == mGreenSize)
+                            && (b == mBlueSize) && (a == mAlphaSize)) {
+                        return config;
+                    }
+                }
+            }
+            return null;
+        }
+
+        private int findConfigAttrib(EGL10 egl, EGLDisplay display,
+                                     EGLConfig config, int attribute, int defaultValue) {
+
+            if (egl.eglGetConfigAttrib(display, config, attribute, mValue)) {
+                return mValue[0];
+            }
+            return defaultValue;
+        }
+
+        private int[] mValue;
+        // Subclasses can adjust these values:
+        protected int mRedSize;
+        protected int mGreenSize;
+        protected int mBlueSize;
+        protected int mAlphaSize;
+        protected int mDepthSize;
+        protected int mStencilSize;
+    }
+
+    /**
+     * This class will choose a RGB_888 surface with
+     * or without a depth buffer.
+     *
+     */
+    private class SimpleEGLConfigChooser extends ComponentSizeChooser {
+        public SimpleEGLConfigChooser(boolean withDepthBuffer) {
+            super(8, 8, 8, 0, withDepthBuffer ? 16 : 0, 0);
+        }
+    }
+
+    /**
+     * An EGL helper class.
+     */
+
+    private static class EglHelper {
+        public EglHelper(WeakReference<EGLSurfaceView> EGLSurfaceViewWeakRef) {
+            mEGLSurfaceViewWeakRef = EGLSurfaceViewWeakRef;
+        }
+
+        /**
+         * Initialize EGL for a given configuration spec.
+         */
+        public void start() {
+            if (LOG_EGL) {
+                Log.w("EglHelper", "start() tid=" + Thread.currentThread().getId());
+            }
+            /*
+             * Get an EGL instance
+             */
+            mEgl = (EGL10) EGLContext.getEGL();
+
+            /*
+             * Get to the default display.
+             */
+            mEglDisplay = mEgl.eglGetDisplay(EGL10.EGL_DEFAULT_DISPLAY);
+
+            if (mEglDisplay == EGL10.EGL_NO_DISPLAY) {
+                throw new RuntimeException("eglGetDisplay failed");
+            }
+
+            /*
+             * We can now initialize EGL for that display
+             */
+            int[] version = new int[2];
+            if(!mEgl.eglInitialize(mEglDisplay, version)) {
+                throw new RuntimeException("eglInitialize failed");
+            }
+            EGLSurfaceView view = mEGLSurfaceViewWeakRef.get();
+            if (view == null) {
+                mEglConfig = null;
+                mEglContext = null;
+            } else {
+                mEglConfig = view.mEGLConfigChooser.chooseConfig(mEgl, mEglDisplay);
+
+                /*
+                 * Create an EGL context. We want to do this as rarely as we can, because an
+                 * EGL context is a somewhat heavy object.
+                 */
+                mEglContext = view.mEGLContextFactory.createContext(mEgl, mEglDisplay, mEglConfig);
+            }
+            if (mEglContext == null || mEglContext == EGL10.EGL_NO_CONTEXT) {
+                mEglContext = null;
+                throwEglException("createContext");
+            }
+            if (LOG_EGL) {
+                Log.w("EglHelper", "createContext " + mEglContext + " tid=" + Thread.currentThread().getId());
+            }
+
+            mEglSurface = null;
+        }
+
+        /**
+         * Create an egl surface for the current SurfaceHolder surface. If a surface
+         * already exists, destroy it before creating the new surface.
+         *
+         * @return true if the surface was created successfully.
+         */
+        public boolean createSurface() {
+            if (LOG_EGL) {
+                Log.w("EglHelper", "createSurface()  tid=" + Thread.currentThread().getId());
+            }
+            /*
+             * Check preconditions.
+             */
+            if (mEgl == null) {
+                throw new RuntimeException("egl not initialized");
+            }
+            if (mEglDisplay == null) {
+                throw new RuntimeException("eglDisplay not initialized");
+            }
+            if (mEglConfig == null) {
+                throw new RuntimeException("mEglConfig not initialized");
+            }
+
+            /*
+             *  The window size has changed, so we need to create a new
+             *  surface.
+             */
+            destroySurfaceImp();
+
+            /*
+             * Create an EGL surface we can render into.
+             */
+            EGLSurfaceView view = mEGLSurfaceViewWeakRef.get();
+            if (view != null) {
+                mEglSurface = view.mEGLWindowSurfaceFactory.createWindowSurface(mEgl,
+                        mEglDisplay, mEglConfig, view.getHolder().getSurface());
+            } else {
+                mEglSurface = null;
+            }
+
+            if (mEglSurface == null || mEglSurface == EGL10.EGL_NO_SURFACE) {
+                int error = mEgl.eglGetError();
+                if (error == EGL10.EGL_BAD_NATIVE_WINDOW) {
+                    Log.e("EglHelper", "createWindowSurface returned EGL_BAD_NATIVE_WINDOW.");
+                }
+                return false;
+            }
+
+            /*
+             * Before we can issue GL commands, we need to make sure
+             * the context is current and bound to a surface.
+             */
+            if (!mEgl.eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface, mEglContext)) {
+                /*
+                 * Could not make the context current, probably because the underlying
+                 * SurfaceView surface has been destroyed.
+                 */
+                logEglErrorAsWarning("EGLHelper", "eglMakeCurrent", mEgl.eglGetError());
+                return false;
+            }
+
+            if (view != null) {
+                view.mRenderer.onEglSetup();
+            }
+
+            return true;
+        }
+
+        /**
+         * Create a GL object for the current EGL context.
+         * @return
+         */
+        GL createGL() {
+
+            GL gl = mEglContext.getGL();
+            EGLSurfaceView view = mEGLSurfaceViewWeakRef.get();
+            if (view != null) {
+                if (view.mGLWrapper != null) {
+                    gl = view.mGLWrapper.wrap(gl);
+                }
+
+                if ((view.mDebugFlags & (DEBUG_CHECK_GL_ERROR | DEBUG_LOG_GL_CALLS)) != 0) {
+                    int configFlags = 0;
+                    Writer log = null;
+                    if ((view.mDebugFlags & DEBUG_CHECK_GL_ERROR) != 0) {
+                        configFlags |= GLDebugHelper.CONFIG_CHECK_GL_ERROR;
+                    }
+                    if ((view.mDebugFlags & DEBUG_LOG_GL_CALLS) != 0) {
+                        log = new LogWriter();
+                    }
+                    gl = GLDebugHelper.wrap(gl, configFlags, log);
+                }
+            }
+            return gl;
+        }
+
+        /**
+         * Display the current render surface.
+         * @return the EGL error code from eglSwapBuffers.
+         */
+        public int swap() {
+            if (! mEgl.eglSwapBuffers(mEglDisplay, mEglSurface)) {
+                return mEgl.eglGetError();
+            }
+            return EGL10.EGL_SUCCESS;
+        }
+
+        public void destroySurface() {
+            if (LOG_EGL) {
+                Log.w("EglHelper", "destroySurface()  tid=" + Thread.currentThread().getId());
+            }
+            destroySurfaceImp();
+        }
+
+        private void destroySurfaceImp() {
+            if (mEglSurface != null && mEglSurface != EGL10.EGL_NO_SURFACE) {
+                EGLSurfaceView view = mEGLSurfaceViewWeakRef.get();
+                if (view != null) {
+                    view.mRenderer.onEglTearDown();
+                }
+                mEgl.eglMakeCurrent(mEglDisplay, EGL10.EGL_NO_SURFACE,
+                        EGL10.EGL_NO_SURFACE,
+                        EGL10.EGL_NO_CONTEXT);
+                if (view != null) {
+                    view.mEGLWindowSurfaceFactory.destroySurface(mEgl, mEglDisplay, mEglSurface);
+                }
+                mEglSurface = null;
+            }
+        }
+
+        public void finish() {
+            if (LOG_EGL) {
+                Log.w("EglHelper", "finish() tid=" + Thread.currentThread().getId());
+            }
+            if (mEglContext != null) {
+                EGLSurfaceView view = mEGLSurfaceViewWeakRef.get();
+                if (view != null) {
+                    view.mEGLContextFactory.destroyContext(mEgl, mEglDisplay, mEglContext);
+                }
+                mEglContext = null;
+            }
+            if (mEglDisplay != null) {
+                mEgl.eglTerminate(mEglDisplay);
+                mEglDisplay = null;
+            }
+        }
+
+        private void throwEglException(String function) {
+            throwEglException(function, mEgl.eglGetError());
+        }
+
+        public static void throwEglException(String function, int error) {
+            String message = formatEglError(function, error);
+            if (LOG_THREADS) {
+                Log.e("EglHelper", "throwEglException tid=" + Thread.currentThread().getId() + " "
+                        + message);
+            }
+            throw new RuntimeException(message);
+        }
+
+        public static void logEglErrorAsWarning(String tag, String function, int error) {
+            Log.w(tag, formatEglError(function, error));
+        }
+
+        public static String formatEglError(String function, int error) {
+            return function + " failed: " + eglGetErrorString(error);
+        }
+
+        static String eglGetErrorString(int error) {
+            switch (error) {
+                case EGL11.EGL_SUCCESS:
+                    return "EGL_SUCCESS";
+                case EGL11.EGL_NOT_INITIALIZED:
+                    return "EGL_NOT_INITIALIZED";
+                case EGL11.EGL_BAD_ACCESS:
+                    return "EGL_BAD_ACCESS";
+                case EGL11.EGL_BAD_ALLOC:
+                    return "EGL_BAD_ALLOC";
+                case EGL11.EGL_BAD_ATTRIBUTE:
+                    return "EGL_BAD_ATTRIBUTE";
+                case EGL11.EGL_BAD_CONFIG:
+                    return "EGL_BAD_CONFIG";
+                case EGL11.EGL_BAD_CONTEXT:
+                    return "EGL_BAD_CONTEXT";
+                case EGL11.EGL_BAD_CURRENT_SURFACE:
+                    return "EGL_BAD_CURRENT_SURFACE";
+                case EGL11.EGL_BAD_DISPLAY:
+                    return "EGL_BAD_DISPLAY";
+                case EGL11.EGL_BAD_MATCH:
+                    return "EGL_BAD_MATCH";
+                case EGL11.EGL_BAD_NATIVE_PIXMAP:
+                    return "EGL_BAD_NATIVE_PIXMAP";
+                case EGL11.EGL_BAD_NATIVE_WINDOW:
+                    return "EGL_BAD_NATIVE_WINDOW";
+                case EGL11.EGL_BAD_PARAMETER:
+                    return "EGL_BAD_PARAMETER";
+                case EGL11.EGL_BAD_SURFACE:
+                    return "EGL_BAD_SURFACE";
+                case EGL11.EGL_CONTEXT_LOST:
+                    return "EGL_CONTEXT_LOST";
+                default:
+                    return "0x" + Integer.toHexString(error);
+            }
+        }
+
+        private WeakReference<EGLSurfaceView> mEGLSurfaceViewWeakRef;
+        EGL10 mEgl;
+        EGLDisplay mEglDisplay;
+        EGLSurface mEglSurface;
+        EGLConfig mEglConfig;
+        EGLContext mEglContext;
+
+    }
+
+    /**
+     * A generic GL Thread. Takes care of initializing EGL and GL. Delegates
+     * to a Renderer instance to do the actual drawing. Can be configured to
+     * render continuously or on request.
+     *
+     * All potentially blocking synchronization is done through the
+     * sGLThreadManager object. This avoids multiple-lock ordering issues.
+     *
+     */
+    class GLThread extends Thread {
+        GLThread(WeakReference<EGLSurfaceView> EGLSurfaceViewWeakRef) {
+            super();
+            mWidth = 0;
+            mHeight = 0;
+            mRequestRender = true;
+            mEGLSurfaceViewWeakRef = EGLSurfaceViewWeakRef;
+        }
+
+        @Override
+        public void run() {
+            setName("GLThread " + getId());
+            if (LOG_THREADS) {
+                Log.i("GLThread", "starting tid=" + getId());
+            }
+
+            try {
+                guardedRun();
+            } catch (InterruptedException e) {
+                // fall through and exit normally
+            } finally {
+                sGLThreadManager.threadExiting(this);
+            }
+        }
+
+        /*
+         * This private method should only be called inside a
+         * synchronized(sGLThreadManager) block.
+         */
+        private void stopEglSurfaceLocked() {
+            if (mHaveEglSurface) {
+                mHaveEglSurface = false;
+                mEglHelper.destroySurface();
+            }
+        }
+
+        /*
+         * This private method should only be called inside a
+         * synchronized(sGLThreadManager) block.
+         */
+        private void stopEglContextLocked() {
+            if (mHaveEglContext) {
+                mEglHelper.finish();
+                mHaveEglContext = false;
+                sGLThreadManager.releaseEglContextLocked(this);
+            }
+        }
+        private void guardedRun() throws InterruptedException {
+            mEglHelper = new EglHelper(mEGLSurfaceViewWeakRef);
+            mHaveEglContext = false;
+            mHaveEglSurface = false;
+            try {
+                GL10 gl = null;
+                boolean createEglContext = false;
+                boolean createEglSurface = false;
+                boolean createGlInterface = false;
+                boolean lostEglContext = false;
+                boolean sizeChanged = false;
+                boolean wantRenderNotification = false;
+                boolean doRenderNotification = false;
+                boolean askedToReleaseEglContext = false;
+                int w = 0;
+                int h = 0;
+                Runnable event = null;
+
+                while (true) {
+                    synchronized (sGLThreadManager) {
+                        while (true) {
+                            if (mShouldExit) {
+                                return;
+                            }
+
+                            if (! mEventQueue.isEmpty()) {
+                                event = mEventQueue.remove(0);
+                                break;
+                            }
+
+                            // Update the pause state.
+                            boolean pausing = false;
+                            if (mPaused != mRequestPaused) {
+                                pausing = mRequestPaused;
+                                mPaused = mRequestPaused;
+                                sGLThreadManager.notifyAll();
+                                if (LOG_PAUSE_RESUME) {
+                                    Log.i("GLThread", "mPaused is now " + mPaused + " tid=" + getId());
+                                }
+                            }
+
+                            // Do we need to give up the EGL context?
+                            if (mShouldReleaseEglContext) {
+                                if (LOG_SURFACE) {
+                                    Log.i("GLThread", "releasing EGL context because asked to tid=" + getId());
+                                }
+                                stopEglSurfaceLocked();
+                                stopEglContextLocked();
+                                mShouldReleaseEglContext = false;
+                                askedToReleaseEglContext = true;
+                            }
+
+                            // Have we lost the EGL context?
+                            if (lostEglContext) {
+                                stopEglSurfaceLocked();
+                                stopEglContextLocked();
+                                lostEglContext = false;
+                            }
+
+                            // When pausing, release the EGL surface:
+                            if (pausing && mHaveEglSurface) {
+                                if (LOG_SURFACE) {
+                                    Log.i("GLThread", "releasing EGL surface because paused tid=" + getId());
+                                }
+                                stopEglSurfaceLocked();
+                            }
+
+                            // When pausing, optionally release the EGL Context:
+                            if (pausing && mHaveEglContext) {
+                                EGLSurfaceView view = mEGLSurfaceViewWeakRef.get();
+                                boolean preserveEglContextOnPause = view == null ?
+                                        false : view.mPreserveEGLContextOnPause;
+                                if (!preserveEglContextOnPause || sGLThreadManager.shouldReleaseEGLContextWhenPausing()) {
+                                    stopEglContextLocked();
+                                    if (LOG_SURFACE) {
+                                        Log.i("GLThread", "releasing EGL context because paused tid=" + getId());
+                                    }
+                                }
+                            }
+
+                            // When pausing, optionally terminate EGL:
+                            if (pausing) {
+                                if (sGLThreadManager.shouldTerminateEGLWhenPausing()) {
+                                    mEglHelper.finish();
+                                    if (LOG_SURFACE) {
+                                        Log.i("GLThread", "terminating EGL because paused tid=" + getId());
+                                    }
+                                }
+                            }
+
+                            // Have we lost the SurfaceView surface?
+                            if ((! mHasSurface) && (! mWaitingForSurface)) {
+                                if (LOG_SURFACE) {
+                                    Log.i("GLThread", "noticed SurfaceView surface lost tid=" + getId());
+                                }
+                                if (mHaveEglSurface) {
+                                    stopEglSurfaceLocked();
+                                }
+                                mWaitingForSurface = true;
+                                mSurfaceIsBad = false;
+                                sGLThreadManager.notifyAll();
+                            }
+
+                            // Have we acquired the surface view surface?
+                            if (mHasSurface && mWaitingForSurface) {
+                                if (LOG_SURFACE) {
+                                    Log.i("GLThread", "noticed SurfaceView surface acquired tid=" + getId());
+                                }
+                                mWaitingForSurface = false;
+                                sGLThreadManager.notifyAll();
+                            }
+
+                            if (doRenderNotification) {
+                                if (LOG_SURFACE) {
+                                    Log.i("GLThread", "sending render notification tid=" + getId());
+                                }
+                                wantRenderNotification = false;
+                                doRenderNotification = false;
+                                mRenderComplete = true;
+                                sGLThreadManager.notifyAll();
+                            }
+
+                            // Ready to draw?
+                            if (readyToDraw()) {
+
+                                // If we don't have an EGL context, try to acquire one.
+                                if (! mHaveEglContext) {
+                                    if (askedToReleaseEglContext) {
+                                        askedToReleaseEglContext = false;
+                                    } else if (sGLThreadManager.tryAcquireEglContextLocked(this)) {
+                                        try {
+                                            mEglHelper.start();
+                                        } catch (RuntimeException t) {
+                                            sGLThreadManager.releaseEglContextLocked(this);
+                                            throw t;
+                                        }
+                                        mHaveEglContext = true;
+                                        createEglContext = true;
+
+                                        sGLThreadManager.notifyAll();
+                                    }
+                                }
+
+                                if (mHaveEglContext && !mHaveEglSurface) {
+                                    mHaveEglSurface = true;
+                                    createEglSurface = true;
+                                    createGlInterface = true;
+                                    sizeChanged = true;
+                                }
+
+                                if (mHaveEglSurface) {
+                                    if (mSizeChanged) {
+                                        sizeChanged = true;
+                                        w = mWidth;
+                                        h = mHeight;
+                                        wantRenderNotification = true;
+                                        if (LOG_SURFACE) {
+                                            Log.i("GLThread",
+                                                    "noticing that we want render notification tid="
+                                                            + getId());
+                                        }
+
+                                        // Destroy and recreate the EGL surface.
+                                        createEglSurface = true;
+
+                                        mSizeChanged = false;
+                                    }
+                                    mRequestRender = false;
+                                    sGLThreadManager.notifyAll();
+                                    break;
+                                }
+                            }
+
+                            // By design, this is the only place in a GLThread thread where we wait().
+                            if (LOG_THREADS) {
+                                Log.i("GLThread", "\nwaiting tid=" + getId()
+                                        + "\nmHaveEglContext: " + mHaveEglContext
+                                        + "\nmHaveEglSurface: " + mHaveEglSurface
+                                        + "\nmFinishedCreatingEglSurface: " + mFinishedCreatingEglSurface
+                                        + "\nmPaused: " + mPaused
+                                        + "\nmHasSurface: " + mHasSurface
+                                        + "\nmSurfaceIsBad: " + mSurfaceIsBad
+                                        + "\nmWaitingForSurface: " + mWaitingForSurface
+                                        + "\nmWidth: " + mWidth
+                                        + "\nmHeight: " + mHeight
+                                        + "\nmRequestRender: " + mRequestRender);
+                            }
+                            sGLThreadManager.wait();
+                        }
+                    } // end of synchronized(sGLThreadManager)
+
+                    if (event != null) {
+                        event.run();
+                        event = null;
+                        continue;
+                    }
+
+                    if (createEglSurface) {
+                        if (LOG_SURFACE) {
+                            Log.w("GLThread", "egl createSurface");
+                        }
+                        if (mEglHelper.createSurface()) {
+                            synchronized(sGLThreadManager) {
+                                mFinishedCreatingEglSurface = true;
+                                sGLThreadManager.notifyAll();
+                            }
+                        } else {
+                            synchronized(sGLThreadManager) {
+                                mFinishedCreatingEglSurface = true;
+                                mSurfaceIsBad = true;
+                                sGLThreadManager.notifyAll();
+                            }
+                            continue;
+                        }
+                        createEglSurface = false;
+                    }
+
+                    if (createGlInterface) {
+                        gl = (GL10) mEglHelper.createGL();
+
+                        sGLThreadManager.checkGLDriver(gl);
+                        createGlInterface = false;
+                    }
+
+                    if (createEglContext) {
+                        if (LOG_RENDERER) {
+                            Log.w("GLThread", "onSurfaceCreated");
+                        }
+                        EGLSurfaceView view = mEGLSurfaceViewWeakRef.get();
+                        if (view != null) {
+                            view.mRenderer.onSurfaceCreated(gl, mEglHelper.mEglConfig);
+                        }
+                        createEglContext = false;
+                    }
+
+                    if (sizeChanged) {
+                        if (LOG_RENDERER) {
+                            Log.w("GLThread", "onSurfaceChanged(" + w + ", " + h + ")");
+                        }
+                        EGLSurfaceView view = mEGLSurfaceViewWeakRef.get();
+                        if (view != null) {
+                            view.mRenderer.onSurfaceChanged(gl, w, h);
+                        }
+                        sizeChanged = false;
+                    }
+
+                    synchronized (VSYNC_LOCK) {
+                        if (vsynced) {
+                            vsynced = false;
+                            if (LOG_RENDERER_DRAW_FRAME) {
+                                Log.w("GLThread", "onDrawFrame tid=" + getId());
+                            }
+                            EGLSurfaceView view = mEGLSurfaceViewWeakRef.get();
+                            if (view != null) {
+                                view.mRenderer.onDrawFrame(gl);
+                            }
+                            if (shouldSwap) {
+                                int swapError = mEglHelper.swap();
+                                shouldSwap = false;
+                                switch (swapError) {
+                                    case EGL10.EGL_SUCCESS:
+                                        break;
+                                    case EGL11.EGL_CONTEXT_LOST:
+                                        if (LOG_SURFACE) {
+                                            Log.i("GLThread", "egl context lost tid=" + getId());
+                                        }
+                                        lostEglContext = true;
+                                        break;
+                                    default:
+                                        // Other errors typically mean that the current surface is bad,
+                                        // probably because the SurfaceView surface has been destroyed,
+                                        // but we haven't been notified yet.
+                                        // Log the error to help developers understand why rendering stopped.
+                                        EglHelper.logEglErrorAsWarning("GLThread", "eglSwapBuffers", swapError);
+
+                                        synchronized (sGLThreadManager) {
+                                            mSurfaceIsBad = true;
+                                            sGLThreadManager.notifyAll();
+                                        }
+                                        break;
+                                }
+                            }
+                        }
+                    }
+
+                    if (wantRenderNotification) {
+                        doRenderNotification = true;
+                    }
+                }
+
+            } finally {
+                /*
+                 * clean-up everything...
+                 */
+                synchronized (sGLThreadManager) {
+                    stopEglSurfaceLocked();
+                    stopEglContextLocked();
+                }
+            }
+        }
+
+        public boolean ableToDraw() {
+            return mHaveEglContext && mHaveEglSurface && readyToDraw();
+        }
+
+        private boolean readyToDraw() {
+            return (!mPaused) && mHasSurface && (!mSurfaceIsBad)
+                    && (mWidth > 0) && (mHeight > 0)
+                    && (mRequestRender);
+        }
+
+        public void requestRender() {
+            synchronized(sGLThreadManager) {
+                mRequestRender = true;
+                sGLThreadManager.notifyAll();
+            }
+        }
+
+        public void surfaceCreated() {
+            synchronized(sGLThreadManager) {
+                if (LOG_THREADS) {
+                    Log.i("GLThread", "surfaceCreated tid=" + getId());
+                }
+                mHasSurface = true;
+                mFinishedCreatingEglSurface = false;
+                sGLThreadManager.notifyAll();
+                while (mWaitingForSurface
+                        && !mFinishedCreatingEglSurface
+                        && !mExited) {
+                    try {
+                        sGLThreadManager.wait();
+                    } catch (InterruptedException e) {
+                        Thread.currentThread().interrupt();
+                    }
+                }
+            }
+        }
+
+        public void surfaceDestroyed() {
+            synchronized(sGLThreadManager) {
+                if (LOG_THREADS) {
+                    Log.i("GLThread", "surfaceDestroyed tid=" + getId());
+                }
+                mHasSurface = false;
+                sGLThreadManager.notifyAll();
+                while((!mWaitingForSurface) && (!mExited)) {
+                    try {
+                        sGLThreadManager.wait();
+                    } catch (InterruptedException e) {
+                        Thread.currentThread().interrupt();
+                    }
+                }
+            }
+        }
+
+        public void onPause() {
+            synchronized (sGLThreadManager) {
+                if (LOG_PAUSE_RESUME) {
+                    Log.i("GLThread", "onPause tid=" + getId());
+                }
+                mRequestPaused = true;
+                sGLThreadManager.notifyAll();
+                while ((! mExited) && (! mPaused)) {
+                    if (LOG_PAUSE_RESUME) {
+                        Log.i("Main thread", "onPause waiting for mPaused.");
+                    }
+                    try {
+                        sGLThreadManager.wait();
+                    } catch (InterruptedException ex) {
+                        Thread.currentThread().interrupt();
+                    }
+                }
+            }
+        }
+
+        public void onResume() {
+            synchronized (sGLThreadManager) {
+                if (LOG_PAUSE_RESUME) {
+                    Log.i("GLThread", "onResume tid=" + getId());
+                }
+                mRequestPaused = false;
+                mRequestRender = true;
+                mRenderComplete = false;
+                sGLThreadManager.notifyAll();
+                while ((! mExited) && mPaused && (!mRenderComplete)) {
+                    if (LOG_PAUSE_RESUME) {
+                        Log.i("Main thread", "onResume waiting for !mPaused.");
+                    }
+                    try {
+                        sGLThreadManager.wait();
+                    } catch (InterruptedException ex) {
+                        Thread.currentThread().interrupt();
+                    }
+                }
+            }
+        }
+
+        public void onWindowResize(int w, int h) {
+            synchronized (sGLThreadManager) {
+                mWidth = w;
+                mHeight = h;
+                mSizeChanged = true;
+                mRequestRender = true;
+                mRenderComplete = false;
+                sGLThreadManager.notifyAll();
+
+                // Wait for thread to react to resize and render a frame
+                while (! mExited && !mPaused && !mRenderComplete
+                        && ableToDraw()) {
+                    if (LOG_SURFACE) {
+                        Log.i("Main thread", "onWindowResize waiting for render complete from tid=" + getId());
+                    }
+                    try {
+                        sGLThreadManager.wait();
+                    } catch (InterruptedException ex) {
+                        Thread.currentThread().interrupt();
+                    }
+                }
+            }
+        }
+
+        public void requestExitAndWait() {
+            // don't call this from GLThread thread or it is a guaranteed
+            // deadlock!
+            synchronized(sGLThreadManager) {
+                mShouldExit = true;
+                sGLThreadManager.notifyAll();
+                while (! mExited) {
+                    try {
+                        sGLThreadManager.wait();
+                    } catch (InterruptedException ex) {
+                        Thread.currentThread().interrupt();
+                    }
+                }
+            }
+        }
+
+        public void requestReleaseEglContextLocked() {
+            mShouldReleaseEglContext = true;
+            sGLThreadManager.notifyAll();
+        }
+
+        /**
+         * Queue an "event" to be run on the GL rendering thread.
+         * @param r the runnable to be run on the GL rendering thread.
+         */
+        public void queueEvent(Runnable r) {
+            if (r == null) {
+                throw new IllegalArgumentException("r must not be null");
+            }
+            synchronized(sGLThreadManager) {
+                mEventQueue.add(r);
+                sGLThreadManager.notifyAll();
+            }
+        }
+
+        // Once the thread is started, all accesses to the following member
+        // variables are protected by the sGLThreadManager monitor
+        private boolean mShouldExit;
+        private boolean mExited;
+        private boolean mRequestPaused;
+        private boolean mPaused;
+        private boolean mHasSurface;
+        private boolean mSurfaceIsBad;
+        private boolean mWaitingForSurface;
+        private boolean mHaveEglContext;
+        private boolean mHaveEglSurface;
+        private boolean mFinishedCreatingEglSurface;
+        private boolean mShouldReleaseEglContext;
+        private int mWidth;
+        private int mHeight;
+        private boolean mRequestRender;
+        private boolean mRenderComplete;
+        private ArrayList<Runnable> mEventQueue = new ArrayList<Runnable>();
+        private boolean mSizeChanged = true;
+
+        // End of member variables protected by the sGLThreadManager monitor.
+
+        private EglHelper mEglHelper;
+
+        /**
+         * Set once at thread construction time, nulled out when the parent view is garbage
+         * called. This weak reference allows the EGLSurfaceView to be garbage collected while
+         * the GLThread is still alive.
+         */
+        private WeakReference<EGLSurfaceView> mEGLSurfaceViewWeakRef;
+
+    }
+
+    static class LogWriter extends Writer {
+
+        @Override public void close() {
+            flushBuilder();
+        }
+
+        @Override public void flush() {
+            flushBuilder();
+        }
+
+        @Override public void write(char[] buf, int offset, int count) {
+            for(int i = 0; i < count; i++) {
+                char c = buf[offset + i];
+                if ( c == '\n') {
+                    flushBuilder();
+                }
+                else {
+                    mBuilder.append(c);
+                }
+            }
+        }
+
+        private void flushBuilder() {
+            if (mBuilder.length() > 0) {
+                Log.v("EGLSurfaceView", mBuilder.toString());
+                mBuilder.delete(0, mBuilder.length());
+            }
+        }
+
+        private StringBuilder mBuilder = new StringBuilder();
+    }
+
+
+    private final void checkRenderThreadState() {
+        if (mGLThread != null) {
+            throw new IllegalStateException(
+                    "setRenderer has already been called for this instance.");
+        }
+    }
+
+    private static class GLThreadManager {
+        private static String TAG = "GLThreadManager";
+
+        public synchronized void threadExiting(GLThread thread) {
+            if (LOG_THREADS) {
+                Log.i("GLThread", "exiting tid=" +  thread.getId());
+            }
+            thread.mExited = true;
+            if (mEglOwner == thread) {
+                mEglOwner = null;
+            }
+            notifyAll();
+        }
+
+        /*
+         * Tries once to acquire the right to use an EGL
+         * context. Does not block. Requires that we are already
+         * in the sGLThreadManager monitor when this is called.
+         *
+         * @return true if the right to use an EGL context was acquired.
+         */
+        public boolean tryAcquireEglContextLocked(GLThread thread) {
+            if (mEglOwner == thread || mEglOwner == null) {
+                mEglOwner = thread;
+                notifyAll();
+                return true;
+            }
+            checkGLESVersion();
+            if (mMultipleGLESContextsAllowed) {
+                return true;
+            }
+            // Notify the owning thread that it should release the context.
+            // TODO: implement a fairness policy. Currently
+            // if the owning thread is drawing continuously it will just
+            // reacquire the EGL context.
+            if (mEglOwner != null) {
+                mEglOwner.requestReleaseEglContextLocked();
+            }
+            return false;
+        }
+
+        /*
+         * Releases the EGL context. Requires that we are already in the
+         * sGLThreadManager monitor when this is called.
+         */
+        public void releaseEglContextLocked(GLThread thread) {
+            if (mEglOwner == thread) {
+                mEglOwner = null;
+            }
+            notifyAll();
+        }
+
+        public synchronized boolean shouldReleaseEGLContextWhenPausing() {
+            // Release the EGL context when pausing even if
+            // the hardware supports multiple EGL contexts.
+            // Otherwise the device could run out of EGL contexts.
+            return mLimitedGLESContexts;
+        }
+
+        public synchronized boolean shouldTerminateEGLWhenPausing() {
+            checkGLESVersion();
+            return !mMultipleGLESContextsAllowed;
+        }
+
+        public synchronized void checkGLDriver(GL10 gl) {
+            if (! mGLESDriverCheckComplete) {
+                checkGLESVersion();
+                String renderer = gl.glGetString(GL10.GL_RENDERER);
+                if (mGLESVersion < kGLES_20) {
+                    mMultipleGLESContextsAllowed =
+                            ! renderer.startsWith(kMSM7K_RENDERER_PREFIX);
+                    notifyAll();
+                }
+                mLimitedGLESContexts = !mMultipleGLESContextsAllowed;
+                if (LOG_SURFACE) {
+                    Log.w(TAG, "checkGLDriver renderer = \"" + renderer + "\" multipleContextsAllowed = "
+                            + mMultipleGLESContextsAllowed
+                            + " mLimitedGLESContexts = " + mLimitedGLESContexts);
+                }
+                mGLESDriverCheckComplete = true;
+            }
+        }
+
+        private void checkGLESVersion() {
+            if (! mGLESVersionCheckComplete) {
+                mGLESVersion = SystemProperties.getInt(
+                        "ro.opengles.version",
+                        ConfigurationInfo.GL_ES_VERSION_UNDEFINED);
+                if (mGLESVersion >= kGLES_20) {
+                    mMultipleGLESContextsAllowed = true;
+                }
+                if (LOG_SURFACE) {
+                    Log.w(TAG, "checkGLESVersion mGLESVersion =" +
+                            " " + mGLESVersion + " mMultipleGLESContextsAllowed = " + mMultipleGLESContextsAllowed);
+                }
+                mGLESVersionCheckComplete = true;
+            }
+        }
+
+        /**
+         * This check was required for some pre-Android-3.0 hardware. Android 3.0 provides
+         * support for hardware-accelerated views, therefore multiple EGL contexts are
+         * supported on all Android 3.0+ EGL drivers.
+         */
+        private boolean mGLESVersionCheckComplete;
+        private int mGLESVersion;
+        private boolean mGLESDriverCheckComplete;
+        private boolean mMultipleGLESContextsAllowed;
+        private boolean mLimitedGLESContexts;
+        private static final int kGLES_20 = 0x20000;
+        private static final String kMSM7K_RENDERER_PREFIX =
+                "Q3Dimension MSM7500 ";
+        private GLThread mEglOwner;
+    }
+
+    private static final GLThreadManager sGLThreadManager = new GLThreadManager();
+
+    private final WeakReference<EGLSurfaceView> mThisWeakRef =
+            new WeakReference<EGLSurfaceView>(this);
+    private GLThread mGLThread;
+    private Renderer mRenderer;
+    private boolean mDetached;
+    private EGLConfigChooser mEGLConfigChooser;
+    private EGLContextFactory mEGLContextFactory;
+    private EGLWindowSurfaceFactory mEGLWindowSurfaceFactory;
+    private GLWrapper mGLWrapper;
+    private int mDebugFlags;
+    private int mEGLContextClientVersion;
+    private boolean mPreserveEGLContextOnPause;
+
+    /**
+     * Gives access to the system properties store.  The system properties
+     * store contains a list of string key-value pairs.
+     */
+    private static class SystemProperties
+    {
+        public static final int PROP_NAME_MAX = 31;
+        public static final int PROP_VALUE_MAX = 91;
+
+        /**
+         * Get the value for the given key.
+         * @return an empty string if the key isn't found
+         * @throws IllegalArgumentException if the key exceeds 32 characters
+         */
+        public static String get(String key) {
+            if (key.length() > PROP_NAME_MAX) {
+                throw new IllegalArgumentException("key.length > " + PROP_NAME_MAX);
+            }
+            try {
+                return native_get(key);
+            } catch (Exception e) {
+                return "";
+            }
+        }
+        /**
+         * Get the value for the given key.
+         * @return if the key isn't found, return def if it isn't null, or an empty string otherwise
+         * @throws IllegalArgumentException if the key exceeds 32 characters
+         */
+        public static String get(String key, String def) {
+            if (key.length() > PROP_NAME_MAX) {
+                throw new IllegalArgumentException("key.length > " + PROP_NAME_MAX);
+            }
+            try {
+                String ret = native_get(key);
+                if(TextUtils.isEmpty(ret)) {
+                    return def;
+                }
+                return ret;
+            } catch (Exception e) {
+                return def;
+            }
+        }
+        /**
+         * Get the value for the given key, and return as an integer.
+         * @param key the key to lookup
+         * @param def a default value to return
+         * @return the key parsed as an integer, or def if the key isn't found or
+         *         cannot be parsed
+         * @throws IllegalArgumentException if the key exceeds 32 characters
+         */
+        public static int getInt(String key, int def) {
+            if (key.length() > PROP_NAME_MAX) {
+                throw new IllegalArgumentException("key.length > " + PROP_NAME_MAX);
+            }
+            try {
+                return Integer.parseInt(native_get(key));
+            } catch (Exception e) {
+                return def;
+            }
+        }
+        /**
+         * Get the value for the given key, and return as a long.
+         * @param key the key to lookup
+         * @param def a default value to return
+         * @return the key parsed as a long, or def if the key isn't found or
+         *         cannot be parsed
+         * @throws IllegalArgumentException if the key exceeds 32 characters
+         */
+        public static long getLong(String key, long def) {
+            if (key.length() > PROP_NAME_MAX) {
+                throw new IllegalArgumentException("key.length > " + PROP_NAME_MAX);
+            }
+            try {
+                return Long.parseLong(native_get(key));
+            } catch (Exception e) {
+                return def;
+            }
+        }
+        /**
+         * Get the value for the given key, returned as a boolean.
+         * Values 'n', 'no', '0', 'false' or 'off' are considered false.
+         * Values 'y', 'yes', '1', 'true' or 'on' are considered true.
+         * (case sensitive).
+         * If the key does not exist, or has any other value, then the default
+         * result is returned.
+         * @param key the key to lookup
+         * @param def a default value to return
+         * @return the key parsed as a boolean, or def if the key isn't found or is
+         *         not able to be parsed as a boolean.
+         * @throws IllegalArgumentException if the key exceeds 32 characters
+         */
+        public static boolean getBoolean(String key, boolean def) {
+            if (key.length() > PROP_NAME_MAX) {
+                throw new IllegalArgumentException("key.length > " + PROP_NAME_MAX);
+            }
+            try {
+                return Boolean.parseBoolean(native_get(key));
+            } catch (Exception e) {
+                return def;
+            }
+        }
+
+        private static Map<String, String> cache = new HashMap<String, String>();
+        private static String native_get(String key) throws Exception {
+            if(cache.containsKey(key)) {
+                return cache.get(key);
+            }
+
+            Process p = Runtime.getRuntime().exec("/system/bin/getprop " + key);
+            p.waitFor();
+            BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream()));
+            String ln = reader.readLine();
+            reader.close();
+            p.destroy();
+
+            cache.put(key, ln);
+            return ln;
+        }
+
+    }
+}
diff --git a/app/src/main/java/smallville7123/EGLSurfaceView_EGLTextureView/EGLTextureView.java b/app/src/main/java/smallville7123/EGLSurfaceView_EGLTextureView/EGLTextureView.java
new file mode 100644
index 00000000..0b6e721a
--- /dev/null
+++ b/app/src/main/java/smallville7123/EGLSurfaceView_EGLTextureView/EGLTextureView.java
@@ -0,0 +1,2406 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package smallville7123.EGLSurfaceView_EGLTextureView;
+
+import android.content.Context;
+import android.content.pm.ConfigurationInfo;
+import android.graphics.SurfaceTexture;
+import android.opengl.EGL14;
+import android.opengl.EGLExt;
+import android.opengl.GLDebugHelper;
+import android.os.SystemClock;
+import android.text.TextUtils;
+import android.util.AttributeSet;
+import android.util.Log;
+import android.view.Choreographer;
+import android.view.TextureView;
+
+import androidx.annotation.CallSuper;
+
+import java.io.BufferedReader;
+import java.io.InputStreamReader;
+import java.io.Writer;
+import java.lang.ref.WeakReference;
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Map;
+
+import javax.microedition.khronos.egl.EGL10;
+import javax.microedition.khronos.egl.EGL11;
+import javax.microedition.khronos.egl.EGLConfig;
+import javax.microedition.khronos.egl.EGLContext;
+import javax.microedition.khronos.egl.EGLDisplay;
+import javax.microedition.khronos.egl.EGLSurface;
+import javax.microedition.khronos.opengles.GL;
+import javax.microedition.khronos.opengles.GL10;
+
+/**
+ * An implementation of TextureView that uses the dedicated surface for
+ * displaying OpenGL rendering.
+ * <p>
+ * A EGLTextureView provides the following features:
+ * <p>
+ * <ul>
+ * <li>Manages a surface, which is a special piece of memory that can be
+ * composited into the Android view system.
+ * <li>Manages an EGL display, which enables OpenGL to render into a surface.
+ * <li>Accepts a user-provided Renderer object that does the actual rendering.
+ * <li>Renders on a dedicated thread to decouple rendering performance from the
+ * UI thread.
+ * <li>Supports both on-demand and continuous rendering.
+ * <li>Optionally wraps, traces, and/or error-checks the renderer's OpenGL calls.
+ * </ul>
+ *
+ * <div class="special reference">
+ * <h3>Developer Guides</h3>
+ * <p>For more information about how to use OpenGL, read the
+ * <a href="{@docRoot}guide/topics/graphics/opengl.html">OpenGL</a> developer guide.</p>
+ * </div>
+ *
+ * <h3>Using EGLTextureView</h3>
+ * <p>
+ * Typically you use EGLTextureView by subclassing it and overriding one or more of the
+ * View system input event methods. If your application does not need to override event
+ * methods then EGLTextureView can be used as-is. For the most part
+ * EGLTextureView behavior is customized by calling "set" methods rather than by subclassing.
+ * For example, unlike a regular View, drawing is delegated to a separate Renderer object which
+ * is registered with the EGLTextureView
+ * using the {@link #setRenderer(Renderer)} call.
+ * <p>
+ * <h3>Initializing EGLTextureView</h3>
+ * All you have to do to initialize a EGLTextureView is call {@link #setRenderer(Renderer)}.
+ * However, if desired, you can modify the default behavior of EGLTextureView by calling one or
+ * more of these methods before calling setRenderer:
+ * <ul>
+ * <li>{@link #setDebugFlags(int)}
+ * <li>{@link #setEGLConfigChooser(boolean)}
+ * <li>{@link #setEGLConfigChooser(EGLConfigChooser)}
+ * <li>{@link #setEGLConfigChooser(int, int, int, int, int, int)}
+ * <li>{@link #setGLWrapper(GLWrapper)}
+ * </ul>
+ * <p>
+ * <h4>Specifying the android.view.Surface</h4>
+ * By default EGLTextureView will create a PixelFormat.RGB_888 format surface. If a translucent
+ * surface is required, call getHolder().setFormat(PixelFormat.TRANSLUCENT).
+ * The exact format of a TRANSLUCENT surface is device dependent, but it will be
+ * a 32-bit-per-pixel surface with 8 bits per component.
+ * <p>
+ * <h4>Choosing an EGL Configuration</h4>
+ * A given Android device may support multiple EGLConfig rendering configurations.
+ * The available configurations may differ in how may channels of data are present, as
+ * well as how many bits are allocated to each channel. Therefore, the first thing
+ * EGLTextureView has to do when starting to render is choose what EGLConfig to use.
+ * <p>
+ * By default EGLTextureView chooses a EGLConfig that has an RGB_888 pixel format,
+ * with at least a 16-bit depth buffer and no stencil.
+ * <p>
+ * If you would prefer a different EGLConfig
+ * you can override the default behavior by calling one of the
+ * setEGLConfigChooser methods.
+ * <p>
+ * <h4>Debug Behavior</h4>
+ * You can optionally modify the behavior of EGLTextureView by calling
+ * one or more of the debugging methods {@link #setDebugFlags(int)},
+ * and {@link #setGLWrapper}. These methods may be called before and/or after setRenderer, but
+ * typically they are called before setRenderer so that they take effect immediately.
+ * <p>
+ * <h4>Setting a Renderer</h4>
+ * Finally, you must call {@link #setRenderer} to register a {@link Renderer}.
+ * The renderer is
+ * responsible for doing the actual OpenGL rendering.
+ * <p>
+ * <h3>Rendering Mode</h3>
+ * Once the renderer is set, you can control whether the renderer draws
+ * continuously or on-demand by calling
+ * {@link #setRenderMode}. The default is continuous rendering.
+ * <p>
+ * <h3>Activity Life-cycle</h3>
+ * A EGLTextureView must be notified when the activity is paused and resumed. EGLTextureView clients
+ * are required to call {@link #onPause()} when the activity pauses and
+ * {@link #onResume()} when the activity resumes. These calls allow EGLTextureView to
+ * pause and resume the rendering thread, and also allow EGLTextureView to release and recreate
+ * the OpenGL display.
+ * <p>
+ * <h3>Handling events</h3>
+ * <p>
+ * To handle an event you will typically subclass EGLTextureView and override the
+ * appropriate method, just as you would with any other View. However, when handling
+ * the event, you may need to communicate with the Renderer object
+ * that's running in the rendering thread. You can do this using any
+ * standard Java cross-thread communication mechanism. In addition,
+ * one relatively easy way to communicate with your renderer is
+ * to call
+ * {@link #queueEvent(Runnable)}. For example:
+ * <pre class="prettyprint">
+ * class MyEGLTextureView extends EGLTextureView {
+ *
+ *     private MyRenderer mMyRenderer;
+ *
+ *     public void start() {
+ *         mMyRenderer = ...;
+ *         setRenderer(mMyRenderer);
+ *     }
+ *
+ *     public boolean onKeyDown(int keyCode, KeyEvent event) {
+ *         if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {
+ *             queueEvent(new Runnable() {
+ *                 // This method will be called on the rendering
+ *                 // thread:
+ *                 public void run() {
+ *                     mMyRenderer.handleDpadCenter();
+ *                 }});
+ *             return true;
+ *         }
+ *         return super.onKeyDown(keyCode, event);
+ *     }
+ * }
+ * </pre>
+ *
+ */
+public class EGLTextureView extends TextureView implements TextureView.SurfaceTextureListener {
+    private final static String TAG = "EGLTextureView";
+
+    private final static boolean LOG_ATTACH_DETACH = false;
+    private final static boolean LOG_THREADS = false;
+    private final static boolean LOG_PAUSE_RESUME = false;
+    private final static boolean LOG_SURFACE = false;
+    private final static boolean LOG_RENDERER = false;
+    private final static boolean LOG_RENDERER_DRAW_FRAME = false;
+    private final static boolean LOG_EGL = false;
+    /**
+     * The renderer only renders
+     * when the surface is created, or when {@link #requestRender} is called.
+     *
+     * @see #getRenderMode()
+     * @see #setRenderMode(int)
+     * @see #requestRender()
+     */
+    public final static int RENDERMODE_WHEN_DIRTY = 0;
+    /**
+     * The renderer is called
+     * continuously to re-render the scene.
+     *
+     * @see #getRenderMode()
+     * @see #setRenderMode(int)
+     */
+    public final static int RENDERMODE_CONTINUOUSLY = 1;
+
+    /**
+     * Check glError() after every GL call and throw an exception if glError indicates
+     * that an error has occurred. This can be used to help track down which OpenGL ES call
+     * is causing an error.
+     *
+     * @see #getDebugFlags
+     * @see #setDebugFlags
+     */
+    public final static int DEBUG_CHECK_GL_ERROR = 1;
+
+    /**
+     * Log GL calls to the system log at "verbose" level with tag "EGLTextureView".
+     *
+     * @see #getDebugFlags
+     * @see #setDebugFlags
+     */
+    public final static int DEBUG_LOG_GL_CALLS = 2;
+
+    /**
+     * Standard View constructor. In order to render something, you
+     * must call {@link #setRenderer} to register a renderer.
+     */
+    public EGLTextureView(Context context) {
+        super(context);
+        init();
+    }
+
+    /**
+     * Standard View constructor. In order to render something, you
+     * must call {@link #setRenderer} to register a renderer.
+     */
+    public EGLTextureView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        init();
+    }
+
+    @Override
+    @CallSuper
+    protected void finalize() throws Throwable {
+        try {
+            if (mGLThread != null) {
+                // GLThread may still be running if this view was never
+                // attached to a window.
+                mGLThread.requestExitAndWait();
+            }
+        } finally {
+            super.finalize();
+        }
+    }
+
+    private class Methods {
+        private final Class<EGLTextureView> clazz;
+        Method swapBuffersMethod;
+        String swapBuffersName;
+        String swapBuffersSignature;
+        Methods() {
+            clazz = EGLTextureView.class;
+            try {
+                swapBuffersMethod = clazz.getDeclaredMethod("swapBuffers");
+            } catch (NoSuchMethodException e) {
+                throw new RuntimeException("cannot find own methods");
+            }
+            swapBuffersName = swapBuffersMethod.getName();
+            swapBuffersSignature = "()V";
+        }
+    }
+
+    private Methods methods;
+
+    public enum METHOD {
+        SWAP_BUFFERS
+    }
+
+    public final String getJavaNameForJNI(METHOD METHOD) {
+        switch (METHOD) {
+            case SWAP_BUFFERS:
+                return methods.swapBuffersName;
+        }
+        return null;
+    }
+
+    public final String getJavaSignatureForJNI(METHOD METHOD) {
+        switch (METHOD) {
+            case SWAP_BUFFERS:
+                return methods.swapBuffersSignature;
+        }
+        return null;
+    }
+
+    private final Choreographer choreographer = Choreographer.getInstance();
+    private final Object VSYNC_LOCK = new Object();
+    private boolean vsynced;
+    private boolean shouldSwap;
+
+    /**
+     * Requests that the render thread swaps its buffers
+     * <br><br>
+     * The buffers will be swapped either when the current draw completes,
+     * or when the next draw completes
+     * <br><br>
+     * Subsequent calls in the same frame has no effect
+     * <br><br>
+     * This may be called from any thread
+     * <br><br>
+     * <br><br>
+     * Ensures that the render thread calls:
+     * <code>eglSwapBuffers(EGLDisplay, EGLSurface)</code>
+     * <br><br>
+     * <br><br>
+     * If you need to call this method from jni,
+     * please adapt your code to use the following
+     * <br><br>
+     *     Java:
+     * <pre class="prettyprint">
+     * {@literal @Override}
+     * public class Example extends EGLTextureView {
+     *     // ...
+     *     class ExampleRenderer implements Renderer {
+     *         native long createNativeInstance();
+     *         native void onEglSetup(long instance, Object classInstance, String name, String signature);
+     *         native void surfaceChanged(long instance, int w, int h);
+     *         native void onDraw(long instance);
+     *         native void onEglTearDown(long instance);
+     *         long nativeInstance;
+     *
+     *         ExampleRenderer() {
+     *             System.loadLibrary("YourNativeLibrary");
+     *             nativeInstance = createNativeInstance();
+     *         }
+     *
+     *         {@literal @Override}
+     *         public void onEglSetup() {
+     *             onEglSetup(nativeInstance, Example.this,
+     *                     getJavaNameForJNI(METHOD.SWAP_BUFFERS),
+     *                     getJavaSignatureForJNI(METHOD.SWAP_BUFFERS)
+     *             );
+     *         }
+     *
+     *         {@literal @Override}
+     *         public void onEglTearDown() {
+     *             onEglTearDown(nativeInstance);
+     *         }
+     *
+     *         {@literal @Override}
+     *         public void onSurfaceChanged(GL10 gl, int width, int height) {
+     *             surfaceChanged(nativeInstance, width, height);
+     *         }
+     *
+     *         {@literal @Override}
+     *         public void onDrawFrame(GL10 gl) {
+     *             onDraw(nativeInstance);
+     *         }
+     *     }
+     * }
+     * </pre>
+     *     Jni Header file:
+     * <pre class="prettyprint">
+     * class Example {
+     *     class JVM_MANAGER {
+     *     public:
+     *         JavaVM * jvm;
+     *         JNIEnv* jenv;
+     *         JavaVMAttachArgs jvmArgs;
+     *         bool needsToDetach;
+     *
+     *         JVM_MANAGER();
+     *         bool getJVM(JNIEnv * env);
+     *         bool attachJVM();
+     *         void detachJVM();
+     *
+     *         template <typename J, typename O> O globalRef(J j, O o) {
+     *             return reinterpret_cast<O>(j->NewGlobalRef(o));
+     *         }
+     *     };
+     *
+     *
+     *     JVM_MANAGER jvmManager;
+     *     jobject jObject;
+     *     jclass jClass;
+     *     jmethodID jSwapBuffers;
+     * }
+     * </pre>
+     *     Jni CPP file:
+     * <pre class="prettyprint">
+     * Example::JVM_MANAGER::JVM_MANAGER() {
+     *     jvm = nullptr;
+     *     jenv = nullptr;
+     *     needsToDetach = false;
+     *     jvmArgs.version = JNI_VERSION_1_6;
+     * }
+     *
+     * bool Example::JVM_MANAGER::getJVM(JNIEnv *env) {
+     *     return env->GetJavaVM(&jvm) == JNI_OK;
+     * }
+     *
+     * bool Example::JVM_MANAGER::attachJVM() {
+     *     // checks if current env needs attaching or it is already attached
+     *     jint res = jvm->GetEnv((void**)&jenv, JNI_VERSION_1_6);
+     *     if (res == JNI_EDETACHED) {
+     *         // Supported but not attached yet, needs to call AttachCurrentThread
+     *         res = jvm->AttachCurrentThread(&jenv, &jvmArgs);
+     *         if (res == JNI_OK) {
+     *             needsToDetach = true;
+     *         } else {
+     *             // Failed to attach, cancel
+     *             return false;
+     *         }
+     *     } else if (JNI_OK == res) {
+     *         // Current thread already attached, do not attach 'again' (just to save the attachedHere flag)
+     *         // We make sure to keep attached = 0
+     *         needsToDetach = false;
+     *     } else {
+     *         // JNI_EVERSION, specified version is not supported cancel this..
+     *         return false;
+     *     }
+     *     return true;
+     * }
+     *
+     * void Example::JVM_MANAGER::detachJVM() {
+     *     if (needsToDetach) {
+     *         jvm->DetachCurrentThread();
+     *     }
+     * }
+     * 
+     * Example::Example(JNIEnv *jenv, jobject classInstance, jstring name, jstring signature) {
+     *     if (!jvmManager.getJVM(jenv)) {
+     *         // failed to get JavaVM
+     *         return;
+     *     }
+     *     if (!jvmManager.attachJVM()) {
+     *         // failed to attach JVM
+     *         return;
+     *     }
+     *     jObject = jvmManager.globalRef(jenv, classInstance);
+     *     jClass = jvmManager.globalRef(jenv, jenv->GetObjectClass(jObject));
+     *     jboolean isCopy1, isCopy2;
+     *
+     *     if (name == nullptr) {
+     *          // cannot use a null name (0x0)
+     *         return;
+     *     }
+     *
+     *     if (signature == nullptr) {
+     *         // cannot use a null signature (0x0)
+     *         return;
+     *     }
+     *
+     *     const char * n = jvmManager.jenv->GetStringUTFChars(name, &isCopy1);
+     *     if (n == nullptr) {
+     *         // cannot get UTF chars from name
+     *         return;
+     *     }
+     *
+     *     const char * s = jvmManager.jenv->GetStringUTFChars(signature, &isCopy2);
+     *     if (s == nullptr) {
+     *         // cannot get UTF chars from signature
+     *         jvmManager.jenv->ReleaseStringUTFChars(name, n);
+     *         return;
+     *     }
+     *
+     *     jSwapBuffers = jvmManager.jenv->GetMethodID(jClass, n, s);
+     *
+     *     jvmManager.jenv->ReleaseStringUTFChars(name, n);
+     *     jvmManager.jenv->ReleaseStringUTFChars(name, s);
+     *
+     *     if (jSwapBuffers == nullptr) {
+     *         // cannot find method with name 'name', and signature 'signature'
+     *     }
+     * }
+     *
+     * Example::~Example() {
+     *     jvmManager.jenv->DeleteGlobalRef(jClass);
+     *     jvmManager.jenv->DeleteGlobalRef(jObject);
+     *     jvmManager.detachJVM();
+     * }
+     *
+     * void Example::swapBuffers() {
+     *     if (jSwapBuffers != nullptr) {
+     *         jvmManager.jenv->CallVoidMethod(jObject, jSwapBuffers);
+     *     }
+     * }
+     * </pre>
+     */
+    protected final void swapBuffers() {
+        synchronized (VSYNC_LOCK) {
+            if (!shouldSwap) {
+                shouldSwap = true;
+            }
+        }
+    }
+
+    @CallSuper
+    protected void init() {
+        shouldSwap = false;
+
+        // provides info for jni to java
+        methods = new Methods();
+
+        choreographer.postFrameCallback(
+                new Choreographer.FrameCallback() {
+                    /**
+                     * Called when a new display frame is being rendered.
+                     * <p>
+                     * This method provides the time in nanoseconds when the frame started being rendered.
+                     * The frame time provides a stable time base for synchronizing animations
+                     * and drawing.  It should be used instead of {@link SystemClock#uptimeMillis()}
+                     * or {@link System#nanoTime()} for animations and drawing in the UI.  Using the frame
+                     * time helps to reduce inter-frame jitter because the frame time is fixed at the time
+                     * the frame was scheduled to start, regardless of when the animations or drawing
+                     * callback actually runs.  All callbacks that run as part of rendering a frame will
+                     * observe the same frame time so using the frame time also helps to synchronize effects
+                     * that are performed by different callbacks.
+                     * </p><p>
+                     * Please note that the framework already takes care to process animations and
+                     * drawing using the frame time as a stable time base.  Most applications should
+                     * not need to use the frame time information directly.
+                     * </p>
+                     *
+                     * @param frameTimeNanos The time in nanoseconds when the frame started being rendered,
+                     *                       in the {@link System#nanoTime()} timebase.  Divide this value by {@code 1000000}
+                     *                       to convert it to the {@link SystemClock#uptimeMillis()} time base.
+                     */
+                    @Override
+                    public void doFrame(long frameTimeNanos) {
+                        synchronized (VSYNC_LOCK) {
+                            vsynced = true;
+                            mGLThread.requestRender();
+                        }
+                        choreographer.postFrameCallback(this);
+                    }
+                }
+        );
+        super.setSurfaceTextureListener(this);
+    }
+
+    /**
+     * Set the glWrapper. If the glWrapper is not null, its
+     * {@link GLWrapper#wrap(GL)} method is called
+     * whenever a surface is created. A GLWrapper can be used to wrap
+     * the GL object that's passed to the renderer. Wrapping a GL
+     * object enables examining and modifying the behavior of the
+     * GL calls made by the renderer.
+     * <p>
+     * Wrapping is typically used for debugging purposes.
+     * <p>
+     * The default value is null.
+     * @param glWrapper the new GLWrapper
+     */
+    public void setGLWrapper(GLWrapper glWrapper) {
+        mGLWrapper = glWrapper;
+    }
+
+    /**
+     * Set the debug flags to a new value. The value is
+     * constructed by OR-together zero or more
+     * of the DEBUG_CHECK_* constants. The debug flags take effect
+     * whenever a surface is created. The default value is zero.
+     * @param debugFlags the new debug flags
+     * @see #DEBUG_CHECK_GL_ERROR
+     * @see #DEBUG_LOG_GL_CALLS
+     */
+    public void setDebugFlags(int debugFlags) {
+        mDebugFlags = debugFlags;
+    }
+
+    /**
+     * Get the current value of the debug flags.
+     * @return the current value of the debug flags.
+     */
+    public int getDebugFlags() {
+        return mDebugFlags;
+    }
+
+    /**
+     * Control whether the EGL context is preserved when the EGLTextureView is paused and
+     * resumed.
+     * <p>
+     * If set to true, then the EGL context may be preserved when the EGLTextureView is paused.
+     * Whether the EGL context is actually preserved or not depends upon whether the
+     * Android device that the program is running on can support an arbitrary number of EGL
+     * contexts or not. Devices that can only support a limited number of EGL contexts must
+     * release the  EGL context in order to allow multiple applications to share the GPU.
+     * <p>
+     * If set to false, the EGL context will be released when the EGLTextureView is paused,
+     * and recreated when the EGLTextureView is resumed.
+     * <p>
+     *
+     * The default is false.
+     *
+     * @param preserveOnPause preserve the EGL context when paused
+     */
+    public void setPreserveEGLContextOnPause(boolean preserveOnPause) {
+        mPreserveEGLContextOnPause = preserveOnPause;
+    }
+
+    /**
+     * @return true if the EGL context will be preserved when paused
+     */
+    public boolean getPreserveEGLContextOnPause() {
+        return mPreserveEGLContextOnPause;
+    }
+
+    /**
+     * Set the renderer associated with this view. Also starts the thread that
+     * will call the renderer, which in turn causes the rendering to start.
+     * <p>This method should be called once and only once in the life-cycle of
+     * a EGLTextureView.
+     * <p>The following EGLTextureView methods can only be called <em>before</em>
+     * setRenderer is called:
+     * <ul>
+     * <li>{@link #setEGLConfigChooser(boolean)}
+     * <li>{@link #setEGLConfigChooser(EGLConfigChooser)}
+     * <li>{@link #setEGLConfigChooser(int, int, int, int, int, int)}
+     * </ul>
+     * <p>
+     * The following EGLTextureView methods can only be called <em>after</em>
+     * setRenderer is called:
+     * <ul>
+     * <li>{@link #getRenderMode()}
+     * <li>{@link #onPause()}
+     * <li>{@link #onResume()}
+     * <li>{@link #queueEvent(Runnable)}
+     * <li>{@link #swapBuffers()}
+     * <li>{@link #setRenderMode(int)}
+     * </ul>
+     *
+     * @param renderer the renderer to use to perform OpenGL drawing.
+     */
+    public void setRenderer(Renderer renderer) {
+        checkRenderThreadState();
+        if (mEGLConfigChooser == null) {
+            mEGLConfigChooser = new SimpleEGLConfigChooser(true);
+        }
+        if (mEGLContextFactory == null) {
+            mEGLContextFactory = new DefaultContextFactory();
+        }
+        if (mEGLWindowSurfaceFactory == null) {
+            mEGLWindowSurfaceFactory = new DefaultWindowSurfaceFactory();
+        }
+        mRenderer = renderer;
+        mGLThread = new GLThread(mThisWeakRef);
+        mGLThread.start();
+    }
+
+    /**
+     * Install a custom EGLContextFactory.
+     * <p>If this method is
+     * called, it must be called before {@link #setRenderer(Renderer)}
+     * is called.
+     * <p>
+     * If this method is not called, then by default
+     * a context will be created with no shared context and
+     * with a null attribute list.
+     */
+    public void setEGLContextFactory(EGLContextFactory factory) {
+        checkRenderThreadState();
+        mEGLContextFactory = factory;
+    }
+
+    /**
+     * Install a custom EGLWindowSurfaceFactory.
+     * <p>If this method is
+     * called, it must be called before {@link #setRenderer(Renderer)}
+     * is called.
+     * <p>
+     * If this method is not called, then by default
+     * a window surface will be created with a null attribute list.
+     */
+    public void setEGLWindowSurfaceFactory(EGLWindowSurfaceFactory factory) {
+        checkRenderThreadState();
+        mEGLWindowSurfaceFactory = factory;
+    }
+
+    /**
+     * Install a custom EGLConfigChooser.
+     * <p>If this method is
+     * called, it must be called before {@link #setRenderer(Renderer)}
+     * is called.
+     * <p>
+     * If no setEGLConfigChooser method is called, then by default the
+     * view will choose an EGLConfig that is compatible with the current
+     * android.view.Surface, with a depth buffer depth of
+     * at least 16 bits.
+     * @param configChooser
+     */
+    public void setEGLConfigChooser(EGLConfigChooser configChooser) {
+        checkRenderThreadState();
+        mEGLConfigChooser = configChooser;
+    }
+
+    /**
+     * Install a config chooser which will choose a config
+     * as close to 16-bit RGB as possible, with or without an optional depth
+     * buffer as close to 16-bits as possible.
+     * <p>If this method is
+     * called, it must be called before {@link #setRenderer(Renderer)}
+     * is called.
+     * <p>
+     * If no setEGLConfigChooser method is called, then by default the
+     * view will choose an RGB_888 surface with a depth buffer depth of
+     * at least 16 bits.
+     *
+     * @param needDepth
+     */
+    public void setEGLConfigChooser(boolean needDepth) {
+        setEGLConfigChooser(new SimpleEGLConfigChooser(needDepth));
+    }
+
+    /**
+     * Install a config chooser which will choose a config
+     * with at least the specified depthSize and stencilSize,
+     * and exactly the specified redSize, greenSize, blueSize and alphaSize.
+     * <p>If this method is
+     * called, it must be called before {@link #setRenderer(Renderer)}
+     * is called.
+     * <p>
+     * If no setEGLConfigChooser method is called, then by default the
+     * view will choose an RGB_888 surface with a depth buffer depth of
+     * at least 16 bits.
+     *
+     */
+    public void setEGLConfigChooser(int redSize, int greenSize, int blueSize,
+                                    int alphaSize, int depthSize, int stencilSize) {
+        setEGLConfigChooser(new ComponentSizeChooser(redSize, greenSize,
+                blueSize, alphaSize, depthSize, stencilSize));
+    }
+
+    /**
+     * Inform the default EGLContextFactory and default EGLConfigChooser
+     * which EGLContext client version to pick.
+     * <p>Use this method to create an OpenGL ES 2.0-compatible context.
+     * Example:
+     * <pre class="prettyprint">
+     *     public MyView(Context context) {
+     *         super(context);
+     *         setEGLContextClientVersion(2); // Pick an OpenGL ES 2.0 context.
+     *         setRenderer(new MyRenderer());
+     *     }
+     * </pre>
+     * <p>Note: Activities which require OpenGL ES 2.0 should indicate this by
+     * setting @lt;uses-feature android:glEsVersion="0x00020000" /> in the activity's
+     * AndroidManifest.xml file.
+     * <p>If this method is called, it must be called before {@link #setRenderer(Renderer)}
+     * is called.
+     * <p>This method only affects the behavior of the default EGLContexFactory and the
+     * default EGLConfigChooser. If
+     * {@link #setEGLContextFactory(EGLContextFactory)} has been called, then the supplied
+     * EGLContextFactory is responsible for creating an OpenGL ES 2.0-compatible context.
+     * If
+     * {@link #setEGLConfigChooser(EGLConfigChooser)} has been called, then the supplied
+     * EGLConfigChooser is responsible for choosing an OpenGL ES 2.0-compatible config.
+     * @param version The EGLContext client version to choose. Use 2 for OpenGL ES 2.0
+     */
+    public void setEGLContextClientVersion(int version) {
+        checkRenderThreadState();
+        mEGLContextClientVersion = version;
+    }
+
+    int mRendermode;
+
+    /**
+     * Set the rendering mode. When renderMode is
+     * RENDERMODE_CONTINUOUSLY, the renderer is called
+     * repeatedly to re-render the scene. When renderMode
+     * is RENDERMODE_WHEN_DIRTY, the renderer only rendered when the surface
+     * is created, or when {@link #swapBuffers} is called. Defaults to RENDERMODE_CONTINUOUSLY.
+     * <p>
+     * Using RENDERMODE_WHEN_DIRTY can improve battery life and overall system performance
+     * by allowing the GPU and CPU to idle when the view does not need to be updated.
+     * <p>
+     * This method can only be called after {@link #setRenderer(Renderer)}
+     * <p>
+     *
+     * @deprecated This has no effect on rendering.
+     * @param renderMode one of the RENDERMODE_X constants
+     * @see #RENDERMODE_CONTINUOUSLY
+     * @see #RENDERMODE_WHEN_DIRTY
+     */
+    public void setRenderMode(int renderMode) {
+        mRendermode = renderMode;
+    }
+
+    /**
+     * Get the current rendering mode. May be called
+     * from any thread. Must not be called before a renderer has been set.
+     *
+     * @deprecated This has no effect on rendering.
+     * @return the current rendering mode.
+     * @see #RENDERMODE_CONTINUOUSLY
+     * @see #RENDERMODE_WHEN_DIRTY
+     */
+    public int getRenderMode() {
+        return mRendermode;
+    }
+
+    /**
+     * Request that the renderer render a frame.
+     * This method is typically used when the render mode has been set to
+     * {@link #RENDERMODE_WHEN_DIRTY}, so that frames are only rendered on demand.
+     * May be called
+     * from any thread. Must not be called before a renderer has been set.
+     * <br><br>
+     * this calls {@link #swapBuffers}
+     * @see #swapBuffers
+     */
+    public void requestRender() {
+        swapBuffers();
+    }
+
+    @Override
+    final public void setSurfaceTextureListener(SurfaceTextureListener listener) {
+        Log.e(TAG, "setSurfaceTextureListener preserved, setRenderer() instead?");
+    }
+
+    @Override
+    final public void onSurfaceTextureAvailable(SurfaceTexture surface, int width, int height) {
+        mGLThread.surfaceCreated();
+        onSurfaceTextureSizeChanged(surface, width, height);
+    }
+
+    @Override
+    final public void onSurfaceTextureSizeChanged(SurfaceTexture surface, int width, int height) {
+        mGLThread.onWindowResize(width, height);
+    }
+
+    @Override
+    final public boolean onSurfaceTextureDestroyed(SurfaceTexture surface) {
+        // Surface will be destroyed when we return
+        mGLThread.surfaceDestroyed();
+        if(null != mRenderer) {
+            mRenderer.onSurfaceDestroyed();
+        }
+        return true;
+    }
+
+    @Override
+    final public void onSurfaceTextureUpdated(SurfaceTexture surface) {
+
+    }
+
+    /**
+     * Inform the view that the activity is paused. The owner of this view must
+     * call this method when the activity is paused. Calling this method will
+     * pause the rendering thread.
+     * Must not be called before a renderer has been set.
+     */
+    @CallSuper
+    public void onPause() {
+        mGLThread.onPause();
+    }
+
+    /**
+     * Inform the view that the activity is resumed. The owner of this view must
+     * call this method when the activity is resumed. Calling this method will
+     * recreate the OpenGL display and resume the rendering
+     * thread.
+     * Must not be called before a renderer has been set.
+     */
+    @CallSuper
+    public void onResume() {
+        mGLThread.onResume();
+    }
+
+    /**
+     * Queue a runnable to be run on the GL rendering thread. This can be used
+     * to communicate with the Renderer on the rendering thread.
+     * Must not be called before a renderer has been set.
+     * @param r the runnable to be run on the GL rendering thread.
+     */
+    @CallSuper
+    public void queueEvent(Runnable r) {
+        mGLThread.queueEvent(r);
+    }
+
+    /**
+     * This method is used as part of the View class and is not normally
+     * called or subclassed by clients of EGLTextureView.
+     */
+    @Override
+    @CallSuper
+    protected void onAttachedToWindow() {
+        super.onAttachedToWindow();
+        if (LOG_ATTACH_DETACH) {
+            Log.d(TAG, "onAttachedToWindow reattach =" + mDetached);
+        }
+        if (mDetached && (mRenderer != null)) {
+            mGLThread = new GLThread(mThisWeakRef);
+            mGLThread.start();
+        }
+        mDetached = false;
+    }
+
+    @Override
+    @CallSuper
+    protected void onDetachedFromWindow() {
+        if (LOG_ATTACH_DETACH) {
+            Log.d(TAG, "onDetachedFromWindow");
+        }
+        if (mGLThread != null) {
+            mGLThread.requestExitAndWait();
+        }
+        mDetached = true;
+        super.onDetachedFromWindow();
+    }
+
+    // ----------------------------------------------------------------------
+
+    /**
+     * An interface used to wrap a GL interface.
+     * <p>Typically
+     * used for implementing debugging and tracing on top of the default
+     * GL interface. You would typically use this by creating your own class
+     * that implemented all the GL methods by delegating to another GL instance.
+     * Then you could add your own behavior before or after calling the
+     * delegate. All the GLWrapper would do was instantiate and return the
+     * wrapper GL instance:
+     * <pre class="prettyprint">
+     * class MyGLWrapper implements GLWrapper {
+     *     GL wrap(GL gl) {
+     *         return new MyGLImplementation(gl);
+     *     }
+     *     static class MyGLImplementation implements GL,GL10,GL11,... {
+     *         ...
+     *     }
+     * }
+     * </pre>
+     * @see #setGLWrapper(GLWrapper)
+     */
+    public interface GLWrapper {
+        /**
+         * Wraps a gl interface in another gl interface.
+         * @param gl a GL interface that is to be wrapped.
+         * @return either the input argument or another GL object that wraps the input argument.
+         */
+        GL wrap(GL gl);
+    }
+
+    /**
+     * A generic renderer interface.
+     * <p>
+     * The renderer is responsible for making OpenGL calls to render a frame.
+     * <p>
+     * EGLTextureView clients typically create their own classes that implement
+     * this interface, and then call {@link EGLTextureView#setRenderer} to
+     * register the renderer with the EGLTextureView.
+     * <p>
+     *
+     * <div class="special reference">
+     * <h3>Developer Guides</h3>
+     * <p>For more information about how to use OpenGL, read the
+     * <a href="{@docRoot}guide/topics/graphics/opengl.html">OpenGL</a> developer guide.</p>
+     * </div>
+     *
+     * <h3>Threading</h3>
+     * The renderer will be called on a separate thread, so that rendering
+     * performance is decoupled from the UI thread. Clients typically need to
+     * communicate with the renderer from the UI thread, because that's where
+     * input events are received. Clients can communicate using any of the
+     * standard Java techniques for cross-thread communication, or they can
+     * use the {@link EGLTextureView#queueEvent(Runnable)} convenience method.
+     * <p>
+     * <h3>EGL Context Lost</h3>
+     * There are situations where the EGL rendering context will be lost. This
+     * typically happens when device wakes up after going to sleep. When
+     * the EGL context is lost, all OpenGL resources (such as textures) that are
+     * associated with that context will be automatically deleted. In order to
+     * keep rendering correctly, a renderer must recreate any lost resources
+     * that it still needs. The {@link #onSurfaceCreated(GL10, EGLConfig)} method
+     * is a convenient place to do this.
+     *
+     *
+     * @see #setRenderer(Renderer)
+     */
+    public interface Renderer {
+        /**
+         * Called when the surface is created or recreated.
+         * <p>
+         * Called when the rendering thread
+         * starts and whenever the EGL context is lost. The EGL context will typically
+         * be lost when the Android device awakes after going to sleep.
+         * <p>
+         * Since this method is called at the beginning of rendering, as well as
+         * every time the EGL context is lost, this method is a convenient place to put
+         * code to create resources that need to be created when the rendering
+         * starts, and that need to be recreated when the EGL context is lost.
+         * Textures are an example of a resource that you might want to create
+         * here.
+         * <p>
+         * Note that when the EGL context is lost, all OpenGL resources associated
+         * with that context will be automatically deleted. You do not need to call
+         * the corresponding "glDelete" methods such as glDeleteTextures to
+         * manually delete these lost resources.
+         * <p>
+         * @param gl the GL interface. Use <code>instanceof</code> to
+         * test if the interface supports GL11 or higher interfaces.
+         * @param config the EGLConfig of the created surface. Can be used
+         * to create matching pbuffers.
+         */
+        default void onSurfaceCreated(GL10 gl, EGLConfig config) {}
+
+        /**
+         * Called when the surface changed size.
+         * <p>
+         * Called after the surface is created and whenever
+         * the OpenGL ES surface size changes.
+         * <p>
+         * Typically you will set your viewport here. If your camera
+         * is fixed then you could also set your projection matrix here:
+         * <pre class="prettyprint">
+         * void onSurfaceChanged(GL10 gl, int width, int height) {
+         *     gl.glViewport(0, 0, width, height);
+         *     // for a fixed camera, set the projection too
+         *     float ratio = (float) width / height;
+         *     gl.glMatrixMode(GL10.GL_PROJECTION);
+         *     gl.glLoadIdentity();
+         *     gl.glFrustumf(-ratio, ratio, -1, 1, 1, 10);
+         * }
+         * </pre>
+         * @param gl the GL interface. Use <code>instanceof</code> to
+         * test if the interface supports GL11 or higher interfaces.
+         * @param width surface width
+         * @param height surface height
+         */
+        void onSurfaceChanged(GL10 gl, int width, int height);
+
+        /**
+         * Called to draw the current frame.
+         * <p>
+         * This method is responsible for drawing the current frame.
+         * <p>
+         * The implementation of this method typically looks like this:
+         * <pre class="prettyprint">
+         * void onDrawFrame(GL10 gl) {
+         *     gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
+         *     //... other gl calls to render the scene ...
+         *     swapBuffers();
+         * }
+         * </pre>
+         * @param gl the GL interface. Use <code>instanceof</code> to
+         * test if the interface supports GL11 or higher interfaces.
+         *
+         * @implSpec you must call {@link #swapBuffers()} to draw anything
+         * @see #swapBuffers()
+         */
+        void onDrawFrame(GL10 gl);
+
+        default void onSurfaceDestroyed() {}
+
+        /**
+         * Called when the EGL context is made current
+         */
+        default void onEglSetup() {}
+
+        /**
+         * Called before the EGL context is lost
+         */
+        default void onEglTearDown() {}
+
+    }
+
+    /**
+     * An interface for customizing the eglCreateContext and eglDestroyContext calls.
+     * <p>
+     * This interface must be implemented by clients wishing to call
+     * {@link EGLTextureView#setEGLContextFactory(EGLContextFactory)}
+     */
+    public interface EGLContextFactory {
+        EGLContext createContext(EGL10 egl, EGLDisplay display, EGLConfig eglConfig);
+        void destroyContext(EGL10 egl, EGLDisplay display, EGLContext context);
+    }
+
+    private class DefaultContextFactory implements EGLContextFactory {
+        private int EGL_CONTEXT_CLIENT_VERSION = 0x3098;
+
+        public EGLContext createContext(EGL10 egl, EGLDisplay display, EGLConfig config) {
+            int[] attrib_list = {EGL_CONTEXT_CLIENT_VERSION, mEGLContextClientVersion,
+                    EGL10.EGL_NONE };
+
+            return egl.eglCreateContext(display, config, EGL10.EGL_NO_CONTEXT,
+                    mEGLContextClientVersion != 0 ? attrib_list : null);
+        }
+
+        public void destroyContext(EGL10 egl, EGLDisplay display,
+                                   EGLContext context) {
+            if (!egl.eglDestroyContext(display, context)) {
+                Log.e("DefaultContextFactory", "display:" + display + " context: " + context);
+                if (LOG_THREADS) {
+                    Log.i("DefaultContextFactory", "tid=" + Thread.currentThread().getId());
+                }
+                EglHelper.throwEglException("eglDestroyContex", egl.eglGetError());
+            }
+        }
+    }
+
+    /**
+     * An interface for customizing the eglCreateWindowSurface and eglDestroySurface calls.
+     * <p>
+     * This interface must be implemented by clients wishing to call
+     * {@link EGLTextureView#setEGLWindowSurfaceFactory(EGLWindowSurfaceFactory)}
+     */
+    public interface EGLWindowSurfaceFactory {
+        /**
+         *  @return null if the surface cannot be constructed.
+         */
+        EGLSurface createWindowSurface(EGL10 egl, EGLDisplay display, EGLConfig config,
+                                       Object nativeWindow);
+        void destroySurface(EGL10 egl, EGLDisplay display, EGLSurface surface);
+    }
+
+    private static class DefaultWindowSurfaceFactory implements EGLWindowSurfaceFactory {
+
+        public EGLSurface createWindowSurface(EGL10 egl, EGLDisplay display,
+                                              EGLConfig config, Object nativeWindow) {
+            EGLSurface result = null;
+            try {
+                result = egl.eglCreateWindowSurface(display, config, nativeWindow, null);
+            } catch (IllegalArgumentException e) {
+                // This exception indicates that the surface flinger surface
+                // is not valid. This can happen if the surface flinger surface has
+                // been torn down, but the application has not yet been
+                // notified via SurfaceHolder.Callback.surfaceDestroyed.
+                // In theory the application should be notified first,
+                // but in practice sometimes it is not. See b/4588890
+                Log.e(TAG, "eglCreateWindowSurface", e);
+            }
+            return result;
+        }
+
+        public void destroySurface(EGL10 egl, EGLDisplay display,
+                                   EGLSurface surface) {
+            egl.eglDestroySurface(display, surface);
+        }
+    }
+
+    /**
+     * An interface for choosing an EGLConfig configuration from a list of
+     * potential configurations.
+     * <p>
+     * This interface must be implemented by clients wishing to call
+     * {@link EGLTextureView#setEGLConfigChooser(EGLConfigChooser)}
+     */
+    public interface EGLConfigChooser {
+        /**
+         * Choose a configuration from the list. Implementors typically
+         * implement this method by calling
+         * {@link EGL10#eglChooseConfig} and iterating through the results. Please consult the
+         * EGL specification available from The Khronos Group to learn how to call eglChooseConfig.
+         * @param egl the EGL10 for the current display.
+         * @param display the current display.
+         * @return the chosen configuration.
+         */
+        EGLConfig chooseConfig(EGL10 egl, EGLDisplay display);
+    }
+
+    private abstract class BaseConfigChooser
+            implements EGLConfigChooser {
+        public BaseConfigChooser(int[] configSpec) {
+            mConfigSpec = filterConfigSpec(configSpec);
+        }
+
+        public EGLConfig chooseConfig(EGL10 egl, EGLDisplay display) {
+            int[] num_config = new int[1];
+            if (!egl.eglChooseConfig(display, mConfigSpec, null, 0,
+                    num_config)) {
+                throw new IllegalArgumentException("eglChooseConfig failed");
+            }
+
+            int numConfigs = num_config[0];
+
+            if (numConfigs <= 0) {
+                throw new IllegalArgumentException(
+                        "No configs match configSpec");
+            }
+
+            EGLConfig[] configs = new EGLConfig[numConfigs];
+            if (!egl.eglChooseConfig(display, mConfigSpec, configs, numConfigs,
+                    num_config)) {
+                throw new IllegalArgumentException("eglChooseConfig#2 failed");
+            }
+            EGLConfig config = chooseConfig(egl, display, configs);
+            if (config == null) {
+                throw new IllegalArgumentException("No config chosen");
+            }
+            return config;
+        }
+
+        abstract EGLConfig chooseConfig(EGL10 egl, EGLDisplay display,
+                                        EGLConfig[] configs);
+
+        protected int[] mConfigSpec;
+
+        private int[] filterConfigSpec(int[] configSpec) {
+            if (mEGLContextClientVersion != 2 && mEGLContextClientVersion != 3) {
+                return configSpec;
+            }
+            /* We know none of the subclasses define EGL_RENDERABLE_TYPE.
+             * And we know the configSpec is well formed.
+             */
+            int len = configSpec.length;
+            int[] newConfigSpec = new int[len + 2];
+            System.arraycopy(configSpec, 0, newConfigSpec, 0, len-1);
+            newConfigSpec[len-1] = EGL10.EGL_RENDERABLE_TYPE;
+            if (mEGLContextClientVersion == 2) {
+                newConfigSpec[len] = EGL14.EGL_OPENGL_ES2_BIT;  /* EGL_OPENGL_ES2_BIT */
+            } else {
+                newConfigSpec[len] = EGLExt.EGL_OPENGL_ES3_BIT_KHR; /* EGL_OPENGL_ES3_BIT_KHR */
+            }
+            newConfigSpec[len+1] = EGL10.EGL_NONE;
+            return newConfigSpec;
+        }
+    }
+
+    /**
+     * Choose a configuration with exactly the specified r,g,b,a sizes,
+     * and at least the specified depth and stencil sizes.
+     */
+    private class ComponentSizeChooser extends BaseConfigChooser {
+        public ComponentSizeChooser(int redSize, int greenSize, int blueSize,
+                                    int alphaSize, int depthSize, int stencilSize) {
+            super(new int[] {
+                    EGL10.EGL_RED_SIZE, redSize,
+                    EGL10.EGL_GREEN_SIZE, greenSize,
+                    EGL10.EGL_BLUE_SIZE, blueSize,
+                    EGL10.EGL_ALPHA_SIZE, alphaSize,
+                    EGL10.EGL_DEPTH_SIZE, depthSize,
+                    EGL10.EGL_STENCIL_SIZE, stencilSize,
+                    EGL10.EGL_NONE});
+            mValue = new int[1];
+            mRedSize = redSize;
+            mGreenSize = greenSize;
+            mBlueSize = blueSize;
+            mAlphaSize = alphaSize;
+            mDepthSize = depthSize;
+            mStencilSize = stencilSize;
+        }
+
+        @Override
+        public EGLConfig chooseConfig(EGL10 egl, EGLDisplay display,
+                                      EGLConfig[] configs) {
+            for (EGLConfig config : configs) {
+                int d = findConfigAttrib(egl, display, config,
+                        EGL10.EGL_DEPTH_SIZE, 0);
+                int s = findConfigAttrib(egl, display, config,
+                        EGL10.EGL_STENCIL_SIZE, 0);
+                if ((d >= mDepthSize) && (s >= mStencilSize)) {
+                    int r = findConfigAttrib(egl, display, config,
+                            EGL10.EGL_RED_SIZE, 0);
+                    int g = findConfigAttrib(egl, display, config,
+                            EGL10.EGL_GREEN_SIZE, 0);
+                    int b = findConfigAttrib(egl, display, config,
+                            EGL10.EGL_BLUE_SIZE, 0);
+                    int a = findConfigAttrib(egl, display, config,
+                            EGL10.EGL_ALPHA_SIZE, 0);
+                    if ((r == mRedSize) && (g == mGreenSize)
+                            && (b == mBlueSize) && (a == mAlphaSize)) {
+                        return config;
+                    }
+                }
+            }
+            return null;
+        }
+
+        private int findConfigAttrib(EGL10 egl, EGLDisplay display,
+                                     EGLConfig config, int attribute, int defaultValue) {
+
+            if (egl.eglGetConfigAttrib(display, config, attribute, mValue)) {
+                return mValue[0];
+            }
+            return defaultValue;
+        }
+
+        private int[] mValue;
+        // Subclasses can adjust these values:
+        protected int mRedSize;
+        protected int mGreenSize;
+        protected int mBlueSize;
+        protected int mAlphaSize;
+        protected int mDepthSize;
+        protected int mStencilSize;
+    }
+
+    /**
+     * This class will choose a RGB_888 surface with
+     * or without a depth buffer.
+     *
+     */
+    private class SimpleEGLConfigChooser extends ComponentSizeChooser {
+        public SimpleEGLConfigChooser(boolean withDepthBuffer) {
+            super(8, 8, 8, 0, withDepthBuffer ? 16 : 0, 0);
+        }
+    }
+
+    /**
+     * An EGL helper class.
+     */
+
+    private static class EglHelper {
+        public EglHelper(WeakReference<EGLTextureView> EGLTextureViewWeakRef) {
+            mEGLTextureViewWeakRef = EGLTextureViewWeakRef;
+        }
+
+        /**
+         * Initialize EGL for a given configuration spec.
+         */
+        public void start() {
+            if (LOG_EGL) {
+                Log.w("EglHelper", "start() tid=" + Thread.currentThread().getId());
+            }
+            /*
+             * Get an EGL instance
+             */
+            mEgl = (EGL10) EGLContext.getEGL();
+
+            /*
+             * Get to the default display.
+             */
+            mEglDisplay = mEgl.eglGetDisplay(EGL10.EGL_DEFAULT_DISPLAY);
+
+            if (mEglDisplay == EGL10.EGL_NO_DISPLAY) {
+                throw new RuntimeException("eglGetDisplay failed");
+            }
+
+            /*
+             * We can now initialize EGL for that display
+             */
+            int[] version = new int[2];
+            if(!mEgl.eglInitialize(mEglDisplay, version)) {
+                throw new RuntimeException("eglInitialize failed");
+            }
+            EGLTextureView view = mEGLTextureViewWeakRef.get();
+            if (view == null) {
+                mEglConfig = null;
+                mEglContext = null;
+            } else {
+                mEglConfig = view.mEGLConfigChooser.chooseConfig(mEgl, mEglDisplay);
+
+                /*
+                 * Create an EGL context. We want to do this as rarely as we can, because an
+                 * EGL context is a somewhat heavy object.
+                 */
+                mEglContext = view.mEGLContextFactory.createContext(mEgl, mEglDisplay, mEglConfig);
+            }
+            if (mEglContext == null || mEglContext == EGL10.EGL_NO_CONTEXT) {
+                mEglContext = null;
+                throwEglException("createContext");
+            }
+            if (LOG_EGL) {
+                Log.w("EglHelper", "createContext " + mEglContext + " tid=" + Thread.currentThread().getId());
+            }
+
+            mEglSurface = null;
+        }
+
+        /**
+         * Create an egl surface for the current SurfaceHolder surface. If a surface
+         * already exists, destroy it before creating the new surface.
+         *
+         * @return true if the surface was created successfully.
+         */
+        public boolean createSurface() {
+            if (LOG_EGL) {
+                Log.w("EglHelper", "createSurface()  tid=" + Thread.currentThread().getId());
+            }
+            /*
+             * Check preconditions.
+             */
+            if (mEgl == null) {
+                throw new RuntimeException("egl not initialized");
+            }
+            if (mEglDisplay == null) {
+                throw new RuntimeException("eglDisplay not initialized");
+            }
+            if (mEglConfig == null) {
+                throw new RuntimeException("mEglConfig not initialized");
+            }
+
+            /*
+             *  The window size has changed, so we need to create a new
+             *  surface.
+             */
+            destroySurfaceImp();
+
+            /*
+             * Create an EGL surface we can render into.
+             */
+            EGLTextureView view = mEGLTextureViewWeakRef.get();
+            if (view != null) {
+                mEglSurface = view.mEGLWindowSurfaceFactory.createWindowSurface(mEgl,
+                        mEglDisplay, mEglConfig, view.getSurfaceTexture());
+            } else {
+                mEglSurface = null;
+            }
+
+            if (mEglSurface == null || mEglSurface == EGL10.EGL_NO_SURFACE) {
+                int error = mEgl.eglGetError();
+                if (error == EGL10.EGL_BAD_NATIVE_WINDOW) {
+                    Log.e("EglHelper", "createWindowSurface returned EGL_BAD_NATIVE_WINDOW.");
+                }
+                return false;
+            }
+
+            /*
+             * Before we can issue GL commands, we need to make sure
+             * the context is current and bound to a surface.
+             */
+            if (!mEgl.eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface, mEglContext)) {
+                /*
+                 * Could not make the context current, probably because the underlying
+                 * TextureView surface has been destroyed.
+                 */
+                logEglErrorAsWarning("EGLHelper", "eglMakeCurrent", mEgl.eglGetError());
+                return false;
+            }
+
+            if (view != null) {
+                view.mRenderer.onEglSetup();
+            }
+
+            return true;
+        }
+
+        /**
+         * Create a GL object for the current EGL context.
+         * @return
+         */
+        GL createGL() {
+
+            GL gl = mEglContext.getGL();
+            EGLTextureView view = mEGLTextureViewWeakRef.get();
+            if (view != null) {
+                if (view.mGLWrapper != null) {
+                    gl = view.mGLWrapper.wrap(gl);
+                }
+
+                if ((view.mDebugFlags & (DEBUG_CHECK_GL_ERROR | DEBUG_LOG_GL_CALLS)) != 0) {
+                    int configFlags = 0;
+                    Writer log = null;
+                    if ((view.mDebugFlags & DEBUG_CHECK_GL_ERROR) != 0) {
+                        configFlags |= GLDebugHelper.CONFIG_CHECK_GL_ERROR;
+                    }
+                    if ((view.mDebugFlags & DEBUG_LOG_GL_CALLS) != 0) {
+                        log = new LogWriter();
+                    }
+                    gl = GLDebugHelper.wrap(gl, configFlags, log);
+                }
+            }
+            return gl;
+        }
+
+        /**
+         * Display the current render surface.
+         * @return the EGL error code from eglSwapBuffers.
+         */
+        public int swap() {
+            if (! mEgl.eglSwapBuffers(mEglDisplay, mEglSurface)) {
+                return mEgl.eglGetError();
+            }
+            return EGL10.EGL_SUCCESS;
+        }
+
+        public void destroySurface() {
+            if (LOG_EGL) {
+                Log.w("EglHelper", "destroySurface()  tid=" + Thread.currentThread().getId());
+            }
+            destroySurfaceImp();
+        }
+
+        private void destroySurfaceImp() {
+            if (mEglSurface != null && mEglSurface != EGL10.EGL_NO_SURFACE) {
+                EGLTextureView view = mEGLTextureViewWeakRef.get();
+                if (view != null) {
+                    view.mRenderer.onEglTearDown();
+                }
+                mEgl.eglMakeCurrent(mEglDisplay, EGL10.EGL_NO_SURFACE,
+                        EGL10.EGL_NO_SURFACE,
+                        EGL10.EGL_NO_CONTEXT);
+                if (view != null) {
+                    view.mEGLWindowSurfaceFactory.destroySurface(mEgl, mEglDisplay, mEglSurface);
+                }
+                mEglSurface = null;
+            }
+        }
+
+        public void finish() {
+            if (LOG_EGL) {
+                Log.w("EglHelper", "finish() tid=" + Thread.currentThread().getId());
+            }
+            if (mEglContext != null) {
+                EGLTextureView view = mEGLTextureViewWeakRef.get();
+                if (view != null) {
+                    view.mEGLContextFactory.destroyContext(mEgl, mEglDisplay, mEglContext);
+                }
+                mEglContext = null;
+            }
+            if (mEglDisplay != null) {
+                mEgl.eglTerminate(mEglDisplay);
+                mEglDisplay = null;
+            }
+        }
+
+        private void throwEglException(String function) {
+            throwEglException(function, mEgl.eglGetError());
+        }
+
+        public static void throwEglException(String function, int error) {
+            String message = formatEglError(function, error);
+            if (LOG_THREADS) {
+                Log.e("EglHelper", "throwEglException tid=" + Thread.currentThread().getId() + " "
+                        + message);
+            }
+            throw new RuntimeException(message);
+        }
+
+        public static void logEglErrorAsWarning(String tag, String function, int error) {
+            Log.w(tag, formatEglError(function, error));
+        }
+
+        public static String formatEglError(String function, int error) {
+            return function + " failed: " + eglGetErrorString(error);
+        }
+
+        static String eglGetErrorString(int error) {
+            switch (error) {
+                case EGL11.EGL_SUCCESS:
+                    return "EGL_SUCCESS";
+                case EGL11.EGL_NOT_INITIALIZED:
+                    return "EGL_NOT_INITIALIZED";
+                case EGL11.EGL_BAD_ACCESS:
+                    return "EGL_BAD_ACCESS";
+                case EGL11.EGL_BAD_ALLOC:
+                    return "EGL_BAD_ALLOC";
+                case EGL11.EGL_BAD_ATTRIBUTE:
+                    return "EGL_BAD_ATTRIBUTE";
+                case EGL11.EGL_BAD_CONFIG:
+                    return "EGL_BAD_CONFIG";
+                case EGL11.EGL_BAD_CONTEXT:
+                    return "EGL_BAD_CONTEXT";
+                case EGL11.EGL_BAD_CURRENT_SURFACE:
+                    return "EGL_BAD_CURRENT_SURFACE";
+                case EGL11.EGL_BAD_DISPLAY:
+                    return "EGL_BAD_DISPLAY";
+                case EGL11.EGL_BAD_MATCH:
+                    return "EGL_BAD_MATCH";
+                case EGL11.EGL_BAD_NATIVE_PIXMAP:
+                    return "EGL_BAD_NATIVE_PIXMAP";
+                case EGL11.EGL_BAD_NATIVE_WINDOW:
+                    return "EGL_BAD_NATIVE_WINDOW";
+                case EGL11.EGL_BAD_PARAMETER:
+                    return "EGL_BAD_PARAMETER";
+                case EGL11.EGL_BAD_SURFACE:
+                    return "EGL_BAD_SURFACE";
+                case EGL11.EGL_CONTEXT_LOST:
+                    return "EGL_CONTEXT_LOST";
+                default:
+                    return "0x" + Integer.toHexString(error);
+            }
+        }
+
+        private WeakReference<EGLTextureView> mEGLTextureViewWeakRef;
+        EGL10 mEgl;
+        EGLDisplay mEglDisplay;
+        EGLSurface mEglSurface;
+        EGLConfig mEglConfig;
+        EGLContext mEglContext;
+
+    }
+
+    /**
+     * A generic GL Thread. Takes care of initializing EGL and GL. Delegates
+     * to a Renderer instance to do the actual drawing. Can be configured to
+     * render continuously or on request.
+     *
+     * All potentially blocking synchronization is done through the
+     * sGLThreadManager object. This avoids multiple-lock ordering issues.
+     *
+     */
+    class GLThread extends Thread {
+        GLThread(WeakReference<EGLTextureView> EGLTextureViewWeakRef) {
+            super();
+            mWidth = 0;
+            mHeight = 0;
+            mRequestRender = true;
+            mEGLTextureViewWeakRef = EGLTextureViewWeakRef;
+        }
+
+        @Override
+        public void run() {
+            setName("GLThread " + getId());
+            if (LOG_THREADS) {
+                Log.i("GLThread", "starting tid=" + getId());
+            }
+
+            try {
+                guardedRun();
+            } catch (InterruptedException e) {
+                // fall through and exit normally
+            } finally {
+                sGLThreadManager.threadExiting(this);
+            }
+        }
+
+        /*
+         * This private method should only be called inside a
+         * synchronized(sGLThreadManager) block.
+         */
+        private void stopEglSurfaceLocked() {
+            if (mHaveEglSurface) {
+                mHaveEglSurface = false;
+                mEglHelper.destroySurface();
+            }
+        }
+
+        /*
+         * This private method should only be called inside a
+         * synchronized(sGLThreadManager) block.
+         */
+        private void stopEglContextLocked() {
+            if (mHaveEglContext) {
+                mEglHelper.finish();
+                mHaveEglContext = false;
+                sGLThreadManager.releaseEglContextLocked(this);
+            }
+        }
+        private void guardedRun() throws InterruptedException {
+            mEglHelper = new EglHelper(mEGLTextureViewWeakRef);
+            mHaveEglContext = false;
+            mHaveEglSurface = false;
+            try {
+                GL10 gl = null;
+                boolean createEglContext = false;
+                boolean createEglSurface = false;
+                boolean createGlInterface = false;
+                boolean lostEglContext = false;
+                boolean sizeChanged = false;
+                boolean wantRenderNotification = false;
+                boolean doRenderNotification = false;
+                boolean askedToReleaseEglContext = false;
+                int w = 0;
+                int h = 0;
+                Runnable event = null;
+
+                while (true) {
+                    synchronized (sGLThreadManager) {
+                        while (true) {
+                            if (mShouldExit) {
+                                return;
+                            }
+
+                            if (! mEventQueue.isEmpty()) {
+                                event = mEventQueue.remove(0);
+                                break;
+                            }
+
+                            // Update the pause state.
+                            boolean pausing = false;
+                            if (mPaused != mRequestPaused) {
+                                pausing = mRequestPaused;
+                                mPaused = mRequestPaused;
+                                sGLThreadManager.notifyAll();
+                                if (LOG_PAUSE_RESUME) {
+                                    Log.i("GLThread", "mPaused is now " + mPaused + " tid=" + getId());
+                                }
+                            }
+
+                            // Do we need to give up the EGL context?
+                            if (mShouldReleaseEglContext) {
+                                if (LOG_SURFACE) {
+                                    Log.i("GLThread", "releasing EGL context because asked to tid=" + getId());
+                                }
+                                stopEglSurfaceLocked();
+                                stopEglContextLocked();
+                                mShouldReleaseEglContext = false;
+                                askedToReleaseEglContext = true;
+                            }
+
+                            // Have we lost the EGL context?
+                            if (lostEglContext) {
+                                stopEglSurfaceLocked();
+                                stopEglContextLocked();
+                                lostEglContext = false;
+                            }
+
+                            // When pausing, release the EGL surface:
+                            if (pausing && mHaveEglSurface) {
+                                if (LOG_SURFACE) {
+                                    Log.i("GLThread", "releasing EGL surface because paused tid=" + getId());
+                                }
+                                stopEglSurfaceLocked();
+                            }
+
+                            // When pausing, optionally release the EGL Context:
+                            if (pausing && mHaveEglContext) {
+                                EGLTextureView view = mEGLTextureViewWeakRef.get();
+                                boolean preserveEglContextOnPause = view == null ?
+                                        false : view.mPreserveEGLContextOnPause;
+                                if (!preserveEglContextOnPause || sGLThreadManager.shouldReleaseEGLContextWhenPausing()) {
+                                    stopEglContextLocked();
+                                    if (LOG_SURFACE) {
+                                        Log.i("GLThread", "releasing EGL context because paused tid=" + getId());
+                                    }
+                                }
+                            }
+
+                            // When pausing, optionally terminate EGL:
+                            if (pausing) {
+                                if (sGLThreadManager.shouldTerminateEGLWhenPausing()) {
+                                    mEglHelper.finish();
+                                    if (LOG_SURFACE) {
+                                        Log.i("GLThread", "terminating EGL because paused tid=" + getId());
+                                    }
+                                }
+                            }
+
+                            // Have we lost the TextureView surface?
+                            if ((! mHasSurface) && (! mWaitingForSurface)) {
+                                if (LOG_SURFACE) {
+                                    Log.i("GLThread", "noticed TextureView surface lost tid=" + getId());
+                                }
+                                if (mHaveEglSurface) {
+                                    stopEglSurfaceLocked();
+                                }
+                                mWaitingForSurface = true;
+                                mSurfaceIsBad = false;
+                                sGLThreadManager.notifyAll();
+                            }
+
+                            // Have we acquired the surface view surface?
+                            if (mHasSurface && mWaitingForSurface) {
+                                if (LOG_SURFACE) {
+                                    Log.i("GLThread", "noticed TextureView surface acquired tid=" + getId());
+                                }
+                                mWaitingForSurface = false;
+                                sGLThreadManager.notifyAll();
+                            }
+
+                            if (doRenderNotification) {
+                                if (LOG_SURFACE) {
+                                    Log.i("GLThread", "sending render notification tid=" + getId());
+                                }
+                                wantRenderNotification = false;
+                                doRenderNotification = false;
+                                mRenderComplete = true;
+                                sGLThreadManager.notifyAll();
+                            }
+
+                            // Ready to draw?
+                            if (readyToDraw()) {
+
+                                // If we don't have an EGL context, try to acquire one.
+                                if (! mHaveEglContext) {
+                                    if (askedToReleaseEglContext) {
+                                        askedToReleaseEglContext = false;
+                                    } else if (sGLThreadManager.tryAcquireEglContextLocked(this)) {
+                                        try {
+                                            mEglHelper.start();
+                                        } catch (RuntimeException t) {
+                                            sGLThreadManager.releaseEglContextLocked(this);
+                                            throw t;
+                                        }
+                                        mHaveEglContext = true;
+                                        createEglContext = true;
+
+                                        sGLThreadManager.notifyAll();
+                                    }
+                                }
+
+                                if (mHaveEglContext && !mHaveEglSurface) {
+                                    mHaveEglSurface = true;
+                                    createEglSurface = true;
+                                    createGlInterface = true;
+                                    sizeChanged = true;
+                                }
+
+                                if (mHaveEglSurface) {
+                                    if (mSizeChanged) {
+                                        sizeChanged = true;
+                                        w = mWidth;
+                                        h = mHeight;
+                                        wantRenderNotification = true;
+                                        if (LOG_SURFACE) {
+                                            Log.i("GLThread",
+                                                    "noticing that we want render notification tid="
+                                                            + getId());
+                                        }
+
+                                        // Destroy and recreate the EGL surface.
+                                        createEglSurface = true;
+
+                                        mSizeChanged = false;
+                                    }
+                                    mRequestRender = false;
+                                    sGLThreadManager.notifyAll();
+                                    break;
+                                }
+                            }
+
+                            // By design, this is the only place in a GLThread thread where we wait().
+                            if (LOG_THREADS) {
+                                Log.i("GLThread", "\nwaiting tid=" + getId()
+                                        + "\nmHaveEglContext: " + mHaveEglContext
+                                        + "\nmHaveEglSurface: " + mHaveEglSurface
+                                        + "\nmFinishedCreatingEglSurface: " + mFinishedCreatingEglSurface
+                                        + "\nmPaused: " + mPaused
+                                        + "\nmHasSurface: " + mHasSurface
+                                        + "\nmSurfaceIsBad: " + mSurfaceIsBad
+                                        + "\nmWaitingForSurface: " + mWaitingForSurface
+                                        + "\nmWidth: " + mWidth
+                                        + "\nmHeight: " + mHeight
+                                        + "\nmRequestRender: " + mRequestRender);
+                            }
+                            sGLThreadManager.wait();
+                        }
+                    } // end of synchronized(sGLThreadManager)
+
+                    if (event != null) {
+                        event.run();
+                        event = null;
+                        continue;
+                    }
+
+                    if (createEglSurface) {
+                        if (LOG_SURFACE) {
+                            Log.w("GLThread", "egl createSurface");
+                        }
+                        if (mEglHelper.createSurface()) {
+                            synchronized(sGLThreadManager) {
+                                mFinishedCreatingEglSurface = true;
+                                sGLThreadManager.notifyAll();
+                            }
+                        } else {
+                            synchronized(sGLThreadManager) {
+                                mFinishedCreatingEglSurface = true;
+                                mSurfaceIsBad = true;
+                                sGLThreadManager.notifyAll();
+                            }
+                            continue;
+                        }
+                        createEglSurface = false;
+                    }
+
+                    if (createGlInterface) {
+                        gl = (GL10) mEglHelper.createGL();
+
+                        sGLThreadManager.checkGLDriver(gl);
+                        createGlInterface = false;
+                    }
+
+                    if (createEglContext) {
+                        if (LOG_RENDERER) {
+                            Log.w("GLThread", "onSurfaceCreated");
+                        }
+                        EGLTextureView view = mEGLTextureViewWeakRef.get();
+                        if (view != null) {
+                            view.mRenderer.onSurfaceCreated(gl, mEglHelper.mEglConfig);
+                        }
+                        createEglContext = false;
+                    }
+
+                    if (sizeChanged) {
+                        if (LOG_RENDERER) {
+                            Log.w("GLThread", "onSurfaceChanged(" + w + ", " + h + ")");
+                        }
+                        EGLTextureView view = mEGLTextureViewWeakRef.get();
+                        if (view != null) {
+                            view.mRenderer.onSurfaceChanged(gl, w, h);
+                        }
+                        sizeChanged = false;
+                    }
+
+                    synchronized (VSYNC_LOCK) {
+                        if (vsynced) {
+                            vsynced = false;
+                            if (LOG_RENDERER_DRAW_FRAME) {
+                                Log.w("GLThread", "onDrawFrame tid=" + getId());
+                            }
+                            EGLTextureView view = mEGLTextureViewWeakRef.get();
+                            if (view != null) {
+                                view.mRenderer.onDrawFrame(gl);
+                            }
+                            if (shouldSwap) {
+                                int swapError = mEglHelper.swap();
+                                shouldSwap = false;
+                                switch (swapError) {
+                                    case EGL10.EGL_SUCCESS:
+                                        break;
+                                    case EGL11.EGL_CONTEXT_LOST:
+                                        if (LOG_SURFACE) {
+                                            Log.i("GLThread", "egl context lost tid=" + getId());
+                                        }
+                                        lostEglContext = true;
+                                        break;
+                                    default:
+                                        // Other errors typically mean that the current surface is bad,
+                                        // probably because the TextureView surface has been destroyed,
+                                        // but we haven't been notified yet.
+                                        // Log the error to help developers understand why rendering stopped.
+                                        EglHelper.logEglErrorAsWarning("GLThread", "eglSwapBuffers", swapError);
+
+                                        synchronized (sGLThreadManager) {
+                                            mSurfaceIsBad = true;
+                                            sGLThreadManager.notifyAll();
+                                        }
+                                        break;
+                                }
+                            }
+                        }
+                    }
+
+                    if (wantRenderNotification) {
+                        doRenderNotification = true;
+                    }
+                }
+
+            } finally {
+                /*
+                 * clean-up everything...
+                 */
+                synchronized (sGLThreadManager) {
+                    stopEglSurfaceLocked();
+                    stopEglContextLocked();
+                }
+            }
+        }
+
+        public boolean ableToDraw() {
+            return mHaveEglContext && mHaveEglSurface && readyToDraw();
+        }
+
+        private boolean readyToDraw() {
+            return (!mPaused) && mHasSurface && (!mSurfaceIsBad)
+                    && (mWidth > 0) && (mHeight > 0)
+                    && (mRequestRender);
+        }
+
+        public void requestRender() {
+            synchronized(sGLThreadManager) {
+                mRequestRender = true;
+                sGLThreadManager.notifyAll();
+            }
+        }
+
+        public void surfaceCreated() {
+            synchronized(sGLThreadManager) {
+                if (LOG_THREADS) {
+                    Log.i("GLThread", "surfaceCreated tid=" + getId());
+                }
+                mHasSurface = true;
+                mFinishedCreatingEglSurface = false;
+                sGLThreadManager.notifyAll();
+                while (mWaitingForSurface
+                        && !mFinishedCreatingEglSurface
+                        && !mExited) {
+                    try {
+                        sGLThreadManager.wait();
+                    } catch (InterruptedException e) {
+                        Thread.currentThread().interrupt();
+                    }
+                }
+            }
+        }
+
+        public void surfaceDestroyed() {
+            synchronized(sGLThreadManager) {
+                if (LOG_THREADS) {
+                    Log.i("GLThread", "surfaceDestroyed tid=" + getId());
+                }
+                mHasSurface = false;
+                sGLThreadManager.notifyAll();
+                while((!mWaitingForSurface) && (!mExited)) {
+                    try {
+                        sGLThreadManager.wait();
+                    } catch (InterruptedException e) {
+                        Thread.currentThread().interrupt();
+                    }
+                }
+            }
+        }
+
+        public void onPause() {
+            synchronized (sGLThreadManager) {
+                if (LOG_PAUSE_RESUME) {
+                    Log.i("GLThread", "onPause tid=" + getId());
+                }
+                mRequestPaused = true;
+                sGLThreadManager.notifyAll();
+                while ((! mExited) && (! mPaused)) {
+                    if (LOG_PAUSE_RESUME) {
+                        Log.i("Main thread", "onPause waiting for mPaused.");
+                    }
+                    try {
+                        sGLThreadManager.wait();
+                    } catch (InterruptedException ex) {
+                        Thread.currentThread().interrupt();
+                    }
+                }
+            }
+        }
+
+        public void onResume() {
+            synchronized (sGLThreadManager) {
+                if (LOG_PAUSE_RESUME) {
+                    Log.i("GLThread", "onResume tid=" + getId());
+                }
+                mRequestPaused = false;
+                mRequestRender = true;
+                mRenderComplete = false;
+                sGLThreadManager.notifyAll();
+                while ((! mExited) && mPaused && (!mRenderComplete)) {
+                    if (LOG_PAUSE_RESUME) {
+                        Log.i("Main thread", "onResume waiting for !mPaused.");
+                    }
+                    try {
+                        sGLThreadManager.wait();
+                    } catch (InterruptedException ex) {
+                        Thread.currentThread().interrupt();
+                    }
+                }
+            }
+        }
+
+        public void onWindowResize(int w, int h) {
+            synchronized (sGLThreadManager) {
+                mWidth = w;
+                mHeight = h;
+                mSizeChanged = true;
+                mRequestRender = true;
+                mRenderComplete = false;
+                sGLThreadManager.notifyAll();
+
+                // Wait for thread to react to resize and render a frame
+                while (! mExited && !mPaused && !mRenderComplete
+                        && ableToDraw()) {
+                    if (LOG_SURFACE) {
+                        Log.i("Main thread", "onWindowResize waiting for render complete from tid=" + getId());
+                    }
+                    try {
+                        sGLThreadManager.wait();
+                    } catch (InterruptedException ex) {
+                        Thread.currentThread().interrupt();
+                    }
+                }
+            }
+        }
+
+        public void requestExitAndWait() {
+            // don't call this from GLThread thread or it is a guaranteed
+            // deadlock!
+            synchronized(sGLThreadManager) {
+                mShouldExit = true;
+                sGLThreadManager.notifyAll();
+                while (! mExited) {
+                    try {
+                        sGLThreadManager.wait();
+                    } catch (InterruptedException ex) {
+                        Thread.currentThread().interrupt();
+                    }
+                }
+            }
+        }
+
+        public void requestReleaseEglContextLocked() {
+            mShouldReleaseEglContext = true;
+            sGLThreadManager.notifyAll();
+        }
+
+        /**
+         * Queue an "event" to be run on the GL rendering thread.
+         * @param r the runnable to be run on the GL rendering thread.
+         */
+        public void queueEvent(Runnable r) {
+            if (r == null) {
+                throw new IllegalArgumentException("r must not be null");
+            }
+            synchronized(sGLThreadManager) {
+                mEventQueue.add(r);
+                sGLThreadManager.notifyAll();
+            }
+        }
+
+        // Once the thread is started, all accesses to the following member
+        // variables are protected by the sGLThreadManager monitor
+        private boolean mShouldExit;
+        private boolean mExited;
+        private boolean mRequestPaused;
+        private boolean mPaused;
+        private boolean mHasSurface;
+        private boolean mSurfaceIsBad;
+        private boolean mWaitingForSurface;
+        private boolean mHaveEglContext;
+        private boolean mHaveEglSurface;
+        private boolean mFinishedCreatingEglSurface;
+        private boolean mShouldReleaseEglContext;
+        private int mWidth;
+        private int mHeight;
+        private boolean mRequestRender;
+        private boolean mRenderComplete;
+        private ArrayList<Runnable> mEventQueue = new ArrayList<Runnable>();
+        private boolean mSizeChanged = true;
+
+        // End of member variables protected by the sGLThreadManager monitor.
+
+        private EglHelper mEglHelper;
+
+        /**
+         * Set once at thread construction time, nulled out when the parent view is garbage
+         * called. This weak reference allows the EGLTextureView to be garbage collected while
+         * the GLThread is still alive.
+         */
+        private WeakReference<EGLTextureView> mEGLTextureViewWeakRef;
+
+    }
+
+    static class LogWriter extends Writer {
+
+        @Override public void close() {
+            flushBuilder();
+        }
+
+        @Override public void flush() {
+            flushBuilder();
+        }
+
+        @Override public void write(char[] buf, int offset, int count) {
+            for(int i = 0; i < count; i++) {
+                char c = buf[offset + i];
+                if ( c == '\n') {
+                    flushBuilder();
+                }
+                else {
+                    mBuilder.append(c);
+                }
+            }
+        }
+
+        private void flushBuilder() {
+            if (mBuilder.length() > 0) {
+                Log.v("EGLTextureView", mBuilder.toString());
+                mBuilder.delete(0, mBuilder.length());
+            }
+        }
+
+        private StringBuilder mBuilder = new StringBuilder();
+    }
+
+
+    private final void checkRenderThreadState() {
+        if (mGLThread != null) {
+            throw new IllegalStateException(
+                    "setRenderer has already been called for this instance.");
+        }
+    }
+
+    private static class GLThreadManager {
+        private static String TAG = "GLThreadManager";
+
+        public synchronized void threadExiting(GLThread thread) {
+            if (LOG_THREADS) {
+                Log.i("GLThread", "exiting tid=" +  thread.getId());
+            }
+            thread.mExited = true;
+            if (mEglOwner == thread) {
+                mEglOwner = null;
+            }
+            notifyAll();
+        }
+
+        /*
+         * Tries once to acquire the right to use an EGL
+         * context. Does not block. Requires that we are already
+         * in the sGLThreadManager monitor when this is called.
+         *
+         * @return true if the right to use an EGL context was acquired.
+         */
+        public boolean tryAcquireEglContextLocked(GLThread thread) {
+            if (mEglOwner == thread || mEglOwner == null) {
+                mEglOwner = thread;
+                notifyAll();
+                return true;
+            }
+            checkGLESVersion();
+            if (mMultipleGLESContextsAllowed) {
+                return true;
+            }
+            // Notify the owning thread that it should release the context.
+            // TODO: implement a fairness policy. Currently
+            // if the owning thread is drawing continuously it will just
+            // reacquire the EGL context.
+            if (mEglOwner != null) {
+                mEglOwner.requestReleaseEglContextLocked();
+            }
+            return false;
+        }
+
+        /*
+         * Releases the EGL context. Requires that we are already in the
+         * sGLThreadManager monitor when this is called.
+         */
+        public void releaseEglContextLocked(GLThread thread) {
+            if (mEglOwner == thread) {
+                mEglOwner = null;
+            }
+            notifyAll();
+        }
+
+        public synchronized boolean shouldReleaseEGLContextWhenPausing() {
+            // Release the EGL context when pausing even if
+            // the hardware supports multiple EGL contexts.
+            // Otherwise the device could run out of EGL contexts.
+            return mLimitedGLESContexts;
+        }
+
+        public synchronized boolean shouldTerminateEGLWhenPausing() {
+            checkGLESVersion();
+            return !mMultipleGLESContextsAllowed;
+        }
+
+        public synchronized void checkGLDriver(GL10 gl) {
+            if (! mGLESDriverCheckComplete) {
+                checkGLESVersion();
+                String renderer = gl.glGetString(GL10.GL_RENDERER);
+                if (mGLESVersion < kGLES_20) {
+                    mMultipleGLESContextsAllowed =
+                            ! renderer.startsWith(kMSM7K_RENDERER_PREFIX);
+                    notifyAll();
+                }
+                mLimitedGLESContexts = !mMultipleGLESContextsAllowed;
+                if (LOG_SURFACE) {
+                    Log.w(TAG, "checkGLDriver renderer = \"" + renderer + "\" multipleContextsAllowed = "
+                            + mMultipleGLESContextsAllowed
+                            + " mLimitedGLESContexts = " + mLimitedGLESContexts);
+                }
+                mGLESDriverCheckComplete = true;
+            }
+        }
+
+        private void checkGLESVersion() {
+            if (! mGLESVersionCheckComplete) {
+                mGLESVersion = SystemProperties.getInt(
+                        "ro.opengles.version",
+                        ConfigurationInfo.GL_ES_VERSION_UNDEFINED);
+                if (mGLESVersion >= kGLES_20) {
+                    mMultipleGLESContextsAllowed = true;
+                }
+                if (LOG_SURFACE) {
+                    Log.w(TAG, "checkGLESVersion mGLESVersion =" +
+                            " " + mGLESVersion + " mMultipleGLESContextsAllowed = " + mMultipleGLESContextsAllowed);
+                }
+                mGLESVersionCheckComplete = true;
+            }
+        }
+
+        /**
+         * This check was required for some pre-Android-3.0 hardware. Android 3.0 provides
+         * support for hardware-accelerated views, therefore multiple EGL contexts are
+         * supported on all Android 3.0+ EGL drivers.
+         */
+        private boolean mGLESVersionCheckComplete;
+        private int mGLESVersion;
+        private boolean mGLESDriverCheckComplete;
+        private boolean mMultipleGLESContextsAllowed;
+        private boolean mLimitedGLESContexts;
+        private static final int kGLES_20 = 0x20000;
+        private static final String kMSM7K_RENDERER_PREFIX =
+                "Q3Dimension MSM7500 ";
+        private GLThread mEglOwner;
+    }
+
+    private static final GLThreadManager sGLThreadManager = new GLThreadManager();
+
+    private final WeakReference<EGLTextureView> mThisWeakRef =
+            new WeakReference<EGLTextureView>(this);
+    private GLThread mGLThread;
+    private Renderer mRenderer;
+    private boolean mDetached;
+    private EGLConfigChooser mEGLConfigChooser;
+    private EGLContextFactory mEGLContextFactory;
+    private EGLWindowSurfaceFactory mEGLWindowSurfaceFactory;
+    private GLWrapper mGLWrapper;
+    private int mDebugFlags;
+    private int mEGLContextClientVersion;
+    private boolean mPreserveEGLContextOnPause;
+
+    /**
+     * Gives access to the system properties store.  The system properties
+     * store contains a list of string key-value pairs.
+     */
+    private static class SystemProperties
+    {
+        public static final int PROP_NAME_MAX = 31;
+        public static final int PROP_VALUE_MAX = 91;
+
+        /**
+         * Get the value for the given key.
+         * @return an empty string if the key isn't found
+         * @throws IllegalArgumentException if the key exceeds 32 characters
+         */
+        public static String get(String key) {
+            if (key.length() > PROP_NAME_MAX) {
+                throw new IllegalArgumentException("key.length > " + PROP_NAME_MAX);
+            }
+            try {
+                return native_get(key);
+            } catch (Exception e) {
+                return "";
+            }
+        }
+        /**
+         * Get the value for the given key.
+         * @return if the key isn't found, return def if it isn't null, or an empty string otherwise
+         * @throws IllegalArgumentException if the key exceeds 32 characters
+         */
+        public static String get(String key, String def) {
+            if (key.length() > PROP_NAME_MAX) {
+                throw new IllegalArgumentException("key.length > " + PROP_NAME_MAX);
+            }
+            try {
+                String ret = native_get(key);
+                if(TextUtils.isEmpty(ret)) {
+                    return def;
+                }
+                return ret;
+            } catch (Exception e) {
+                return def;
+            }
+        }
+        /**
+         * Get the value for the given key, and return as an integer.
+         * @param key the key to lookup
+         * @param def a default value to return
+         * @return the key parsed as an integer, or def if the key isn't found or
+         *         cannot be parsed
+         * @throws IllegalArgumentException if the key exceeds 32 characters
+         */
+        public static int getInt(String key, int def) {
+            if (key.length() > PROP_NAME_MAX) {
+                throw new IllegalArgumentException("key.length > " + PROP_NAME_MAX);
+            }
+            try {
+                return Integer.parseInt(native_get(key));
+            } catch (Exception e) {
+                return def;
+            }
+        }
+        /**
+         * Get the value for the given key, and return as a long.
+         * @param key the key to lookup
+         * @param def a default value to return
+         * @return the key parsed as a long, or def if the key isn't found or
+         *         cannot be parsed
+         * @throws IllegalArgumentException if the key exceeds 32 characters
+         */
+        public static long getLong(String key, long def) {
+            if (key.length() > PROP_NAME_MAX) {
+                throw new IllegalArgumentException("key.length > " + PROP_NAME_MAX);
+            }
+            try {
+                return Long.parseLong(native_get(key));
+            } catch (Exception e) {
+                return def;
+            }
+        }
+        /**
+         * Get the value for the given key, returned as a boolean.
+         * Values 'n', 'no', '0', 'false' or 'off' are considered false.
+         * Values 'y', 'yes', '1', 'true' or 'on' are considered true.
+         * (case sensitive).
+         * If the key does not exist, or has any other value, then the default
+         * result is returned.
+         * @param key the key to lookup
+         * @param def a default value to return
+         * @return the key parsed as a boolean, or def if the key isn't found or is
+         *         not able to be parsed as a boolean.
+         * @throws IllegalArgumentException if the key exceeds 32 characters
+         */
+        public static boolean getBoolean(String key, boolean def) {
+            if (key.length() > PROP_NAME_MAX) {
+                throw new IllegalArgumentException("key.length > " + PROP_NAME_MAX);
+            }
+            try {
+                return Boolean.parseBoolean(native_get(key));
+            } catch (Exception e) {
+                return def;
+            }
+        }
+
+        private static Map<String, String> cache = new HashMap<String, String>();
+        private static String native_get(String key) throws Exception {
+            if(cache.containsKey(key)) {
+                return cache.get(key);
+            }
+
+            Process p = Runtime.getRuntime().exec("/system/bin/getprop " + key);
+            p.waitFor();
+            BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream()));
+            String ln = reader.readLine();
+            reader.close();
+            p.destroy();
+
+            cache.put(key, ln);
+            return ln;
+        }
+
+    }
+}
diff --git a/app/src/main/java/smallville7123/graphical/tool/kit/Cleaner.java b/app/src/main/java/smallville7123/graphical/tool/kit/Cleaner.java
new file mode 100644
index 00000000..04e23155
--- /dev/null
+++ b/app/src/main/java/smallville7123/graphical/tool/kit/Cleaner.java
@@ -0,0 +1,39 @@
+package smallville7123.graphical.tool.kit;
+
+public class Cleaner {
+    public interface Cleanable {
+        void clean();
+    }
+    public static Cleanable register(Object o, Runnable r) {
+        CleanerReference c = new CleanerReference(
+                java.util.Objects.requireNonNull(o), java.util.Objects.requireNonNull(r));
+        phantomReferences.add(c);
+        return c;
+    }
+    private static final java.util.Set<smallville7123.graphical.tool.kit.Cleaner.CleanerReference> phantomReferences
+                                             = java.util.concurrent.ConcurrentHashMap.newKeySet();
+    private static final java.lang.ref.ReferenceQueue<Object> garbageCollectedObjectsQueue
+                                              = new java.lang.ref.ReferenceQueue<>();
+
+    static final class CleanerReference extends java.lang.ref.PhantomReference<Object>
+                                        implements Cleanable {
+        private final Runnable cleaningAction;
+
+        CleanerReference(Object referent, Runnable action) {
+            super(referent, garbageCollectedObjectsQueue);
+            cleaningAction = action;
+        }
+        public void clean() {
+            if(phantomReferences.remove(this)) {
+                super.clear();
+                cleaningAction.run();
+            }
+        }
+    }
+    public static void deleteOrphanedNativePeerObjects() {
+        CleanerReference reference;
+        while((reference=(CleanerReference)garbageCollectedObjectsQueue.poll()) != null) {
+            reference.clean();
+        }
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/smallville7123/graphical/tool/kit/DiligentEngineView.java b/app/src/main/java/smallville7123/graphical/tool/kit/DiligentEngineView.java
new file mode 100644
index 00000000..449307bf
--- /dev/null
+++ b/app/src/main/java/smallville7123/graphical/tool/kit/DiligentEngineView.java
@@ -0,0 +1,189 @@
+package smallville7123.graphical.tool.kit;
+
+import android.content.Context;
+import android.util.AttributeSet;
+import android.view.MotionEvent;
+
+import javax.microedition.khronos.egl.EGLConfig;
+import javax.microedition.khronos.opengles.GL10;
+
+import smallville7123.EGLSurfaceView_EGLTextureView.EGLTextureView;
+
+public class DiligentEngineView extends EGLTextureView {
+
+
+    private DiligentEngineView.DiligentEngineRenderer renderer;
+
+    /**
+     * Standard View constructor. In order to render something, you
+     * must call {@link #setRenderer} to register a renderer.
+     *
+     * @param context
+     */
+    public DiligentEngineView(Context context) {
+        super(context);
+    }
+
+    /**
+     * Standard View constructor. In order to render something, you
+     * must call {@link #setRenderer} to register a renderer.
+     *
+     * @param context
+     * @param attrs
+     */
+    public DiligentEngineView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+    }
+
+    @Override
+    protected void init() {
+        super.init();
+        setEGLContextClientVersion(3);
+        setRenderer(renderer = new DiligentEngineRenderer());
+    }
+
+    @Override
+    public boolean onTouchEvent(MotionEvent event) {
+        int action = event.getActionMasked();
+        int actionIndex = event.getActionIndex();
+        int id = 0;
+        boolean isUpDown = false;
+        switch (action) {
+            case MotionEvent.ACTION_CANCEL:
+            case MotionEvent.ACTION_DOWN:
+            case MotionEvent.ACTION_UP:
+            case MotionEvent.ACTION_POINTER_DOWN:
+            case MotionEvent.ACTION_POINTER_UP:
+                id = event.getPointerId(actionIndex);
+                isUpDown = true;
+                break;
+        }
+
+        int c = event.getPointerCount();
+        for (int i = 0; i < c; i++) {
+            int pid = event.getPointerId(i);
+            if (actionIndex != i || !isUpDown) {
+                renderer.moveTouch(
+                        pid,
+                        event.getX(i),
+                        event.getY(i),
+                        event.getSize(i),
+                        event.getPressure(i)
+                );
+            }
+        }
+        if (isUpDown) {
+            switch (action) {
+                case MotionEvent.ACTION_CANCEL:
+                    renderer.cancelTouch(
+                            id,
+                            event.getX(actionIndex),
+                            event.getY(actionIndex),
+                            event.getSize(actionIndex),
+                            event.getPressure(actionIndex)
+                    );
+                    break;
+                case MotionEvent.ACTION_DOWN:
+                case MotionEvent.ACTION_POINTER_DOWN:
+                    renderer.addTouch(
+                            id,
+                            event.getX(actionIndex),
+                            event.getY(actionIndex),
+                            event.getSize(actionIndex),
+                            event.getPressure(actionIndex)
+                    );
+                    break;
+                case MotionEvent.ACTION_UP:
+                case MotionEvent.ACTION_POINTER_UP:
+                    renderer.removeTouch(
+                            id,
+                            event.getX(actionIndex),
+                            event.getY(actionIndex),
+                            event.getSize(actionIndex),
+                            event.getPressure(actionIndex)
+                    );
+                    break;
+            }
+        }
+        renderer.onTouchEvent(renderer.nativeInstance);
+        // should a ViewGroup always return true for onTouchEvent?
+        return true;
+    }
+
+    private class DiligentEngineRenderer implements Renderer {
+        native long createNativeInstance();
+        native void destroyNativeInstance(long instance);
+        native void onEglSetup(long instance, Object classInstance, String name, String signature);
+        native void surfaceChanged(long instance, int w, int h);
+        native void addTouch(long identity, float x, float y);
+        native void addTouch(long identity, float x, float y, float size);
+        native void addTouch(long identity, float x, float y, float size, float pressure);
+        native void moveTouch(long identity, float x, float y);
+        native void moveTouch(long identity, float x, float y, float size);
+        native void moveTouch(long identity, float x, float y, float size, float pressure);
+        native void removeTouch(long identity, float x, float y);
+        native void removeTouch(long identity, float x, float y, float size);
+        native void removeTouch(long identity, float x, float y, float size, float pressure);
+        native void cancelTouch(long identity, float x, float y);
+        native void cancelTouch(long identity, float x, float y, float size);
+        native void cancelTouch(long identity, float x, float y, float size, float pressure);
+        native boolean onTouchEvent(long instance);
+        native void onDraw(long instance);
+        native void onEglTearDown(long instance);
+        long nativeInstance;
+
+        DiligentEngineRenderer() {
+            System.loadLibrary("native-lib");
+        }
+
+        @Override
+        public void onEglSetup() {
+            nativeInstance = createNativeInstance();
+            onEglSetup(nativeInstance, DiligentEngineView.this,
+                    getJavaNameForJNI(METHOD.SWAP_BUFFERS),
+                    getJavaSignatureForJNI(METHOD.SWAP_BUFFERS)
+            );
+        }
+
+        @Override
+        public void onEglTearDown() {
+            onEglTearDown(nativeInstance);
+            destroyNativeInstance(nativeInstance);
+        }
+
+        @Override
+        public void onSurfaceCreated(GL10 gl, EGLConfig config) {
+            // do nothing
+        }
+
+        @Override
+        public void onSurfaceChanged(GL10 gl, int width, int height) {
+            surfaceChanged(nativeInstance, width, height);
+        }
+
+        @Override
+        public void onDrawFrame(GL10 gl) {
+            onDraw(nativeInstance);
+        }
+    }
+}
+
+// public class DiligentEngineController {
+//     DiligentEngineView mEngine;
+    
+//     public void onCreate(Context context) {
+//         mEngine = new DiligentEngineView(context);
+//     }
+    
+//     DiligentEngineView view() {
+//       return mEngine;
+//     }
+
+//     public void onPause() {
+//       mEngine.onPause();
+//     }
+
+//     public void onResume() {
+//       mEngine.onResume();
+//     }
+// }
\ No newline at end of file
diff --git a/app/src/main/res/values/strings.xml b/app/src/main/res/values/strings.xml
index 236db7ed..897f283a 100644
--- a/app/src/main/res/values/strings.xml
+++ b/app/src/main/res/values/strings.xml
@@ -1,5 +1,5 @@
 <resources>
-    <string name="app_name">Media Player Pro</string>
+    <string name="app_name">Linux Kernel 6.11</string>
 
     <!-- Common -->
     <string name="cancel_label">Cancel</string>
diff --git a/app/src/test/java/media/player/pro/ExampleUnitTest.kt b/app/src/test/java/linux/kernel/ExampleUnitTest.kt
similarity index 92%
rename from app/src/test/java/media/player/pro/ExampleUnitTest.kt
rename to app/src/test/java/linux/kernel/ExampleUnitTest.kt
index 28d4d9bc..084a9e19 100644
--- a/app/src/test/java/media/player/pro/ExampleUnitTest.kt
+++ b/app/src/test/java/linux/kernel/ExampleUnitTest.kt
@@ -1,4 +1,4 @@
-package media.player.pro
+package linux.kernel
 
 import org.junit.Test
 
diff --git a/settings.gradle b/settings.gradle
index f9e92492..cb854736 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -1,2 +1,2 @@
 include ':app'
-rootProject.name='Media Player Pro'
+rootProject.name='Linux Kernel 6.11'
-- 
2.46.0

