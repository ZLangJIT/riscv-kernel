From 07bc7d55b1051744fbb8b93695b1e0fa10ce7de4 Mon Sep 17 00:00:00 2001
From: root <root@localhost.localdomain>
Date: Sun, 22 Sep 2024 08:14:26 +0000
Subject: [PATCH 1/1] c

---
 app/build.gradle                              |    2 +-
 app/src/main/AndroidManifest.xml              |    2 +-
 app/src/main/CMakeLists.txt                   |    5 +-
 .../java/libengine/AppInstanceAndroidBase.cpp |   70 +
 .../java/libengine/AppInstanceAndroidBase.h   |   27 +
 app/src/main/java/libengine/CMakeLists.txt    |   32 +
 .../java/libengine/DiligentLog/CMakeLists.txt |  332 +++
 app/src/main/java/libengine/DiligentLog/Log.h |   71 +
 .../Platforms/Android/CMakeLists.txt          |   46 +
 .../Android/interface/AndroidDebug.hpp        |   43 +
 .../Android/interface/AndroidFileSystem.hpp   |   99 +
 .../Android/interface/AndroidNativeWindow.h   |   39 +
 .../interface/AndroidPlatformDefinitions.h    |   40 +
 .../Android/interface/AndroidPlatformMisc.hpp |   36 +
 .../Platforms/Android/src/AndroidDebug.cpp    |   62 +
 .../Android/src/AndroidFileSystem.cpp         |  359 +++
 .../Platforms/Apple/CMakeLists.txt            |   73 +
 .../Platforms/Apple/interface/AppleDebug.hpp  |   43 +
 .../Apple/interface/AppleFileSystem.hpp       |   53 +
 .../interface/ApplePlatformDefinitions.h      |   44 +
 .../Apple/interface/ApplePlatformMisc.hpp     |   36 +
 .../Apple/interface/CFObjectWrapper.hpp       |   53 +
 .../Apple/interface/IOSNativeWindow.h         |   48 +
 .../Apple/interface/MacOSNativeWindow.h       |   48 +
 .../Apple/interface/TVOSNativeWindow.h        |   47 +
 .../Platforms/Apple/src/AppleDebug.mm         |   59 +
 .../Platforms/Apple/src/AppleFileSystem.cpp   |  150 +
 .../Platforms/Basic/CMakeLists.txt            |   52 +
 .../Basic/interface/BasicAtomics.hpp          |   69 +
 .../Basic/interface/BasicFileSystem.hpp       |  108 +
 .../Basic/interface/BasicPlatformDebug.hpp    |   46 +
 .../Basic/interface/BasicPlatformMisc.hpp     |   69 +
 .../Basic/interface/DebugUtilities.hpp        |  108 +
 .../Basic/interface/StandardFile.hpp          |   55 +
 .../Platforms/Basic/src/BasicFileSystem.cpp   |  143 +
 .../Basic/src/BasicPlatformDebug.cpp          |   75 +
 .../Platforms/Basic/src/StandardFile.cpp      |  123 +
 .../DiligentLog/Platforms/CMakeLists.txt      |   40 +
 .../Platforms/Linux/CMakeLists.txt            |   44 +
 .../Platforms/Linux/interface/LinuxDebug.hpp  |   43 +
 .../Linux/interface/LinuxFileSystem.hpp       |   53 +
 .../Linux/interface/LinuxNativeWindow.h       |   42 +
 .../interface/LinuxPlatformDefinitions.h      |   44 +
 .../Linux/interface/LinuxPlatformMisc.hpp     |  102 +
 .../Platforms/Linux/src/LinuxDebug.cpp        |   61 +
 .../Platforms/Linux/src/LinuxFileSystem.cpp   |   89 +
 .../DiligentLog/Platforms/UWP/CMakeLists.txt  |   46 +
 .../Platforms/UWP/interface/UWPDebug.hpp      |   43 +
 .../Platforms/UWP/interface/UWPDefinitions.h  |   30 +
 .../Platforms/UWP/interface/UWPFileSystem.hpp |   80 +
 .../Platforms/UWP/interface/UWPNativeWindow.h |   49 +
 .../Platforms/UWP/src/UWPDebug.cpp            |   89 +
 .../Platforms/UWP/src/UWPFileSystem.cpp       |  277 ++
 .../Platforms/Win32/CMakeLists.txt            |   47 +
 .../Win32/interface/Win32Atomics.hpp          |   55 +
 .../Platforms/Win32/interface/Win32Debug.hpp  |   43 +
 .../Win32/interface/Win32FileSystem.hpp       |  136 +
 .../Win32/interface/Win32NativeWindow.h       |   48 +
 .../interface/Win32PlatformDefinitions.h      |   30 +
 .../Win32/interface/Win32PlatformMisc.hpp     |  141 +
 .../Platforms/Win32/src/Win32Atomics.cpp      |   67 +
 .../Platforms/Win32/src/Win32Debug.cpp        |   91 +
 .../Platforms/Win32/src/Win32FileSystem.cpp   |  392 +++
 .../Platforms/interface/Atomics.hpp           |   43 +
 .../Platforms/interface/FileSystem.hpp        |   66 +
 .../Platforms/interface/NativeWindow.h        |   98 +
 .../Platforms/interface/PlatformDebug.hpp     |   54 +
 .../Platforms/interface/PlatformDefinitions.h |  100 +
 .../Platforms/interface/PlatformMisc.hpp      |   52 +
 .../DiligentLog/Primitives/CMakeLists.txt     |   49 +
 .../Primitives/interface/BasicTypes.h         |   69 +
 .../Primitives/interface/CommonDefinitions.h  |  107 +
 .../Primitives/interface/DataBlob.h           |   84 +
 .../Primitives/interface/DebugOutput.h        |   72 +
 .../interface/DefineGlobalFuncHelperMacros.h  |   41 +
 .../interface/DefineInterfaceHelperMacros.h   |   90 +
 .../Primitives/interface/Errors.hpp           |  165 ++
 .../Primitives/interface/FileStream.h         |   90 +
 .../Primitives/interface/FlagEnum.h           |   53 +
 .../Primitives/interface/FormatString.hpp     |  103 +
 .../Primitives/interface/InterfaceID.h        |   59 +
 .../Primitives/interface/MemoryAllocator.h    |   81 +
 .../DiligentLog/Primitives/interface/Object.h |  120 +
 .../Primitives/interface/ReferenceCounters.h  |  165 ++
 .../interface/UndefGlobalFuncHelperMacros.h   |   28 +
 .../interface/UndefInterfaceHelperMacros.h    |   37 +
 .../Primitives/src/DebugOutput.cpp            |   40 +
 .../DiligentLog/Primitives/src/test.cpp       |   35 +
 .../java/libengine/DiligentLog/common.cpp     |   25 +
 app/src/main/java/libengine/JVM_MANAGER.cpp   |   45 +
 app/src/main/java/libengine/JVM_MANAGER.h     |   26 +
 app/src/main/java/libengine/native.cpp        |  213 ++
 .../main/java/linux/kernel/MainActivity.kt    |   95 +
 .../pro => linux/kernel}/UpdatingTextView.kt  |    2 +-
 .../java/media/player/pro/MainActivity.kt     |  170 --
 .../EGLSurfaceView.java                       | 2426 +++++++++++++++++
 .../EGLTextureView.java                       | 2406 ++++++++++++++++
 .../graphical/tool/kit/Cleaner.java           |   39 +
 .../tool/kit/DiligentEngineView.java          |  169 ++
 settings.gradle                               |    2 +-
 100 files changed, 12293 insertions(+), 175 deletions(-)
 create mode 100644 app/src/main/java/libengine/AppInstanceAndroidBase.cpp
 create mode 100644 app/src/main/java/libengine/AppInstanceAndroidBase.h
 create mode 100644 app/src/main/java/libengine/CMakeLists.txt
 create mode 100644 app/src/main/java/libengine/DiligentLog/CMakeLists.txt
 create mode 100644 app/src/main/java/libengine/DiligentLog/Log.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Android/CMakeLists.txt
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Android/interface/AndroidDebug.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Android/interface/AndroidFileSystem.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Android/interface/AndroidNativeWindow.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Android/interface/AndroidPlatformDefinitions.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Android/interface/AndroidPlatformMisc.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Android/src/AndroidDebug.cpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Android/src/AndroidFileSystem.cpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Apple/CMakeLists.txt
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/AppleDebug.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/AppleFileSystem.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/ApplePlatformDefinitions.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/ApplePlatformMisc.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/CFObjectWrapper.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/IOSNativeWindow.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/MacOSNativeWindow.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/TVOSNativeWindow.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Apple/src/AppleDebug.mm
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Apple/src/AppleFileSystem.cpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Basic/CMakeLists.txt
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/BasicAtomics.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/BasicFileSystem.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/BasicPlatformDebug.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/BasicPlatformMisc.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/DebugUtilities.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/StandardFile.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Basic/src/BasicFileSystem.cpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Basic/src/BasicPlatformDebug.cpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Basic/src/StandardFile.cpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/CMakeLists.txt
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Linux/CMakeLists.txt
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Linux/interface/LinuxDebug.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Linux/interface/LinuxFileSystem.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Linux/interface/LinuxNativeWindow.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Linux/interface/LinuxPlatformDefinitions.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Linux/interface/LinuxPlatformMisc.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Linux/src/LinuxDebug.cpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Linux/src/LinuxFileSystem.cpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/UWP/CMakeLists.txt
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/UWP/interface/UWPDebug.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/UWP/interface/UWPDefinitions.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/UWP/interface/UWPFileSystem.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/UWP/interface/UWPNativeWindow.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/UWP/src/UWPDebug.cpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/UWP/src/UWPFileSystem.cpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Win32/CMakeLists.txt
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32Atomics.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32Debug.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32FileSystem.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32NativeWindow.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32PlatformDefinitions.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32PlatformMisc.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Win32/src/Win32Atomics.cpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Win32/src/Win32Debug.cpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/Win32/src/Win32FileSystem.cpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/interface/Atomics.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/interface/FileSystem.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/interface/NativeWindow.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/interface/PlatformDebug.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/interface/PlatformDefinitions.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Platforms/interface/PlatformMisc.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Primitives/CMakeLists.txt
 create mode 100644 app/src/main/java/libengine/DiligentLog/Primitives/interface/BasicTypes.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Primitives/interface/CommonDefinitions.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Primitives/interface/DataBlob.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Primitives/interface/DebugOutput.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Primitives/interface/DefineGlobalFuncHelperMacros.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Primitives/interface/DefineInterfaceHelperMacros.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Primitives/interface/Errors.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Primitives/interface/FileStream.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Primitives/interface/FlagEnum.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Primitives/interface/FormatString.hpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Primitives/interface/InterfaceID.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Primitives/interface/MemoryAllocator.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Primitives/interface/Object.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Primitives/interface/ReferenceCounters.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Primitives/interface/UndefGlobalFuncHelperMacros.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Primitives/interface/UndefInterfaceHelperMacros.h
 create mode 100644 app/src/main/java/libengine/DiligentLog/Primitives/src/DebugOutput.cpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/Primitives/src/test.cpp
 create mode 100644 app/src/main/java/libengine/DiligentLog/common.cpp
 create mode 100644 app/src/main/java/libengine/JVM_MANAGER.cpp
 create mode 100644 app/src/main/java/libengine/JVM_MANAGER.h
 create mode 100644 app/src/main/java/libengine/native.cpp
 create mode 100644 app/src/main/java/linux/kernel/MainActivity.kt
 rename app/src/main/java/{media/player/pro => linux/kernel}/UpdatingTextView.kt (98%)
 delete mode 100644 app/src/main/java/media/player/pro/MainActivity.kt
 create mode 100644 app/src/main/java/smallville7123/EGLSurfaceView_EGLTextureView/EGLSurfaceView.java
 create mode 100644 app/src/main/java/smallville7123/EGLSurfaceView_EGLTextureView/EGLTextureView.java
 create mode 100644 app/src/main/java/smallville7123/graphical/tool/kit/Cleaner.java
 create mode 100644 app/src/main/java/smallville7123/graphical/tool/kit/DiligentEngineView.java

diff --git a/app/build.gradle b/app/build.gradle
index 8365cc7a..172dadc6 100755
--- a/app/build.gradle
+++ b/app/build.gradle
@@ -15,7 +15,7 @@ android { // main settings for your application
     }
 
     defaultConfig {
-        applicationId "media.player.pro"
+        applicationId "linux.kernel"
         minSdkVersion 26
         targetSdkVersion 29
         versionCode 1
diff --git a/app/src/main/AndroidManifest.xml b/app/src/main/AndroidManifest.xml
index 6843690f..5180a236 100644
--- a/app/src/main/AndroidManifest.xml
+++ b/app/src/main/AndroidManifest.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="media.player.pro" >
+    package="linux.kernel" >
 
     <uses-feature android:name="android.hardware.touchscreen" android:required="false" />
 
diff --git a/app/src/main/CMakeLists.txt b/app/src/main/CMakeLists.txt
index 8e8e3779..9b980553 100644
--- a/app/src/main/CMakeLists.txt
+++ b/app/src/main/CMakeLists.txt
@@ -4,4 +4,7 @@ cmake_minimum_required(VERSION 3.4.1)
 add_subdirectory(java/alpine/term/jni)
 
 # AudioEngine
-add_subdirectory(java/libmedia)
\ No newline at end of file
+#add_subdirectory(java/libmedia)
+
+# EngineView
+add_subdirectory(java/libengine)
diff --git a/app/src/main/java/libengine/AppInstanceAndroidBase.cpp b/app/src/main/java/libengine/AppInstanceAndroidBase.cpp
new file mode 100644
index 00000000..3ae626ae
--- /dev/null
+++ b/app/src/main/java/libengine/AppInstanceAndroidBase.cpp
@@ -0,0 +1,70 @@
+//
+// Created by Matthew Good on 29/6/21.
+//
+
+#include <MultiTouch/DiligentLog/Log.h>
+#include "AppInstanceAndroidBase.h"
+
+void AppInstanceAndroidBase::onEglSetup (JNIEnv * jenv, jobject classInstance, jstring name, jstring signature)
+{
+    if (!jvmManager.getJVM(jenv)) {
+        Log::Error("failed to get JavaVM");
+        return;
+    }
+    if (!jvmManager.attachJVM()) {
+        Log::Error("failed to attach JVM");
+        return;
+    }
+    jObject = jvmManager.globalRef(jenv, classInstance);
+    jClass = jvmManager.globalRef(jenv, jenv->GetObjectClass(jObject));
+    jboolean isCopy1, isCopy2;
+    
+    if (name == nullptr) {
+        Log::Error("cannot use a null name (0x0)");
+        return;
+    }
+    
+    if (signature == nullptr) {
+        Log::Error("cannot use a null signature (0x0)");
+        return;
+    }
+    
+    const char * n = jvmManager.jenv->GetStringUTFChars(name, &isCopy1);
+    if (n == nullptr) {
+        Log::Error("cannot get UTF chars from name");
+        return;
+    }
+    
+    const char * s = jvmManager.jenv->GetStringUTFChars(signature, &isCopy2);
+    if (s == nullptr) {
+        Log::Error("cannot get UTF chars from signature");
+        jvmManager.jenv->ReleaseStringUTFChars(name, n);
+        return;
+    }
+    
+    jSwapBuffers = jvmManager.jenv->GetMethodID(jClass, n, s);
+    
+    jvmManager.jenv->ReleaseStringUTFChars(name, n);
+    jvmManager.jenv->ReleaseStringUTFChars(name, s);
+    
+    if (jSwapBuffers == nullptr) {
+        Log::Error(
+                "cannot find method with name '", name, "', and signature '", signature, "'"
+        );
+    }
+}
+
+void AppInstanceAndroidBase::onEglTearDown ()
+{
+    jvmManager.jenv->DeleteGlobalRef(jClass);
+    jvmManager.jenv->DeleteGlobalRef(jObject);
+    jvmManager.detachJVM();
+    jSwapBuffers = nullptr;
+}
+
+void AppInstanceAndroidBase::swapBuffers ()
+{
+    if (jSwapBuffers != nullptr) {
+        jvmManager.jenv->CallVoidMethod(jObject, jSwapBuffers);
+    }
+}
diff --git a/app/src/main/java/libengine/AppInstanceAndroidBase.h b/app/src/main/java/libengine/AppInstanceAndroidBase.h
new file mode 100644
index 00000000..860ddd6e
--- /dev/null
+++ b/app/src/main/java/libengine/AppInstanceAndroidBase.h
@@ -0,0 +1,27 @@
+//
+// Created by Matthew Good on 29/6/21.
+//
+
+#ifndef GRAPHICAL_TOOL_KIT_APPINSTANCEANDROIDBASE_H
+#define GRAPHICAL_TOOL_KIT_APPINSTANCEANDROIDBASE_H
+
+#include "JVM_MANAGER.h"
+
+class AppInstanceAndroidBase
+{
+public:
+    JVM_MANAGER jvmManager;
+    jobject jObject;
+    jclass jClass;
+    jmethodID jSwapBuffers;
+
+    // delete called on non-final that has virtual functions but non-virtual destructor
+    virtual ~AppInstanceAndroidBase() = default;
+    virtual void swapBuffers();
+
+    virtual void onEglSetup(JNIEnv *jenv, jobject classInstance, jstring name, jstring signature);
+    virtual void onEglTearDown();
+};
+
+
+#endif //GRAPHICAL_TOOL_KIT_APPINSTANCEANDROIDBASE_H
diff --git a/app/src/main/java/libengine/CMakeLists.txt b/app/src/main/java/libengine/CMakeLists.txt
new file mode 100644
index 00000000..aa264f39
--- /dev/null
+++ b/app/src/main/java/libengine/CMakeLists.txt
@@ -0,0 +1,32 @@
+cmake_minimum_required(VERSION 3.4.1)
+
+set(CMAKE_CXX_STANDARD 11)
+set(CMAKE_CXX_STANDARD_REQUIRED ON)
+set(CMAKE_CXX_EXTENSIONS OFF)
+
+set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/OUTPUT)
+set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_DEBUG ${CMAKE_ARCHIVE_OUTPUT_DIRECTORY})
+set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_RELEASE ${CMAKE_ARCHIVE_OUTPUT_DIRECTORY})
+set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_ARCHIVE_OUTPUT_DIRECTORY})
+set(CMAKE_LIBRARY_OUTPUT_DIRECTORY_DEBUG ${CMAKE_ARCHIVE_OUTPUT_DIRECTORY})
+set(CMAKE_LIBRARY_OUTPUT_DIRECTORY_RELEASE ${CMAKE_ARCHIVE_OUTPUT_DIRECTORY})
+
+add_subdirectory(DilligentLog)
+
+add_library (
+        native-lib SHARED
+        native.cpp
+        JVM_MANAGER.cpp
+        AppInstanceAndroidBase.cpp
+)
+
+target_link_libraries (
+        native-lib
+        aaudio
+        log
+        android
+        jnigraphics
+        GLESv3
+        m
+        DilligentLog
+)
\ No newline at end of file
diff --git a/app/src/main/java/libengine/DiligentLog/CMakeLists.txt b/app/src/main/java/libengine/DiligentLog/CMakeLists.txt
new file mode 100644
index 00000000..2053abe3
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/CMakeLists.txt
@@ -0,0 +1,332 @@
+# For more information about using CMake with Android Studio, read the
+# documentation: https://d.android.com/studio/projects/add-native-code.html
+
+# Sets the minimum version of CMake required to build the native library.
+
+cmake_minimum_required(VERSION 3.10.2)
+
+# Declares and names the project.
+
+project(Diligent-Log)
+
+# Define GNU standard installation directories such as CMAKE_INSTALL_INCLUDEDIR, CMAKE_INSTALL_LIBDIR, etc.
+include(GNUInstallDirs)
+
+set_property(GLOBAL PROPERTY USE_FOLDERS ON)
+
+if(NOT CMAKE_BUILD_TYPE)
+    set(CMAKE_BUILD_TYPE Debug CACHE STRING "" FORCE)
+    message(STATUS "CMAKE_BUILD_TYPE is not specified, default to Debug. Note that this is only relevant for single-configuration generators (such as Makefile Generators and Ninja).")
+endif()
+
+set(DEBUG_CONFIGURATIONS DEBUG CACHE INTERNAL "Debug configurations")
+set(RELEASE_CONFIGURATIONS RELEASE RELWITHDEBINFO MINSIZEREL CACHE INTERNAL "Release configurations")
+
+if(BUILD_CONFIGURATION_FILE)
+    message("Using build configuration file " ${CUSTOM_BUILD_SCRIPT})
+    include(${CMAKE_SOURCE_DIR}/${BUILD_CONFIGURATION_FILE})
+
+    if(COMMAND custom_configure_build)
+        custom_configure_build()
+    else()
+        message("custom_configure_build() function not found in " ${CUSTOM_BUILD_SCRIPT})
+    endif()
+endif()
+
+# Generate XCode schemes
+set(CMAKE_XCODE_GENERATE_SCHEME TRUE)
+# Make malloc write 0xAA to newly allocated memory and 0x55 to deallocated memory
+set(CMAKE_XCODE_SCHEME_MALLOC_SCRIBBLE YES)
+# Place guard pages on each side of large (4096 bytes or more) buffers
+set(CMAKE_XCODE_SCHEME_MALLOC_GUARD_EDGES YES)
+
+if("${CMAKE_SIZEOF_VOID_P}" EQUAL "8")
+    set(ARCH 64 CACHE INTERNAL "64-bit architecture")
+else()
+    set(ARCH 32 CACHE INTERNAL "32-bit architecture")
+endif()
+
+# we need to rename due to conflics, normally this would link with PublicBuildSettings
+# however PublicBuildSettings is related to Diligent Backends
+add_library(Diligent-BuildSettings__LOG INTERFACE)
+target_link_libraries(Diligent-BuildSettings__LOG INTERFACE)
+
+if (NOT PLATFORM_HAS_BEEN_DEFINED)
+    if(WIN32)
+        if(${CMAKE_SYSTEM_NAME} STREQUAL "WindowsStore")
+            target_compile_definitions(Diligent-BuildSettings__LOG INTERFACE -DPLATFORM_UNIVERSAL_WINDOWS)
+            set(PLATFORM_UNIVERSAL_WINDOWS TRUE CACHE INTERNAL "Target platform: Windows Store")
+            message("Target platform: Universal Windows. SDK Version: " ${CMAKE_SYSTEM_VERSION})
+        else()
+            target_compile_definitions(Diligent-BuildSettings__LOG INTERFACE -DPLATFORM_WIN32)
+            set(PLATFORM_WIN32 TRUE CACHE INTERNAL "Target platform: Win32") #WIN32 is a variable, so we cannot use string "WIN32"
+            message("Target platform: Win32. SDK Version: " ${CMAKE_SYSTEM_VERSION})
+        endif()
+    else()
+        if(${CMAKE_SYSTEM_NAME} STREQUAL "Android")
+            target_compile_definitions(Diligent-BuildSettings__LOG INTERFACE -DPLATFORM_ANDROID)
+            set(PLATFORM_ANDROID TRUE CACHE INTERNAL "Target platform: Android")
+            message("Target platform: Android")
+        elseif(${CMAKE_SYSTEM_NAME} STREQUAL "Linux")
+            target_compile_definitions(Diligent-BuildSettings__LOG INTERFACE -DPLATFORM_LINUX)
+            set(PLATFORM_LINUX TRUE CACHE INTERNAL "Target platform: Linux")
+            message("Target Platform: Linux")
+        elseif(${CMAKE_SYSTEM_NAME} STREQUAL "Darwin")
+            if(IOS)
+                target_compile_definitions(Diligent-BuildSettings__LOG INTERFACE -DPLATFORM_IOS)
+                set(PLATFORM_IOS TRUE CACHE INTERNAL "Target platform: iOS")
+                message("Target Platform: iOS")
+            else()
+                target_compile_definitions(Diligent-BuildSettings__LOG INTERFACE -DPLATFORM_MACOS)
+                set(PLATFORM_MACOS TRUE CACHE INTERNAL "Target platform: MacOS")
+                message("Target Platform: MacOS")
+            endif()
+        elseif(${CMAKE_SYSTEM_NAME} STREQUAL "iOS")
+            target_compile_definitions(Diligent-BuildSettings__LOG INTERFACE -DPLATFORM_IOS)
+            set(PLATFORM_IOS TRUE CACHE INTERNAL "Target platform: iOS")
+            message("Target Platform: iOS")
+        elseif(${CMAKE_SYSTEM_NAME} STREQUAL "tvOS")
+            target_compile_definitions(Diligent-BuildSettings__LOG INTERFACE -DPLATFORM_TVOS)
+            set(PLATFORM_TVOS TRUE CACHE INTERNAL "Target platform: tvOS")
+            message("Target Platform: tvOS")
+        else()
+            message(FATAL_ERROR "Unsupported platform")
+        endif()
+    endif(WIN32)
+
+    if(PLATFORM_MACOS OR PLATFORM_IOS OR PLATFORM_TVOS)
+        target_compile_definitions(Diligent-BuildSettings__LOG INTERFACE -DPLATFORM_APPLE -DGL_SILENCE_DEPRECATION)
+        set(PLATFORM_APPLE TRUE CACHE INTERNAL "Apple platform (macOS, iOS, or tvOS)")
+    endif()
+
+    set(PLATFORM_HAS_BEEN_DEFINED TRUE "Platform has been defined")
+endif()
+
+foreach(DBG_CONFIG ${DEBUG_CONFIGURATIONS})
+    target_compile_definitions(Diligent-BuildSettings__LOG INTERFACE "$<$<CONFIG:${DBG_CONFIG}>:_DEBUG;DEBUG>")
+endforeach()
+
+foreach(REL_CONFIG ${RELEASE_CONFIGURATIONS})
+    target_compile_definitions(Diligent-BuildSettings__LOG INTERFACE "$<$<CONFIG:${REL_CONFIG}>:NDEBUG>")
+endforeach()
+
+if(MSVC)
+    # For msvc, enable level 4 warnings and treat warnings as errors, except for
+    # - w4100 - unreferenced formal parameter
+    # - w4505 - unreferenced local function has been removed
+    # - w4201 - nonstandard extension used: nameless struct/union
+    target_compile_options(Diligent-BuildSettings__LOG INTERFACE /W4 /WX /wd4100 /wd4505 /wd4201 /MP)
+    # In all release modes also:
+    # - disable w4189 - local variable is initialized but not referenced
+    # - Disable RTTI (/GR-)
+    # - Enable whole program optimization (/GL)
+    # - Enable string pooling (/GF)
+    set(MSVC_ALL_RELEASE_COMPILE_OPTIONS /wd4189 /GR- /GL /GF)
+    #target_compile_options(Diligent-BuildSettings__LOG INTERFACE "$<$<CONFIG:RELEASE>:/wd4189 /Ot")
+    # In RELEASE mode:
+    # - Set favor fast code option (/Ot)
+    # - Enable intrinsic functions (/Oi)
+    # - Maximize Speed (/O2)
+    # - Inline any suitable function (/Ob2)
+    set(MSVC_RELEASE_COMPILE_OPTIONS ${MSVC_ALL_RELEASE_COMPILE_OPTIONS} /Ot /Oi /Ob2 /O2)
+    set(MSVC_RELWITHDEBINFO_COMPILE_OPTIONS ${MSVC_RELEASE_COMPILE_OPTIONS})
+    # In MINSIZEREL mode set favor small code option (/Os)
+    set(MSVC_MINSIZEREL_COMPILE_OPTIONS ${MSVC_ALL_RELEASE_COMPILE_OPTIONS} /Os)
+    target_compile_options(Diligent-BuildSettings__LOG INTERFACE "$<$<CONFIG:RELEASE>:${MSVC_RELEASE_COMPILE_OPTIONS}>")
+    target_compile_options(Diligent-BuildSettings__LOG INTERFACE "$<$<CONFIG:MINSIZEREL>:${MSVC_MINSIZEREL_COMPILE_OPTIONS}>")
+    target_compile_options(Diligent-BuildSettings__LOG INTERFACE "$<$<CONFIG:RELWITHDEBINFO>:${MSVC_RELWITHDEBINFO_COMPILE_OPTIONS}>")
+    # !!!NOTE!!! For some reason above is the only form of generator expression that works
+    # For instance, this way
+    # target_compile_options(Diligent-BuildSettings__LOG INTERFACE "$<$<CONFIG:RELEASE>:/Ot>")
+    # does not work as expected
+else()
+    # Todo: use __attribute__((always_inline)), but it needs to be defined in a header file
+    target_compile_definitions(Diligent-BuildSettings__LOG INTERFACE __forceinline=inline)
+endif(MSVC)
+
+
+if (CMAKE_CXX_COMPILER_ID MATCHES "Clang" OR
+        CMAKE_CXX_COMPILER_ID MATCHES "GNU")
+    if(PLATFORM_APPLE)
+        set(WHOLE_ARCHIVE_FLAG "-Wl,-all_load" CACHE INTERNAL "all_load flag")
+        set(NO_WHOLE_ARCHIVE_FLAG "-Wl,-noall_load" CACHE INTERNAL "noall_load flag")
+    else()
+        set(WHOLE_ARCHIVE_FLAG "-Wl,--whole-archive" CACHE INTERNAL "whole-archive flag")
+        set(NO_WHOLE_ARCHIVE_FLAG "-Wl,--no-whole-archive" CACHE INTERNAL "no-whole-archive flag")
+    endif()
+else()
+    set(WHOLE_ARCHIVE_FLAG "")
+    set(NO_WHOLE_ARCHIVE_FLAG "")
+endif()
+
+if (CMAKE_CXX_COMPILER_ID MATCHES "Clang")
+    target_compile_options(Diligent-BuildSettings__LOG INTERFACE
+            # All warnings are errors
+            -Werror
+            # Some extra warnings
+            -Wall -Wextra -Wuninitialized -Wconditional-uninitialized -Wextra-tokens -Wpointer-arith -Wloop-analysis -Wunused
+            # Disable few warnings
+            -Wno-overloaded-virtual -Wno-incompatible-pointer-types-discards-qualifiers -Wno-unknown-pragmas
+            -Wno-zero-as-null-pointer-constant -Wno-unused-parameter
+            )
+    set(CLANG_RELEASE_OPTIONS -Wno-unused-variable)
+    target_compile_options(Diligent-BuildSettings__LOG INTERFACE $<$<NOT:$<CONFIG:Debug>>:${CLANG_RELEASE_OPTIONS}>)
+
+    if ((PLATFORM_IOS  AND CMAKE_OSX_SYSROOT STREQUAL "iphonesimulator")  OR PLATFORM_IOS_SIMULATOR OR
+    (PLATFORM_TVOS AND CMAKE_OSX_SYSROOT STREQUAL "appletvsimulator") OR PLATFORM_TVOS_SIMULATOR)
+        # There is a known long-standing issue in simulator SDK:
+        # the compiler generates a lot of bogus warnings in Metal
+        # headers about unavailable API
+        target_compile_options(Diligent-BuildSettings__LOG
+                INTERFACE
+                -Wno-error=unguarded-availability-new
+                )
+    endif()
+endif()
+
+# Returns path to the target relative to CMake root
+function(get_target_relative_dir__LOG _TARGET _DIR)
+    get_target_property(TARGET_SOURCE_DIR ${_TARGET} SOURCE_DIR)
+    file(RELATIVE_PATH TARGET_RELATIVE_PATH "${CMAKE_SOURCE_DIR}" "${TARGET_SOURCE_DIR}")
+    set(${_DIR} ${TARGET_RELATIVE_PATH} PARENT_SCOPE)
+endfunction()
+
+# Performs installation steps for the core library
+function(install_core_lib__LOG _TARGET)
+    get_target_relative_dir__LOG(${_TARGET} TARGET_RELATIVE_PATH)
+
+    get_target_property(TARGET_TYPE ${_TARGET} TYPE)
+    if(TARGET_TYPE STREQUAL STATIC_LIBRARY)
+        list(APPEND DILIGENT_CORE_INSTALL_LIBS_LIST ${_TARGET})
+        set(DILIGENT_CORE_INSTALL_LIBS_LIST ${DILIGENT_CORE_INSTALL_LIBS_LIST} CACHE INTERNAL "Core libraries installation list")
+    elseif(TARGET_TYPE STREQUAL SHARED_LIBRARY)
+        install(TARGETS				 ${_TARGET}
+                ARCHIVE DESTINATION "${CMAKE_INSTALL_LIBDIR}/${DILIGENT_CORE_DIR}/$<CONFIG>"
+                LIBRARY DESTINATION "${CMAKE_INSTALL_LIBDIR}/${DILIGENT_CORE_DIR}/$<CONFIG>"
+                RUNTIME DESTINATION "${CMAKE_INSTALL_BINDIR}/${DILIGENT_CORE_DIR}/$<CONFIG>"
+                )
+        if (DILIGENT_INSTALL_PDB)
+            install(FILES $<TARGET_PDB_FILE:${_TARGET}> DESTINATION "${CMAKE_INSTALL_BINDIR}/${DILIGENT_CORE_DIR}/$<CONFIG>" OPTIONAL)
+        endif()
+    endif()
+
+    if(EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/interface")
+        install(DIRECTORY    interface
+                DESTINATION  "${CMAKE_INSTALL_INCLUDEDIR}/${TARGET_RELATIVE_PATH}/"
+                )
+    endif()
+endfunction()
+
+function(set_common_target_properties__LOG TARGET)
+
+    if(COMMAND custom_pre_configure_target)
+        custom_pre_configure_target(${TARGET})
+        if(TARGET_CONFIGURATION_COMPLETE)
+            return()
+        endif()
+    endif()
+
+    get_target_property(TARGET_TYPE ${TARGET} TYPE)
+
+    if(MSVC)
+        # For msvc, enable link-time code generation for release builds (I was not able to
+        # find any way to set these settings through interface library BuildSettings)
+        if(TARGET_TYPE STREQUAL STATIC_LIBRARY)
+
+            foreach(REL_CONFIG ${RELEASE_CONFIGURATIONS})
+                set_target_properties(${TARGET} PROPERTIES
+                        STATIC_LIBRARY_FLAGS_${REL_CONFIG} /LTCG
+                        )
+            endforeach()
+
+        else()
+
+            foreach(REL_CONFIG ${RELEASE_CONFIGURATIONS})
+                set_target_properties(${TARGET} PROPERTIES
+                        LINK_FLAGS_${REL_CONFIG} "/LTCG /OPT:REF /INCREMENTAL:NO"
+                        )
+            endforeach()
+
+            if(PLATFORM_UNIVERSAL_WINDOWS)
+                # On UWP, disable incremental link to avoid linker warnings
+                foreach(DBG_CONFIG ${DEBUG_CONFIGURATIONS})
+                    set_target_properties(${TARGET} PROPERTIES
+                            LINK_FLAGS_${DBG_CONFIG} "/INCREMENTAL:NO"
+                            )
+                endforeach()
+            endif()
+        endif()
+    else()
+        set_target_properties(${TARGET} PROPERTIES
+                CXX_VISIBILITY_PRESET hidden # -fvisibility=hidden
+                C_VISIBILITY_PRESET hidden # -fvisibility=hidden
+                VISIBILITY_INLINES_HIDDEN TRUE
+
+                # Without -fPIC option GCC fails to link static libraries into dynamic library:
+                #  -fPIC
+                #      If supported for the target machine, emit position-independent code, suitable for
+                #      dynamic linking and avoiding any limit on the size of the global offset table.
+                POSITION_INDEPENDENT_CODE ON
+
+                # It is crucial to set CXX_STANDARD flag to only affect c++ files and avoid failures compiling c-files:
+                # error: invalid argument '-std=c++14' not allowed with 'C/ObjC'
+                CXX_STANDARD 14
+                CXX_STANDARD_REQUIRED ON
+
+                C_STANDARD 11
+                )
+
+        if(NOT MINGW_BUILD)
+            # Do not disable extensions when building with MinGW!
+            set_target_properties(${TARGET} PROPERTIES
+                    CXX_EXTENSIONS OFF
+                    )
+        endif()
+    endif()
+
+    if(COMMAND custom_post_configure_target)
+        custom_post_configure_target(${TARGET})
+    endif()
+
+endfunction()
+
+if(PLATFORM_MACOS)
+    find_library(APP_KIT AppKit)
+    if (NOT APP_KIT)
+        message(FATAL_ERROR "AppKit not found")
+    endif()
+elseif(PLATFORM_IOS)
+    find_library(CORE_FOUNDATION CoreFoundation)
+    if(NOT CORE_FOUNDATION)
+        message(FATAL_ERROR "Cannot find CoreFoundation framework")
+    endif()
+
+    find_library(FOUNDATION Foundation)
+    if(NOT FOUNDATION)
+        message(FATAL_ERROR "Cannot find Foundation framework")
+    endif()
+elseif(PLATFORM_TVOS)
+    find_library(CORE_FOUNDATION CoreFoundation)
+    if(NOT CORE_FOUNDATION)
+        message(FATAL_ERROR "Cannot find CoreFoundation framework")
+    endif()
+
+    find_library(FOUNDATION Foundation)
+    if(NOT FOUNDATION)
+        message(FATAL_ERROR "Cannot find Foundation framework")
+    endif()
+endif()
+
+add_subdirectory(Primitives)
+add_subdirectory(Platforms)
+
+add_library(
+        Diligent-Log SHARED
+        common.cpp
+)
+
+target_link_libraries(
+        Diligent-Log
+        Diligent-Primitives
+        Diligent-TargetPlatform
+)
diff --git a/app/src/main/java/libengine/DiligentLog/Log.h b/app/src/main/java/libengine/DiligentLog/Log.h
new file mode 100644
index 00000000..e902ac0f
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Log.h
@@ -0,0 +1,71 @@
+//
+// Created by Matthew Good on 29/7/21.
+//
+
+#ifndef GRAPHICAL_TOOL_KIT_LOG_H
+#define GRAPHICAL_TOOL_KIT_LOG_H
+
+#include <sstream>
+
+class Log {
+public:
+    enum SEVERITY {
+        INFO,
+        ERROR,
+        FATAL
+    };
+
+private:
+    template <typename SSType, typename ArgType>
+    static void FormatStrSS(SSType& ss, const ArgType& Arg)
+    {
+        ss << Arg;
+    }
+
+    template <typename SSType, typename FirstArgType, typename... RestArgsType>
+    static void FormatStrSS(SSType& ss, const FirstArgType& FirstArg, const RestArgsType&... RestArgs)
+    {
+        FormatStrSS(ss, FirstArg);
+        FormatStrSS(ss, RestArgs...); // recursive call using pack expansion syntax
+    }
+
+public:
+    static void Log_String(const SEVERITY & severity, const char * msg);
+    static void Log_String(const SEVERITY & severity, const std::string & msg);
+
+    template <typename... RestArgsType>
+    static std::string FormatString(const RestArgsType&... Args)
+    {
+        std::stringstream ss;
+        FormatStrSS(ss, Args...);
+        return ss.str();
+    }
+
+    template<typename... RestArgsType>
+    static void Log_With_Severity(const SEVERITY & severity, const RestArgsType &... Args) {
+        std::string msg = FormatString(Args...);
+        Log_String(severity, msg);
+    }
+
+    template<typename... RestArgsType>
+    static void Debug(const RestArgsType &... Args) {
+        Log_With_Severity(INFO, Args...);
+    }
+
+    template<typename... RestArgsType>
+    static void Info(const RestArgsType &... Args) {
+        Log_With_Severity(INFO, Args...);
+    }
+
+    template<typename... RestArgsType>
+    static void Error(const RestArgsType &... Args) {
+        Log_With_Severity(ERROR, Args...);
+    }
+
+    template<typename... RestArgsType>
+    static void Error_And_Throw(const RestArgsType &... Args) {
+        Log_With_Severity(FATAL, Args...);
+    }
+};
+
+#endif //GRAPHICAL_TOOL_KIT_LOG_H
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Android/CMakeLists.txt b/app/src/main/java/libengine/DiligentLog/Platforms/Android/CMakeLists.txt
new file mode 100644
index 00000000..f782a566
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Android/CMakeLists.txt
@@ -0,0 +1,46 @@
+cmake_minimum_required (VERSION 3.6)
+
+project(Diligent-AndroidPlatform_LOG CXX)
+
+set(INTERFACE 
+    interface/AndroidDebug.hpp
+    interface/AndroidFileSystem.hpp
+    interface/AndroidPlatformDefinitions.h
+    interface/AndroidPlatformMisc.hpp
+    interface/AndroidNativeWindow.h
+)
+
+set(SOURCE 
+    src/AndroidDebug.cpp
+    src/AndroidFileSystem.cpp
+)
+
+add_library(Diligent-AndroidPlatform_LOG ${SOURCE} ${INTERFACE} ${PLATFORM_INTERFACE_HEADERS})
+set_common_target_properties__LOG(Diligent-AndroidPlatform_LOG)
+
+target_include_directories(Diligent-AndroidPlatform_LOG
+PUBLIC
+    interface
+)
+
+target_link_libraries(Diligent-AndroidPlatform_LOG
+PRIVATE
+    log
+    android
+    Diligent-BuildSettings__LOG 
+PUBLIC
+    Diligent-PlatformInterface
+    Diligent-BasicPlatform_LOG
+)
+
+source_group("src" FILES ${SOURCE})
+source_group("include" FILES ${INCLUDE})
+source_group("interface" FILES ${PLATFORM_INTERFACE_HEADERS})
+
+set_target_properties(Diligent-AndroidPlatform_LOG PROPERTIES
+    FOLDER DiligentLog/Platforms
+)
+
+if(DILIGENT_INSTALL_CORE)
+    install_core_lib__LOG(Diligent-AndroidPlatform_LOG)
+endif()
\ No newline at end of file
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Android/interface/AndroidDebug.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/Android/interface/AndroidDebug.hpp
new file mode 100644
index 00000000..cef4bdab
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Android/interface/AndroidDebug.hpp
@@ -0,0 +1,43 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../Basic/interface/BasicPlatformDebug.hpp"
+
+struct AndroidDebug : public BasicPlatformDebug
+{
+    static void AssertionFailed(const Diligent::Char* Message,
+                                const char*           Function, // type of __FUNCTION__
+                                const char*           File,     // type of __FILE__
+                                int                   Line);
+    static void OutputDebugMessage(Diligent::DEBUG_MESSAGE_SEVERITY Severity,
+                                   const Diligent::Char*            Message,
+                                   const char*                      Function, // type of __FUNCTION__
+                                   const char*                      File,     // type of __FILE__
+                                   int                              Line);
+};
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Android/interface/AndroidFileSystem.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/Android/interface/AndroidFileSystem.hpp
new file mode 100644
index 00000000..1f5b6d8b
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Android/interface/AndroidFileSystem.hpp
@@ -0,0 +1,99 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include <memory>
+#include <vector>
+#include <fstream>
+#include <android/asset_manager.h>
+
+#include "../../Basic/interface/BasicFileSystem.hpp"
+#include "../../../../../MultiTouch/DiligentLog/Primitives/interface/DataBlob.h"
+
+struct ANativeActivity;
+struct AAssetManager;
+
+class AndroidFile : public BasicFile
+{
+public:
+    AndroidFile(const FileOpenAttribs& OpenAttribs);
+    ~AndroidFile();
+
+    void Read(Diligent::IDataBlob* pData);
+
+    bool Read(void* Data, size_t BufferSize);
+
+    bool Write(const void* Data, size_t BufferSize);
+
+    size_t GetSize() { return m_Size; }
+
+    size_t GetPos();
+
+    void SetPos(size_t Offset, FilePosOrigin Origin);
+
+    static bool Open(const char* FileName, std::ifstream& IFS, AAsset*& AssetFile, size_t& Size);
+
+private:
+    std::ifstream m_IFS;
+    AAsset*       m_AssetFile = nullptr;
+    size_t        m_Size      = 0;
+};
+
+
+/// Android file system implementation.
+struct AndroidFileSystem : public BasicFileSystem
+{
+public:
+    /// Initializes the file system.
+
+    /// \param [in] NativeActivity          - Pointer to the native activity object (ANativeActivity).
+    /// \param [in] NativeActivityClassName - Native activity class name.
+    /// \param [in] AssetManager            - Pointer to the asset manager (AAssetManager).
+    ///
+    /// \remarks The file system can be initialized to use either native activity or asset manager, or both.
+    ///          When NativeActivity is not null, the file system will try to use it first when openining files.
+    ///          It will then resort to using the asset manager. When NativeActivity is not null, but AssetManager
+    ///          parameter is null, the file system will use the asset manager from the activity.
+    ///          If NativeActivity is null, the file system will only use the asset manager.
+    static void Init(struct ANativeActivity* NativeActivity,
+                     const char*             NativeActivityClassName,
+                     struct AAssetManager*   AssetManager);
+
+
+    static AndroidFile*          OpenFile(const FileOpenAttribs& OpenAttribs);
+    static inline Diligent::Char GetSlashSymbol() { return '/'; }
+
+    static bool FileExists(const Diligent::Char* strFilePath);
+    static bool PathExists(const Diligent::Char* strPath);
+
+    static bool CreateDirectory(const Diligent::Char* strPath);
+    static void ClearDirectory(const Diligent::Char* strPath);
+    static void DeleteFile(const Diligent::Char* strPath);
+
+    static std::vector<std::unique_ptr<FindFileData>> Search(const Diligent::Char* SearchPattern);
+};
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Android/interface/AndroidNativeWindow.h b/app/src/main/java/libengine/DiligentLog/Platforms/Android/interface/AndroidNativeWindow.h
new file mode 100644
index 00000000..be6a1d97
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Android/interface/AndroidNativeWindow.h
@@ -0,0 +1,39 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../../../../MultiTouch/DiligentLog/Primitives/interface/CommonDefinitions.h"
+
+DILIGENT_BEGIN_NAMESPACE(Diligent)
+
+struct AndroidNativeWindow
+{
+    void* pAWindow DEFAULT_INITIALIZER(nullptr);
+};
+
+DILIGENT_END_NAMESPACE // namespace Diligent
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Android/interface/AndroidPlatformDefinitions.h b/app/src/main/java/libengine/DiligentLog/Platforms/Android/interface/AndroidPlatformDefinitions.h
new file mode 100644
index 00000000..6aa0084c
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Android/interface/AndroidPlatformDefinitions.h
@@ -0,0 +1,40 @@
+/*     Copyright 2015-2018 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF ANY PROPRIETARY RIGHTS.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../../../../MultiTouch/DiligentLog/Primitives/interface/CommonDefinitions.h"
+
+#if DILIGENT_C_INTERFACE
+
+#    define _countof(arr) (sizeof(arr) / sizeof(arr[0]))
+
+#else
+
+#    include <cstddef>
+
+template <typename _CountofType, std::size_t _SizeOfArray>
+char (*__countof_helper(_CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];
+#    define _countof(_Array) (sizeof(*__countof_helper(_Array)) + 0)
+
+#endif
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Android/interface/AndroidPlatformMisc.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/Android/interface/AndroidPlatformMisc.hpp
new file mode 100644
index 00000000..879e4514
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Android/interface/AndroidPlatformMisc.hpp
@@ -0,0 +1,36 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../Basic/interface/BasicPlatformMisc.hpp"
+#include "../../../../../MultiTouch/DiligentLog/Platforms/Basic/interface/DebugUtilities.hpp"
+#include "../../Linux/interface/LinuxPlatformMisc.hpp"
+
+struct AndroidMisc : public LinuxMisc
+{
+};
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Android/src/AndroidDebug.cpp b/app/src/main/java/libengine/DiligentLog/Platforms/Android/src/AndroidDebug.cpp
new file mode 100644
index 00000000..ff824847
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Android/src/AndroidDebug.cpp
@@ -0,0 +1,62 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#include "AndroidDebug.hpp"
+#include "FormatString.hpp"
+#include <android/log.h>
+#include <csignal>
+
+using namespace Diligent;
+
+void AndroidDebug::AssertionFailed(const Char* Message, const char* Function, const char* File, int Line)
+{
+    auto AssertionFailedMessage = FormatAssertionFailedMessage(Message, Function, File, Line);
+    OutputDebugMessage(DEBUG_MESSAGE_SEVERITY_ERROR, AssertionFailedMessage.c_str(), nullptr, nullptr, 0);
+
+    raise(SIGTRAP);
+};
+
+
+void AndroidDebug::OutputDebugMessage(DEBUG_MESSAGE_SEVERITY Severity, const Char* Message, const char* Function, const char* File, int Line)
+{
+    auto msg = FormatDebugMessage(Severity, Message, Function, File, Line);
+
+    static const android_LogPriority Priorities[] = {ANDROID_LOG_INFO, ANDROID_LOG_WARN, ANDROID_LOG_ERROR, ANDROID_LOG_FATAL};
+    __android_log_print(Priorities[static_cast<int>(Severity)], "Diligent Engine", "%s", msg.c_str());
+}
+
+void DebugAssertionFailed(const Char* Message, const char* Function, const char* File, int Line)
+{
+    AndroidDebug::AssertionFailed(Message, Function, File, Line);
+}
+
+namespace Diligent
+{
+
+DebugMessageCallbackType DebugMessageCallback = AndroidDebug::OutputDebugMessage;
+
+}
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Android/src/AndroidFileSystem.cpp b/app/src/main/java/libengine/DiligentLog/Platforms/Android/src/AndroidFileSystem.cpp
new file mode 100644
index 00000000..cee264eb
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Android/src/AndroidFileSystem.cpp
@@ -0,0 +1,359 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#include <string>
+#include <android/native_activity.h>
+
+#include "AndroidFileSystem.hpp"
+#include "Errors.hpp"
+#include "DebugUtilities.hpp"
+
+
+namespace
+{
+
+class JNIMiniHelper
+{
+public:
+    static void Init(ANativeActivity* activity, std::string activity_class_name, AAssetManager* asset_manager)
+    {
+        VERIFY(activity != nullptr || asset_manager != nullptr, "Activity and asset manager can't both be null");
+
+        auto& TheHelper                = GetInstance();
+        TheHelper.activity_            = activity;
+        TheHelper.activity_class_name_ = std::move(activity_class_name);
+        TheHelper.asset_manager_       = asset_manager;
+        if (TheHelper.asset_manager_ == nullptr && TheHelper.activity_ != nullptr)
+        {
+            TheHelper.asset_manager_ = TheHelper.activity_->assetManager;
+        }
+    }
+
+    static JNIMiniHelper& GetInstance()
+    {
+        static JNIMiniHelper helper;
+        return helper;
+    }
+
+
+    bool OpenFile(const char* fileName, std::ifstream& IFS, AAsset*& AssetFile, size_t& FileSize)
+    {
+        if (activity_ == nullptr && asset_manager_ == nullptr)
+        {
+            LOG_ERROR_MESSAGE("JNIMiniHelper has not been initialized. Call init() to initialize the helper");
+            return false;
+        }
+
+        // Lock mutex
+        std::lock_guard<std::mutex> lock(mutex_);
+
+        if (activity_ != nullptr)
+        {
+            // First, try reading from externalFileDir;
+            std::string ExternalFilesPath;
+            {
+                JNIEnv* env          = nullptr;
+                bool    DetachThread = AttachCurrentThread(env);
+                if (jstring jstr_path = GetExternalFilesDirJString(env))
+                {
+                    const char* path  = env->GetStringUTFChars(jstr_path, nullptr);
+                    ExternalFilesPath = std::string(path);
+                    if (fileName[0] != '/')
+                    {
+                        ExternalFilesPath.append("/");
+                    }
+                    ExternalFilesPath.append(fileName);
+                    env->ReleaseStringUTFChars(jstr_path, path);
+                    env->DeleteLocalRef(jstr_path);
+                }
+                if (DetachThread)
+                    DetachCurrentThread();
+            }
+
+            IFS.open(ExternalFilesPath.c_str(), std::ios::binary);
+        }
+
+        if (IFS && IFS.is_open())
+        {
+            IFS.seekg(0, std::ifstream::end);
+            FileSize = IFS.tellg();
+            IFS.seekg(0, std::ifstream::beg);
+            return true;
+        }
+        else if (asset_manager_ != nullptr)
+        {
+            // Fallback to assetManager
+            AssetFile = AAssetManager_open(asset_manager_, fileName, AASSET_MODE_BUFFER);
+            if (!AssetFile)
+            {
+                return false;
+            }
+            uint8_t* data = (uint8_t*)AAsset_getBuffer(AssetFile);
+            if (data == nullptr)
+            {
+                AAsset_close(AssetFile);
+
+                LOG_ERROR_MESSAGE("Failed to open: ", fileName);
+                return false;
+            }
+            FileSize = AAsset_getLength(AssetFile);
+            return true;
+        }
+        else
+        {
+            return false;
+        }
+    }
+
+    /*
+     * Attach current thread
+     * In Android, the thread doesn't have to be 'Detach' current thread
+     * as application process is only killed and VM does not shut down
+     */
+    bool AttachCurrentThread(JNIEnv*& env)
+    {
+        env = nullptr;
+        if (activity_->vm->GetEnv((void**)&env, JNI_VERSION_1_4) == JNI_OK)
+            return false; // Already attached
+        activity_->vm->AttachCurrentThread(&env, nullptr);
+        pthread_key_create((int32_t*)activity_, DetachCurrentThreadDtor);
+        return true;
+    }
+
+    /*
+     * Unregister this thread from the VM
+     */
+    static void DetachCurrentThreadDtor(void* p)
+    {
+        LOG_INFO_MESSAGE("detached current thread");
+        auto* activity = reinterpret_cast<ANativeActivity*>(p);
+        activity->vm->DetachCurrentThread();
+    }
+
+private:
+    JNIMiniHelper()
+    {
+    }
+
+    ~JNIMiniHelper()
+    {
+    }
+
+    // clang-format off
+    JNIMiniHelper           (const JNIMiniHelper&) = delete;
+    JNIMiniHelper& operator=(const JNIMiniHelper&) = delete;
+    JNIMiniHelper           (JNIMiniHelper&&)      = delete;
+    JNIMiniHelper& operator=(JNIMiniHelper&&)      = delete;
+    // clang-format on
+
+    jstring GetExternalFilesDirJString(JNIEnv* env)
+    {
+        if (activity_ == nullptr)
+        {
+            LOG_ERROR_MESSAGE("JNIHelper has not been initialized. Call init() to initialize the helper");
+            return NULL;
+        }
+
+        jstring obj_Path = nullptr;
+        // Invoking getExternalFilesDir() java API
+        jclass    cls_Env  = env->FindClass(activity_class_name_.c_str());
+        jmethodID mid      = env->GetMethodID(cls_Env, "getExternalFilesDir", "(Ljava/lang/String;)Ljava/io/File;");
+        jobject   obj_File = env->CallObjectMethod(activity_->clazz, mid, NULL);
+        if (obj_File)
+        {
+            jclass    cls_File    = env->FindClass("java/io/File");
+            jmethodID mid_getPath = env->GetMethodID(cls_File, "getPath", "()Ljava/lang/String;");
+            obj_Path              = (jstring)env->CallObjectMethod(obj_File, mid_getPath);
+            env->DeleteLocalRef(cls_File);
+            env->DeleteLocalRef(obj_File);
+        }
+        env->DeleteLocalRef(cls_Env);
+        return obj_Path;
+    }
+
+    void DetachCurrentThread()
+    {
+        activity_->vm->DetachCurrentThread();
+    }
+
+    ANativeActivity* activity_ = nullptr;
+    std::string      activity_class_name_;
+    AAssetManager*   asset_manager_ = nullptr;
+
+    // mutex for synchronization
+    // This class uses singleton pattern and can be invoked from multiple threads,
+    // each methods locks the mutex for a thread safety
+    mutable std::mutex mutex_;
+};
+
+
+} // namespace
+
+
+bool AndroidFile::Open(const char* FileName, std::ifstream& IFS, AAsset*& AssetFile, size_t& Size)
+{
+    return JNIMiniHelper::GetInstance().OpenFile(FileName, IFS, AssetFile, Size);
+}
+
+AndroidFile::AndroidFile(const FileOpenAttribs& OpenAttribs) :
+    BasicFile(OpenAttribs, AndroidFileSystem::GetSlashSymbol())
+{
+    auto FullPath = m_OpenAttribs.strFilePath;
+    if (!Open(FullPath, m_IFS, m_AssetFile, m_Size))
+    {
+        LOG_ERROR_AND_THROW("Failed to open file ", FullPath);
+    }
+}
+
+AndroidFile::~AndroidFile()
+{
+    if (m_IFS && m_IFS.is_open())
+        m_IFS.close();
+
+    if (m_AssetFile != nullptr)
+        AAsset_close(m_AssetFile);
+}
+
+void AndroidFile::Read(Diligent::IDataBlob* pData)
+{
+    pData->Resize(GetSize());
+    Read(pData->GetDataPtr(), pData->GetSize());
+}
+
+bool AndroidFile::Read(void* Data, size_t BufferSize)
+{
+    VERIFY(BufferSize == m_Size, "Only whole file reads are currently supported");
+
+    if (m_IFS && m_IFS.is_open())
+    {
+        m_IFS.read((char*)Data, BufferSize);
+        return true;
+    }
+    else if (m_AssetFile != nullptr)
+    {
+        const uint8_t* src_data = (uint8_t*)AAsset_getBuffer(m_AssetFile);
+        off_t          FileSize = AAsset_getLength(m_AssetFile);
+        if (FileSize > static_cast<off_t>(BufferSize))
+        {
+            LOG_WARNING_MESSAGE("Requested buffer size (", BufferSize, ") exceeds file size (", FileSize, ")");
+            BufferSize = FileSize;
+        }
+        memcpy(Data, src_data, BufferSize);
+        return true;
+    }
+    else
+    {
+        return false;
+    }
+}
+
+bool AndroidFile::Write(const void* Data, size_t BufferSize)
+{
+    UNSUPPORTED("Not implemented");
+
+    return false;
+}
+
+size_t AndroidFile::GetPos()
+{
+    UNSUPPORTED("Not implemented");
+
+    return 0;
+}
+
+void AndroidFile::SetPos(size_t Offset, FilePosOrigin Origin)
+{
+    UNSUPPORTED("Not implemented");
+}
+
+
+void AndroidFileSystem::Init(ANativeActivity* NativeActivity, const char* NativeActivityClassName, AAssetManager* AssetManager)
+{
+    JNIMiniHelper::Init(NativeActivity, NativeActivityClassName != nullptr ? NativeActivityClassName : "", AssetManager);
+}
+
+AndroidFile* AndroidFileSystem::OpenFile(const FileOpenAttribs& OpenAttribs)
+{
+    AndroidFile* pFile = nullptr;
+    try
+    {
+        pFile = new AndroidFile(OpenAttribs);
+    }
+    catch (const std::runtime_error& err)
+    {
+    }
+
+    return pFile;
+}
+
+
+bool AndroidFileSystem::FileExists(const Diligent::Char* strFilePath)
+{
+    std::ifstream   IFS;
+    AAsset*         AssetFile = nullptr;
+    size_t          Size      = 0;
+    FileOpenAttribs OpenAttribs;
+    OpenAttribs.strFilePath = strFilePath;
+    BasicFile   DummyFile(OpenAttribs, AndroidFileSystem::GetSlashSymbol());
+    const auto& Path   = DummyFile.GetPath(); // This is necessary to correct slashes
+    bool        Exists = AndroidFile::Open(Path.c_str(), IFS, AssetFile, Size);
+
+    if (IFS && IFS.is_open())
+        IFS.close();
+    if (AssetFile != nullptr)
+        AAsset_close(AssetFile);
+
+    return Exists;
+}
+
+bool AndroidFileSystem::PathExists(const Diligent::Char* strPath)
+{
+    UNSUPPORTED("Not implemented");
+    return false;
+}
+
+bool AndroidFileSystem::CreateDirectory(const Diligent::Char* strPath)
+{
+    UNSUPPORTED("Not implemented");
+    return false;
+}
+
+void AndroidFileSystem::ClearDirectory(const Diligent::Char* strPath)
+{
+    UNSUPPORTED("Not implemented");
+}
+
+void AndroidFileSystem::DeleteFile(const Diligent::Char* strPath)
+{
+    UNSUPPORTED("Not implemented");
+}
+
+std::vector<std::unique_ptr<FindFileData>> AndroidFileSystem::Search(const Diligent::Char* SearchPattern)
+{
+    UNSUPPORTED("Not implemented");
+    return std::vector<std::unique_ptr<FindFileData>>();
+}
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Apple/CMakeLists.txt b/app/src/main/java/libengine/DiligentLog/Platforms/Apple/CMakeLists.txt
new file mode 100644
index 00000000..634db60a
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Apple/CMakeLists.txt
@@ -0,0 +1,73 @@
+cmake_minimum_required (VERSION 3.6)
+
+project(Diligent-ApplePlatform CXX)
+
+if(PLATFORM_MACOS)
+    set(APPLE_NATIVE_WINDOW_H interface/MacOSNativeWindow.h)
+elseif(PLATFORM_IOS)
+    set(APPLE_NATIVE_WINDOW_H interface/IOSNativeWindow.h)
+elseif(PLATFORM_TVOS)
+    set(APPLE_NATIVE_WINDOW_H interface/TVOSNativeWindow.h)
+endif()
+
+set(INTERFACE
+    interface/CFObjectWrapper.hpp
+    interface/AppleDebug.hpp
+    interface/AppleFileSystem.hpp
+    interface/ApplePlatformDefinitions.h
+    interface/ApplePlatformMisc.hpp
+    ${APPLE_NATIVE_WINDOW_H}
+)
+
+set(SOURCE
+    src/AppleDebug.mm
+    src/AppleFileSystem.cpp
+)
+
+
+add_library(Diligent-ApplePlatform ${SOURCE} ${INTERFACE} ${PLATFORM_INTERFACE_HEADERS})
+set_common_target_properties__LOG(Diligent-ApplePlatform)
+
+target_include_directories(Diligent-ApplePlatform
+PUBLIC
+    interface
+)
+
+target_link_libraries(Diligent-ApplePlatform
+PRIVATE
+    Diligent-BuildSettings__LOG 
+PUBLIC
+    Diligent-BasicPlatform_LOG
+    Diligent-PlatformInterface
+)
+
+if(PLATFORM_MACOS)
+    target_link_libraries(Diligent-ApplePlatform
+    PRIVATE
+        ${APP_KIT}
+    )
+elseif(PLATFORM_IOS)
+    target_link_libraries(Diligent-ApplePlatform
+    PRIVATE
+        ${CORE_FOUNDATION}
+        ${FOUNDATION}
+    )
+elseif(PLATFORM_TVOS)
+    target_link_libraries(Diligent-ApplePlatform
+    PRIVATE
+        ${CORE_FOUNDATION}
+        ${FOUNDATION}
+    )
+endif()
+
+source_group("src" FILES ${SOURCE})
+source_group("include" FILES ${INCLUDE})
+source_group("interface" FILES ${PLATFORM_INTERFACE_HEADERS})
+
+set_target_properties(Diligent-ApplePlatform PROPERTIES
+    FOLDER DiligentLog/Platforms
+)
+
+if(DILIGENT_INSTALL_CORE)
+    install_core_lib__LOG(Diligent-ApplePlatform)
+endif()
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/AppleDebug.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/AppleDebug.hpp
new file mode 100644
index 00000000..1f99b2e8
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/AppleDebug.hpp
@@ -0,0 +1,43 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../Basic/interface/BasicPlatformDebug.hpp"
+
+struct AppleDebug : public BasicPlatformDebug
+{
+    static void AssertionFailed(const Diligent::Char* Message,
+                                const char*           Function, // type of __FUNCTION__
+                                const char*           File,     // type of __FILE__
+                                int                   Line);
+    static void OutputDebugMessage(Diligent::DEBUG_MESSAGE_SEVERITY Severity,
+                                   const Diligent::Char*            Message,
+                                   const char*                      Function, // type of __FUNCTION__
+                                   const char*                      File,     // type of __FILE__
+                                   int                              Line);
+};
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/AppleFileSystem.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/AppleFileSystem.hpp
new file mode 100644
index 00000000..71528b0a
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/AppleFileSystem.hpp
@@ -0,0 +1,53 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include <memory>
+#include <vector>
+
+#include "../../Basic/interface/BasicFileSystem.hpp"
+#include "../../Basic/interface/StandardFile.hpp"
+
+using AppleFile = StandardFile;
+
+struct AppleFileSystem : public BasicFileSystem
+{
+public:
+    static AppleFile* OpenFile(const FileOpenAttribs& OpenAttribs);
+
+    static inline Diligent::Char GetSlashSymbol() { return '/'; }
+
+    static bool FileExists(const Diligent::Char* strFilePath);
+    static bool PathExists(const Diligent::Char* strPath);
+
+    static bool CreateDirectory(const Diligent::Char* strPath);
+    static void ClearDirectory(const Diligent::Char* strPath);
+    static void DeleteFile(const Diligent::Char* strPath);
+
+    static std::vector<std::unique_ptr<FindFileData>> Search(const Diligent::Char* SearchPattern);
+};
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/ApplePlatformDefinitions.h b/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/ApplePlatformDefinitions.h
new file mode 100644
index 00000000..bc4fb45b
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/ApplePlatformDefinitions.h
@@ -0,0 +1,44 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../../../../MultiTouch/DiligentLog/Primitives/interface/CommonDefinitions.h"
+
+#if DILIGENT_C_INTERFACE
+
+#    define _countof(arr) (sizeof(arr) / sizeof(arr[0]))
+
+#else
+
+#    include <cstddef>
+
+template <typename _CountofType, std::size_t _SizeOfArray>
+char (*__countof_helper(_CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];
+#    define _countof(_Array) (sizeof(*__countof_helper(_Array)) + 0)
+
+#endif
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/ApplePlatformMisc.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/ApplePlatformMisc.hpp
new file mode 100644
index 00000000..571ec761
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/ApplePlatformMisc.hpp
@@ -0,0 +1,36 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../Basic/interface/BasicPlatformMisc.hpp"
+#include "../../../../../MultiTouch/DiligentLog/Platforms/Basic/interface/DebugUtilities.hpp"
+#include "../../Linux/interface/LinuxPlatformMisc.hpp"
+
+struct AppleMisc : public LinuxMisc
+{
+};
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/CFObjectWrapper.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/CFObjectWrapper.hpp
new file mode 100644
index 00000000..8d9a3d15
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/CFObjectWrapper.hpp
@@ -0,0 +1,53 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+template <typename CFType>
+class CFObjectWrapper
+{
+public:
+    CFObjectWrapper(CFType obj) :
+        m_Obj{obj}
+    {}
+
+    ~CFObjectWrapper()
+    {
+        if (m_Obj != NULL)
+        {
+            CFRelease(m_Obj);
+        }
+    }
+
+    operator CFType() { return m_Obj; }
+
+private:
+    CFType m_Obj;
+};
+
+using CFStringWrapper = CFObjectWrapper<CFStringRef>;
+using CFURLWrapper    = CFObjectWrapper<CFURLRef>;
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/IOSNativeWindow.h b/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/IOSNativeWindow.h
new file mode 100644
index 00000000..3f0e1bc8
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/IOSNativeWindow.h
@@ -0,0 +1,48 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../../../../MultiTouch/DiligentLog/Primitives/interface/CommonDefinitions.h"
+
+DILIGENT_BEGIN_NAMESPACE(Diligent)
+
+struct IOSNativeWindow
+{
+    void* pCALayer DEFAULT_INITIALIZER(nullptr);
+
+#if DILIGENT_CPP_INTERFACE
+    IOSNativeWindow() noexcept
+    {}
+
+    explicit IOSNativeWindow(void* _pCALayer) noexcept :
+        pCALayer{_pCALayer}
+    {}
+#endif
+};
+
+DILIGENT_END_NAMESPACE // namespace Diligent
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/MacOSNativeWindow.h b/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/MacOSNativeWindow.h
new file mode 100644
index 00000000..5b3ac26d
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/MacOSNativeWindow.h
@@ -0,0 +1,48 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../../../../MultiTouch/DiligentLog/Primitives/interface/CommonDefinitions.h"
+
+DILIGENT_BEGIN_NAMESPACE(Diligent)
+
+struct MacOSNativeWindow
+{
+    void* pNSView DEFAULT_INITIALIZER(nullptr);
+
+#if DILIGENT_CPP_INTERFACE
+    MacOSNativeWindow() noexcept
+    {}
+
+    explicit MacOSNativeWindow(void* _pNSView) noexcept :
+        pNSView(_pNSView)
+    {}
+#endif
+};
+
+DILIGENT_END_NAMESPACE // namespace Diligent
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/TVOSNativeWindow.h b/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/TVOSNativeWindow.h
new file mode 100644
index 00000000..0fd90904
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Apple/interface/TVOSNativeWindow.h
@@ -0,0 +1,47 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../../../../MultiTouch/DiligentLog/Primitives/interface/CommonDefinitions.h"
+
+DILIGENT_BEGIN_NAMESPACE(Diligent)
+
+struct TVOSNativeWindow
+{
+    void* pCALayer DEFAULT_INITIALIZER(nullptr);
+
+#if DILIGENT_CPP_INTERFACE
+    TVOSNativeWindow() noexcept
+    {}
+
+    explicit TVOSNativeWindow(void* _pCALayer) noexcept :
+        pCALayer{_pCALayer}
+    {}
+#endif
+};
+
+DILIGENT_END_NAMESPACE // namespace Diligent
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Apple/src/AppleDebug.mm b/app/src/main/java/libengine/DiligentLog/Platforms/Apple/src/AppleDebug.mm
new file mode 100644
index 00000000..60f71f4e
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Apple/src/AppleDebug.mm
@@ -0,0 +1,59 @@
+/*     Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF ANY PROPRIETARY RIGHTS.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#include <csignal>
+#include <iostream>
+
+#import <Foundation/Foundation.h>
+
+#include "AppleDebug.hpp"
+#include "FormatString.hpp"
+
+using namespace Diligent;
+
+void AppleDebug :: AssertionFailed( const Char *Message, const char *Function, const char *File, int Line )
+{
+    auto AssertionFailedMessage = FormatAssertionFailedMessage(Message, Function, File, Line);
+    OutputDebugMessage(DEBUG_MESSAGE_SEVERITY_ERROR, AssertionFailedMessage.c_str(), nullptr, nullptr, 0);
+
+    raise( SIGTRAP );
+};
+
+
+void AppleDebug::OutputDebugMessage(DEBUG_MESSAGE_SEVERITY Severity, const Char *Message, const char *Function, const char *File, int Line)
+{
+    auto msg = FormatDebugMessage(Severity, Message, Function, File, Line);
+    // NSLog truncates the log at 1024 symbols
+    printf("%s", msg.c_str());
+    //NSLog(@"%s", str.c_str());
+}
+
+void DebugAssertionFailed(const Diligent::Char* Message, const char* Function, const char* File, int Line)
+{
+    AppleDebug :: AssertionFailed( Message, Function, File, Line );
+}
+
+namespace Diligent
+{
+DebugMessageCallbackType DebugMessageCallback = AppleDebug::OutputDebugMessage;
+}
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Apple/src/AppleFileSystem.cpp b/app/src/main/java/libengine/DiligentLog/Platforms/Apple/src/AppleFileSystem.cpp
new file mode 100644
index 00000000..1d9664c3
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Apple/src/AppleFileSystem.cpp
@@ -0,0 +1,150 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#include <stdio.h>
+#include <unistd.h>
+#include <cstdio>
+#include <CoreFoundation/CoreFoundation.h>
+
+#include "CFObjectWrapper.hpp"
+
+#include "AppleFileSystem.hpp"
+#include "Errors.hpp"
+#include "DebugUtilities.hpp"
+
+namespace
+{
+
+std::string FindResource(const std::string& FilePath)
+{
+    std::string dir, name;
+    BasicFileSystem::SplitFilePath(FilePath, &dir, &name);
+    auto        dotPos = name.find(".");
+    std::string type   = (dotPos != std::string::npos) ? name.substr(dotPos + 1) : "";
+    if (dotPos != std::string::npos)
+        name.erase(dotPos);
+
+    // Naming convention established by Core Foundation library:
+    // * If a function name contains the word "Create" or "Copy", you own the object.
+    // * If a function name contains the word "Get", you do not own the object.
+    // If you own an object, it is your responsibility to relinquish ownership
+    // (using CFRelease) when you have finished with it.
+    // https://developer.apple.com/library/content/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html
+
+    // get bundle and CFStrings
+    CFBundleRef     mainBundle       = CFBundleGetMainBundle();
+    CFStringWrapper cf_resource_path = CFStringCreateWithCString(NULL, dir.c_str(), kCFStringEncodingUTF8);
+    CFStringWrapper cf_filename      = CFStringCreateWithCString(NULL, name.c_str(), kCFStringEncodingUTF8);
+    CFStringWrapper cf_file_type     = CFStringCreateWithCString(NULL, type.c_str(), kCFStringEncodingUTF8);
+    CFURLWrapper    cf_url_resource  = CFBundleCopyResourceURL(mainBundle, cf_filename, cf_file_type, cf_resource_path);
+    std::string     resource_path;
+    if (cf_url_resource != NULL)
+    {
+        CFStringWrapper cf_url_string = CFURLCopyFileSystemPath(cf_url_resource, kCFURLPOSIXPathStyle);
+        const char*     url_string    = CFStringGetCStringPtr(cf_url_string, kCFStringEncodingUTF8);
+        resource_path                 = url_string;
+    }
+    return resource_path;
+}
+
+} // namespace
+
+AppleFile* AppleFileSystem::OpenFile(const FileOpenAttribs& OpenAttribs)
+{
+    // Try to find the file in the bundle first
+    std::string path(OpenAttribs.strFilePath);
+    CorrectSlashes(path, AppleFileSystem::GetSlashSymbol());
+    auto resource_path = FindResource(path);
+
+    AppleFile* pFile = nullptr;
+    if (!resource_path.empty())
+    {
+        try
+        {
+            FileOpenAttribs BundleResourceOpenAttribs = OpenAttribs;
+            BundleResourceOpenAttribs.strFilePath     = resource_path.c_str();
+            pFile                                     = new AppleFile(BundleResourceOpenAttribs, AppleFileSystem::GetSlashSymbol());
+        }
+        catch (const std::runtime_error& err)
+        {
+        }
+    }
+
+    if (pFile == nullptr)
+    {
+        try
+        {
+            pFile = new AppleFile(OpenAttribs, AppleFileSystem::GetSlashSymbol());
+        }
+        catch (const std::runtime_error& err)
+        {
+        }
+    }
+    return pFile;
+}
+
+
+bool AppleFileSystem::FileExists(const Diligent::Char* strFilePath)
+{
+    std::string path(strFilePath);
+    CorrectSlashes(path, AppleFileSystem::GetSlashSymbol());
+    auto resource_path = FindResource(path);
+
+    if (!FindResource(path).empty())
+        return true;
+
+    auto res = access(path.c_str(), F_OK);
+    return res == 0;
+}
+
+bool AppleFileSystem::PathExists(const Diligent::Char* strPath)
+{
+    UNSUPPORTED("Not implemented");
+    return false;
+}
+
+bool AppleFileSystem::CreateDirectory(const Diligent::Char* strPath)
+{
+    UNSUPPORTED("Not implemented");
+    return false;
+}
+
+void AppleFileSystem::ClearDirectory(const Diligent::Char* strPath)
+{
+    UNSUPPORTED("Not implemented");
+}
+
+void AppleFileSystem::DeleteFile(const Diligent::Char* strPath)
+{
+    remove(strPath);
+}
+
+std::vector<std::unique_ptr<FindFileData>> AppleFileSystem::Search(const Diligent::Char* SearchPattern)
+{
+    UNSUPPORTED("Not implemented");
+    return std::vector<std::unique_ptr<FindFileData>>();
+}
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Basic/CMakeLists.txt b/app/src/main/java/libengine/DiligentLog/Platforms/Basic/CMakeLists.txt
new file mode 100644
index 00000000..70827549
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Basic/CMakeLists.txt
@@ -0,0 +1,52 @@
+cmake_minimum_required (VERSION 3.6)
+
+project(Diligent-BasicPlatform_LOG CXX)
+
+set(SOURCE 
+    src/BasicFileSystem.cpp
+    src/BasicPlatformDebug.cpp
+)
+
+set(INTERFACE 
+    interface/BasicAtomics.hpp
+    interface/BasicFileSystem.hpp
+    interface/BasicPlatformDebug.hpp
+    interface/BasicPlatformMisc.hpp
+    interface/DebugUtilities.hpp
+)
+
+if(PLATFORM_LINUX OR PLATFORM_WIN32 OR PLATFORM_APPLE)
+    list(APPEND SOURCE src/StandardFile.cpp)
+    list(APPEND INTERFACE interface/StandardFile.hpp)
+endif()
+
+add_library(Diligent-BasicPlatform_LOG STATIC ${SOURCE} ${INTERFACE})
+set_common_target_properties__LOG(Diligent-BasicPlatform_LOG)
+
+target_include_directories(Diligent-BasicPlatform_LOG
+PUBLIC
+    interface
+)
+
+target_link_libraries(Diligent-BasicPlatform_LOG
+PRIVATE
+    Diligent-BuildSettings__LOG 
+PUBLIC
+    Diligent-Primitives
+)
+
+source_group("src" FILES ${SOURCE})
+source_group("interface" FILES ${INTERFACE})
+
+set_target_properties(Diligent-BasicPlatform_LOG PROPERTIES
+    FOLDER DiligentLog/Platforms
+)
+
+
+if(DILIGENT_INSTALL_CORE)
+    install_core_lib__LOG(Diligent-BasicPlatform_LOG)
+    get_target_relative_dir__LOG(Diligent-BasicPlatform_LOG BASIC_PLATFORM_DIR)
+    install(DIRECTORY    "../interface"
+            DESTINATION  "${CMAKE_INSTALL_INCLUDEDIR}/${BASIC_PLATFORM_DIR}/../"
+    )
+endif()
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/BasicAtomics.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/BasicAtomics.hpp
new file mode 100644
index 00000000..2ae640ec
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/BasicAtomics.hpp
@@ -0,0 +1,69 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include <atomic>
+
+struct BasicAtomics
+{
+    using Long        = long;
+    using AtomicLong  = std::atomic<Long>;
+    using Int64       = int64_t;
+    using AtomicInt64 = std::atomic<Int64>;
+
+    // The function returns the resulting INCREMENTED value.
+    template <typename Type>
+    static inline Type AtomicIncrement(std::atomic<Type>& Val)
+    {
+        return ++Val;
+    }
+
+    // The function returns the resulting DECREMENTED value.
+    template <typename Type>
+    static inline Type AtomicDecrement(std::atomic<Type>& Val)
+    {
+        return --Val;
+    }
+
+    // The function compares the Destination value with the Comparand value. If the Destination value is equal
+    // to the Comparand value, the Exchange value is stored in the address specified by Destination.
+    // Otherwise, no operation is performed.
+    // The function returns the initial value of the Destination parameter
+    template <typename Type>
+    static inline Type AtomicCompareExchange(std::atomic<Type>& Destination, Type Exchange, Type Comparand)
+    {
+        Destination.compare_exchange_strong(Comparand, Exchange);
+        return Comparand;
+    }
+
+    template <typename Type>
+    static inline Type AtomicAdd(std::atomic<Type>& Destination, Type Val)
+    {
+        return std::atomic_fetch_add(&Destination, Val);
+    }
+};
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/BasicFileSystem.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/BasicFileSystem.hpp
new file mode 100644
index 00000000..446e1963
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/BasicFileSystem.hpp
@@ -0,0 +1,108 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include <vector>
+#include "../../../../../MultiTouch/DiligentLog/Primitives/interface/BasicTypes.h"
+
+enum class EFileAccessMode
+{
+    Read,
+    Overwrite,
+    Append
+};
+
+enum class FilePosOrigin
+{
+    Start,
+    Curr,
+    End
+};
+
+
+struct FileOpenAttribs
+{
+    const Diligent::Char* strFilePath;
+    EFileAccessMode       AccessMode;
+    FileOpenAttribs(const Diligent::Char* Path   = nullptr,
+                    EFileAccessMode       Access = EFileAccessMode::Read) :
+        strFilePath{Path},
+        AccessMode{Access}
+    {}
+};
+
+class BasicFile
+{
+public:
+    BasicFile(const FileOpenAttribs& OpenAttribs, Diligent::Char SlashSymbol);
+    virtual ~BasicFile();
+
+    const Diligent::String& GetPath() { return m_Path; }
+
+protected:
+    Diligent::String GetOpenModeStr();
+
+    FileOpenAttribs  m_OpenAttribs;
+    Diligent::String m_Path;
+};
+
+struct FindFileData
+{
+    virtual const Diligent::Char* Name() const        = 0;
+    virtual bool                  IsDirectory() const = 0;
+
+    virtual ~FindFileData() {}
+};
+
+struct BasicFileSystem
+{
+public:
+    static BasicFile* OpenFile(FileOpenAttribs& OpenAttribs);
+    static void       ReleaseFile(BasicFile*);
+
+    static std::string GetFullPath(const Diligent::Char* strFilePath);
+
+    static bool FileExists(const Diligent::Char* strFilePath);
+
+    static void SetWorkingDirectory(const Diligent::Char* strWorkingDir) { m_strWorkingDirectory = strWorkingDir; }
+
+    static const Diligent::String& GetWorkingDirectory() { return m_strWorkingDirectory; }
+
+    static Diligent::Char GetSlashSymbol();
+
+    static void CorrectSlashes(Diligent::String& Path, Diligent::Char SlashSymbol);
+
+    static void SplitFilePath(const Diligent::String& FullName,
+                              Diligent::String*       Path,
+                              Diligent::String*       Name);
+
+    static bool IsPathAbsolute(const Diligent::Char* strPath);
+
+protected:
+    static Diligent::String m_strWorkingDirectory;
+};
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/BasicPlatformDebug.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/BasicPlatformDebug.hpp
new file mode 100644
index 00000000..8ea35bc4
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/BasicPlatformDebug.hpp
@@ -0,0 +1,46 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../../../../MultiTouch/DiligentLog/Primitives/interface/Errors.hpp"
+
+struct BasicPlatformDebug
+{
+    static Diligent::String FormatAssertionFailedMessage(const Diligent::Char* Message,
+                                                         const char*           Function, // type of __FUNCTION__
+                                                         const char*           File,     // type of __FILE__
+                                                         int                   Line);
+    static Diligent::String FormatDebugMessage(Diligent::DEBUG_MESSAGE_SEVERITY Severity,
+                                               const Diligent::Char*            Message,
+                                               const char*                      Function, // type of __FUNCTION__
+                                               const char*                      File,     // type of __FILE__
+                                               int                              Line);
+};
+
+// Forward declarations of platform-specific debug functions
+void DebugAssertionFailed(const Diligent::Char* Message, const char* Function, const char* File, int Line);
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/BasicPlatformMisc.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/BasicPlatformMisc.hpp
new file mode 100644
index 00000000..333c159c
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/BasicPlatformMisc.hpp
@@ -0,0 +1,69 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../../../../MultiTouch/DiligentLog/Primitives/interface/BasicTypes.h"
+
+struct BasicPlatformMisc
+{
+    template <typename Type>
+    static Diligent::Uint32 GetMSB(Type Val)
+    {
+        if (Val == 0) return sizeof(Type) * 8;
+
+        Diligent::Uint32 MSB = sizeof(Type) * 8 - 1;
+        while (!(Val & (Type{1} << MSB)))
+            --MSB;
+
+        return MSB;
+    }
+
+    template <typename Type>
+    static Diligent::Uint32 GetLSB(Type Val)
+    {
+        if (Val == 0) return sizeof(Type) * 8;
+
+        Diligent::Uint32 LSB = 0;
+        while (!(Val & (Type{1} << LSB)))
+            ++LSB;
+
+        return LSB;
+    }
+
+    template <typename Type>
+    static Diligent::Uint32 CountOneBits(Type Val)
+    {
+        Diligent::Uint32 bits = 0;
+        while (Val != 0)
+        {
+            Val &= (Val - 1);
+            ++bits;
+        }
+        return bits;
+    }
+};
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/DebugUtilities.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/DebugUtilities.hpp
new file mode 100644
index 00000000..7c8a982f
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/DebugUtilities.hpp
@@ -0,0 +1,108 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../../../../MultiTouch/DiligentLog/Primitives/interface/FormatString.hpp"
+#include "../../../../../MultiTouch/DiligentLog/Primitives/interface/Errors.hpp"
+#include "BasicPlatformDebug.hpp"
+
+#ifdef DILIGENT_DEBUG
+
+#    include <typeinfo>
+
+#    define ASSERTION_FAILED(Message, ...)                                       \
+        do                                                                       \
+        {                                                                        \
+            auto msg = Diligent::FormatString(Message, ##__VA_ARGS__);           \
+            DebugAssertionFailed(msg.c_str(), __FUNCTION__, __FILE__, __LINE__); \
+        } while (false)
+
+#    define VERIFY(Expr, Message, ...)                    \
+        do                                                \
+        {                                                 \
+            if (!(Expr))                                  \
+            {                                             \
+                ASSERTION_FAILED(Message, ##__VA_ARGS__); \
+            }                                             \
+        } while (false)
+
+#    define UNEXPECTED  ASSERTION_FAILED
+#    define UNSUPPORTED ASSERTION_FAILED
+
+#    define VERIFY_EXPR(Expr) VERIFY(Expr, "Debug expression failed:\n", #    Expr)
+
+
+template <typename DstType, typename SrcType>
+void CheckDynamicType(SrcType* pSrcPtr)
+{
+    VERIFY(pSrcPtr == nullptr || dynamic_cast<DstType*>(pSrcPtr) != nullptr, "Dynamic type cast failed. Src typeid: \'", typeid(*pSrcPtr).name(), "\' Dst typeid: \'", typeid(DstType).name(), '\'');
+}
+#    define CHECK_DYNAMIC_TYPE(DstType, pSrcPtr) \
+        do                                       \
+        {                                        \
+            CheckDynamicType<DstType>(pSrcPtr);  \
+        } while (false)
+
+
+#else
+
+// clang-format off
+#    define CHECK_DYNAMIC_TYPE(...) do{}while(false)
+#    define VERIFY(...)do{}while(false)
+#    define UNEXPECTED(...)do{}while(false)
+#    define UNSUPPORTED(...)do{}while(false)
+#    define VERIFY_EXPR(...)do{}while(false)
+// clang-format on
+
+#endif
+
+#if defined(DILIGENT_DEBUG)
+#    define DEV_CHECK_ERR VERIFY
+#elif defined(DILIGENT_DEVELOPMENT)
+#    define DEV_CHECK_ERR CHECK_ERR
+#else
+// clang-format off
+#    define DEV_CHECK_ERR(...)do{}while(false)
+// clang-format on
+#endif
+
+#define DEV_ERROR(...) DEV_CHECK_ERR(false, __VA_ARGS__)
+
+#ifdef DILIGENT_DEVELOPMENT
+
+#    define DEV_CHECK_WARN CHECK_WARN
+#    define DEV_CHECK_INFO CHECK_INFO
+
+#else
+
+// clang-format off
+#    define DEV_CHECK_WARN(...)do{}while(false)
+#    define DEV_CHECK_INFO(...)do{}while(false)
+// clang-format on
+
+#endif
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/StandardFile.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/StandardFile.hpp
new file mode 100644
index 00000000..88d22fcf
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Basic/interface/StandardFile.hpp
@@ -0,0 +1,55 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include <stdio.h>
+
+#include "../../../../../MultiTouch/DiligentLog/Primitives/interface/DataBlob.h"
+#include "BasicFileSystem.hpp"
+
+class StandardFile : public BasicFile
+{
+public:
+    StandardFile(const FileOpenAttribs& OpenAttribs, Diligent::Char SlashSymbol);
+    virtual ~StandardFile() override;
+
+    void Read(Diligent::IDataBlob* pData);
+
+    bool Read(void* Data, size_t Size);
+
+    bool Write(const void* Data, size_t Size);
+
+    size_t GetSize();
+
+    size_t GetPos();
+
+    void SetPos(size_t Offset, FilePosOrigin Origin);
+
+protected:
+    FILE* m_pFile = nullptr;
+};
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Basic/src/BasicFileSystem.cpp b/app/src/main/java/libengine/DiligentLog/Platforms/Basic/src/BasicFileSystem.cpp
new file mode 100644
index 00000000..23993e3a
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Basic/src/BasicFileSystem.cpp
@@ -0,0 +1,143 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#include "BasicFileSystem.hpp"
+#include "DebugUtilities.hpp"
+#include <algorithm>
+
+Diligent::String BasicFileSystem::m_strWorkingDirectory;
+
+BasicFile::BasicFile(const FileOpenAttribs& OpenAttribs, Diligent::Char SlashSymbol) :
+    m_OpenAttribs{OpenAttribs},
+    m_Path{BasicFileSystem::GetFullPath(OpenAttribs.strFilePath)}
+{
+    BasicFileSystem::CorrectSlashes(m_Path, SlashSymbol);
+
+    m_OpenAttribs.strFilePath = m_Path.c_str();
+}
+
+BasicFile::~BasicFile()
+{
+}
+
+Diligent::String BasicFile::GetOpenModeStr()
+{
+    std::string OpenModeStr;
+    switch (m_OpenAttribs.AccessMode)
+    {
+        // clang-format off
+        case EFileAccessMode::Read:      OpenModeStr += 'r'; break;
+        case EFileAccessMode::Overwrite: OpenModeStr += 'w'; break;
+        case EFileAccessMode::Append:    OpenModeStr += 'a'; break;
+        // clang-format on
+        default: break;
+    }
+
+    // Always open file in binary mode. Text mode is platform-specific
+    OpenModeStr += 'b';
+
+    return OpenModeStr;
+}
+
+
+std::string BasicFileSystem::GetFullPath(const Diligent::Char* strFilePath)
+{
+    std::string FullPath = m_strWorkingDirectory;
+    auto        len      = FullPath.length();
+    if (len > 0 && FullPath[len - 1] != '\\')
+    {
+        FullPath += '\\';
+    }
+    FullPath += strFilePath;
+    return FullPath;
+}
+
+BasicFile* BasicFileSystem::OpenFile(FileOpenAttribs& OpenAttribs)
+{
+    return nullptr;
+}
+
+void BasicFileSystem::ReleaseFile(BasicFile* pFile)
+{
+    if (pFile)
+        delete pFile;
+}
+
+bool BasicFileSystem::FileExists(const Diligent::Char* strFilePath)
+{
+    return false;
+}
+
+Diligent::Char BasicFileSystem::GetSlashSymbol()
+{
+    UNSUPPORTED("Unsupported");
+    return 0;
+}
+
+void BasicFileSystem::CorrectSlashes(Diligent::String& Path, Diligent::Char SlashSymbol)
+{
+    VERIFY(SlashSymbol == '\\' || SlashSymbol == '/',
+           "Incorrect slash symbol");
+    Diligent::Char RevSlashSym = (SlashSymbol == '\\') ? '/' : '\\';
+    std::replace(Path.begin(), Path.end(), RevSlashSym, SlashSymbol);
+}
+
+void BasicFileSystem::SplitFilePath(const Diligent::String& FullName,
+                                    Diligent::String*       Path,
+                                    Diligent::String*       Name)
+{
+    auto LastSlashPos = FullName.find_last_of("/\\");
+    if (Path)
+    {
+        if (LastSlashPos != Diligent::String::npos)
+            *Path = FullName.substr(0, LastSlashPos);
+        else
+            *Path = "";
+    }
+
+    if (Name)
+    {
+        if (LastSlashPos != Diligent::String::npos)
+            *Name = FullName.substr(LastSlashPos + 1);
+        else
+            *Name = FullName;
+    }
+}
+
+bool BasicFileSystem::IsPathAbsolute(const Diligent::Char* strPath)
+{
+    if (strPath == nullptr || strPath[0] == 0)
+        return false;
+
+#if PLATFORM_WIN32 || PLATFORM_UNIVERSAL_WINDOWS
+    return strPath[1] == ':' && (strPath[2] == '\\' || strPath[2] == '/');
+#elif PLATFORM_LINUX || PLATFORM_MACOS || PLATFORM_IOS || PLATFORM_TVOS || PLATFORM_ANDROID
+    return strPath[0] == '/';
+#else
+#    error Unknown platform.
+#endif
+}
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Basic/src/BasicPlatformDebug.cpp b/app/src/main/java/libengine/DiligentLog/Platforms/Basic/src/BasicPlatformDebug.cpp
new file mode 100644
index 00000000..afc32c82
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Basic/src/BasicPlatformDebug.cpp
@@ -0,0 +1,75 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#include "BasicPlatformDebug.hpp"
+#include "FormatString.hpp"
+#include "BasicFileSystem.hpp"
+#include <iostream>
+
+using namespace Diligent;
+
+String BasicPlatformDebug::FormatAssertionFailedMessage(const char* Message,
+                                                        const char* Function, // type of __FUNCTION__
+                                                        const char* File,     // type of __FILE__
+                                                        int         Line)
+{
+    String FileName;
+    BasicFileSystem::SplitFilePath(File, nullptr, &FileName);
+    return Diligent::FormatString("Debug assertion failed in ", Function, "(), file ", FileName, ", line ", Line, ":\n", Message);
+}
+
+String BasicPlatformDebug::FormatDebugMessage(DEBUG_MESSAGE_SEVERITY Severity,
+                                              const Char*            Message,
+                                              const char*            Function, // type of __FUNCTION__
+                                              const char*            File,     // type of __FILE__
+                                              int                    Line)
+{
+    std::stringstream msg_ss;
+
+    static const Char* const strSeverities[] = {"Info", "Warning", "ERROR", "CRITICAL ERROR"};
+    const auto*              MessageSevery   = strSeverities[static_cast<int>(Severity)];
+
+    msg_ss << "Diligent Engine: " << MessageSevery;
+    if (Function != nullptr || File != nullptr)
+    {
+        msg_ss << " in ";
+        if (Function != nullptr)
+        {
+            msg_ss << Function << "()";
+            if (File != nullptr)
+                msg_ss << " (";
+        }
+
+        if (File != nullptr)
+        {
+            msg_ss << File << ", " << Line << ')';
+        }
+    }
+    msg_ss << ": " << Message << '\n';
+
+    return msg_ss.str();
+}
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Basic/src/StandardFile.cpp b/app/src/main/java/libengine/DiligentLog/Platforms/Basic/src/StandardFile.cpp
new file mode 100644
index 00000000..f996e01d
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Basic/src/StandardFile.cpp
@@ -0,0 +1,123 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#include "StandardFile.hpp"
+#include "DebugUtilities.hpp"
+#include "Errors.hpp"
+
+StandardFile::StandardFile(const FileOpenAttribs& OpenAttribs, Diligent::Char SlashSymbol) :
+    BasicFile{OpenAttribs, SlashSymbol},
+    m_pFile{nullptr}
+{
+#if PLATFORM_LINUX || PLATFORM_MACOS || PLATFORM_IOS || PLATFORM_TVOS
+    auto OpenModeStr = GetOpenModeStr();
+    m_pFile          = fopen(m_OpenAttribs.strFilePath, OpenModeStr.c_str());
+    if (m_pFile == nullptr)
+    {
+        LOG_ERROR_AND_THROW("Failed to open file ", m_OpenAttribs.strFilePath,
+                            "\nThe following error occurred: ", strerror(errno));
+    }
+#endif
+}
+
+StandardFile::~StandardFile()
+{
+    if (m_pFile)
+    {
+        fclose(m_pFile);
+        m_pFile = nullptr;
+    }
+}
+
+void StandardFile::Read(Diligent::IDataBlob* pData)
+{
+    VERIFY_EXPR(pData != nullptr);
+    auto FileSize = GetSize();
+    pData->Resize(FileSize);
+    auto Res = Read(pData->GetDataPtr(), pData->GetSize());
+    VERIFY(Res, "Failed to read ", FileSize, " bytes from file");
+    (void)Res;
+}
+
+bool StandardFile::Read(void* Data, size_t Size)
+{
+    VERIFY(m_pFile, "File is not opened");
+    if (!m_pFile)
+        return false;
+    auto BytesRead = fread(Data, 1, Size, m_pFile);
+
+    return BytesRead == Size;
+}
+
+bool StandardFile::Write(const void* Data, size_t Size)
+{
+    VERIFY(m_pFile, "File is not opened");
+    if (!m_pFile)
+        return false;
+    auto BytesWritten = fwrite(Data, 1, Size, m_pFile);
+
+    return BytesWritten == Size;
+}
+
+size_t StandardFile::GetSize()
+{
+    auto OrigPos = ftell(m_pFile);
+    fseek(m_pFile, 0, SEEK_END);
+    auto FileSize = ftell(m_pFile);
+
+    fseek(m_pFile, OrigPos, SEEK_SET);
+    return FileSize;
+}
+
+size_t StandardFile::GetPos()
+{
+    VERIFY(m_pFile, "File is not opened");
+    if (!m_pFile)
+        return 0;
+
+    return ftell(m_pFile);
+}
+
+void StandardFile::SetPos(size_t Offset, FilePosOrigin Origin)
+{
+    VERIFY(m_pFile, "File is not opened");
+    if (!m_pFile)
+        return;
+
+    int orig = SEEK_SET;
+    switch (Origin)
+    {
+        // clang-format off
+        case FilePosOrigin::Start: orig = SEEK_SET; break;
+        case FilePosOrigin::Curr:  orig = SEEK_CUR; break;
+        case FilePosOrigin::End:   orig = SEEK_END; break;
+        // clang-format on
+        default: UNEXPECTED("Unknown origin");
+    }
+
+    fseek(m_pFile, static_cast<long>(Offset), orig);
+}
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/CMakeLists.txt b/app/src/main/java/libengine/DiligentLog/Platforms/CMakeLists.txt
new file mode 100644
index 00000000..d50d1469
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/CMakeLists.txt
@@ -0,0 +1,40 @@
+cmake_minimum_required (VERSION 3.6)
+
+add_library(Diligent-PlatformInterface INTERFACE)
+
+target_include_directories(Diligent-PlatformInterface INTERFACE interface)
+
+set(PLATFORM_INTERFACE_HEADERS
+	../interface/Atomics.hpp
+	../interface/FileSystem.hpp
+	../interface/PlatformDebug.hpp
+	../interface/PlatformDefinitions.h
+	../interface/PlatformMisc.hpp
+	../interface/NativeWindow.h
+)
+
+add_subdirectory(Basic)
+
+set(WAS_SHARED ${BUILD_SHARED_LIBS})
+set(BUILD_SHARED_LIBS OFF CACHE BOOL " " FORCE)
+
+if(PLATFORM_WIN32)
+	add_subdirectory(Win32)
+	add_library(Diligent-TargetPlatform ALIAS Diligent-Win32Platform)
+elseif(PLATFORM_UNIVERSAL_WINDOWS)
+	add_subdirectory(UWP)
+	add_library(Diligent-TargetPlatform ALIAS Diligent-UniversalWindowsPlatform)
+elseif(PLATFORM_ANDROID)
+	add_subdirectory(Android)
+	add_library(Diligent-TargetPlatform ALIAS Diligent-AndroidPlatform_LOG)
+elseif(PLATFORM_LINUX)
+	add_subdirectory(Linux)
+	add_library(Diligent-TargetPlatform ALIAS Diligent-LinuxPlatform)
+elseif(PLATFORM_APPLE)
+	add_subdirectory(Apple)
+	add_library(Diligent-TargetPlatform ALIAS Diligent-ApplePlatform)
+else()
+	message(FATAL_ERROR "No PLATFORM_XXX variable defined. Make sure that 'DiligentCore' folder is processed first")
+endif()
+
+set(BUILD_SHARED_LIBS ${WAS_SHARED} CACHE BOOL " " FORCE)
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Linux/CMakeLists.txt b/app/src/main/java/libengine/DiligentLog/Platforms/Linux/CMakeLists.txt
new file mode 100644
index 00000000..f77f676e
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Linux/CMakeLists.txt
@@ -0,0 +1,44 @@
+cmake_minimum_required (VERSION 3.6)
+
+project(Diligent-LinuxPlatform CXX)
+
+set(INTERFACE 
+    interface/LinuxDebug.hpp
+    interface/LinuxFileSystem.hpp
+    interface/LinuxPlatformDefinitions.h
+    interface/LinuxPlatformMisc.hpp
+    interface/LinuxNativeWindow.h
+)
+
+set(SOURCE 
+    src/LinuxDebug.cpp
+    src/LinuxFileSystem.cpp
+)
+
+add_library(Diligent-LinuxPlatform ${SOURCE} ${INTERFACE} ${PLATFORM_INTERFACE_HEADERS})
+set_common_target_properties__LOG(Diligent-LinuxPlatform)
+
+target_include_directories(Diligent-LinuxPlatform 
+PUBLIC
+    interface
+)
+
+target_link_libraries(Diligent-LinuxPlatform 
+PRIVATE
+    Diligent-BuildSettings__LOG 
+PUBLIC
+    Diligent-BasicPlatform_LOG
+    Diligent-PlatformInterface
+)
+
+source_group("src" FILES ${SOURCE})
+source_group("include" FILES ${INCLUDE})
+source_group("interface" FILES ${PLATFORM_INTERFACE_HEADERS})
+
+set_target_properties(Diligent-LinuxPlatform PROPERTIES
+    FOLDER DiligentLog/Platforms
+)
+
+if(DILIGENT_INSTALL_CORE)
+    install_core_lib__LOG(Diligent-LinuxPlatform)
+endif()
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Linux/interface/LinuxDebug.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/Linux/interface/LinuxDebug.hpp
new file mode 100644
index 00000000..68a91e37
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Linux/interface/LinuxDebug.hpp
@@ -0,0 +1,43 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../Basic/interface/BasicPlatformDebug.hpp"
+
+struct LinuxDebug : public BasicPlatformDebug
+{
+    static void AssertionFailed(const Diligent::Char* Message,
+                                const char*           Function, // type of __FUNCTION__
+                                const char*           File,     // type of __FILE__
+                                int                   Line);
+    static void OutputDebugMessage(Diligent::DEBUG_MESSAGE_SEVERITY Severity,
+                                   const Diligent::Char*            Message,
+                                   const char*                      Function, // type of __FUNCTION__
+                                   const char*                      File,     // type of __FILE__
+                                   int                              Line);
+};
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Linux/interface/LinuxFileSystem.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/Linux/interface/LinuxFileSystem.hpp
new file mode 100644
index 00000000..9025360c
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Linux/interface/LinuxFileSystem.hpp
@@ -0,0 +1,53 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include <memory>
+#include <vector>
+
+#include "../../Basic/interface/BasicFileSystem.hpp"
+#include "../../Basic/interface/StandardFile.hpp"
+
+using LinuxFile = StandardFile;
+
+struct LinuxFileSystem : public BasicFileSystem
+{
+public:
+    static LinuxFile* OpenFile(const FileOpenAttribs& OpenAttribs);
+
+    static inline Diligent::Char GetSlashSymbol() { return '/'; }
+
+    static bool FileExists(const Diligent::Char* strFilePath);
+    static bool PathExists(const Diligent::Char* strPath);
+
+    static bool CreateDirectory(const Diligent::Char* strPath);
+    static void ClearDirectory(const Diligent::Char* strPath);
+    static void DeleteFile(const Diligent::Char* strPath);
+
+    static std::vector<std::unique_ptr<FindFileData>> Search(const Diligent::Char* SearchPattern);
+};
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Linux/interface/LinuxNativeWindow.h b/app/src/main/java/libengine/DiligentLog/Platforms/Linux/interface/LinuxNativeWindow.h
new file mode 100644
index 00000000..cae99ce7
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Linux/interface/LinuxNativeWindow.h
@@ -0,0 +1,42 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../../../../MultiTouch/DiligentLog/Primitives/interface/CommonDefinitions.h"
+#include "../../../../../MultiTouch/DiligentLog/Primitives/interface/BasicTypes.h"
+
+DILIGENT_BEGIN_NAMESPACE(Diligent)
+
+struct LinuxNativeWindow
+{
+    Uint32 WindowId      DEFAULT_INITIALIZER(0);
+    void* pDisplay       DEFAULT_INITIALIZER(nullptr);
+    void* pXCBConnection DEFAULT_INITIALIZER(nullptr);
+};
+
+DILIGENT_END_NAMESPACE // namespace Diligent
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Linux/interface/LinuxPlatformDefinitions.h b/app/src/main/java/libengine/DiligentLog/Platforms/Linux/interface/LinuxPlatformDefinitions.h
new file mode 100644
index 00000000..bc4fb45b
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Linux/interface/LinuxPlatformDefinitions.h
@@ -0,0 +1,44 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../../../../MultiTouch/DiligentLog/Primitives/interface/CommonDefinitions.h"
+
+#if DILIGENT_C_INTERFACE
+
+#    define _countof(arr) (sizeof(arr) / sizeof(arr[0]))
+
+#else
+
+#    include <cstddef>
+
+template <typename _CountofType, std::size_t _SizeOfArray>
+char (*__countof_helper(_CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];
+#    define _countof(_Array) (sizeof(*__countof_helper(_Array)) + 0)
+
+#endif
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Linux/interface/LinuxPlatformMisc.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/Linux/interface/LinuxPlatformMisc.hpp
new file mode 100644
index 00000000..2a4aa167
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Linux/interface/LinuxPlatformMisc.hpp
@@ -0,0 +1,102 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../Basic/interface/BasicPlatformMisc.hpp"
+#include "../../../../../MultiTouch/DiligentLog/Platforms/Basic/interface/DebugUtilities.hpp"
+
+struct LinuxMisc : public BasicPlatformMisc
+{
+    static Diligent::Uint32 GetMSB(Diligent::Uint32 Val)
+    {
+        if (Val == 0) return 32;
+
+        // Returns the number of leading 0-bits in x, starting at the
+        // most significant bit position. If x is 0, the result is undefined.
+        int  LeadingZeros = __builtin_clz(Val);
+        auto MSB          = static_cast<Diligent::Uint32>(31 - LeadingZeros);
+        VERIFY_EXPR(MSB == BasicPlatformMisc::GetMSB(Val));
+
+        return MSB;
+    }
+
+    static Diligent::Uint32 GetLSB(Diligent::Uint32 Val)
+    {
+        if (Val == 0) return 32;
+
+        // Returns the number of trailing 0-bits in x, starting at the
+        // least significant bit position. If x is 0, the result is undefined.
+        auto TrailingZeros = __builtin_ctz(Val);
+        auto LSB           = static_cast<Diligent::Uint32>(TrailingZeros);
+        VERIFY_EXPR(LSB == BasicPlatformMisc::GetLSB(Val));
+
+        return LSB;
+    }
+
+    static Diligent::Uint32 GetMSB(Diligent::Uint64 Val)
+    {
+        if (Val == 0) return 64;
+
+        // Returns the number of leading 0-bits in x, starting at the
+        // most significant bit position. If x is 0, the result is undefined.
+        int  LeadingZeros = __builtin_clzll(Val);
+        auto MSB          = static_cast<Diligent::Uint32>(63 - LeadingZeros);
+        VERIFY_EXPR(MSB == BasicPlatformMisc::GetMSB(Val));
+
+        return MSB;
+    }
+
+    static Diligent::Uint32 GetLSB(Diligent::Uint64 Val)
+    {
+        if (Val == 0) return 64;
+
+        // Returns the number of trailing 0-bits in x, starting at the
+        // least significant bit position. If x is 0, the result is undefined.
+        auto TrailingZeros = __builtin_ctzll(Val);
+        auto LSB           = static_cast<Diligent::Uint32>(TrailingZeros);
+        VERIFY_EXPR(LSB == BasicPlatformMisc::GetLSB(Val));
+
+        return LSB;
+    }
+
+    static Diligent::Uint32 CountOneBits(Diligent::Uint32 Val)
+    {
+        // Returns the number of 1-bits in x.
+        auto bits = static_cast<Diligent::Uint32>(__builtin_popcount(Val));
+        VERIFY_EXPR(bits == BasicPlatformMisc::CountOneBits(Val));
+        return bits;
+    }
+
+    static Diligent::Uint32 CountOneBits(Diligent::Uint64 Val)
+    {
+        // Returns the number of 1-bits in x.
+        auto bits = static_cast<Diligent::Uint32>(__builtin_popcountll(Val));
+        VERIFY_EXPR(bits == BasicPlatformMisc::CountOneBits(Val));
+        return bits;
+    }
+};
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Linux/src/LinuxDebug.cpp b/app/src/main/java/libengine/DiligentLog/Platforms/Linux/src/LinuxDebug.cpp
new file mode 100644
index 00000000..1145f1f0
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Linux/src/LinuxDebug.cpp
@@ -0,0 +1,61 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#include <csignal>
+#include <iostream>
+
+#include "LinuxDebug.hpp"
+#include "FormatString.hpp"
+
+using namespace Diligent;
+
+void LinuxDebug ::AssertionFailed(const Char* Message, const char* Function, const char* File, int Line)
+{
+    auto AssertionFailedMessage = FormatAssertionFailedMessage(Message, Function, File, Line);
+    OutputDebugMessage(DEBUG_MESSAGE_SEVERITY_ERROR, AssertionFailedMessage.c_str(), nullptr, nullptr, 0);
+
+    raise(SIGTRAP);
+};
+
+
+void LinuxDebug::OutputDebugMessage(DEBUG_MESSAGE_SEVERITY Severity, const Char* Message, const char* Function, const char* File, int Line)
+{
+    auto msg = FormatDebugMessage(Severity, Message, Function, File, Line);
+    std::cerr << msg;
+}
+
+void DebugAssertionFailed(const Diligent::Char* Message, const char* Function, const char* File, int Line)
+{
+    LinuxDebug ::AssertionFailed(Message, Function, File, Line);
+}
+
+namespace Diligent
+{
+
+DebugMessageCallbackType DebugMessageCallback = LinuxDebug::OutputDebugMessage;
+
+}
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Linux/src/LinuxFileSystem.cpp b/app/src/main/java/libengine/DiligentLog/Platforms/Linux/src/LinuxFileSystem.cpp
new file mode 100644
index 00000000..1e0582a6
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Linux/src/LinuxFileSystem.cpp
@@ -0,0 +1,89 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#include <stdio.h>
+#include <unistd.h>
+#include <cstdio>
+
+#include "LinuxFileSystem.hpp"
+#include "Errors.hpp"
+#include "DebugUtilities.hpp"
+
+LinuxFile* LinuxFileSystem::OpenFile(const FileOpenAttribs& OpenAttribs)
+{
+    LinuxFile* pFile = nullptr;
+    try
+    {
+        pFile = new LinuxFile(OpenAttribs, LinuxFileSystem::GetSlashSymbol());
+    }
+    catch (const std::runtime_error& err)
+    {
+    }
+    return pFile;
+}
+
+
+bool LinuxFileSystem::FileExists(const Diligent::Char* strFilePath)
+{
+    FileOpenAttribs OpenAttribs;
+    OpenAttribs.strFilePath = strFilePath;
+    BasicFile   DummyFile(OpenAttribs, LinuxFileSystem::GetSlashSymbol());
+    const auto& Path   = DummyFile.GetPath(); // This is necessary to correct slashes
+    FILE*       pFile  = fopen(Path.c_str(), "r");
+    bool        Exists = (pFile != nullptr);
+    if (Exists)
+        fclose(pFile);
+    return Exists;
+}
+
+bool LinuxFileSystem::PathExists(const Diligent::Char* strPath)
+{
+    UNSUPPORTED("Not implemented");
+    return false;
+}
+
+bool LinuxFileSystem::CreateDirectory(const Diligent::Char* strPath)
+{
+    UNSUPPORTED("Not implemented");
+    return false;
+}
+
+void LinuxFileSystem::ClearDirectory(const Diligent::Char* strPath)
+{
+    UNSUPPORTED("Not implemented");
+}
+
+void LinuxFileSystem::DeleteFile(const Diligent::Char* strPath)
+{
+    remove(strPath);
+}
+
+std::vector<std::unique_ptr<FindFileData>> LinuxFileSystem::Search(const Diligent::Char* SearchPattern)
+{
+    UNSUPPORTED("Not implemented");
+    return std::vector<std::unique_ptr<FindFileData>>();
+}
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/UWP/CMakeLists.txt b/app/src/main/java/libengine/DiligentLog/Platforms/UWP/CMakeLists.txt
new file mode 100644
index 00000000..ce52bbb0
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/UWP/CMakeLists.txt
@@ -0,0 +1,46 @@
+cmake_minimum_required (VERSION 3.8)
+
+project(Diligent-UniversalWindowsPlatform CXX)
+
+set(INTERFACE 
+    interface/UWPDebug.hpp
+    interface/UWPFileSystem.hpp
+    interface/UWPDefinitions.h
+    interface/UWPNativeWindow.h
+    ../Win32/interface/Win32Atomics.hpp
+)
+
+set(SOURCE 
+    src/UWPDebug.cpp
+    src/UWPFileSystem.cpp
+    ../Win32/src/Win32Atomics.cpp
+)
+
+add_library(Diligent-UniversalWindowsPlatform ${SOURCE} ${INTERFACE} ${PLATFORM_INTERFACE_HEADERS})
+set_common_target_properties__LOG(Diligent-UniversalWindowsPlatform)
+
+target_include_directories(Diligent-UniversalWindowsPlatform 
+PUBLIC
+    ../Win32/interface
+    interface
+)
+
+target_link_libraries(Diligent-UniversalWindowsPlatform 
+PRIVATE
+    Diligent-BuildSettings__LOG 
+PUBLIC
+    Diligent-BasicPlatform_LOG
+    Diligent-PlatformInterface
+)
+
+source_group("src" FILES ${SOURCE})
+source_group("interface\\UWP" FILES ${INTERFACE})
+source_group("interface\\common" FILES ${PLATFORM_INTERFACE_HEADERS})
+
+set_target_properties(Diligent-UniversalWindowsPlatform PROPERTIES
+    FOLDER DiligentLog/Platforms
+)
+
+if(DILIGENT_INSTALL_CORE)
+    install_core_lib__LOG(Diligent-UniversalWindowsPlatform)
+endif()
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/UWP/interface/UWPDebug.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/UWP/interface/UWPDebug.hpp
new file mode 100644
index 00000000..31e77041
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/UWP/interface/UWPDebug.hpp
@@ -0,0 +1,43 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../Basic/interface/BasicPlatformDebug.hpp"
+
+struct WindowsStoreDebug : public BasicPlatformDebug
+{
+    static void AssertionFailed(const Diligent::Char* Message,
+                                const char*           Function, // type of __FUNCTION__
+                                const char*           File,     // type of __FILE__
+                                int                   Line);
+    static void OutputDebugMessage(Diligent::DEBUG_MESSAGE_SEVERITY Severity,
+                                   const Diligent::Char*            Message,
+                                   const char*                      Function, // type of __FUNCTION__
+                                   const char*                      File,     // type of __FILE__
+                                   int                              Line);
+};
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/UWP/interface/UWPDefinitions.h b/app/src/main/java/libengine/DiligentLog/Platforms/UWP/interface/UWPDefinitions.h
new file mode 100644
index 00000000..23b13165
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/UWP/interface/UWPDefinitions.h
@@ -0,0 +1,30 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../../../../MultiTouch/DiligentLog/Primitives/interface/CommonDefinitions.h"
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/UWP/interface/UWPFileSystem.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/UWP/interface/UWPFileSystem.hpp
new file mode 100644
index 00000000..c0139d81
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/UWP/interface/UWPFileSystem.hpp
@@ -0,0 +1,80 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include <memory>
+
+#include "../../Basic/interface/BasicFileSystem.hpp"
+#include "../../../../../MultiTouch/DiligentLog/Primitives/interface/DataBlob.h"
+
+// Do not include windows headers here as they will mess up CreateDirectory()
+// and DeleteFile() functions!
+//#define NOMINMAX
+//#include <wrl.h>
+
+class WindowsStoreFile : public BasicFile
+{
+public:
+    WindowsStoreFile(const FileOpenAttribs& OpenAttribs);
+    ~WindowsStoreFile();
+
+    void Read(Diligent::IDataBlob* pData);
+
+    bool Read(void* Data, size_t BufferSize);
+
+    void Write(Diligent::IDataBlob* pData);
+    bool Write(const void* Data, size_t BufferSize);
+
+    size_t GetSize();
+
+    size_t GetPos();
+
+    void SetPos(size_t Offset, FilePosOrigin Origin);
+
+private:
+    // We have to do such tricks, because we cannot #include <wrl.h>
+    // to avoid name clashes.
+    std::unique_ptr<class FileHandleWrapper> m_FileHandle;
+};
+
+struct WindowsStoreFileSystem : public BasicFileSystem
+{
+public:
+    static WindowsStoreFile* OpenFile(const FileOpenAttribs& OpenAttribs);
+
+    static inline Diligent::Char GetSlashSymbol() { return '\\'; }
+
+    static bool FileExists(const Diligent::Char* strFilePath);
+    static bool PathExists(const Diligent::Char* strPath);
+
+    static bool CreateDirectory(const Diligent::Char* strPath);
+    static void ClearDirectory(const Diligent::Char* strPath);
+    static void DeleteFile(const Diligent::Char* strPath);
+
+    static std::vector<std::unique_ptr<FindFileData>> Search(const Diligent::Char* SearchPattern);
+};
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/UWP/interface/UWPNativeWindow.h b/app/src/main/java/libengine/DiligentLog/Platforms/UWP/interface/UWPNativeWindow.h
new file mode 100644
index 00000000..8b878bde
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/UWP/interface/UWPNativeWindow.h
@@ -0,0 +1,49 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../../../../MultiTouch/DiligentLog/Primitives/interface/CommonDefinitions.h"
+
+DILIGENT_BEGIN_NAMESPACE(Diligent)
+
+struct UWPNativeWindow
+{
+    /// Windows::UI::Core::CoreWindow
+    void* pCoreWindow DEFAULT_INITIALIZER(nullptr);
+
+#if DILIGENT_CPP_INTERFACE
+    UWPNativeWindow() noexcept
+    {}
+
+    explicit UWPNativeWindow(void* _pCoreWindow) noexcept :
+        pCoreWindow{_pCoreWindow}
+    {}
+#endif
+};
+
+DILIGENT_END_NAMESPACE // namespace Diligent
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/UWP/src/UWPDebug.cpp b/app/src/main/java/libengine/DiligentLog/Platforms/UWP/src/UWPDebug.cpp
new file mode 100644
index 00000000..2641966e
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/UWP/src/UWPDebug.cpp
@@ -0,0 +1,89 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#include "UWPDebug.hpp"
+#include "FormatString.hpp"
+#include <csignal>
+
+#define NOMINMAX
+#include <windows.h>
+
+using namespace Diligent;
+
+void WindowsStoreDebug ::AssertionFailed(const Diligent::Char* Message, const char* Function, const char* File, int Line)
+{
+    auto AssertionFailedMessage = FormatAssertionFailedMessage(Message, Function, File, Line);
+    OutputDebugMessage(DEBUG_MESSAGE_SEVERITY_ERROR, AssertionFailedMessage.c_str(), nullptr, nullptr, 0);
+
+    __debugbreak();
+    //int nCode = MessageBoxA(NULL,
+    //                        FullMsg.c_str(),
+    //                        "Runtime assertion failed",
+    //                        MB_TASKMODAL|MB_ICONHAND|MB_ABORTRETRYIGNORE|MB_SETFOREGROUND);
+
+    //// Abort: abort the program
+    //if (nCode == IDABORT)
+    //{
+    //    // raise abort signal
+    //    raise(SIGABRT);
+
+    //    // We usually won't get here, but it's possible that
+    //    //  SIGABRT was ignored.  So exit the program anyway.
+    //    exit(3);
+    //}
+
+    //// Retry: call the debugger
+    //if (nCode == IDRETRY)
+    //{
+    //    DebugBreak();
+    //    /* return to user code */
+    //    return;
+    //}
+
+    //// Ignore: continue execution
+    //if (nCode == IDIGNORE)
+    //    return;
+};
+
+
+void WindowsStoreDebug::OutputDebugMessage(DEBUG_MESSAGE_SEVERITY Severity, const Char* Message, const char* Function, const char* File, int Line)
+{
+    auto msg = FormatDebugMessage(Severity, Message, Function, File, Line);
+    OutputDebugStringA(msg.c_str());
+}
+
+void DebugAssertionFailed(const Diligent::Char* Message, const char* Function, const char* File, int Line)
+{
+    WindowsStoreDebug ::AssertionFailed(Message, Function, File, Line);
+}
+
+namespace Diligent
+{
+
+DebugMessageCallbackType DebugMessageCallback = WindowsStoreDebug::OutputDebugMessage;
+
+}
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/UWP/src/UWPFileSystem.cpp b/app/src/main/java/libengine/DiligentLog/Platforms/UWP/src/UWPFileSystem.cpp
new file mode 100644
index 00000000..3460bca4
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/UWP/src/UWPFileSystem.cpp
@@ -0,0 +1,277 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#include "UWPFileSystem.hpp"
+#include "Errors.hpp"
+#include "../../Common/interface/StringTools.hpp"
+#include "DebugUtilities.hpp"
+
+
+// Windows headers define CreateDirectory and DeleteFile as macros.
+// So we need to do some tricks to avoid name mess.
+bool CreateDirectoryImpl(const Diligent::Char* strPath);
+
+bool WindowsStoreFileSystem::CreateDirectory(const Diligent::Char* strPath)
+{
+    return CreateDirectoryImpl(strPath);
+}
+
+void DeleteFileImpl(const Diligent::Char* strPath);
+
+void WindowsStoreFileSystem::DeleteFile(const Diligent::Char* strPath)
+{
+    return DeleteFileImpl(strPath);
+}
+
+
+#define NOMINMAX
+#include <wrl.h>
+
+using namespace Diligent;
+using namespace Microsoft::WRL;
+
+class FileHandleWrapper
+{
+public:
+    Wrappers::FileHandle FH;
+};
+
+WindowsStoreFile::WindowsStoreFile(const FileOpenAttribs& OpenAttribs) :
+    BasicFile(OpenAttribs, WindowsStoreFileSystem::GetSlashSymbol()),
+    m_FileHandle(new FileHandleWrapper)
+{
+    CREATEFILE2_EXTENDED_PARAMETERS extendedParams = {0};
+
+    extendedParams.dwSize               = sizeof(CREATEFILE2_EXTENDED_PARAMETERS);
+    extendedParams.dwFileAttributes     = FILE_ATTRIBUTE_NORMAL;
+    extendedParams.dwFileFlags          = FILE_FLAG_SEQUENTIAL_SCAN;
+    extendedParams.dwSecurityQosFlags   = SECURITY_ANONYMOUS;
+    extendedParams.lpSecurityAttributes = nullptr;
+    extendedParams.hTemplateFile        = nullptr;
+
+    auto  wstrPath           = Diligent::WidenString(m_OpenAttribs.strFilePath);
+    DWORD dwDesiredAccess    = 0;
+    DWORD dwShareMode        = 0;
+    DWORD dwCreateDeposition = 0;
+    switch (OpenAttribs.AccessMode)
+    {
+        case EFileAccessMode::Read:
+            dwDesiredAccess = GENERIC_READ;
+            // In Windows 8.1, the file cannot be opened if it is not shared!
+            dwShareMode        = FILE_SHARE_READ;
+            dwCreateDeposition = OPEN_EXISTING;
+            break;
+
+        case EFileAccessMode::Overwrite:
+            dwDesiredAccess    = GENERIC_WRITE;
+            dwShareMode        = 0;
+            dwCreateDeposition = CREATE_ALWAYS;
+            break;
+
+        case EFileAccessMode::Append:
+            dwDesiredAccess    = GENERIC_WRITE;
+            dwShareMode        = 0;
+            dwCreateDeposition = OPEN_ALWAYS;
+            break;
+
+        default:
+            UNEXPECTED("Unknown file access mode");
+            break;
+    }
+    m_FileHandle->FH.Attach(CreateFile2(
+        wstrPath.c_str(),
+        dwDesiredAccess,
+        dwShareMode,
+        dwCreateDeposition,
+        &extendedParams));
+
+    if (m_FileHandle->FH.Get() == INVALID_HANDLE_VALUE)
+    {
+        LOG_ERROR_AND_THROW("Failed to open file ", m_OpenAttribs.strFilePath);
+    }
+}
+
+WindowsStoreFile::~WindowsStoreFile()
+{
+}
+
+bool WindowsStoreFile::Read(void* Data, size_t BufferSize)
+{
+    DWORD BytesRead = 0;
+    if (!ReadFile(
+            m_FileHandle->FH.Get(),
+            Data,
+            static_cast<DWORD>(BufferSize),
+            &BytesRead,
+            nullptr))
+    {
+        return false;
+    }
+
+    return BytesRead == BufferSize;
+}
+
+size_t WindowsStoreFile::GetSize()
+{
+    FILE_STANDARD_INFO fileInfo = {0};
+    if (!GetFileInformationByHandleEx(
+            m_FileHandle->FH.Get(),
+            FileStandardInfo,
+            &fileInfo,
+            sizeof(fileInfo)))
+    {
+        LOG_ERROR_AND_THROW("Failed to get file info");
+    }
+
+    if (fileInfo.EndOfFile.HighPart != 0)
+    {
+        LOG_ERROR_AND_THROW("File is too large to be read");
+    }
+
+    return fileInfo.EndOfFile.LowPart;
+}
+
+void WindowsStoreFile::Read(Diligent::IDataBlob* pData)
+{
+    pData->Resize(GetSize());
+
+    if (!Read(pData->GetDataPtr(), pData->GetSize()))
+    {
+        LOG_ERROR_AND_THROW("Failed to read data from file");
+    }
+}
+
+void WindowsStoreFile::Write(Diligent::IDataBlob* pData)
+{
+    DWORD numBytesWritten;
+    if (!WriteFile(
+            m_FileHandle->FH.Get(),
+            pData->GetDataPtr(),
+            static_cast<DWORD>(pData->GetSize()),
+            &numBytesWritten,
+            nullptr) ||
+        numBytesWritten != pData->GetSize())
+    {
+        LOG_ERROR_AND_THROW("Failed to write data to file");
+    }
+}
+
+bool WindowsStoreFile::Write(const void* Data, size_t BufferSize)
+{
+    UNSUPPORTED("Not implemented");
+    return false;
+}
+
+size_t WindowsStoreFile::GetPos()
+{
+    UNSUPPORTED("Not implemented");
+    return 0;
+}
+
+void WindowsStoreFile::SetPos(size_t Offset, FilePosOrigin Origin)
+{
+    UNSUPPORTED("Not implemented");
+}
+
+
+WindowsStoreFile* WindowsStoreFileSystem::OpenFile(const FileOpenAttribs& OpenAttribs)
+{
+    WindowsStoreFile* pFile = nullptr;
+    try
+    {
+        pFile = new WindowsStoreFile(OpenAttribs);
+    }
+    catch (const std::runtime_error& /*err*/)
+    {
+    }
+
+    return pFile;
+}
+
+bool WindowsStoreFileSystem::FileExists(const Diligent::Char* strFilePath)
+{
+    FileOpenAttribs OpenAttribs;
+    OpenAttribs.AccessMode  = EFileAccessMode::Read;
+    OpenAttribs.strFilePath = strFilePath;
+    BasicFile   DummyFile(OpenAttribs, WindowsStoreFileSystem::GetSlashSymbol());
+    const auto& Path = DummyFile.GetPath();
+
+    CREATEFILE2_EXTENDED_PARAMETERS extendedParams = {0};
+
+    extendedParams.dwSize               = sizeof(CREATEFILE2_EXTENDED_PARAMETERS);
+    extendedParams.dwFileAttributes     = FILE_ATTRIBUTE_NORMAL;
+    extendedParams.dwFileFlags          = FILE_FLAG_SEQUENTIAL_SCAN;
+    extendedParams.dwSecurityQosFlags   = SECURITY_ANONYMOUS;
+    extendedParams.lpSecurityAttributes = nullptr;
+    extendedParams.hTemplateFile        = nullptr;
+
+    auto wstrPath = Diligent::WidenString(Path);
+
+    auto Handle = CreateFile2(
+        wstrPath.c_str(),
+        GENERIC_READ,
+        FILE_SHARE_READ,
+        OPEN_EXISTING,
+        &extendedParams);
+    bool Exists = false;
+    if (Handle != INVALID_HANDLE_VALUE)
+    {
+        CloseHandle(Handle);
+        Exists = true;
+    }
+    return Exists;
+}
+
+
+bool WindowsStoreFileSystem::PathExists(const Diligent::Char* strPath)
+{
+    UNSUPPORTED("Not implemented");
+    return false;
+}
+
+void WindowsStoreFileSystem::ClearDirectory(const Diligent::Char* strPath)
+{
+    UNSUPPORTED("Not implemented");
+}
+
+
+bool CreateDirectoryImpl(const Diligent::Char* strPath)
+{
+    UNSUPPORTED("Not implemented");
+    return false;
+}
+
+void DeleteFileImpl(const Diligent::Char* strPath)
+{
+    UNSUPPORTED("Not implemented");
+}
+
+std::vector<std::unique_ptr<FindFileData>> WindowsStoreFileSystem::Search(const Diligent::Char* SearchPattern)
+{
+    UNSUPPORTED("Not implemented");
+    return std::vector<std::unique_ptr<FindFileData>>();
+}
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Win32/CMakeLists.txt b/app/src/main/java/libengine/DiligentLog/Platforms/Win32/CMakeLists.txt
new file mode 100644
index 00000000..fd213a65
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Win32/CMakeLists.txt
@@ -0,0 +1,47 @@
+cmake_minimum_required (VERSION 3.3)
+
+project(WindowsPlatform CXX)
+
+set(INTERFACE
+    interface/Win32Atomics.hpp
+    interface/Win32Debug.hpp
+    interface/Win32FileSystem.hpp
+    interface/Win32PlatformDefinitions.h
+    interface/Win32PlatformMisc.hpp
+    interface/Win32NativeWindow.h
+)
+
+set(SOURCE 
+    src/Win32Atomics.cpp
+    src/Win32Debug.cpp
+    src/Win32FileSystem.cpp
+)
+
+add_library(Diligent-Win32Platform ${SOURCE} ${INTERFACE} ${PLATFORM_INTERFACE_HEADERS})
+set_common_target_properties__LOG(Diligent-Win32Platform)
+
+target_include_directories(Diligent-Win32Platform 
+PUBLIC
+    interface
+)
+
+target_link_libraries(Diligent-Win32Platform 
+PUBLIC
+    Diligent-BasicPlatform_LOG
+    Diligent-PlatformInterface
+PRIVATE
+    Diligent-BuildSettings
+    Shlwapi.lib
+)
+
+source_group("src" FILES ${SOURCE})
+source_group("interface\\win32" FILES ${INTERFACE})
+source_group("interface\\common" FILES ${PLATFORM_INTERFACE_HEADERS})
+
+set_target_properties(Diligent-Win32Platform PROPERTIES
+    FOLDER DiligentLog/Platforms
+)
+
+if(DILIGENT_INSTALL_CORE)
+    install_core_lib__LOG(Diligent-Win32Platform)
+endif()
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32Atomics.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32Atomics.hpp
new file mode 100644
index 00000000..987fef7f
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32Atomics.hpp
@@ -0,0 +1,55 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+struct WindowsAtomics
+{
+    // Use windows-specific atomics. Standard atomic eventually call
+    // the same functions, but introduce significant overhead
+    using Long        = long;
+    using AtomicLong  = volatile long;
+    using Int64       = long long;
+    using AtomicInt64 = volatile long long;
+
+    // The function returns the resulting INCREMENTED value.
+    static Long  AtomicIncrement(AtomicLong& Val);
+    static Int64 AtomicIncrement(AtomicInt64& Val);
+
+    // The function returns the resulting DECREMENTED value.
+    static Long  AtomicDecrement(AtomicLong& Val);
+    static Int64 AtomicDecrement(AtomicInt64& Val);
+
+    // The function compares the Destination value with the Comparand value. If the Destination value is equal
+    // to the Comparand value, the Exchange value is stored in the address specified by Destination.
+    // Otherwise, no operation is performed.
+    // The function returns the initial value of the Destination parameter
+    static Long AtomicCompareExchange(AtomicLong& Destination, Long Exchange, Long Comparand);
+
+    static Long  AtomicAdd(AtomicLong& Destination, Long Val);
+    static Int64 AtomicAdd(AtomicInt64& Destination, Int64 Val);
+};
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32Debug.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32Debug.hpp
new file mode 100644
index 00000000..47fa2c8b
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32Debug.hpp
@@ -0,0 +1,43 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../Basic/interface/BasicPlatformDebug.hpp"
+
+struct WindowsDebug : public BasicPlatformDebug
+{
+    static void AssertionFailed(const Diligent::Char* Message,
+                                const char*           Function, // type of __FUNCTION__
+                                const char*           File,     // type of __FILE__
+                                int                   Line);
+    static void OutputDebugMessage(Diligent::DEBUG_MESSAGE_SEVERITY Severity,
+                                   const Diligent::Char*            Message,
+                                   const char*                      Function, // type of __FUNCTION__
+                                   const char*                      File,     // type of __FILE__
+                                   int                              Line);
+};
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32FileSystem.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32FileSystem.hpp
new file mode 100644
index 00000000..8b74ab8a
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32FileSystem.hpp
@@ -0,0 +1,136 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include <memory>
+#include "../../Basic/interface/BasicFileSystem.hpp"
+#include "../../Basic/interface/StandardFile.hpp"
+#include "../../../../../MultiTouch/DiligentLog/Primitives/interface/FlagEnum.h"
+
+class WindowsFile : public StandardFile
+{
+public:
+    WindowsFile(const FileOpenAttribs& OpenAttribs);
+};
+
+enum FILE_DIALOG_FLAGS : Diligent::Uint32
+{
+    FILE_DIALOG_FLAG_NONE = 0x000,
+
+    /// Prevents the system from adding a link to the selected file in the file system
+    /// directory that contains the user's most recently used documents.
+    FILE_DIALOG_FLAG_DONT_ADD_TO_RECENT = 0x001,
+
+    /// Only existing files can be opened
+    FILE_DIALOG_FLAG_FILE_MUST_EXIST = 0x002,
+
+    /// Restores the current directory to its original value if the user changed the
+    /// directory while searching for files.
+    FILE_DIALOG_FLAG_NO_CHANGE_DIR = 0x004,
+
+    /// Causes the Save As dialog box to show a message box if the selected file already exists.
+    FILE_DIALOG_FLAG_OVERWRITE_PROMPT = 0x008
+};
+DEFINE_FLAG_ENUM_OPERATORS(FILE_DIALOG_FLAGS);
+
+enum FILE_DIALOG_TYPE : Diligent::Uint32
+{
+    FILE_DIALOG_TYPE_OPEN,
+    FILE_DIALOG_TYPE_SAVE
+};
+
+struct FileDialogAttribs
+{
+    FILE_DIALOG_TYPE  Type  = FILE_DIALOG_TYPE_OPEN;
+    FILE_DIALOG_FLAGS Flags = FILE_DIALOG_FLAG_NONE;
+
+    const char* Title  = nullptr;
+    const char* Filter = nullptr;
+
+    FileDialogAttribs() noexcept {}
+
+    explicit FileDialogAttribs(FILE_DIALOG_TYPE _Type) noexcept :
+        Type{_Type}
+    {
+        switch (Type)
+        {
+            case FILE_DIALOG_TYPE_OPEN:
+                Flags = FILE_DIALOG_FLAG_DONT_ADD_TO_RECENT | FILE_DIALOG_FLAG_FILE_MUST_EXIST | FILE_DIALOG_FLAG_NO_CHANGE_DIR;
+                break;
+
+            case FILE_DIALOG_TYPE_SAVE:
+                Flags = FILE_DIALOG_FLAG_DONT_ADD_TO_RECENT | FILE_DIALOG_FLAG_OVERWRITE_PROMPT | FILE_DIALOG_FLAG_NO_CHANGE_DIR;
+                break;
+        }
+    }
+};
+
+struct WindowsFileSystem : public BasicFileSystem
+{
+public:
+    static WindowsFile* OpenFile(const FileOpenAttribs& OpenAttribs);
+
+    static inline Diligent::Char GetSlashSymbol() { return '\\'; }
+
+    static bool FileExists(const Diligent::Char* strFilePath);
+    static bool PathExists(const Diligent::Char* strPath);
+
+    static bool CreateDirectory(const Diligent::Char* strPath);
+    static void ClearDirectory(const Diligent::Char* strPath, bool Recursive = false);
+    static void DeleteFile(const Diligent::Char* strPath);
+    static void DeleteDirectory(const Diligent::Char* strPath);
+    static bool IsDirectory(const Diligent::Char* strPath);
+
+    static std::vector<std::unique_ptr<FindFileData>> Search(const Diligent::Char* SearchPattern);
+
+    static std::string FileDialog(const FileDialogAttribs& DialogAttribs);
+
+    static std::string GetCurrentDirectory();
+
+
+    /// Returns a relative path from one file or folder to another.
+
+    /// \param [in]  strPathFrom     - Path that defines the start of the relative path.
+    ///                                If this parameter is null, current directory will be used.
+    /// \param [in]  IsFromDirectory - Indicates if strPathFrom is a directory.
+    ///                                Ignored if strPathFrom is null (in which case current directory
+    ///                                is used).
+    /// \param [in]  strPathTo       - Path that defines the endpoint of the relative path.
+    ///                                This parameter must not be null.
+    /// \param [in]  IsToDirectory   - Indicates if strPathTo is a directory.
+    /// \param [out] RelativePath    - Relative path from strPathFrom to strPathTo.
+    ///                                If no relative path exists, strPathFrom will be returned.
+    ///
+    /// \return                        true if the relative path exists (i.e. strPathFrom and strPathTo
+    ///                                have a common prefix), and false otherwise.
+    static bool GetRelativePath(const Diligent::Char* strPathFrom,
+                                bool                  IsFromDirectory,
+                                const Diligent::Char* strPathTo,
+                                bool                  IsToDirectory,
+                                std::string&          RelativePath);
+};
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32NativeWindow.h b/app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32NativeWindow.h
new file mode 100644
index 00000000..a079101d
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32NativeWindow.h
@@ -0,0 +1,48 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence),
+ *  contract, or otherwise, unless required by applicable law (such as deliberate
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental,
+ *  or consequential damages of any character arising as a result of this License or
+ *  out of the use or inability to use the software (including but not limited to damages
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and
+ *  all other commercial damages or losses), even if such Contributor has been advised
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../../../../MultiTouch/DiligentLog/Primitives/interface/CommonDefinitions.h"
+
+DILIGENT_BEGIN_NAMESPACE(Diligent)
+
+struct Win32NativeWindow
+{
+    void* hWnd DEFAULT_INITIALIZER(nullptr);
+
+#if DILIGENT_CPP_INTERFACE
+    Win32NativeWindow() noexcept
+    {}
+
+    explicit Win32NativeWindow(void* _hWnd) noexcept :
+        hWnd{_hWnd}
+    {}
+#endif
+};
+
+DILIGENT_END_NAMESPACE // namespace Diligent
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32PlatformDefinitions.h b/app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32PlatformDefinitions.h
new file mode 100644
index 00000000..23b13165
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32PlatformDefinitions.h
@@ -0,0 +1,30 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../../../../MultiTouch/DiligentLog/Primitives/interface/CommonDefinitions.h"
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32PlatformMisc.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32PlatformMisc.hpp
new file mode 100644
index 00000000..79941f7a
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Win32/interface/Win32PlatformMisc.hpp
@@ -0,0 +1,141 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "../../Basic/interface/BasicPlatformMisc.hpp"
+#include "../../../../../MultiTouch/DiligentLog/Platforms/Basic/interface/DebugUtilities.hpp"
+
+#include <intrin.h>
+
+struct WindowsMisc : public BasicPlatformMisc
+{
+    inline static Diligent::Uint32 GetMSB(Diligent::Uint32 Val)
+    {
+        if (Val == 0) return 32;
+
+        unsigned long MSB = 32;
+        _BitScanReverse(&MSB, Val);
+        VERIFY_EXPR(MSB == BasicPlatformMisc::GetMSB(Val));
+
+        return MSB;
+    }
+
+    inline static Diligent::Uint32 GetMSB(Diligent::Uint64 Val)
+    {
+        if (Val == 0) return 64;
+
+        unsigned long MSB = 64;
+#if _WIN64
+        _BitScanReverse64(&MSB, Val);
+#else
+        Diligent::Uint32 high = static_cast<Diligent::Uint32>((Val >> 32) & 0xFFFFFFFF);
+        if (high != 0)
+        {
+            MSB = 32 + GetMSB(high);
+        }
+        else
+        {
+            Diligent::Uint32 low = static_cast<Diligent::Uint32>(Val & 0xFFFFFFFF);
+            VERIFY_EXPR(low != 0);
+            MSB = GetMSB(low);
+        }
+#endif
+        VERIFY_EXPR(MSB == BasicPlatformMisc::GetMSB(Val));
+
+        return MSB;
+    }
+
+    inline static Diligent::Uint32 GetLSB(Diligent::Uint32 Val)
+    {
+        if (Val == 0) return 32;
+
+        unsigned long LSB = 32;
+        _BitScanForward(&LSB, Val);
+        VERIFY_EXPR(LSB == BasicPlatformMisc::GetLSB(Val));
+
+        return LSB;
+    }
+
+    inline static Diligent::Uint32 GetLSB(Diligent::Uint64 Val)
+    {
+        if (Val == 0) return 64;
+
+        unsigned long LSB = 64;
+#if _WIN64
+        _BitScanForward64(&LSB, Val);
+#else
+        Diligent::Uint32 low = static_cast<Diligent::Uint32>(Val & 0xFFFFFFFF);
+        if (low != 0)
+        {
+            LSB = GetLSB(low);
+        }
+        else
+        {
+            Diligent::Uint32 high = static_cast<Diligent::Uint32>((Val >> 32) & 0xFFFFFFFF);
+            VERIFY_EXPR(high != 0);
+            LSB = 32 + GetLSB(high);
+        }
+#endif
+
+        VERIFY_EXPR(LSB == BasicPlatformMisc::GetLSB(Val));
+        return LSB;
+    }
+
+    inline static Diligent::Uint32 CountOneBits(Diligent::Uint32 Val)
+    {
+#if defined _M_ARM || defined _M_ARM64
+        // MSVC _CountOneBits intrinsics undefined for ARM64
+        // Cast bits to 8x8 datatype and use VCNT on result
+        const uint8x8_t Vsum = vcnt_u8(vcreate_u8(static_cast<uint64_t>(Val)));
+        // Pairwise sums: 8x8 -> 16x4 -> 32x2
+        auto Bits = static_cast<Diligent::Uint32>(vget_lane_u32(vpaddl_u16(vpaddl_u8(Vsum)), 0));
+#else
+        auto Bits = __popcnt(Val);
+#endif
+        VERIFY_EXPR(Bits == BasicPlatformMisc::CountOneBits(Val));
+        return Bits;
+    }
+
+    inline static Diligent::Uint32 CountOneBits(Diligent::Uint64 Val)
+    {
+#if defined _M_ARM || defined _M_ARM64
+        // Cast bits to 8x8 datatype and use VCNT on result
+        const uint8x8_t Vsum = vcnt_u8(vcreate_u8(Val));
+        // Pairwise sums: 8x8 -> 16x4 -> 32x2 -> 64x1
+        auto Bits = static_cast<Diligent::Uint32>(vget_lane_u64(vpaddl_u32(vpaddl_u16(vpaddl_u8(Vsum))), 0));
+#elif _WIN64
+        auto Bits = __popcnt64(Val);
+#else
+        auto Bits =
+            CountOneBits(static_cast<Diligent::Uint32>((Val >> 0) & 0xFFFFFFFF)) +
+            CountOneBits(static_cast<Diligent::Uint32>((Val >> 32) & 0xFFFFFFFF));
+#endif
+        VERIFY_EXPR(Bits == BasicPlatformMisc::CountOneBits(Val));
+        return static_cast<Diligent::Uint32>(Bits);
+    }
+};
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Win32/src/Win32Atomics.cpp b/app/src/main/java/libengine/DiligentLog/Platforms/Win32/src/Win32Atomics.cpp
new file mode 100644
index 00000000..fcf3c903
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Win32/src/Win32Atomics.cpp
@@ -0,0 +1,67 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#include "Win32Atomics.hpp"
+
+#include <Windows.h>
+
+// The function returns the resulting INCREMENTED value.
+WindowsAtomics::Long WindowsAtomics::AtomicIncrement(AtomicLong& Val)
+{
+    return InterlockedIncrement(&Val);
+}
+
+WindowsAtomics::Int64 WindowsAtomics::AtomicIncrement(AtomicInt64& Val)
+{
+    return InterlockedIncrement64(&Val);
+}
+
+// The function returns the resulting DECREMENTED value.
+WindowsAtomics::Long WindowsAtomics::AtomicDecrement(AtomicLong& Val)
+{
+    return InterlockedDecrement(&Val);
+}
+
+WindowsAtomics::Int64 WindowsAtomics::AtomicDecrement(AtomicInt64& Val)
+{
+    return InterlockedDecrement64(&Val);
+}
+
+WindowsAtomics::Long WindowsAtomics::AtomicCompareExchange(AtomicLong& Destination, Long Exchange, Long Comparand)
+{
+    return InterlockedCompareExchange(&Destination, Exchange, Comparand);
+}
+
+WindowsAtomics::Long WindowsAtomics::AtomicAdd(AtomicLong& Destination, Long Val)
+{
+    return InterlockedAdd(&Destination, Val);
+}
+
+WindowsAtomics::Int64 WindowsAtomics::AtomicAdd(AtomicInt64& Destination, Int64 Val)
+{
+    return InterlockedAdd64(&Destination, Val);
+}
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Win32/src/Win32Debug.cpp b/app/src/main/java/libengine/DiligentLog/Platforms/Win32/src/Win32Debug.cpp
new file mode 100644
index 00000000..7dfad268
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Win32/src/Win32Debug.cpp
@@ -0,0 +1,91 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#include "Win32Debug.hpp"
+#include "FormatString.hpp"
+#include <csignal>
+#include <iostream>
+#include <Windows.h>
+
+using namespace Diligent;
+
+void WindowsDebug::AssertionFailed(const Diligent::Char* Message, const char* Function, const char* File, int Line)
+{
+    auto AssertionFailedMessage = FormatAssertionFailedMessage(Message, Function, File, Line);
+    OutputDebugMessage(DEBUG_MESSAGE_SEVERITY_ERROR, AssertionFailedMessage.c_str(), nullptr, nullptr, 0);
+
+    int nCode = MessageBoxA(NULL,
+                            AssertionFailedMessage.c_str(),
+                            "Runtime assertion failed",
+                            MB_TASKMODAL | MB_ICONHAND | MB_ABORTRETRYIGNORE | MB_SETFOREGROUND);
+
+    // Abort: abort the program
+    if (nCode == IDABORT)
+    {
+        // raise abort signal
+        raise(SIGABRT);
+
+        // We usually won't get here, but it's possible that
+        //  SIGABRT was ignored.  So exit the program anyway.
+        exit(3);
+    }
+
+    // Retry: call the debugger
+    if (nCode == IDRETRY)
+    {
+        DebugBreak();
+        // return to user code
+        return;
+    }
+
+    // Ignore: continue execution
+    if (nCode == IDIGNORE)
+        return;
+};
+
+void WindowsDebug::OutputDebugMessage(DEBUG_MESSAGE_SEVERITY Severity, const Char* Message, const char* Function, const char* File, int Line)
+{
+    auto msg = FormatDebugMessage(Severity, Message, Function, File, Line);
+    OutputDebugStringA(msg.c_str());
+
+    if (Severity == DEBUG_MESSAGE_SEVERITY_ERROR || Severity == DEBUG_MESSAGE_SEVERITY_FATAL_ERROR)
+        std::cerr << msg;
+    else
+        std::cout << msg;
+}
+
+void DebugAssertionFailed(const Diligent::Char* Message, const char* Function, const char* File, int Line)
+{
+    WindowsDebug::AssertionFailed(Message, Function, File, Line);
+}
+
+namespace Diligent
+{
+
+DebugMessageCallbackType DebugMessageCallback = WindowsDebug::OutputDebugMessage;
+
+}
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/Win32/src/Win32FileSystem.cpp b/app/src/main/java/libengine/DiligentLog/Platforms/Win32/src/Win32FileSystem.cpp
new file mode 100644
index 00000000..aa60fe44
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/Win32/src/Win32FileSystem.cpp
@@ -0,0 +1,392 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#include "Win32FileSystem.hpp"
+#include "Errors.hpp"
+#include "../../Common/interface/StringTools.hpp"
+
+// We can't use namespace Diligent before #including <Windows.h> because Diligent::INTERFACE_ID will confilct with windows InterfaceID
+//using namespace Diligent;
+
+// Windows.h defines CreateDirectory and DeleteFile as macros.
+// So we need to do some tricks to avoid name mess.
+static bool CreateDirectoryImpl(const Diligent::Char* strPath);
+
+bool WindowsFileSystem::CreateDirectory(const Diligent::Char* strPath)
+{
+    return CreateDirectoryImpl(strPath);
+}
+
+static void DeleteFileImpl(const Diligent::Char* strPath);
+
+void WindowsFileSystem::DeleteFile(const Diligent::Char* strPath)
+{
+    DeleteFileImpl(strPath);
+}
+
+static std::string GetCurrentDirectoryImpl();
+
+std::string WindowsFileSystem::GetCurrentDirectory()
+{
+    return GetCurrentDirectoryImpl();
+}
+
+#include <Windows.h>
+#include <Shlwapi.h>
+#pragma comment(lib, "Shlwapi.lib")
+
+using namespace Diligent;
+
+static std::vector<wchar_t> UTF8ToUTF16(LPCSTR lpUTF8)
+{
+    // When last parameter is 0, the function returns the required buffer size, in characters,
+    // including any terminating null character.
+    auto                 nChars = MultiByteToWideChar(CP_UTF8, 0, lpUTF8, -1, NULL, 0);
+    std::vector<wchar_t> wstr(nChars);
+    MultiByteToWideChar(CP_UTF8, 0, lpUTF8, -1, wstr.data(), nChars);
+    return wstr;
+}
+
+WindowsFile::WindowsFile(const FileOpenAttribs& OpenAttribs) :
+    StandardFile(OpenAttribs, WindowsFileSystem::GetSlashSymbol())
+{
+    VERIFY_EXPR(m_pFile == nullptr);
+    auto OpenModeStr = WidenString(GetOpenModeStr());
+
+    for (;;)
+    {
+        auto    UTF16FilePath = UTF8ToUTF16(m_OpenAttribs.strFilePath);
+        errno_t err           = _wfopen_s(&m_pFile, UTF16FilePath.data(), OpenModeStr.c_str());
+        if (err == 0)
+        {
+            break;
+        }
+        else if (err == ENFILE || // Too many files open in system
+                 err == EMFILE)   // Too many open files
+        {
+            // No more file descriptors are available: we have to wait
+            //g_SystemMetricsStream << "Failed to open file " << FileName;
+            //g_SystemMetricsStream << "\nWaiting 50 ms...\n";
+            Sleep(50);
+            continue;
+        }
+        else
+        {
+            char errstr[128];
+            strerror_s(errstr, _countof(errstr), err);
+            LOG_ERROR_AND_THROW("Failed to open file ", m_OpenAttribs.strFilePath,
+                                "\nThe following error occurred: ", errstr);
+        }
+    }
+}
+
+WindowsFile* WindowsFileSystem::OpenFile(const FileOpenAttribs& OpenAttribs)
+{
+    WindowsFile* pFile = nullptr;
+    try
+    {
+        pFile = new WindowsFile(OpenAttribs);
+    }
+    catch (const std::runtime_error& /*err*/)
+    {
+    }
+
+    return pFile;
+}
+
+bool WindowsFileSystem::FileExists(const Char* strFilePath)
+{
+    if (!PathExists(strFilePath))
+        return false;
+
+    auto FileAttribs = GetFileAttributesA(strFilePath);
+    if (FileAttribs == INVALID_FILE_ATTRIBUTES)
+        return false;
+
+    return (FileAttribs & FILE_ATTRIBUTE_DIRECTORY) == 0;
+}
+
+static bool CreateDirectoryImpl(const Char* strPath)
+{
+    // Test all parent directories
+    std::string            DirectoryPath = strPath;
+    std::string::size_type SlashPos      = std::wstring::npos;
+    const auto             SlashSym      = WindowsFileSystem::GetSlashSymbol();
+    WindowsFileSystem::CorrectSlashes(DirectoryPath, SlashSym);
+
+    do
+    {
+        SlashPos = DirectoryPath.find(SlashSym, (SlashPos != std::string::npos) ? SlashPos + 1 : 0);
+
+        std::string ParentDir = (SlashPos != std::wstring::npos) ? DirectoryPath.substr(0, SlashPos) : DirectoryPath;
+        if (!WindowsFileSystem::PathExists(ParentDir.c_str()))
+        {
+            // If there is no directory, create it
+            if (!::CreateDirectoryA(ParentDir.c_str(), NULL))
+                return false;
+        }
+    } while (SlashPos != std::string::npos);
+
+    return true;
+}
+
+void WindowsFileSystem::ClearDirectory(const Char* strPath, bool Recursive)
+{
+    WIN32_FIND_DATAA ffd;
+    HANDLE           hFind = INVALID_HANDLE_VALUE;
+
+    // Find the first file in the directory.
+    std::string Directory(strPath);
+    if (Directory.length() > 0 && Directory.back() != GetSlashSymbol())
+        Directory.push_back(GetSlashSymbol());
+
+    auto SearchPattern = Directory + "*";
+    hFind              = FindFirstFileA(SearchPattern.c_str(), &ffd);
+
+    if (INVALID_HANDLE_VALUE == hFind)
+    {
+        LOG_ERROR_MESSAGE("FindFirstFile failed with error code ", GetLastError());
+        return;
+    }
+
+    // List all the files in the directory
+    do
+    {
+        if (ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
+        {
+            if (Recursive)
+            {
+                // Skip '.' and anything that begins with '..'
+                if (!((ffd.cFileName[0] == '.' && ffd.cFileName[1] == 0) || (ffd.cFileName[0] == '.' && ffd.cFileName[1] == '.')))
+                {
+                    auto SubDirName = Directory + ffd.cFileName;
+                    ClearDirectory(SubDirName.c_str(), Recursive);
+
+                    if (RemoveDirectoryA(SubDirName.c_str()) == FALSE)
+                    {
+                        LOG_ERROR_MESSAGE("Failed to remove directory '", SubDirName, "'. Error code: ", GetLastError());
+                    }
+                }
+            }
+        }
+        else
+        {
+            auto FileName = Directory + ffd.cFileName;
+            DeleteFileImpl(FileName.c_str());
+        }
+    } while (FindNextFileA(hFind, &ffd) != 0);
+
+    FindClose(hFind);
+}
+
+
+static void DeleteFileImpl(const Char* strPath)
+{
+    if (SetFileAttributesA(strPath, FILE_ATTRIBUTE_NORMAL) == FALSE)
+    {
+        LOG_WARNING_MESSAGE("Failed to set FILE_ATTRIBUTE_NORMAL for file '", strPath, "'. Error code: ", GetLastError());
+    }
+
+    if (DeleteFileA(strPath) == FALSE)
+    {
+        LOG_ERROR_MESSAGE("Failed to delete file '", strPath, "'. Error code: ", GetLastError());
+    }
+}
+
+void WindowsFileSystem::DeleteDirectory(const Diligent::Char* strPath)
+{
+    ClearDirectory(strPath, true);
+
+    if (RemoveDirectoryA(strPath) == FALSE)
+    {
+        LOG_ERROR_MESSAGE("Failed to remove directory '", strPath, "'. Error code: ", GetLastError());
+    }
+}
+
+
+bool WindowsFileSystem::PathExists(const Char* strPath)
+{
+    return PathFileExistsA(strPath) != FALSE;
+}
+
+struct WndFindFileData : public FindFileData
+{
+    virtual const Char* Name() const override { return ffd.cFileName; }
+
+    virtual bool IsDirectory() const override { return (ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0; }
+
+    WIN32_FIND_DATAA ffd;
+
+    WndFindFileData(const WIN32_FIND_DATAA& _ffd) :
+        ffd{_ffd} {}
+};
+
+std::vector<std::unique_ptr<FindFileData>> WindowsFileSystem::Search(const Char* SearchPattern)
+{
+    std::vector<std::unique_ptr<FindFileData>> SearchRes;
+
+    WIN32_FIND_DATAA ffd;
+    // Find the first file in the directory.
+    auto hFind = FindFirstFileA(SearchPattern, &ffd);
+
+    if (INVALID_HANDLE_VALUE == hFind)
+    {
+        return SearchRes;
+    }
+
+    // List all the files in the directory
+    do
+    {
+        SearchRes.emplace_back(new WndFindFileData(ffd));
+    } while (FindNextFileA(hFind, &ffd) != 0);
+
+    auto dwError = GetLastError();
+    if (dwError != ERROR_NO_MORE_FILES)
+    {
+        //ErrorHandler(TEXT("FindFirstFile"));
+    }
+
+    FindClose(hFind);
+
+    return SearchRes;
+}
+
+static DWORD FileDialogFlagsToOFNFlags(FILE_DIALOG_FLAGS FileDialogFlags)
+{
+    DWORD OFNFlags = 0;
+    while (FileDialogFlags != FILE_DIALOG_FLAG_NONE)
+    {
+        auto Flag = FileDialogFlags & ~static_cast<FILE_DIALOG_FLAGS>(static_cast<Uint32>(FileDialogFlags) - 1);
+        switch (Flag)
+        {
+            case FILE_DIALOG_FLAG_DONT_ADD_TO_RECENT:
+                OFNFlags |= OFN_DONTADDTORECENT;
+                break;
+
+            case FILE_DIALOG_FLAG_FILE_MUST_EXIST:
+                OFNFlags |= OFN_FILEMUSTEXIST;
+                break;
+
+            case FILE_DIALOG_FLAG_NO_CHANGE_DIR:
+                OFNFlags |= OFN_NOCHANGEDIR;
+                break;
+
+            case FILE_DIALOG_FLAG_OVERWRITE_PROMPT:
+                OFNFlags |= OFN_OVERWRITEPROMPT;
+                break;
+
+            default:
+                UNEXPECTED("Unknown file dialog flag (", Flag, ")");
+        }
+        FileDialogFlags &= ~Flag;
+    }
+    return OFNFlags;
+}
+
+std::string WindowsFileSystem::FileDialog(const FileDialogAttribs& DialogAttribs)
+{
+    OPENFILENAMEA ofn = {};
+
+    char buffer[1024] = {};
+    ofn.lStructSize   = sizeof(ofn);
+    ofn.lpstrFilter   = DialogAttribs.Filter;
+    ofn.lpstrFile     = buffer;
+    ofn.nMaxFile      = _countof(buffer);
+    ofn.lpstrTitle    = DialogAttribs.Title;
+    ofn.Flags         = FileDialogFlagsToOFNFlags(DialogAttribs.Flags);
+
+    std::string FileName;
+    if (DialogAttribs.Type == FILE_DIALOG_TYPE_OPEN ? GetOpenFileNameA(&ofn) : GetSaveFileNameA(&ofn))
+    {
+        FileName = buffer;
+    }
+    return FileName;
+}
+
+bool WindowsFileSystem::IsDirectory(const Diligent::Char* strPath)
+{
+    if (!PathExists(strPath))
+    {
+        LOG_WARNING_MESSAGE("Path '", strPath, "' does not exist. Use PathExists function to check if path exists.");
+        return false;
+    }
+
+    return (GetFileAttributesA(strPath) & FILE_ATTRIBUTE_DIRECTORY) != 0;
+}
+
+std::string GetCurrentDirectoryImpl()
+{
+    std::string CurrDir;
+
+    // If the function succeeds, the return value specifies the number of characters that
+    // are written to the buffer, NOT including the terminating null character.
+    // HOWEVER, if the buffer that is pointed to by lpBuffer is not large enough,
+    // the return value specifies the required size of the buffer, in characters,
+    // INCLUDING the null-terminating character.
+    // https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getcurrentdirectory
+    auto BufferSize = GetCurrentDirectoryA(0, nullptr);
+
+    if (BufferSize > 1)
+    {
+        // Note that std::string::resize(n) resizes the string to a length of n characters.
+        CurrDir.resize(BufferSize - 1);
+
+        // BufferSize must include room for a terminating null character.
+        auto NumChars = GetCurrentDirectoryA(BufferSize, &CurrDir[0]);
+        VERIFY_EXPR(CurrDir.length() == NumChars);
+    }
+    return CurrDir;
+}
+
+bool WindowsFileSystem::GetRelativePath(const Diligent::Char* strPathFrom,
+                                        bool                  IsFromDirectory,
+                                        const Diligent::Char* strPathTo,
+                                        bool                  IsToDirectory,
+                                        std::string&          RelativePath)
+{
+    VERIFY_EXPR(strPathTo != nullptr);
+
+    // https://docs.microsoft.com/en-us/windows/win32/api/shlwapi/nf-shlwapi-pathrelativepathtoa
+    char strRelativePath[MAX_PATH];
+
+    auto Res = PathRelativePathToA(strRelativePath,
+                                   strPathFrom != nullptr ? strPathFrom : GetCurrentDirectoryImpl().c_str(),
+                                   (strPathFrom == nullptr || IsFromDirectory) ? FILE_ATTRIBUTE_DIRECTORY : FILE_ATTRIBUTE_NORMAL,
+                                   strPathTo,
+                                   IsToDirectory ? FILE_ATTRIBUTE_DIRECTORY : FILE_ATTRIBUTE_NORMAL);
+
+    if (Res != FALSE)
+    {
+        RelativePath = strRelativePath;
+    }
+    else
+    {
+        RelativePath = strPathFrom;
+    }
+
+    return Res != FALSE;
+}
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/interface/Atomics.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/interface/Atomics.hpp
new file mode 100644
index 00000000..38d20289
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/interface/Atomics.hpp
@@ -0,0 +1,43 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "PlatformDefinitions.h"
+
+#if PLATFORM_WIN32 || PLATFORM_UNIVERSAL_WINDOWS
+
+#    include "../Win32/interface/Win32Atomics.hpp"
+using Atomics = WindowsAtomics;
+
+#else
+
+// Use c++11 standard atomics
+#    include "../Basic/interface/BasicAtomics.hpp"
+using Atomics = BasicAtomics;
+
+#endif
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/interface/FileSystem.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/interface/FileSystem.hpp
new file mode 100644
index 00000000..6a26d2d8
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/interface/FileSystem.hpp
@@ -0,0 +1,66 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "PlatformDefinitions.h"
+
+#if PLATFORM_WIN32
+
+#    include "../Win32/interface/Win32FileSystem.hpp"
+using FileSystem = WindowsFileSystem;
+using CFile      = WindowsFile;
+
+#elif PLATFORM_UNIVERSAL_WINDOWS
+
+#    include "../UWP/interface/UWPFileSystem.hpp"
+using FileSystem = WindowsStoreFileSystem;
+using CFile      = WindowsStoreFile;
+
+#elif PLATFORM_ANDROID
+
+#    include "../Android/interface/AndroidFileSystem.hpp"
+using FileSystem = AndroidFileSystem;
+using CFile      = AndroidFile;
+
+#elif PLATFORM_LINUX
+
+#    include "../Linux/interface/LinuxFileSystem.hpp"
+using FileSystem = LinuxFileSystem;
+using CFile      = LinuxFile;
+
+#elif PLATFORM_MACOS || PLATFORM_IOS || PLATFORM_TVOS
+
+#    include "../Apple/interface/AppleFileSystem.hpp"
+using FileSystem = AppleFileSystem;
+using CFile      = AppleFile;
+
+#else
+
+#    error Unknown platform. Please define one of the following macros as 1:  PLATFORM_WIN32, PLATFORM_UNIVERSAL_WINDOWS, PLATFORM_ANDROID, PLATFORM_LINUX, PLATFORM_MACOS, PLATFORM_IOS, PLATFORM_TVOS.
+
+#endif
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/interface/NativeWindow.h b/app/src/main/java/libengine/DiligentLog/Platforms/interface/NativeWindow.h
new file mode 100644
index 00000000..15ef778f
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/interface/NativeWindow.h
@@ -0,0 +1,98 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "PlatformDefinitions.h"
+
+#if PLATFORM_WIN32
+
+#    include "../Win32/interface/Win32NativeWindow.h"
+
+#elif PLATFORM_UNIVERSAL_WINDOWS
+
+#    include "../UWP/interface/UWPNativeWindow.h"
+
+#elif PLATFORM_ANDROID
+
+#    include "../Android/interface/AndroidNativeWindow.h"
+
+#elif PLATFORM_LINUX
+
+#    include "../Linux/interface/LinuxNativeWindow.h"
+
+#elif PLATFORM_MACOS
+
+#    include "../Apple/interface/MacOSNativeWindow.h"
+
+#elif PLATFORM_IOS
+
+#    include "../Apple/interface/IOSNativeWindow.h"
+
+#elif PLATFORM_TVOS
+
+#    include "../Apple/interface/TVOSNativeWindow.h"
+
+#else
+#    error Unknown platform. Please define one of the following macros as 1: PLATFORM_WIN32, PLATFORM_UNIVERSAL_WINDOWS, PLATFORM_ANDROID, PLATFORM_LINUX, PLATFORM_MACOS, PLATFORM_IOS, PLATFORM_TVOS.
+#endif
+
+DILIGENT_BEGIN_NAMESPACE(Diligent)
+
+#if PLATFORM_WIN32
+
+typedef struct Win32NativeWindow NativeWindow;
+
+#elif PLATFORM_UNIVERSAL_WINDOWS
+
+typedef struct UWPNativeWindow NativeWindow;
+
+#elif PLATFORM_ANDROID
+
+typedef struct AndroidNativeWindow NativeWindow;
+
+#elif PLATFORM_LINUX
+
+typedef struct LinuxNativeWindow NativeWindow;
+
+#elif PLATFORM_MACOS
+
+typedef struct MacOSNativeWindow NativeWindow;
+
+#elif PLATFORM_IOS
+
+typedef struct IOSNativeWindow NativeWindow;
+
+#elif PLATFORM_TVOS
+
+typedef struct TVOSNativeWindow NativeWindow;
+
+#else
+#    error Unknown platform. Please define one of the following macros as 1: PLATFORM_WIN32, PLATFORM_UNIVERSAL_WINDOWS, PLATFORM_ANDROID, PLATFORM_LINUX, PLATFORM_MACOS, PLATFORM_IOS, PLATFORM_TVOS.
+#endif
+
+DILIGENT_END_NAMESPACE // namespace Diligent
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/interface/PlatformDebug.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/interface/PlatformDebug.hpp
new file mode 100644
index 00000000..f1552cd9
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/interface/PlatformDebug.hpp
@@ -0,0 +1,54 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "PlatformDefinitions.h"
+
+#if PLATFORM_WIN32
+#    include "../Win32/interface/Win32Debug.hpp"
+using PlatformDebug = WindowsDebug;
+
+#elif PLATFORM_UNIVERSAL_WINDOWS
+#    include "../UWP/interface/UWPDebug.hpp"
+using PlatformDebug = WindowsStoreDebug;
+
+#elif PLATFORM_ANDROID
+#    include "../Android/interface/AndroidDebug.hpp"
+using PlatformDebug = AndroidDebug;
+
+#elif PLATFORM_LINUX
+#    include "../Linux/interface/LinuxDebug.hpp"
+using PlatformDebug = LinuxDebug;
+
+#elif PLATFORM_MACOS || PLATFORM_IOS || PLATFORM_TVOS
+#    include "../Apple/interface/AppleDebug.hpp"
+using PlatformDebug = AppleDebug;
+
+#else
+#    error Unknown platform. Please define one of the following macros as 1:  PLATFORM_WIN32, PLATFORM_UNIVERSAL_WINDOWS, PLATFORM_ANDROID, PLATFORM_LINUX, PLATFORM_MACOS, PLATFORM_IOS, PLATFORM_TVOS.
+#endif
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/interface/PlatformDefinitions.h b/app/src/main/java/libengine/DiligentLog/Platforms/interface/PlatformDefinitions.h
new file mode 100644
index 00000000..23a5b920
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/interface/PlatformDefinitions.h
@@ -0,0 +1,100 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#if defined(ANDROID)
+#    ifndef PLATFORM_ANDROID
+#        define PLATFORM_ANDROID 1
+#    endif
+#endif
+
+#if !PLATFORM_WIN32 && !PLATFORM_UNIVERSAL_WINDOWS && !PLATFORM_ANDROID && !PLATFORM_LINUX && !PLATFORM_MACOS && !PLATFORM_IOS && !PLATFORM_TVOS
+#    error Unknown platform. Please define one of the following macros as 1:  PLATFORM_WIN32, PLATFORM_UNIVERSAL_WINDOWS, PLATFORM_ANDROID, PLATFORM_LINUX, PLATFORM_MACOS, PLATFORM_IOS, PLATFORM_TVOS.
+#endif
+
+#if PLATFORM_WIN32
+
+#    if PLATFORM_UNIVERSAL_WINDOWS || PLATFORM_ANDROID || PLATFORM_LINUX || PLATFORM_MACOS || PLATFORM_IOS || PLATFORM_TVOS
+#        error Conflicting platform macros
+#    endif
+
+#    include "../Win32/interface/Win32PlatformDefinitions.h"
+
+#elif PLATFORM_UNIVERSAL_WINDOWS
+
+#    if PLATFORM_WIN32 || PLATFORM_ANDROID || PLATFORM_LINUX || PLATFORM_MACOS || PLATFORM_IOS || PLATFORM_TVOS
+#        error Conflicting platform macros
+#    endif
+
+#    include "../UWP/interface/UWPDefinitions.h"
+
+#elif PLATFORM_ANDROID
+
+#    if PLATFORM_WIN32 || PLATFORM_UNIVERSAL_WINDOWS || PLATFORM_LINUX || PLATFORM_MACOS || PLATFORM_IOS || PLATFORM_TVOS
+#        error Conflicting platform macros
+#    endif
+
+#    include "../Android/interface/AndroidPlatformDefinitions.h"
+
+#elif PLATFORM_LINUX
+
+#    if PLATFORM_WIN32 || PLATFORM_UNIVERSAL_WINDOWS || PLATFORM_ANDROID || PLATFORM_MACOS || PLATFORM_IOS || PLATFORM_TVOS
+#        error Conflicting platform macros
+#    endif
+
+#    include "../Linux/interface/LinuxPlatformDefinitions.h"
+
+#elif PLATFORM_MACOS
+
+#    if PLATFORM_WIN32 || PLATFORM_UNIVERSAL_WINDOWS || PLATFORM_ANDROID || PLATFORM_LINUX || PLATFORM_IOS || PLATFORM_TVOS
+#        error Conflicting platform macros
+#    endif
+
+#    include "../Apple/interface/ApplePlatformDefinitions.h"
+
+#elif PLATFORM_IOS
+
+#    if PLATFORM_WIN32 || PLATFORM_UNIVERSAL_WINDOWS || PLATFORM_ANDROID || PLATFORM_LINUX || PLATFORM_MACOS || PLATFORM_TVOS
+#        error Conflicting platform macros
+#    endif
+
+#    include "../Apple/interface/ApplePlatformDefinitions.h"
+
+#elif PLATFORM_TVOS
+
+#    if PLATFORM_WIN32 || PLATFORM_UNIVERSAL_WINDOWS || PLATFORM_ANDROID || PLATFORM_LINUX || PLATFORM_MACOS || PLATFORM_IOS
+#        error Conflicting platform macros
+#    endif
+
+#    include "../Apple/interface/ApplePlatformDefinitions.h"
+
+#else
+
+#    error Unsupported platform
+
+#endif
diff --git a/app/src/main/java/libengine/DiligentLog/Platforms/interface/PlatformMisc.hpp b/app/src/main/java/libengine/DiligentLog/Platforms/interface/PlatformMisc.hpp
new file mode 100644
index 00000000..c8043a9b
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Platforms/interface/PlatformMisc.hpp
@@ -0,0 +1,52 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "PlatformDefinitions.h"
+
+#if PLATFORM_WIN32 || PLATFORM_UNIVERSAL_WINDOWS
+#    include "../Win32/interface/Win32PlatformMisc.hpp"
+using PlatformMisc = WindowsMisc;
+
+#elif PLATFORM_ANDROID
+#    include "../Android/interface/AndroidPlatformMisc.hpp"
+using PlatformMisc = AndroidMisc;
+
+#elif PLATFORM_LINUX
+#    include "../Linux/interface/LinuxPlatformMisc.hpp"
+using PlatformMisc = LinuxMisc;
+
+#elif PLATFORM_MACOS || PLATFORM_IOS || PLATFORM_TVOS
+#    include "../Apple/interface/ApplePlatformMisc.hpp"
+using PlatformMisc = AppleMisc;
+
+#else
+
+#    error Unknown platform. Please define one of the following macros as 1:  PLATFORM_WIN32, PLATFORM_UNIVERSAL_WINDOWS, PLATFORM_ANDROID, PLATFORM_LINUX, PLATFORM_MACOS, PLATFORM_IOS, PLATFORM_TVOS.
+
+#endif
diff --git a/app/src/main/java/libengine/DiligentLog/Primitives/CMakeLists.txt b/app/src/main/java/libengine/DiligentLog/Primitives/CMakeLists.txt
new file mode 100644
index 00000000..a2bc4529
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Primitives/CMakeLists.txt
@@ -0,0 +1,49 @@
+cmake_minimum_required (VERSION 3.6)
+
+project(Diligent-Primitives CXX)
+
+set(SOURCE
+    src/DebugOutput.cpp
+    src/test.cpp
+)
+
+set(INTERFACE
+    interface/BasicTypes.h
+    interface/CommonDefinitions.h
+    interface/DataBlob.h
+    interface/DebugOutput.h
+    interface/DefineGlobalFuncHelperMacros.h
+    interface/DefineInterfaceHelperMacros.h
+    interface/FlagEnum.h
+    interface/Errors.hpp
+    interface/FileStream.h
+    interface/FormatString.hpp
+    interface/InterfaceID.h
+    interface/MemoryAllocator.h
+    interface/Object.h
+    interface/ReferenceCounters.h
+    interface/UndefGlobalFuncHelperMacros.h
+    interface/UndefInterfaceHelperMacros.h
+)
+
+# This should be an interface library. However, CMake does not show
+# interface libraries in an IDE, so we have to create a static library instead
+add_library(Diligent-Primitives STATIC ${INTERFACE} ${SOURCE})
+set_common_target_properties__LOG(Diligent-Primitives)
+
+target_link_libraries(Diligent-Primitives
+PRIVATE
+    Diligent-BuildSettings__LOG
+)
+
+target_include_directories(Diligent-Primitives
+PUBLIC
+    interface
+)
+
+source_group("interface" FILES ${INTERFACE})
+source_group("src" FILES ${SOURCE})
+
+if(DILIGENT_INSTALL_CORE)
+    install_core_lib__LOG(Diligent-Primitives)
+endif()
\ No newline at end of file
diff --git a/app/src/main/java/libengine/DiligentLog/Primitives/interface/BasicTypes.h b/app/src/main/java/libengine/DiligentLog/Primitives/interface/BasicTypes.h
new file mode 100644
index 00000000..fd324344
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Primitives/interface/BasicTypes.h
@@ -0,0 +1,69 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "CommonDefinitions.h"
+
+#if DILIGENT_C_INTERFACE
+#    include <stdint.h>
+#    include <stdbool.h>
+#    include <stddef.h>
+#else
+#    include <cstdint>
+#    include <string>
+#endif
+
+DILIGENT_BEGIN_NAMESPACE(Diligent)
+
+typedef float Float32; ///< 32-bit float
+
+typedef int64_t Int64; ///< 64-bit signed integer
+typedef int32_t Int32; ///< 32-bit signed integer
+typedef int16_t Int16; ///< 16-bit signed integer
+typedef int8_t  Int8;  ///< 8-bit signed integer
+
+typedef uint64_t Uint64; ///< 64-bit unsigned integer
+typedef uint32_t Uint32; ///< 32-bit unsigned integer
+typedef uint16_t Uint16; ///< 16-bit unsigned integer
+typedef uint8_t  Uint8;  ///< 8-bit unsigned integer
+
+typedef size_t      SizeType;
+typedef void*       PVoid;
+typedef const void* CPVoid;
+
+typedef bool Bool; ///< Boolean
+
+static const Bool False = false;
+static const Bool True  = true;
+
+typedef char Char;
+#if !DILIGENT_C_INTERFACE
+using String = std::basic_string<Char>; ///< String variable
+#endif
+
+DILIGENT_END_NAMESPACE // namespace Diligent
diff --git a/app/src/main/java/libengine/DiligentLog/Primitives/interface/CommonDefinitions.h b/app/src/main/java/libengine/DiligentLog/Primitives/interface/CommonDefinitions.h
new file mode 100644
index 00000000..483ae86f
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Primitives/interface/CommonDefinitions.h
@@ -0,0 +1,107 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+/// \file
+/// Common definitions
+
+#ifndef DILIGENT_C_INTERFACE
+#    ifdef __cplusplus
+#        define DILIGENT_C_INTERFACE 0
+#    else
+#        define DILIGENT_C_INTERFACE 1
+#    endif
+#endif
+
+#ifdef _MSC_VER
+// Note that MSVC x86 compiler by default uses __this call for class member functions
+#    define DILIGENT_CALL_TYPE __cdecl
+#else
+#    define DILIGENT_CALL_TYPE
+#endif
+
+#if DILIGENT_C_INTERFACE
+
+#    define DILIGENT_BEGIN_NAMESPACE(Name)
+#    define DILIGENT_END_NAMESPACE
+
+#    define DILIGENT_TYPED_ENUM(EnumName, EnumType) \
+        typedef EnumType EnumName;                  \
+        enum _##EnumName
+
+#    define DILIGENT_DERIVE(TypeName) \
+        {                             \
+            struct TypeName _##TypeName;
+
+#    define DEFAULT_INITIALIZER(x)
+
+#    define DILIGENT_GLOBAL_FUNCTION(FuncName) Diligent_##FuncName
+
+#    define DILIGENT_BEGIN_INTERFACE(Iface, Base) \
+        typedef struct Iface                      \
+        {                                         \
+            struct Iface##Vtbl* pVtbl;            \
+        } Iface;                                  \
+        struct Iface##Methods
+
+#    define DEFAULT_VALUE(x)
+
+#    define CALL_IFACE_METHOD(Iface, Method, This, ...) (This)->pVtbl->Iface.Method((I##Iface*)(This), ##__VA_ARGS__)
+
+// Two levels of indirection are required to concatenate expanded macros
+#    define DILIGENT_CONCATENATE0(X, Y) X##Y
+#    define DILIGENT_CONCATENATE(X, Y)  DILIGENT_CONCATENATE0(X, Y)
+
+#else
+
+#    define DILIGENT_BEGIN_NAMESPACE(Name) \
+        namespace Name                     \
+        {
+
+#    define DILIGENT_END_NAMESPACE }
+
+#    define DILIGENT_TYPED_ENUM(EnumName, EnumType) enum EnumName : EnumType
+
+#    define DILIGENT_DERIVE(TypeName) : public TypeName \
+        {
+
+#    define DEFAULT_INITIALIZER(x) = x
+
+#    define DILIGENT_GLOBAL_FUNCTION(FuncName) FuncName
+
+#    define DILIGENT_BEGIN_INTERFACE(Name, Base) struct Name : public Base
+
+#    define DEFAULT_VALUE(x) = x
+
+#endif
+
+#if DILIGENT_C_INTERFACE
+#    define DILIGENT_CPP_INTERFACE 0
+#else
+#    define DILIGENT_CPP_INTERFACE 1
+#endif
diff --git a/app/src/main/java/libengine/DiligentLog/Primitives/interface/DataBlob.h b/app/src/main/java/libengine/DiligentLog/Primitives/interface/DataBlob.h
new file mode 100644
index 00000000..04f387ab
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Primitives/interface/DataBlob.h
@@ -0,0 +1,84 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+/// \file
+/// Defines Diligent::IDataBlob interface
+
+#include "Object.h"
+
+DILIGENT_BEGIN_NAMESPACE(Diligent)
+
+
+// {F578FF0D-ABD2-4514-9D32-7CB454D4A73B}
+static const struct INTERFACE_ID IID_DataBlob =
+    {0xf578ff0d, 0xabd2, 0x4514, {0x9d, 0x32, 0x7c, 0xb4, 0x54, 0xd4, 0xa7, 0x3b}};
+
+// clang-format off
+
+#define DILIGENT_INTERFACE_NAME IDataBlob
+#include "DefineInterfaceHelperMacros.h"
+
+#define IDataBlobInclusiveMethods \
+    IObjectInclusiveMethods;      \
+    IDataBlobMethods DataBlob
+
+/// Base interface for a file stream
+DILIGENT_BEGIN_INTERFACE(IDataBlob, IObject)
+{
+    /// Sets the size of the internal data buffer
+    VIRTUAL void METHOD(Resize)(THIS_
+                                size_t NewSize) PURE;
+
+    /// Returns the size of the internal data buffer
+    VIRTUAL size_t METHOD(GetSize)(THIS) CONST PURE;
+
+    /// Returns the pointer to the internal data buffer
+    VIRTUAL void* METHOD(GetDataPtr)(THIS) PURE;
+
+    /// Returns const pointer to the internal data buffer
+    VIRTUAL const void* METHOD(GetConstDataPtr)(THIS) CONST PURE;
+};
+DILIGENT_END_INTERFACE
+
+#include "UndefInterfaceHelperMacros.h"
+
+#if DILIGENT_C_INTERFACE
+
+// clang-format off
+
+#    define IDataBlob_Resize(This, ...)      CALL_IFACE_METHOD(DataBlob, Resize,          This, __VA_ARGS__)
+#    define IDataBlob_GetSize(This)          CALL_IFACE_METHOD(DataBlob, GetSize,         This)
+#    define IDataBlob_GetDataPtr(This)       CALL_IFACE_METHOD(DataBlob, GetDataPtr,      This)
+#    define IDataBlob_GetConstDataPtr(This)  CALL_IFACE_METHOD(DataBlob, GetConstDataPtr, This)
+
+// clang-format on
+
+#endif
+
+DILIGENT_END_NAMESPACE // namespace Diligent
diff --git a/app/src/main/java/libengine/DiligentLog/Primitives/interface/DebugOutput.h b/app/src/main/java/libengine/DiligentLog/Primitives/interface/DebugOutput.h
new file mode 100644
index 00000000..7c3857cc
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Primitives/interface/DebugOutput.h
@@ -0,0 +1,72 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "BasicTypes.h"
+
+DILIGENT_BEGIN_NAMESPACE(Diligent)
+
+/// Describes debug message severity
+enum DEBUG_MESSAGE_SEVERITY
+{
+    /// Information message
+    DEBUG_MESSAGE_SEVERITY_INFO = 0,
+
+    /// Warning message
+    DEBUG_MESSAGE_SEVERITY_WARNING,
+
+    /// Error, with potential recovery
+    DEBUG_MESSAGE_SEVERITY_ERROR,
+
+    /// Fatal error - recovery is not possible
+    DEBUG_MESSAGE_SEVERITY_FATAL_ERROR
+};
+
+
+/// Type of the debug message callback function
+
+/// \param [in] Severity - Message severity
+/// \param [in] Message - Debug message
+/// \param [in] Function - Name of the function or nullptr
+/// \param [in] File - File name or nullptr
+/// \param [in] Line - Line number
+typedef void (*DebugMessageCallbackType)(enum DEBUG_MESSAGE_SEVERITY Severity,
+                                         const Char*                 Message,
+                                         const Char*                 Function,
+                                         const Char*                 File,
+                                         int                         Line);
+extern DebugMessageCallbackType DebugMessageCallback;
+
+
+/// Sets the debug message callback function
+
+/// \note This function needs to be called for every executable module that
+///       wants to use the callback.
+void SetDebugMessageCallback(DebugMessageCallbackType DbgMessageCallback);
+
+DILIGENT_END_NAMESPACE // namespace Diligent
diff --git a/app/src/main/java/libengine/DiligentLog/Primitives/interface/DefineGlobalFuncHelperMacros.h b/app/src/main/java/libengine/DiligentLog/Primitives/interface/DefineGlobalFuncHelperMacros.h
new file mode 100644
index 00000000..a35649b0
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Primitives/interface/DefineGlobalFuncHelperMacros.h
@@ -0,0 +1,41 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#include "CommonDefinitions.h"
+
+#pragma push_macro("REF")
+#undef REF
+
+#if DILIGENT_C_INTERFACE
+
+#    define REF *
+
+#else
+
+#    define REF &
+
+#endif
diff --git a/app/src/main/java/libengine/DiligentLog/Primitives/interface/DefineInterfaceHelperMacros.h b/app/src/main/java/libengine/DiligentLog/Primitives/interface/DefineInterfaceHelperMacros.h
new file mode 100644
index 00000000..51a3e319
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Primitives/interface/DefineInterfaceHelperMacros.h
@@ -0,0 +1,90 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#include "CommonDefinitions.h"
+
+#ifndef DILIGENT_INTERFACE_NAME
+#    error Interface name is undefined
+#endif
+
+#pragma push_macro("THIS")
+#pragma push_macro("THIS_")
+#pragma push_macro("VIRTUAL")
+#pragma push_macro("CONST")
+#pragma push_macro("PURE")
+#pragma push_macro("REF")
+#pragma push_macro("METHOD")
+
+#undef THIS
+#undef THIS_
+#undef VIRTUAL
+#undef CONST
+#undef PURE
+#undef REF
+#undef METHOD
+
+#if DILIGENT_C_INTERFACE
+
+#    define THIS  struct DILIGENT_INTERFACE_NAME*
+#    define THIS_ struct DILIGENT_INTERFACE_NAME*,
+#    define VIRTUAL
+#    define CONST
+#    define PURE
+#    define REF          *
+#    define METHOD(Name) (DILIGENT_CALL_TYPE * Name)
+
+// Suppose that DILIGENT_INTERFACE_NAME == Iface, then DILIGENT_END_INTERFACE macro below will expand to the following:
+//
+//      typedef struct IfaceMethods IfaceMethods;
+//      typedef struct IfaceVtbl
+//      {
+//          IfaceInclusiveMethods;
+//      } IfaceVtbl;
+//
+// IfaceInclusiveMethods macro must be properly defined
+
+// clang-format off
+#    define DILIGENT_END_INTERFACE\
+        typedef struct DILIGENT_CONCATENATE(DILIGENT_INTERFACE_NAME, Methods) DILIGENT_CONCATENATE(DILIGENT_INTERFACE_NAME, Methods); \
+        typedef struct DILIGENT_CONCATENATE(DILIGENT_INTERFACE_NAME, Vtbl)  \
+        {                                                                   \
+            DILIGENT_CONCATENATE(DILIGENT_INTERFACE_NAME, InclusiveMethods);\
+        } DILIGENT_CONCATENATE(DILIGENT_INTERFACE_NAME, Vtbl);
+// clang-format on
+
+#else
+
+#    define THIS
+#    define THIS_
+#    define VIRTUAL      virtual
+#    define CONST        const
+#    define PURE         = 0
+#    define REF          &
+#    define METHOD(Name) DILIGENT_CALL_TYPE Name
+#    define DILIGENT_END_INTERFACE
+
+#endif
diff --git a/app/src/main/java/libengine/DiligentLog/Primitives/interface/Errors.hpp b/app/src/main/java/libengine/DiligentLog/Primitives/interface/Errors.hpp
new file mode 100644
index 00000000..64887ae1
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Primitives/interface/Errors.hpp
@@ -0,0 +1,165 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include <stdexcept>
+#include <string>
+#include <iostream>
+
+#include "DebugOutput.h"
+#include "FormatString.hpp"
+
+namespace Diligent
+{
+
+template <bool>
+void ThrowIf(std::string&&)
+{
+}
+
+template <>
+inline void ThrowIf<true>(std::string&& msg)
+{
+    throw std::runtime_error(std::move(msg));
+}
+
+template <bool bThrowException, typename... ArgsType>
+void LogError(bool IsFatal, const char* Function, const char* FullFilePath, int Line, const ArgsType&... Args)
+{
+    std::string FileName(FullFilePath);
+
+    auto LastSlashPos = FileName.find_last_of("/\\");
+    if (LastSlashPos != std::string::npos)
+        FileName.erase(0, LastSlashPos + 1);
+    auto Msg = FormatString(Args...);
+    if (DebugMessageCallback != nullptr)
+    {
+        DebugMessageCallback(IsFatal ? DEBUG_MESSAGE_SEVERITY_FATAL_ERROR : DEBUG_MESSAGE_SEVERITY_ERROR, Msg.c_str(), Function, FileName.c_str(), Line);
+    }
+    else
+    {
+        // No callback set - output to cerr
+        std::cerr << "Diligent Engine: " << (IsFatal ? "Fatal Error" : "Error") << " in " << Function << "() (" << FileName << ", " << Line << "): " << Msg << '\n';
+    }
+    ThrowIf<bThrowException>(std::move(Msg));
+}
+
+} // namespace Diligent
+
+
+
+#define LOG_ERROR(...)                                                                                 \
+    do                                                                                                 \
+    {                                                                                                  \
+        Diligent::LogError<false>(/*IsFatal=*/false, __FUNCTION__, __FILE__, __LINE__, ##__VA_ARGS__); \
+    } while (false)
+
+
+#define LOG_FATAL_ERROR(...)                                                                          \
+    do                                                                                                \
+    {                                                                                                 \
+        Diligent::LogError<false>(/*IsFatal=*/true, __FUNCTION__, __FILE__, __LINE__, ##__VA_ARGS__); \
+    } while (false)
+
+#define LOG_ERROR_ONCE(...)             \
+    do                                  \
+    {                                   \
+        static bool IsFirstTime = true; \
+        if (IsFirstTime)                \
+        {                               \
+            LOG_ERROR(##__VA_ARGS__);   \
+            IsFirstTime = false;        \
+        }                               \
+    } while (false)
+
+
+#define LOG_ERROR_AND_THROW(...)                                                                      \
+    do                                                                                                \
+    {                                                                                                 \
+        Diligent::LogError<true>(/*IsFatal=*/false, __FUNCTION__, __FILE__, __LINE__, ##__VA_ARGS__); \
+    } while (false)
+
+#define LOG_FATAL_ERROR_AND_THROW(...)                                                               \
+    do                                                                                               \
+    {                                                                                                \
+        Diligent::LogError<true>(/*IsFatal=*/true, __FUNCTION__, __FILE__, __LINE__, ##__VA_ARGS__); \
+    } while (false)
+
+
+#define LOG_DEBUG_MESSAGE(Severity, ...)                                                                                            \
+    do                                                                                                                              \
+    {                                                                                                                               \
+        auto _msg = Diligent::FormatString(__VA_ARGS__);                                                                            \
+        if (Diligent::DebugMessageCallback != nullptr) Diligent::DebugMessageCallback(Severity, _msg.c_str(), nullptr, nullptr, 0); \
+    } while (false)
+
+#define LOG_FATAL_ERROR_MESSAGE(...) LOG_DEBUG_MESSAGE(Diligent::DEBUG_MESSAGE_SEVERITY_FATAL_ERROR, ##__VA_ARGS__)
+#define LOG_ERROR_MESSAGE(...)       LOG_DEBUG_MESSAGE(Diligent::DEBUG_MESSAGE_SEVERITY_ERROR, ##__VA_ARGS__)
+#define LOG_WARNING_MESSAGE(...)     LOG_DEBUG_MESSAGE(Diligent::DEBUG_MESSAGE_SEVERITY_WARNING, ##__VA_ARGS__)
+#define LOG_INFO_MESSAGE(...)        LOG_DEBUG_MESSAGE(Diligent::DEBUG_MESSAGE_SEVERITY_INFO, ##__VA_ARGS__)
+
+
+#define LOG_DEBUG_MESSAGE_ONCE(Severity, ...)           \
+    do                                                  \
+    {                                                   \
+        static bool IsFirstTime = true;                 \
+        if (IsFirstTime)                                \
+        {                                               \
+            LOG_DEBUG_MESSAGE(Severity, ##__VA_ARGS__); \
+            IsFirstTime = false;                        \
+        }                                               \
+    } while (false)
+
+#define LOG_FATAL_ERROR_MESSAGE_ONCE(...) LOG_DEBUG_MESSAGE_ONCE(Diligent::DEBUG_MESSAGE_SEVERITY_FATAL_ERROR, ##__VA_ARGS__)
+#define LOG_ERROR_MESSAGE_ONCE(...)       LOG_DEBUG_MESSAGE_ONCE(Diligent::DEBUG_MESSAGE_SEVERITY_ERROR, ##__VA_ARGS__)
+#define LOG_WARNING_MESSAGE_ONCE(...)     LOG_DEBUG_MESSAGE_ONCE(Diligent::DEBUG_MESSAGE_SEVERITY_WARNING, ##__VA_ARGS__)
+#define LOG_INFO_MESSAGE_ONCE(...)        LOG_DEBUG_MESSAGE_ONCE(Diligent::DEBUG_MESSAGE_SEVERITY_INFO, ##__VA_ARGS__)
+
+
+#define CHECK(Expr, Severity, ...)                      \
+    do                                                  \
+    {                                                   \
+        if (!(Expr))                                    \
+        {                                               \
+            LOG_DEBUG_MESSAGE(Severity, ##__VA_ARGS__); \
+        }                                               \
+    } while (false)
+
+#define CHECK_FATAL_ERR(Expr, ...) CHECK(Expr, Diligent::DEBUG_MESSAGE_SEVERITY_FATAL_ERROR, ##__VA_ARGS__)
+#define CHECK_ERR(Expr, ...)       CHECK(Expr, Diligent::DEBUG_MESSAGE_SEVERITY_ERROR, ##__VA_ARGS__)
+#define CHECK_WARN(Expr, ...)      CHECK(Expr, Diligent::DEBUG_MESSAGE_SEVERITY_WARNING, ##__VA_ARGS__)
+#define CHECK_INFO(Expr, ...)      CHECK(Expr, Diligent::DEBUG_MESSAGE_SEVERITY_INFO, ##__VA_ARGS__)
+
+#define CHECK_THROW(Expr, ...)                  \
+    do                                          \
+    {                                           \
+        if (!(Expr))                            \
+        {                                       \
+            LOG_ERROR_AND_THROW(##__VA_ARGS__); \
+        }                                       \
+    } while (false)
diff --git a/app/src/main/java/libengine/DiligentLog/Primitives/interface/FileStream.h b/app/src/main/java/libengine/DiligentLog/Primitives/interface/FileStream.h
new file mode 100644
index 00000000..0ef223fb
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Primitives/interface/FileStream.h
@@ -0,0 +1,90 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+/// \file
+/// Defines Diligent::IFileStream interface
+
+#include "Object.h"
+#include "DataBlob.h"
+
+DILIGENT_BEGIN_NAMESPACE(Diligent)
+
+/// IFileStream interface unique identifier
+// {E67F386C-6A5A-4A24-A0CE-C66435465D41}
+static const struct INTERFACE_ID IID_FileStream =
+    {0xe67f386c, 0x6a5a, 0x4a24, {0xa0, 0xce, 0xc6, 0x64, 0x35, 0x46, 0x5d, 0x41}};
+
+// clang-format off
+
+#define DILIGENT_INTERFACE_NAME IFileStream
+#include "DefineInterfaceHelperMacros.h"
+
+#define IFileStreamInclusiveMethods \
+    IObjectInclusiveMethods;        \
+    IFileStreamMethods FileStream
+
+/// Base interface for a file stream
+DILIGENT_BEGIN_INTERFACE(IFileStream, IObject)
+{
+    /// Reads data from the stream
+    VIRTUAL bool METHOD(Read)(THIS_
+                              void*  Data,
+                              size_t BufferSize) PURE;
+
+    VIRTUAL void METHOD(ReadBlob)(THIS_
+                                  IDataBlob* pData) PURE;
+
+    /// Writes data to the stream
+    VIRTUAL bool METHOD(Write)(THIS_
+                               const void* Data, 
+                               size_t      Size) PURE;
+
+    VIRTUAL size_t METHOD(GetSize)(THIS) PURE;
+
+    VIRTUAL bool METHOD(IsValid)(THIS) PURE;
+};
+DILIGENT_END_INTERFACE
+
+#include "UndefInterfaceHelperMacros.h"
+
+#if DILIGENT_C_INTERFACE
+
+// clang-format off
+
+#    define IFileStream_Read(This, ...)     CALL_IFACE_METHOD(FileStream, Read,     This, __VA_ARGS__)
+#    define IFileStream_ReadBlob(This, ...) CALL_IFACE_METHOD(FileStream, ReadBlob, This, __VA_ARGS__)
+#    define IFileStream_Write(This, ...)    CALL_IFACE_METHOD(FileStream, Write,    This, __VA_ARGS__)
+#    define IFileStream_GetSize(This)       CALL_IFACE_METHOD(FileStream, GetSize,  This)
+#    define IFileStream_IsValid(This)       CALL_IFACE_METHOD(FileStream, IsValid,  This)
+
+// clang-format on
+
+#endif
+
+DILIGENT_END_NAMESPACE // namespace Diligent
diff --git a/app/src/main/java/libengine/DiligentLog/Primitives/interface/FlagEnum.h b/app/src/main/java/libengine/DiligentLog/Primitives/interface/FlagEnum.h
new file mode 100644
index 00000000..b97e013a
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Primitives/interface/FlagEnum.h
@@ -0,0 +1,53 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include "BasicTypes.h"
+
+#if DILIGENT_C_INTERFACE
+
+#    define DEFINE_FLAG_ENUM_OPERATORS(ENUMTYPE)
+
+#else
+
+template <typename EnumType>
+using _UNDERLYING_ENUM_T = typename std::underlying_type<EnumType>::type;
+
+#    define DEFINE_FLAG_ENUM_OPERATORS(ENUMTYPE)                                                                                                                                                                      \
+        extern "C++"                                                                                                                                                                                                  \
+        {                                                                                                                                                                                                             \
+            inline ENUMTYPE&          operator|=(ENUMTYPE& a, ENUMTYPE b) { return reinterpret_cast<ENUMTYPE&>(reinterpret_cast<_UNDERLYING_ENUM_T<ENUMTYPE>&>(a) |= static_cast<_UNDERLYING_ENUM_T<ENUMTYPE>>(b)); } \
+            inline ENUMTYPE&          operator&=(ENUMTYPE& a, ENUMTYPE b) { return reinterpret_cast<ENUMTYPE&>(reinterpret_cast<_UNDERLYING_ENUM_T<ENUMTYPE>&>(a) &= static_cast<_UNDERLYING_ENUM_T<ENUMTYPE>>(b)); } \
+            inline ENUMTYPE&          operator^=(ENUMTYPE& a, ENUMTYPE b) { return reinterpret_cast<ENUMTYPE&>(reinterpret_cast<_UNDERLYING_ENUM_T<ENUMTYPE>&>(a) ^= static_cast<_UNDERLYING_ENUM_T<ENUMTYPE>>(b)); } \
+            inline constexpr ENUMTYPE operator|(ENUMTYPE a, ENUMTYPE b) { return static_cast<ENUMTYPE>(static_cast<_UNDERLYING_ENUM_T<ENUMTYPE>>(a) | static_cast<_UNDERLYING_ENUM_T<ENUMTYPE>>(b)); }                \
+            inline constexpr ENUMTYPE operator&(ENUMTYPE a, ENUMTYPE b) { return static_cast<ENUMTYPE>(static_cast<_UNDERLYING_ENUM_T<ENUMTYPE>>(a) & static_cast<_UNDERLYING_ENUM_T<ENUMTYPE>>(b)); }                \
+            inline constexpr ENUMTYPE operator^(ENUMTYPE a, ENUMTYPE b) { return static_cast<ENUMTYPE>(static_cast<_UNDERLYING_ENUM_T<ENUMTYPE>>(a) ^ static_cast<_UNDERLYING_ENUM_T<ENUMTYPE>>(b)); }                \
+            inline constexpr ENUMTYPE operator~(ENUMTYPE a) { return static_cast<ENUMTYPE>(~static_cast<_UNDERLYING_ENUM_T<ENUMTYPE>>(a)); }                                                                          \
+        }
+
+#endif
diff --git a/app/src/main/java/libengine/DiligentLog/Primitives/interface/FormatString.hpp b/app/src/main/java/libengine/DiligentLog/Primitives/interface/FormatString.hpp
new file mode 100644
index 00000000..bc42aa76
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Primitives/interface/FormatString.hpp
@@ -0,0 +1,103 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include <sstream>
+#include <iomanip>
+
+namespace Diligent
+{
+
+template <typename SSType>
+void FormatStrSS(SSType& ss)
+{
+}
+
+template <typename SSType, typename ArgType>
+void FormatStrSS(SSType& ss, const ArgType& Arg)
+{
+    ss << Arg;
+}
+
+template <typename SSType, typename FirstArgType, typename... RestArgsType>
+void FormatStrSS(SSType& ss, const FirstArgType& FirstArg, const RestArgsType&... RestArgs)
+{
+    FormatStrSS(ss, FirstArg);
+    FormatStrSS(ss, RestArgs...); // recursive call using pack expansion syntax
+}
+
+template <typename... RestArgsType>
+std::string FormatString(const RestArgsType&... Args)
+{
+    std::stringstream ss;
+    FormatStrSS(ss, Args...);
+    return ss.str();
+}
+
+template <typename Type>
+struct MemorySizeFormatter
+{
+    MemorySizeFormatter(Type _size, int _precision, Type _ref_size) :
+        size{_size},
+        precision{_precision},
+        ref_size{_ref_size}
+    {}
+    Type size      = 0;
+    int  precision = 0;
+    Type ref_size  = 0;
+};
+
+template <typename Type>
+MemorySizeFormatter<Type> FormatMemorySize(Type _size, int _precision = 0, Type _ref_size = 0)
+{
+    return MemorySizeFormatter<Type>{_size, _precision, _ref_size};
+}
+
+template <typename SSType, typename Type>
+void FormatStrSS(SSType& ss, const MemorySizeFormatter<Type>& Arg)
+{
+    auto ref_size = Arg.ref_size != 0 ? Arg.ref_size : Arg.size;
+    if (ref_size >= (1 << 30))
+    {
+        ss << std::fixed << std::setprecision(Arg.precision) << static_cast<double>(Arg.size) / double{1 << 30} << " GB";
+    }
+    else if (ref_size >= (1 << 20))
+    {
+        ss << std::fixed << std::setprecision(Arg.precision) << static_cast<double>(Arg.size) / double{1 << 20} << " MB";
+    }
+    else if (ref_size >= (1 << 10))
+    {
+        ss << std::fixed << std::setprecision(Arg.precision) << static_cast<double>(Arg.size) / double{1 << 10} << " KB";
+    }
+    else
+    {
+        ss << Arg.size << (((Arg.size & 0x01) == 0x01) ? " Byte" : " Bytes");
+    }
+}
+
+} // namespace Diligent
diff --git a/app/src/main/java/libengine/DiligentLog/Primitives/interface/InterfaceID.h b/app/src/main/java/libengine/DiligentLog/Primitives/interface/InterfaceID.h
new file mode 100644
index 00000000..aca1a64d
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Primitives/interface/InterfaceID.h
@@ -0,0 +1,59 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+#include <string.h>
+#include "BasicTypes.h"
+
+/// Unique identification structures
+DILIGENT_BEGIN_NAMESPACE(Diligent)
+
+/// Unique interface identifier
+struct INTERFACE_ID
+{
+    Uint32 Data1;
+    Uint16 Data2;
+    Uint16 Data3;
+    Uint8  Data4[8];
+
+#if DILIGENT_CPP_INTERFACE
+    bool operator==(const INTERFACE_ID& rhs) const
+    {
+        return Data1 == rhs.Data1 &&
+            Data2 == rhs.Data2 &&
+            Data3 == rhs.Data3 &&
+            memcmp(Data4, rhs.Data4, sizeof(Data4)) == 0;
+    }
+#endif
+};
+typedef struct INTERFACE_ID INTERFACE_ID;
+
+/// Unknown interface
+static const INTERFACE_ID IID_Unknown = {0, 0, 0, {0, 0, 0, 0, 0, 0, 0, 0}};
+
+DILIGENT_END_NAMESPACE // namespace Diligent
diff --git a/app/src/main/java/libengine/DiligentLog/Primitives/interface/MemoryAllocator.h b/app/src/main/java/libengine/DiligentLog/Primitives/interface/MemoryAllocator.h
new file mode 100644
index 00000000..af660f0d
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Primitives/interface/MemoryAllocator.h
@@ -0,0 +1,81 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+/// \file
+/// Defines Diligent::IMemoryAllocator interface
+
+#include "BasicTypes.h"
+
+DILIGENT_BEGIN_NAMESPACE(Diligent)
+
+
+#if DILIGENT_CPP_INTERFACE
+
+/// Base interface for a raw memory allocator
+struct IMemoryAllocator
+{
+    /// Allocates block of memory
+    virtual void* Allocate(size_t Size, const Char* dbgDescription, const char* dbgFileName, const Int32 dbgLineNumber) = 0;
+
+    /// Releases memory
+    virtual void Free(void* Ptr) = 0;
+};
+
+#else
+
+struct IMemoryAllocator;
+
+// clang-format off
+
+struct IMemoryAllocatorMethods
+{
+    void* (*Allocate) (struct IMemoryAllocator*, size_t Size, const Char* dbgDescription, const char* dbgFileName, const Int32 dbgLineNumber);
+    void  (*Free)     (struct IMemoryAllocator*, void* Ptr);
+};
+
+struct IMemoryAllocatorVtbl
+{
+    struct IMemoryAllocatorMethods MemoryAllocator;
+};
+
+// clang-format on
+
+typedef struct IMemoryAllocator
+{
+    struct IMemoryAllocatorVtbl* pVtbl;
+} IMemoryAllocator;
+
+// clang-format off
+
+#    define IMemoryAllocator_Allocate(This, ...) CALL_IFACE_METHOD(MemoryAllocator, Allocate, This, __VA_ARGS__)
+#    define IMemoryAllocator_Free(This, ...)     CALL_IFACE_METHOD(MemoryAllocator, Free,     This, __VA_ARGS__)
+
+#endif
+
+DILIGENT_END_NAMESPACE // namespace Diligent
diff --git a/app/src/main/java/libengine/DiligentLog/Primitives/interface/Object.h b/app/src/main/java/libengine/DiligentLog/Primitives/interface/Object.h
new file mode 100644
index 00000000..20a4ad98
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Primitives/interface/Object.h
@@ -0,0 +1,120 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+/// \file
+/// Defines Diligent::IObject interface
+
+#include "InterfaceID.h"
+#include "ReferenceCounters.h"
+
+DILIGENT_BEGIN_NAMESPACE(Diligent)
+
+#if DILIGENT_CPP_INTERFACE
+
+/// Base interface for all dynamic objects in the engine
+struct IObject
+{
+    /// Queries the specific interface.
+
+    /// \param [in] IID - Unique identifier of the requested interface.
+    /// \param [out] ppInterface - Memory address where the pointer to the requested interface will be written.
+    ///                            If the interface is not supported, null pointer will be returned.
+    /// \remark The method increments the number of strong references by 1. The interface must be
+    ///         released by a call to Release() method when it is no longer needed.
+    virtual void DILIGENT_CALL_TYPE QueryInterface(const INTERFACE_ID& IID, IObject** ppInterface) = 0;
+
+
+    /// Increments the number of strong references by 1.
+
+    /// \remark This method is equivalent to GetReferenceCounters()->AddStrongRef().\n
+    ///         The method is thread-safe and does not require explicit synchronization.
+    /// \return The number of strong references after incrementing the counter.
+    /// \note   In a multithreaded environment, the returned number may not be reliable
+    ///         as other threads may simultaneously change the actual value of the counter.
+    virtual ReferenceCounterValueType DILIGENT_CALL_TYPE AddRef() = 0;
+
+
+    /// Decrements the number of strong references by 1 and destroys the object when the
+    /// counter reaches zero.
+
+    /// \remark This method is equivalent to GetReferenceCounters()->ReleaseStrongRef().\n
+    ///         The method is thread-safe and does not require explicit synchronization.
+    /// \return The number of strong references after decrementing the counter.
+    /// \note   In a multithreaded environment, the returned number may not be reliable
+    ///         as other threads may simultaneously change the actual value of the counter.
+    ///         The only reliable value is 0 as the object is destroyed when the last
+    ///         strong reference is released.
+    virtual ReferenceCounterValueType DILIGENT_CALL_TYPE Release() = 0;
+
+
+    /// Returns the pointer to IReferenceCounters interface of the associated
+    /// reference counters object. The method does *NOT* increment
+    /// the number of strong references to the returned object.
+    virtual IReferenceCounters* DILIGENT_CALL_TYPE GetReferenceCounters() const = 0;
+};
+
+#else
+
+struct IObject;
+
+// clang-format off
+
+typedef struct IObjectMethods
+{
+    void                       (*QueryInterface)      (struct IObject*, const struct INTERFACE_ID* IID, struct IObject** ppInterface);
+    ReferenceCounterValueType  (*AddRef)              (struct IObject*);
+    ReferenceCounterValueType  (*Release)             (struct IObject*);
+    struct IReferenceCounters* (*GetReferenceCounters)(struct IObject*);
+} IObjectMethods;
+
+#define IObjectInclusiveMethods IObjectMethods Object
+
+typedef struct IObjectVtbl
+{
+    IObjectInclusiveMethods;
+} IObjectVtbl;
+
+// clang-format on
+
+typedef struct IObject
+{
+    struct IObjectVtbl* pVtbl;
+} IObject;
+
+// clang-format off
+
+#    define IObject_QueryInterface(This, ...) CALL_IFACE_METHOD(Object, QueryInterface, This, __VA_ARGS__)
+#    define IObject_AddRef(This)              CALL_IFACE_METHOD(Object, AddRef,         This)
+#    define IObject_Release(This)             CALL_IFACE_METHOD(Object, Release,        This)
+
+// clang-format on
+
+#endif
+
+DILIGENT_END_NAMESPACE // namespace Diligent
diff --git a/app/src/main/java/libengine/DiligentLog/Primitives/interface/ReferenceCounters.h b/app/src/main/java/libengine/DiligentLog/Primitives/interface/ReferenceCounters.h
new file mode 100644
index 00000000..0ac50791
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Primitives/interface/ReferenceCounters.h
@@ -0,0 +1,165 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma once
+
+/// \file
+/// Defines Diligent::IReferenceCounters interface
+
+#include "InterfaceID.h"
+
+DILIGENT_BEGIN_NAMESPACE(Diligent)
+
+typedef long ReferenceCounterValueType;
+
+#if DILIGENT_CPP_INTERFACE
+
+/// Base interface for a reference counter object that stores the number of strong and
+/// weak references and the pointer to the object. It is necessary to separate reference
+/// counters from the object to support weak pointers.
+class IReferenceCounters
+{
+public:
+    /// Increments the number of strong references by 1.
+
+    /// \return The number of strong references after incrementing the counter.
+    /// \remark The method is thread-safe and does not require explicit synchronization.
+    /// \note   In a multithreaded environment, the returned number may not be reliable
+    ///         as other threads may simultaneously change the actual value of the counter.
+    virtual ReferenceCounterValueType AddStrongRef() = 0;
+
+
+    /// Decrements the number of strong references by 1 and destroys the referenced object
+    /// when the counter reaches zero. If there are no more weak references, destroys the
+    /// reference counters object itself.
+
+    /// \return The number of strong references after decrementing the counter.
+    /// \remark The referenced object is destroyed when the last strong reference is released.\n
+    ///         If there are no more weak references, the reference counters object itself is
+    ///         also destroyed.\n
+    ///         The method is thread-safe and does not require explicit synchronization.
+    /// \note   In a multithreaded environment, the returned number may not be reliable
+    ///         as other threads may simultaneously change the actual value of the counter.
+    ///         The only reliable value is 0 as the object is destroyed when the last
+    ///         strong reference is released.
+    virtual ReferenceCounterValueType ReleaseStrongRef() = 0;
+
+
+    /// Increments the number of weak references by 1.
+
+    /// \return The number of weak references after incrementing the counter.
+    /// \remark The method is thread-safe and does not require explicit synchronization.
+    /// \note   In a multithreaded environment, the returned number may not be reliable
+    ///         as other threads may simultaneously change the actual value of the counter.
+    virtual ReferenceCounterValueType AddWeakRef() = 0;
+
+
+    /// Decrements the number of weak references by 1. If there are no more strong and weak
+    /// references, destroys the reference counters object itself.
+
+    /// \return The number of weak references after decrementing the counter.
+    /// \remark The method is thread-safe and does not require explicit synchronization.
+    /// \note   In a multithreaded environment, the returned number may not be reliable
+    ///         as other threads may simultaneously change the actual value of the counter.
+    virtual ReferenceCounterValueType ReleaseWeakRef() = 0;
+
+
+    /// Gets the pointer to the IUnknown interface of the referenced object.
+
+    /// \param [out] ppObject - Memory address where the pointer to the object
+    ///                         will be stored.
+    /// \remark If the object was destroyed, nullptr will be written to *ppObject.
+    ///         If the object was not released, the pointer to the object's IUnknown interface
+    ///         will be stored. In this case, the number of strong references to the object
+    ///         will be incremented by 1.\n
+    ///         The method is thread-safe and does not require explicit synchronization.
+    virtual void GetObject(struct IObject** ppObject) = 0;
+
+
+    /// Returns the number of outstanding strong references.
+
+    /// \return The number of strong references.
+    /// \note   In a multithreaded environment, the returned number may not be reliable
+    ///         as other threads may simultaneously change the actual value of the counter.
+    ///         The only reliable value is 0 as the object is destroyed when the last
+    ///         strong reference is released.
+    virtual ReferenceCounterValueType GetNumStrongRefs() const = 0;
+
+
+    /// Returns the number of outstanding weak references.
+
+    /// \return The number of weak references.
+    /// \note   In a multithreaded environment, the returned number may not be reliable
+    ///         as other threads may simultaneously change the actual value of the counter.
+    virtual ReferenceCounterValueType GetNumWeakRefs() const = 0;
+};
+
+#else
+
+struct IObject;
+struct IReferenceCounters;
+
+// clang-format off
+
+typedef struct IReferenceCountersMethods
+{
+    ReferenceCounterValueType (*AddStrongRef)      (struct IReferenceCounters*);
+    ReferenceCounterValueType (*ReleaseStrongRef)  (struct IReferenceCounters*);
+    ReferenceCounterValueType (*AddWeakRef)        (struct IReferenceCounters*);
+    ReferenceCounterValueType (*ReleaseWeakRef)    (struct IReferenceCounters*);
+    void                      (*GetObject)         (struct IReferenceCounters*, struct IObject** ppObject);
+    ReferenceCounterValueType (*GetNumStrongRefs)  (struct IReferenceCounters*);
+    ReferenceCounterValueType (*GetNumWeakRefs)    (struct IReferenceCounters*);
+} IReferenceCountersMethods;
+
+typedef struct IReferenceCountersVtbl
+{
+    IReferenceCountersMethods ReferenceCounters;
+} IReferenceCountersVtbl;
+
+// clang-format on
+
+typedef struct IReferenceCounters
+{
+    struct IReferenceCountersVtbl* pVtbl;
+} IReferenceCounters;
+
+// clang-format off
+
+#    define IReferenceCounters_AddStrongRef(This)      CALL_IFACE_METHOD(ReferenceCounters, AddStrongRef,     This)
+#    define IReferenceCounters_ReleaseStrongRef(This)  CALL_IFACE_METHOD(ReferenceCounters, ReleaseStrongRef, This)
+#    define IReferenceCounters_AddWeakRef(This)        CALL_IFACE_METHOD(ReferenceCounters, AddWeakRef,       This)
+#    define IReferenceCounters_ReleaseWeakRef(This)    CALL_IFACE_METHOD(ReferenceCounters, ReleaseWeakRef,   This)
+#    define IReferenceCounters_GetObject(This, ...)    CALL_IFACE_METHOD(ReferenceCounters, GetObject,        This, __VA_ARGS__)
+#    define IReferenceCounters_GetNumStrongRefs(This)  CALL_IFACE_METHOD(ReferenceCounters, GetNumStrongRefs, This)
+#    define IReferenceCounters_GetNumWeakRefs(This)    CALL_IFACE_METHOD(ReferenceCounters, GetNumWeakRefs,   This)
+
+// clang-format on
+
+#endif
+
+DILIGENT_END_NAMESPACE // namespace Diligent
diff --git a/app/src/main/java/libengine/DiligentLog/Primitives/interface/UndefGlobalFuncHelperMacros.h b/app/src/main/java/libengine/DiligentLog/Primitives/interface/UndefGlobalFuncHelperMacros.h
new file mode 100644
index 00000000..6d189ea7
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Primitives/interface/UndefGlobalFuncHelperMacros.h
@@ -0,0 +1,28 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma pop_macro("REF")
diff --git a/app/src/main/java/libengine/DiligentLog/Primitives/interface/UndefInterfaceHelperMacros.h b/app/src/main/java/libengine/DiligentLog/Primitives/interface/UndefInterfaceHelperMacros.h
new file mode 100644
index 00000000..6ab8fc99
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Primitives/interface/UndefInterfaceHelperMacros.h
@@ -0,0 +1,37 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence), 
+ *  contract, or otherwise, unless required by applicable law (such as deliberate 
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental, 
+ *  or consequential damages of any character arising as a result of this License or 
+ *  out of the use or inability to use the software (including but not limited to damages 
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and 
+ *  all other commercial damages or losses), even if such Contributor has been advised 
+ *  of the possibility of such damages.
+ */
+
+#pragma pop_macro("THIS")
+#pragma pop_macro("THIS_")
+#pragma pop_macro("VIRTUAL")
+#pragma pop_macro("CONST")
+#pragma pop_macro("PURE")
+#pragma pop_macro("REF")
+#pragma pop_macro("METHOD")
+
+#undef DILIGENT_INTERFACE_NAME
+#undef DILIGENT_END_INTERFACE
diff --git a/app/src/main/java/libengine/DiligentLog/Primitives/src/DebugOutput.cpp b/app/src/main/java/libengine/DiligentLog/Primitives/src/DebugOutput.cpp
new file mode 100644
index 00000000..2882af50
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Primitives/src/DebugOutput.cpp
@@ -0,0 +1,40 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence),
+ *  contract, or otherwise, unless required by applicable law (such as deliberate
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental,
+ *  or consequential damages of any character arising as a result of this License or
+ *  out of the use or inability to use the software (including but not limited to damages
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and
+ *  all other commercial damages or losses), even if such Contributor has been advised
+ *  of the possibility of such damages.
+ */
+
+#include "DebugOutput.h"
+
+namespace Diligent
+{
+
+void SetDebugMessageCallback(DebugMessageCallbackType DbgMessageCallback)
+{
+    // DebugMessageCallback variable is defined in every platform-specific implementation file
+    // and initialized with the platform-specific callback
+    DebugMessageCallback = DbgMessageCallback;
+}
+
+} // namespace Diligent
diff --git a/app/src/main/java/libengine/DiligentLog/Primitives/src/test.cpp b/app/src/main/java/libengine/DiligentLog/Primitives/src/test.cpp
new file mode 100644
index 00000000..d63d7572
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/Primitives/src/test.cpp
@@ -0,0 +1,35 @@
+/*
+ *  Copyright 2019-2021 Diligent Graphics LLC
+ *  Copyright 2015-2019 Egor Yusov
+ *  
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  In no event and under no legal theory, whether in tort (including negligence),
+ *  contract, or otherwise, unless required by applicable law (such as deliberate
+ *  and grossly negligent acts) or agreed to in writing, shall any Contributor be
+ *  liable for any damages, including any direct, indirect, special, incidental,
+ *  or consequential damages of any character arising as a result of this License or
+ *  out of the use or inability to use the software (including but not limited to damages
+ *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and
+ *  all other commercial damages or losses), even if such Contributor has been advised
+ *  of the possibility of such damages.
+ */
+
+#include "BasicTypes.h"
+#include "InterfaceID.h"
+#include "ReferenceCounters.h"
+#include "Object.h"
+#include "MemoryAllocator.h"
+#include "FormatString.hpp"
+#include "FileStream.h"
+#include "DataBlob.h"
diff --git a/app/src/main/java/libengine/DiligentLog/common.cpp b/app/src/main/java/libengine/DiligentLog/common.cpp
new file mode 100644
index 00000000..62748999
--- /dev/null
+++ b/app/src/main/java/libengine/DiligentLog/common.cpp
@@ -0,0 +1,25 @@
+//
+// Created by Matthew Good on 29/7/21.
+//
+
+#include "Log.h"
+#include "Primitives/interface/Errors.hpp"
+
+void Log::Log_String(const Log::SEVERITY & severity, const char * msg) {
+    if (Diligent::DebugMessageCallback != nullptr) {
+        Diligent::DebugMessageCallback(
+                severity == Log::INFO ? Diligent::DEBUG_MESSAGE_SEVERITY_INFO
+                                      : (
+                        severity == Log::ERROR ? Diligent::DEBUG_MESSAGE_SEVERITY_ERROR
+                                               : Diligent::DEBUG_MESSAGE_SEVERITY_FATAL_ERROR
+                ), msg, nullptr, nullptr, 0
+        );
+    }
+    if (severity == Log::FATAL) {
+        throw std::runtime_error(msg);
+    }
+}
+
+void Log::Log_String(const Log::SEVERITY & severity, const std::string & msg) {
+    Log_String(severity, msg.c_str());
+}
diff --git a/app/src/main/java/libengine/JVM_MANAGER.cpp b/app/src/main/java/libengine/JVM_MANAGER.cpp
new file mode 100644
index 00000000..6102a854
--- /dev/null
+++ b/app/src/main/java/libengine/JVM_MANAGER.cpp
@@ -0,0 +1,45 @@
+//
+// Created by Matthew Good on 29/6/21.
+//
+
+#include "JVM_MANAGER.h"
+
+JVM_MANAGER::JVM_MANAGER() {
+    jvm = nullptr;
+    jenv = nullptr;
+    needsToDetach = false;
+    jvmArgs.version = JNI_VERSION_1_6;
+}
+
+bool JVM_MANAGER::getJVM(JNIEnv *env) {
+    return env->GetJavaVM(&jvm) == JNI_OK;
+}
+
+bool JVM_MANAGER::attachJVM() {
+    // checks if current env needs attaching or it is already attached
+    jint res = jvm->GetEnv((void**)&jenv, JNI_VERSION_1_6);
+    if (res == JNI_EDETACHED) {
+        // Supported but not attached yet, needs to call AttachCurrentThread
+        res = jvm->AttachCurrentThread(&jenv, &jvmArgs);
+        if (res == JNI_OK) {
+            needsToDetach = true;
+        } else {
+            // Failed to attach, cancel
+            return false;
+        }
+    } else if (JNI_OK == res) {
+        // Current thread already attached, do not attach 'again' (just to save the attachedHere flag)
+        // We make sure to keep attached = 0
+        needsToDetach = false;
+    } else {
+        // JNI_EVERSION, specified version is not supported cancel this..
+        return false;
+    }
+    return true;
+}
+
+void JVM_MANAGER::detachJVM() {
+    if (needsToDetach) {
+        jvm->DetachCurrentThread();
+    }
+}
diff --git a/app/src/main/java/libengine/JVM_MANAGER.h b/app/src/main/java/libengine/JVM_MANAGER.h
new file mode 100644
index 00000000..b16824db
--- /dev/null
+++ b/app/src/main/java/libengine/JVM_MANAGER.h
@@ -0,0 +1,26 @@
+//
+// Created by Matthew Good on 29/6/21.
+//
+
+#ifndef GRAPHICAL_TOOL_KIT_JVM_MANAGER_H
+#define GRAPHICAL_TOOL_KIT_JVM_MANAGER_H
+#include <jni.h>
+
+class JVM_MANAGER {
+public:
+    JavaVM * jvm;
+    JNIEnv* jenv;
+    JavaVMAttachArgs jvmArgs;
+    bool needsToDetach;
+    
+    JVM_MANAGER();
+    bool getJVM(JNIEnv * env);
+    bool attachJVM();
+    void detachJVM();
+    
+    template <typename J, typename O> O globalRef(J j, O o) {
+        return reinterpret_cast<O>(j->NewGlobalRef(o));
+    }
+};
+
+#endif //GRAPHICAL_TOOL_KIT_JVM_MANAGER_H
diff --git a/app/src/main/java/libengine/native.cpp b/app/src/main/java/libengine/native.cpp
new file mode 100644
index 00000000..3002e6a9
--- /dev/null
+++ b/app/src/main/java/libengine/native.cpp
@@ -0,0 +1,213 @@
+#include <string>
+#include <jni.h>
+
+#include <Log.h>
+
+#include "AppInstanceAndroidBase.h"
+#include "DiligentLog/Primitives/interface/Errors.hpp"
+
+//MultiTouch multiTouch;
+
+struct Renderer : AppInstanceAndroidBase {
+    void onEglSetup(JNIEnv *jenv, jobject classInstance, jstring name, jstring signature) override {
+      AppInstancePlatformBase::onEglSetup(jenv, classInstance, name, signature);
+    }
+    void onEglTearDown() {
+      destroyResources();
+      AppInstancePlatformBase::onEglTearDown();
+    }
+    void surfaceChanged(int w, int h) {
+      
+    }
+    void onDraw() {
+      swapBuffers();
+    }
+    //bool onTouchEvent(MultiTouch & touchEvent);
+    void swapBuffers() {
+      AppInstancePlatformBase::swapBuffers();
+    }
+    void destroyResources() {
+      
+    }
+    ~Renderer() {
+      destroyResources();
+    }
+};
+
+#if PLATFORM_ANDROID
+
+#define APP(jlong) reinterpret_cast<AppInstance*>(jlong)
+#define JLONG(ptr) reinterpret_cast<jlong>(ptr)
+
+extern "C" JNIEXPORT jlong JNICALL
+Java_smallville7123_graphical_tool_kit_DiligentEngineView_00024DiligentEngineRenderer_createNativeInstance (
+        JNIEnv * env, jobject thiz
+)
+{
+    // multiTouch.setMaxSupportedTouches(10);
+    LOG_ERROR_MESSAGE("CREATE APP");
+    return JLONG(new Renderer());
+}
+
+extern "C" JNIEXPORT void JNICALL
+Java_smallville7123_graphical_tool_kit_DiligentEngineView_00024DiligentEngineRenderer_destroyNativeInstance (
+        JNIEnv * env, jobject thiz, jlong instance
+)
+{
+    LOG_ERROR_MESSAGE("DESTROY APP");
+    delete APP(instance);
+}
+
+extern "C" JNIEXPORT void JNICALL
+Java_smallville7123_graphical_tool_kit_DiligentEngineView_00024DiligentEngineRenderer_onEglSetup (
+        JNIEnv * env, jobject thiz, jlong instance, jobject class_instance, jstring name,
+        jstring signature
+)
+{
+    LOG_ERROR_MESSAGE("EGL SETUP");
+    APP(instance)->onEglSetup(env, class_instance, name, signature);
+}
+
+extern "C" JNIEXPORT void JNICALL
+Java_smallville7123_graphical_tool_kit_DiligentEngineView_00024DiligentEngineRenderer_surfaceChanged (
+        JNIEnv * env, jobject thiz, jlong instance, jint w, jint h
+)
+{
+    LOG_ERROR_MESSAGE("EGL SURFACE CHANGE");
+    APP(instance)->surfaceChanged(w, h);
+}
+
+extern "C" JNIEXPORT void JNICALL
+Java_smallville7123_graphical_tool_kit_DiligentEngineView_00024DiligentEngineRenderer_addTouch__JFF(
+        JNIEnv * env, jobject thiz,
+        jlong identifier, jfloat x, jfloat y
+)
+{
+    multiTouch.addTouch(identifier, x, y);
+}
+
+extern "C" JNIEXPORT void JNICALL
+Java_smallville7123_graphical_tool_kit_DiligentEngineView_00024DiligentEngineRenderer_addTouch__JFFF (
+        JNIEnv * env, jobject thiz,
+        jlong identifier, jfloat x, jfloat y, jfloat size
+)
+{
+    multiTouch.addTouch(identifier, x, y, size);
+}
+
+extern "C" JNIEXPORT void JNICALL
+Java_smallville7123_graphical_tool_kit_DiligentEngineView_00024DiligentEngineRenderer_addTouch__JFFFF (
+        JNIEnv * env, jobject thiz,
+        jlong identifier, jfloat x, jfloat y, jfloat size, jfloat pressure
+)
+{
+    multiTouch.addTouch(identifier, x, y, size, pressure);
+}
+
+extern "C" JNIEXPORT void JNICALL
+Java_smallville7123_graphical_tool_kit_DiligentEngineView_00024DiligentEngineRenderer_moveTouch__JFF (
+        JNIEnv * env, jobject thiz,
+        jlong identifier, jfloat x, jfloat y
+)
+{
+    multiTouch.moveTouch(identifier, x, y);
+}
+
+extern "C" JNIEXPORT void JNICALL
+Java_smallville7123_graphical_tool_kit_DiligentEngineView_00024DiligentEngineRenderer_moveTouch__JFFF (
+        JNIEnv * env, jobject thiz,
+        jlong identifier, jfloat x, jfloat y, jfloat size
+)
+{
+    multiTouch.moveTouch(identifier, x, y, size);
+}
+
+extern "C" JNIEXPORT void JNICALL
+Java_smallville7123_graphical_tool_kit_DiligentEngineView_00024DiligentEngineRenderer_moveTouch__JFFFF (
+        JNIEnv * env, jobject thiz,
+        jlong identifier, jfloat x, jfloat y, jfloat size, jfloat pressure
+)
+{
+    multiTouch.moveTouch(identifier, x, y, size, pressure);
+}
+
+extern "C" JNIEXPORT void JNICALL
+Java_smallville7123_graphical_tool_kit_DiligentEngineView_00024DiligentEngineRenderer_removeTouch__JFF (
+        JNIEnv * env, jobject thiz,
+        jlong identifier, jfloat x, jfloat y
+)
+{
+    multiTouch.removeTouch(identifier, x, y);
+}
+
+extern "C" JNIEXPORT void JNICALL
+Java_smallville7123_graphical_tool_kit_DiligentEngineView_00024DiligentEngineRenderer_removeTouch__JFFF (
+        JNIEnv * env, jobject thiz,
+        jlong identifier, jfloat x, jfloat y, jfloat size
+)
+{
+    multiTouch.removeTouch(identifier, x, y, size);
+}
+
+extern "C" JNIEXPORT void JNICALL
+Java_smallville7123_graphical_tool_kit_DiligentEngineView_00024DiligentEngineRenderer_removeTouch__JFFFF (
+        JNIEnv * env, jobject thiz,
+        jlong identifier, jfloat x, jfloat y, jfloat size, jfloat pressure
+)
+{
+    multiTouch.removeTouch(identifier, x, y, size, pressure);
+}
+
+extern "C" JNIEXPORT void JNICALL
+Java_smallville7123_graphical_tool_kit_DiligentEngineView_00024DiligentEngineRenderer_cancelTouch__JFF (
+        JNIEnv * env, jobject thiz,
+        jlong identifier, jfloat x, jfloat y
+)
+{
+    multiTouch.cancelTouch(identifier, x, y);
+}
+
+extern "C" JNIEXPORT void JNICALL
+Java_smallville7123_graphical_tool_kit_DiligentEngineView_00024DiligentEngineRenderer_cancelTouch__JFFF (
+        JNIEnv * env, jobject thiz,
+        jlong identifier, jfloat x, jfloat y, jfloat size
+)
+{
+    multiTouch.cancelTouch(identifier, x, y, size);
+}
+
+extern "C" JNIEXPORT void JNICALL
+Java_smallville7123_graphical_tool_kit_DiligentEngineView_00024DiligentEngineRenderer_cancelTouch__JFFFF (
+        JNIEnv * env, jobject thiz,
+        jlong identifier, jfloat x, jfloat y, jfloat size, jfloat pressure
+)
+{
+    multiTouch.cancelTouch(identifier, x, y, size, pressure);
+}
+
+extern "C" JNIEXPORT jboolean JNICALL
+Java_smallville7123_graphical_tool_kit_DiligentEngineView_00024DiligentEngineRenderer_onTouchEvent (
+        JNIEnv * env, jobject thiz, jlong instance
+)
+{
+    return APP(instance)->onTouchEvent(multiTouch);
+}
+
+extern "C" JNIEXPORT void JNICALL
+Java_smallville7123_graphical_tool_kit_DiligentEngineView_00024DiligentEngineRenderer_onDraw (
+        JNIEnv * env, jobject thiz, jlong instance
+)
+{
+    APP(instance)->onDraw();
+}
+
+extern "C" JNIEXPORT void JNICALL
+Java_smallville7123_graphical_tool_kit_DiligentEngineView_00024DiligentEngineRenderer_onEglTearDown (
+        JNIEnv * env, jobject thiz, jlong instance
+)
+{
+    LOG_ERROR_MESSAGE("EGL TEAR DOWN");
+    APP(instance)->onEglTearDown();
+}
+
+#endif
\ No newline at end of file
diff --git a/app/src/main/java/linux/kernel/MainActivity.kt b/app/src/main/java/linux/kernel/MainActivity.kt
new file mode 100644
index 00000000..1324ed60
--- /dev/null
+++ b/app/src/main/java/linux/kernel/MainActivity.kt
@@ -0,0 +1,95 @@
+package linux.kernel
+
+// proot -
+// https://github.com/bilbilaki/Tiny-Vterm/blob/main/vterm/src/main/java/com/vectras/vterm/Terminal.java
+
+import alpine.term.TerminalController
+import alpine.term.terminal_view.TerminalView
+import android.os.Bundle
+import android.view.ContextMenu
+import android.view.ContextMenu.ContextMenuInfo
+import android.view.Menu
+import android.view.MenuItem
+import android.view.View
+import android.widget.Button
+import androidx.appcompat.app.AppCompatActivity
+import liblayout.Builder
+import liblayout.UiThread
+import android.opengl.GLSurfaceView
+import smallville7123.graphical.tool.kit.DiligentEngineView
+
+class MainActivity : AppCompatActivity() {
+
+    var terminalController: TerminalController? = null
+    var engineView : DiligentEngineView? = null;
+
+    override fun onCreate(savedInstanceState: Bundle?) {
+        super.onCreate(savedInstanceState)
+        
+        engineView = DiligentEngineView(this)
+
+        // If this method is called more than once with the same library name
+        // the second and subsequent calls are ignored.
+
+        // set log view
+        setContentView(R.layout.slide_out_terminal)
+
+        // obtain log view instance
+        terminalController = TerminalController()
+        terminalController!!.onCreate(this, findViewById<TerminalView>(R.id.terminal_view))
+
+        when(terminalController!!.terminalContainer.visibility) {
+            View.INVISIBLE -> findViewById<Button>(R.id.toggle_terminal).setText(R.string.Show_LogTerminal)
+            else -> findViewById<Button>(R.id.toggle_terminal).setText(R.string.Hide_LogTerminal)
+        }
+
+        findViewById<Button>(R.id.toggle_terminal).setOnClickListener {
+            terminalController!!.onClick(findViewById<Button>(R.id.toggle_terminal))
+        }
+
+        Builder(this, findViewById<View>(R.id.mainView))
+            .row().column { engineView }
+            .build()
+    }
+
+    override fun onStart() {
+        super.onStart()
+        terminalController!!.onStart()
+    }
+
+    override fun onResume() {
+        super.onResume()
+        engineView.onStart();
+    }
+
+    override fun onPause() {
+        super.onPause()
+        engineView.onPause();
+    }
+
+    override fun onStop() {
+        super.onStop()
+        terminalController!!.onStop()
+    }
+
+    override fun onDestroy() {
+        terminalController!!.onDestroy()
+        super.onDestroy()
+    }
+
+    override fun onCreateContextMenu(
+        menu: ContextMenu?,
+        v: View?,
+        menuInfo: ContextMenuInfo?
+    ) {
+        terminalController!!.onCreateContextMenu(menu, v, menuInfo)
+    }
+
+    override fun onContextItemSelected(item: MenuItem?): Boolean {
+        return terminalController!!.onContextItemSelected(item) || super.onContextItemSelected(item)
+    }
+
+    override fun onBackPressed() {
+        if (!terminalController!!.onBackPressed()) super.onBackPressed()
+    }
+}
diff --git a/app/src/main/java/media/player/pro/UpdatingTextView.kt b/app/src/main/java/linux/kernel/UpdatingTextView.kt
similarity index 98%
rename from app/src/main/java/media/player/pro/UpdatingTextView.kt
rename to app/src/main/java/linux/kernel/UpdatingTextView.kt
index 229660a3..5d569e14 100644
--- a/app/src/main/java/media/player/pro/UpdatingTextView.kt
+++ b/app/src/main/java/linux/kernel/UpdatingTextView.kt
@@ -1,4 +1,4 @@
-package media.player.pro
+package linux.kernel
 
 import android.content.Context
 import android.graphics.Canvas
diff --git a/app/src/main/java/media/player/pro/MainActivity.kt b/app/src/main/java/media/player/pro/MainActivity.kt
deleted file mode 100644
index 68bc1f72..00000000
--- a/app/src/main/java/media/player/pro/MainActivity.kt
+++ /dev/null
@@ -1,170 +0,0 @@
-package media.player.pro
-
-import alpine.term.TerminalController
-import alpine.term.terminal_view.TerminalView
-import android.os.Bundle
-import android.view.ContextMenu
-import android.view.ContextMenu.ContextMenuInfo
-import android.view.Menu
-import android.view.MenuItem
-import android.view.View
-import android.widget.Button
-import androidx.appcompat.app.AppCompatActivity
-import liblayout.Builder
-import liblayout.UiThread
-import libmedia.Media
-
-class MainActivity : AppCompatActivity() {
-
-    var media: Media? = null
-    var terminalController: TerminalController? = null
-
-
-    override fun onCreate(savedInstanceState: Bundle?) {
-        super.onCreate(savedInstanceState)
-
-        // If this method is called more than once with the same library name
-        // the second and subsequent calls are ignored.
-
-        // set log view
-        setContentView(R.layout.slide_out_terminal)
-
-        // obtain log view instance
-        terminalController = TerminalController()
-        terminalController!!.onCreate(this, findViewById<TerminalView>(R.id.terminal_view))
-
-        when(terminalController!!.terminalContainer.visibility) {
-            View.INVISIBLE -> findViewById<Button>(R.id.toggle_terminal).setText(R.string.Show_LogTerminal)
-            else -> findViewById<Button>(R.id.toggle_terminal).setText(R.string.Hide_LogTerminal)
-        }
-
-        findViewById<Button>(R.id.toggle_terminal).setOnClickListener {
-            terminalController!!.onClick(findViewById<Button>(R.id.toggle_terminal))
-        }
-
-        media = Media(this).also {
-            it.init()
-            it.loadMediaAssetAsFile("00001313_48000.raw")
-            it.loop(true)
-        }
-
-        Builder(this, findViewById<View>(R.id.mainView))
-            .row().height(80)
-            .column {
-                media!!.WaveformView(
-                    context = this,
-                    height = it.sizeFromTop,
-                    width = it.sizeFromLeft,
-                    media = media!!
-                )
-            }
-            .row().height(10).column {
-                UpdatingTextView(this).also {
-                    it.addOnFirstDrawAction {
-                        it.text = "Time:                      0\n" +
-                                "current frame :                0\n" +
-                                "Audio Timing NANO :            0\n" +
-                                "Audio Timing MICRO:            0\n" +
-                                "Audio Timing MILLI:            0\n" +
-                                "Audio Timing Format NANO :     0\n" +
-                                "Audio Timing Format MICRO:     0\n" +
-                                "Audio Timing Format MILLI:     0\n" +
-                                "Audio Timing Chrono NANO :     0\n" +
-                                "Audio Timing Chrono MICRO:     0\n" +
-                                "Audio Timing Chrono MILLI:     0\n" +
-                                "underruns:                     0\n" +
-                                "buffer size:                   0\n" +
-                                "buffer capacity:               0\n" +
-                                "frame bursts in buffer:        0\n" +
-                                "frames per burst:              0"
-                    }
-                    it.addOnDrawAction {
-                        it.text = "Time:                      ${media!!.Oboe_getCurrentTime()}\n" +
-                                "current frame :                ${media!!.Oboe_getCurrentFrame()}\n" +
-                                "Audio Timing NANO :            ${media!!.Oboe_getAudioTimingNANO()}\n" +
-                                "Audio Timing MICRO:            ${media!!.Oboe_getAudioTimingMICRO()}\n" +
-                                "Audio Timing MILLI:            ${media!!.Oboe_getAudioTimingMILLI()}\n" +
-                                "Audio Timing Format NANO :     ${media!!.Oboe_getAudioTimingFormatNANO()}\n" +
-                                "Audio Timing Format MICRO:     ${media!!.Oboe_getAudioTimingFormatMICRO()}\n" +
-                                "Audio Timing Format MILLI:     ${media!!.Oboe_getAudioTimingFormatMILLI()}\n" +
-                                "Audio Timing Chrono NANO :     ${media!!.Oboe_getAudioTimingChronoNANO()}\n" +
-                                "Audio Timing Chrono MICRO:     ${media!!.Oboe_getAudioTimingChronoMICRO()}\n" +
-                                "Audio Timing Chrono MILLI:     ${media!!.Oboe_getAudioTimingChronoMILLI()}\n" +
-                                "underruns:                     ${media!!.Oboe_underrunCount()}\n" +
-                                "buffer size:                   ${media!!.Oboe_bufferSize()}\n" +
-                                "buffer capacity:               ${media!!.Oboe_bufferCapacity()}\n" +
-                                "frame bursts in buffer:        ${
-                                media!!.Oboe_bufferCapacity() / media!!.Oboe_framesPerBurst()
-                                }\n" +
-                                "frames per burst:              ${media!!.Oboe_framesPerBurst()}"
-                    }
-                }
-            }
-            .row().height(10)
-            .column {
-                Button(this).also {
-                    media!!.Listner.play = {
-                        it.text = "playing"
-                    }
-                    media!!.Listner.pause = {
-                        it.text = "paused"
-                    }
-                    media!!.Listner.stop = {
-                        it.text = "stopped"
-                    }
-                    it.setOnClickListener {
-                        if (media!!.isPlaying) media!!.pause()
-                        else media!!.play()
-                    }
-                    when {
-                        media!!.isPlaying -> it.text = "playing"
-                        media!!.isPaused -> it.text = "paused"
-                        media!!.isStopped -> it.text = "stopped"
-                    }
-                }
-            }
-            .build()
-    }
-
-    override fun onStart() {
-        super.onStart()
-        terminalController!!.onStart()
-    }
-
-    override fun onResume() {
-        super.onResume()
-        media!!.foreground()
-    }
-
-    override fun onPause() {
-        super.onPause()
-        media!!.background()
-    }
-
-    override fun onStop() {
-        super.onStop()
-        terminalController!!.onStop()
-    }
-
-    override fun onDestroy() {
-        media!!.destroy()
-        terminalController!!.onDestroy()
-        super.onDestroy()
-    }
-
-    override fun onCreateContextMenu(
-        menu: ContextMenu?,
-        v: View?,
-        menuInfo: ContextMenuInfo?
-    ) {
-        terminalController!!.onCreateContextMenu(menu, v, menuInfo)
-    }
-
-    override fun onContextItemSelected(item: MenuItem?): Boolean {
-        return terminalController!!.onContextItemSelected(item) || super.onContextItemSelected(item)
-    }
-
-    override fun onBackPressed() {
-        if (!terminalController!!.onBackPressed()) super.onBackPressed()
-    }
-}
diff --git a/app/src/main/java/smallville7123/EGLSurfaceView_EGLTextureView/EGLSurfaceView.java b/app/src/main/java/smallville7123/EGLSurfaceView_EGLTextureView/EGLSurfaceView.java
new file mode 100644
index 00000000..4271209e
--- /dev/null
+++ b/app/src/main/java/smallville7123/EGLSurfaceView_EGLTextureView/EGLSurfaceView.java
@@ -0,0 +1,2426 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package smallville7123.EGLSurfaceView_EGLTextureView;
+
+import android.content.Context;
+import android.content.pm.ConfigurationInfo;
+import android.graphics.PixelFormat;
+import android.opengl.EGL14;
+import android.opengl.EGLExt;
+import android.opengl.GLDebugHelper;
+import android.os.SystemClock;
+import android.text.TextUtils;
+import android.util.AttributeSet;
+import android.util.Log;
+import android.view.Choreographer;
+import android.view.Surface;
+import android.view.SurfaceHolder;
+import android.view.SurfaceView;
+
+import androidx.annotation.CallSuper;
+import androidx.annotation.NonNull;
+
+import java.io.BufferedReader;
+import java.io.InputStreamReader;
+import java.io.Writer;
+import java.lang.ref.WeakReference;
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Map;
+
+import javax.microedition.khronos.egl.EGL10;
+import javax.microedition.khronos.egl.EGL11;
+import javax.microedition.khronos.egl.EGLConfig;
+import javax.microedition.khronos.egl.EGLContext;
+import javax.microedition.khronos.egl.EGLDisplay;
+import javax.microedition.khronos.egl.EGLSurface;
+import javax.microedition.khronos.opengles.GL;
+import javax.microedition.khronos.opengles.GL10;
+
+/**
+ * An implementation of SurfaceView that uses the dedicated surface for
+ * displaying OpenGL rendering.
+ * <p>
+ * A EGLSurfaceView provides the following features:
+ * <p>
+ * <ul>
+ * <li>Manages a surface, which is a special piece of memory that can be
+ * composited into the Android view system.
+ * <li>Manages an EGL display, which enables OpenGL to render into a surface.
+ * <li>Accepts a user-provided Renderer object that does the actual rendering.
+ * <li>Renders on a dedicated thread to decouple rendering performance from the
+ * UI thread.
+ * <li>Supports both on-demand and continuous rendering.
+ * <li>Optionally wraps, traces, and/or error-checks the renderer's OpenGL calls.
+ * </ul>
+ *
+ * <div class="special reference">
+ * <h3>Developer Guides</h3>
+ * <p>For more information about how to use OpenGL, read the
+ * <a href="{@docRoot}guide/topics/graphics/opengl.html">OpenGL</a> developer guide.</p>
+ * </div>
+ *
+ * <h3>Using EGLSurfaceView</h3>
+ * <p>
+ * Typically you use EGLSurfaceView by subclassing it and overriding one or more of the
+ * View system input event methods. If your application does not need to override event
+ * methods then EGLSurfaceView can be used as-is. For the most part
+ * EGLSurfaceView behavior is customized by calling "set" methods rather than by subclassing.
+ * For example, unlike a regular View, drawing is delegated to a separate Renderer object which
+ * is registered with the EGLSurfaceView
+ * using the {@link #setRenderer(Renderer)} call.
+ * <p>
+ * <h3>Initializing EGLSurfaceView</h3>
+ * All you have to do to initialize a EGLSurfaceView is call {@link #setRenderer(Renderer)}.
+ * However, if desired, you can modify the default behavior of EGLSurfaceView by calling one or
+ * more of these methods before calling setRenderer:
+ * <ul>
+ * <li>{@link #setDebugFlags(int)}
+ * <li>{@link #setEGLConfigChooser(boolean)}
+ * <li>{@link #setEGLConfigChooser(EGLConfigChooser)}
+ * <li>{@link #setEGLConfigChooser(int, int, int, int, int, int)}
+ * <li>{@link #setGLWrapper(GLWrapper)}
+ * </ul>
+ * <p>
+ * <h4>Specifying the android.view.Surface</h4>
+ * By default EGLSurfaceView will create a PixelFormat.RGB_888 format surface. If a translucent
+ * surface is required, call getHolder().setFormat(PixelFormat.TRANSLUCENT).
+ * The exact format of a TRANSLUCENT surface is device dependent, but it will be
+ * a 32-bit-per-pixel surface with 8 bits per component.
+ * <p>
+ * <h4>Choosing an EGL Configuration</h4>
+ * A given Android device may support multiple EGLConfig rendering configurations.
+ * The available configurations may differ in how may channels of data are present, as
+ * well as how many bits are allocated to each channel. Therefore, the first thing
+ * EGLSurfaceView has to do when starting to render is choose what EGLConfig to use.
+ * <p>
+ * By default EGLSurfaceView chooses a EGLConfig that has an RGB_888 pixel format,
+ * with at least a 16-bit depth buffer and no stencil.
+ * <p>
+ * If you would prefer a different EGLConfig
+ * you can override the default behavior by calling one of the
+ * setEGLConfigChooser methods.
+ * <p>
+ * <h4>Debug Behavior</h4>
+ * You can optionally modify the behavior of EGLSurfaceView by calling
+ * one or more of the debugging methods {@link #setDebugFlags(int)},
+ * and {@link #setGLWrapper}. These methods may be called before and/or after setRenderer, but
+ * typically they are called before setRenderer so that they take effect immediately.
+ * <p>
+ * <h4>Setting a Renderer</h4>
+ * Finally, you must call {@link #setRenderer} to register a {@link Renderer}.
+ * The renderer is
+ * responsible for doing the actual OpenGL rendering.
+ * <p>
+ * <h3>Rendering Mode</h3>
+ * Once the renderer is set, you can control whether the renderer draws
+ * continuously or on-demand by calling
+ * {@link #setRenderMode}. The default is continuous rendering.
+ * <p>
+ * <h3>Activity Life-cycle</h3>
+ * A EGLSurfaceView must be notified when the activity is paused and resumed. EGLSurfaceView clients
+ * are required to call {@link #onPause()} when the activity pauses and
+ * {@link #onResume()} when the activity resumes. These calls allow EGLSurfaceView to
+ * pause and resume the rendering thread, and also allow EGLSurfaceView to release and recreate
+ * the OpenGL display.
+ * <p>
+ * <h3>Handling events</h3>
+ * <p>
+ * To handle an event you will typically subclass EGLSurfaceView and override the
+ * appropriate method, just as you would with any other View. However, when handling
+ * the event, you may need to communicate with the Renderer object
+ * that's running in the rendering thread. You can do this using any
+ * standard Java cross-thread communication mechanism. In addition,
+ * one relatively easy way to communicate with your renderer is
+ * to call
+ * {@link #queueEvent(Runnable)}. For example:
+ * <pre class="prettyprint">
+ * class MyEGLSurfaceView extends EGLSurfaceView {
+ *
+ *     private MyRenderer mMyRenderer;
+ *
+ *     public void start() {
+ *         mMyRenderer = ...;
+ *         setRenderer(mMyRenderer);
+ *     }
+ *
+ *     public boolean onKeyDown(int keyCode, KeyEvent event) {
+ *         if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {
+ *             queueEvent(new Runnable() {
+ *                 // This method will be called on the rendering
+ *                 // thread:
+ *                 public void run() {
+ *                     mMyRenderer.handleDpadCenter();
+ *                 }});
+ *             return true;
+ *         }
+ *         return super.onKeyDown(keyCode, event);
+ *     }
+ * }
+ * </pre>
+ *
+ */
+public class EGLSurfaceView extends SurfaceView implements SurfaceHolder.Callback {
+    private final static String TAG = "EGLSurfaceView";
+
+    private final static boolean LOG_ATTACH_DETACH = false;
+    private final static boolean LOG_THREADS = false;
+    private final static boolean LOG_PAUSE_RESUME = false;
+    private final static boolean LOG_SURFACE = false;
+    private final static boolean LOG_RENDERER = false;
+    private final static boolean LOG_RENDERER_DRAW_FRAME = false;
+    private final static boolean LOG_EGL = false;
+    /**
+     * The renderer only renders
+     * when the surface is created, or when {@link #requestRender} is called.
+     *
+     * @see #getRenderMode()
+     * @see #setRenderMode(int)
+     * @see #requestRender()
+     */
+    public final static int RENDERMODE_WHEN_DIRTY = 0;
+    /**
+     * The renderer is called
+     * continuously to re-render the scene.
+     *
+     * @see #getRenderMode()
+     * @see #setRenderMode(int)
+     */
+    public final static int RENDERMODE_CONTINUOUSLY = 1;
+
+    /**
+     * Check glError() after every GL call and throw an exception if glError indicates
+     * that an error has occurred. This can be used to help track down which OpenGL ES call
+     * is causing an error.
+     *
+     * @see #getDebugFlags
+     * @see #setDebugFlags
+     */
+    public final static int DEBUG_CHECK_GL_ERROR = 1;
+
+    /**
+     * Log GL calls to the system log at "verbose" level with tag "EGLSurfaceView".
+     *
+     * @see #getDebugFlags
+     * @see #setDebugFlags
+     */
+    public final static int DEBUG_LOG_GL_CALLS = 2;
+
+    /**
+     * Standard View constructor. In order to render something, you
+     * must call {@link #setRenderer} to register a renderer.
+     */
+    public EGLSurfaceView(Context context) {
+        super(context);
+        init();
+    }
+
+    /**
+     * Standard View constructor. In order to render something, you
+     * must call {@link #setRenderer} to register a renderer.
+     */
+    public EGLSurfaceView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        init();
+    }
+
+    @Override
+    @CallSuper
+    protected void finalize() throws Throwable {
+        try {
+            if (mGLThread != null) {
+                // GLThread may still be running if this view was never
+                // attached to a window.
+                mGLThread.requestExitAndWait();
+            }
+        } finally {
+            super.finalize();
+        }
+    }
+
+    private class Methods {
+        private final Class<EGLSurfaceView> clazz;
+        Method swapBuffersMethod;
+        String swapBuffersName;
+        String swapBuffersSignature;
+        Methods() {
+            clazz = EGLSurfaceView.class;
+            try {
+                swapBuffersMethod = clazz.getDeclaredMethod("swapBuffers");
+            } catch (NoSuchMethodException e) {
+                throw new RuntimeException("cannot find own methods");
+            }
+            swapBuffersName = swapBuffersMethod.getName();
+            swapBuffersSignature = "()V";
+        }
+    }
+
+    private Methods methods;
+
+    public enum METHOD {
+        SWAP_BUFFERS
+    }
+
+    public final String getJavaNameForJNI(METHOD METHOD) {
+        switch (METHOD) {
+            case SWAP_BUFFERS:
+                return methods.swapBuffersName;
+        }
+        return null;
+    }
+
+    public final String getJavaSignatureForJNI(METHOD METHOD) {
+        switch (METHOD) {
+            case SWAP_BUFFERS:
+                return methods.swapBuffersSignature;
+        }
+        return null;
+    }
+
+    private final Choreographer choreographer = Choreographer.getInstance();
+    private final Object VSYNC_LOCK = new Object();
+    private boolean vsynced;
+    private boolean shouldSwap;
+
+    /**
+     * Requests that the render thread swaps its buffers
+     * <br><br>
+     * The buffers will be swapped either when the current draw completes,
+     * or when the next draw completes
+     * <br><br>
+     * Subsequent calls in the same frame has no effect
+     * <br><br>
+     * This may be called from any thread
+     * <br><br>
+     * <br><br>
+     * Ensures that the render thread calls:
+     * <code>eglSwapBuffers(EGLDisplay, EGLSurface)</code>
+     * <br><br>
+     * <br><br>
+     * If you need to call this method from jni,
+     * please adapt your code to use the following
+     * <br><br>
+     *     Java:
+     * <pre class="prettyprint">
+     * {@literal @Override}
+     * public class Example extends EGLSurfaceView {
+     *     // ...
+     *     class ExampleRenderer implements Renderer {
+     *         native long createNativeInstance();
+     *         native void onEglSetup(long instance, Object classInstance, String name, String signature);
+     *         native void surfaceChanged(long instance, int w, int h);
+     *         native void onDraw(long instance);
+     *         native void onEglTearDown(long instance);
+     *         long nativeInstance;
+     *
+     *         ExampleRenderer() {
+     *             System.loadLibrary("YourNativeLibrary");
+     *             nativeInstance = createNativeInstance();
+     *         }
+     *
+     *         {@literal @Override}
+     *         public void onEglSetup() {
+     *             onEglSetup(nativeInstance, Example.this,
+     *                     getJavaNameForJNI(METHOD.SWAP_BUFFERS),
+     *                     getJavaSignatureForJNI(METHOD.SWAP_BUFFERS)
+     *             );
+     *         }
+     *
+     *         {@literal @Override}
+     *         public void onEglTearDown() {
+     *             onEglTearDown(nativeInstance);
+     *         }
+     *
+     *         {@literal @Override}
+     *         public void onSurfaceChanged(GL10 gl, int width, int height) {
+     *             surfaceChanged(nativeInstance, width, height);
+     *         }
+     *
+     *         {@literal @Override}
+     *         public void onDrawFrame(GL10 gl) {
+     *             onDraw(nativeInstance);
+     *         }
+     *     }
+     * }
+     * </pre>
+     *     Jni Header file:
+     * <pre class="prettyprint">
+     * class Example {
+     *     class JVM_MANAGER {
+     *     public:
+     *         JavaVM * jvm;
+     *         JNIEnv* jenv;
+     *         JavaVMAttachArgs jvmArgs;
+     *         bool needsToDetach;
+     *
+     *         JVM_MANAGER();
+     *         bool getJVM(JNIEnv * env);
+     *         bool attachJVM();
+     *         void detachJVM();
+     *
+     *         template <typename J, typename O> O globalRef(J j, O o) {
+     *             return reinterpret_cast<O>(j->NewGlobalRef(o));
+     *         }
+     *     };
+     *
+     *
+     *     JVM_MANAGER jvmManager;
+     *     jobject jObject;
+     *     jclass jClass;
+     *     jmethodID jSwapBuffers;
+     * }
+     * </pre>
+     *     Jni CPP file:
+     * <pre class="prettyprint">
+     * Example::JVM_MANAGER::JVM_MANAGER() {
+     *     jvm = nullptr;
+     *     jenv = nullptr;
+     *     needsToDetach = false;
+     *     jvmArgs.version = JNI_VERSION_1_6;
+     * }
+     *
+     * bool Example::JVM_MANAGER::getJVM(JNIEnv *env) {
+     *     return env->GetJavaVM(&jvm) == JNI_OK;
+     * }
+     *
+     * bool Example::JVM_MANAGER::attachJVM() {
+     *     // checks if current env needs attaching or it is already attached
+     *     jint res = jvm->GetEnv((void**)&jenv, JNI_VERSION_1_6);
+     *     if (res == JNI_EDETACHED) {
+     *         // Supported but not attached yet, needs to call AttachCurrentThread
+     *         res = jvm->AttachCurrentThread(&jenv, &jvmArgs);
+     *         if (res == JNI_OK) {
+     *             needsToDetach = true;
+     *         } else {
+     *             // Failed to attach, cancel
+     *             return false;
+     *         }
+     *     } else if (JNI_OK == res) {
+     *         // Current thread already attached, do not attach 'again' (just to save the attachedHere flag)
+     *         // We make sure to keep attached = 0
+     *         needsToDetach = false;
+     *     } else {
+     *         // JNI_EVERSION, specified version is not supported cancel this..
+     *         return false;
+     *     }
+     *     return true;
+     * }
+     *
+     * void Example::JVM_MANAGER::detachJVM() {
+     *     if (needsToDetach) {
+     *         jvm->DetachCurrentThread();
+     *     }
+     * }
+     * 
+     * Example::Example(JNIEnv *jenv, jobject classInstance, jstring name, jstring signature) {
+     *     if (!jvmManager.getJVM(jenv)) {
+     *         // failed to get JavaVM
+     *         return;
+     *     }
+     *     if (!jvmManager.attachJVM()) {
+     *         // failed to attach JVM
+     *         return;
+     *     }
+     *     jObject = jvmManager.globalRef(jenv, classInstance);
+     *     jClass = jvmManager.globalRef(jenv, jenv->GetObjectClass(jObject));
+     *     jboolean isCopy1, isCopy2;
+     *
+     *     if (name == nullptr) {
+     *          // cannot use a null name (0x0)
+     *         return;
+     *     }
+     *
+     *     if (signature == nullptr) {
+     *         // cannot use a null signature (0x0)
+     *         return;
+     *     }
+     *
+     *     const char * n = jvmManager.jenv->GetStringUTFChars(name, &isCopy1);
+     *     if (n == nullptr) {
+     *         // cannot get UTF chars from name
+     *         return;
+     *     }
+     *
+     *     const char * s = jvmManager.jenv->GetStringUTFChars(signature, &isCopy2);
+     *     if (s == nullptr) {
+     *         // cannot get UTF chars from signature
+     *         jvmManager.jenv->ReleaseStringUTFChars(name, n);
+     *         return;
+     *     }
+     *
+     *     jSwapBuffers = jvmManager.jenv->GetMethodID(jClass, n, s);
+     *
+     *     jvmManager.jenv->ReleaseStringUTFChars(name, n);
+     *     jvmManager.jenv->ReleaseStringUTFChars(name, s);
+     *
+     *     if (jSwapBuffers == nullptr) {
+     *         // cannot find method with name 'name', and signature 'signature'
+     *     }
+     * }
+     *
+     * Example::~Example() {
+     *     jvmManager.jenv->DeleteGlobalRef(jClass);
+     *     jvmManager.jenv->DeleteGlobalRef(jObject);
+     *     jvmManager.detachJVM();
+     * }
+     *
+     * void Example::swapBuffers() {
+     *     if (jSwapBuffers != nullptr) {
+     *         jvmManager.jenv->CallVoidMethod(jObject, jSwapBuffers);
+     *     }
+     * }
+     * </pre>
+     */
+    protected final void swapBuffers() {
+        synchronized (VSYNC_LOCK) {
+            if (!shouldSwap) {
+                shouldSwap = true;
+            }
+        }
+    }
+
+    @CallSuper
+    protected void init() {
+        shouldSwap = false;
+
+        // provides info for jni to java
+        methods = new Methods();
+
+        choreographer.postFrameCallback(
+                new Choreographer.FrameCallback() {
+                    /**
+                     * Called when a new display frame is being rendered.
+                     * <p>
+                     * This method provides the time in nanoseconds when the frame started being rendered.
+                     * The frame time provides a stable time base for synchronizing animations
+                     * and drawing.  It should be used instead of {@link SystemClock#uptimeMillis()}
+                     * or {@link System#nanoTime()} for animations and drawing in the UI.  Using the frame
+                     * time helps to reduce inter-frame jitter because the frame time is fixed at the time
+                     * the frame was scheduled to start, regardless of when the animations or drawing
+                     * callback actually runs.  All callbacks that run as part of rendering a frame will
+                     * observe the same frame time so using the frame time also helps to synchronize effects
+                     * that are performed by different callbacks.
+                     * </p><p>
+                     * Please note that the framework already takes care to process animations and
+                     * drawing using the frame time as a stable time base.  Most applications should
+                     * not need to use the frame time information directly.
+                     * </p>
+                     *
+                     * @param frameTimeNanos The time in nanoseconds when the frame started being rendered,
+                     *                       in the {@link System#nanoTime()} timebase.  Divide this value by {@code 1000000}
+                     *                       to convert it to the {@link SystemClock#uptimeMillis()} time base.
+                     */
+                    @Override
+                    public void doFrame(long frameTimeNanos) {
+                        synchronized (VSYNC_LOCK) {
+                            vsynced = true;
+                            mGLThread.requestRender();
+                        }
+                        choreographer.postFrameCallback(this);
+                    }
+                }
+        );
+        super.getHolder().addCallback(this);
+    }
+
+    /**
+     * Set the glWrapper. If the glWrapper is not null, its
+     * {@link GLWrapper#wrap(GL)} method is called
+     * whenever a surface is created. A GLWrapper can be used to wrap
+     * the GL object that's passed to the renderer. Wrapping a GL
+     * object enables examining and modifying the behavior of the
+     * GL calls made by the renderer.
+     * <p>
+     * Wrapping is typically used for debugging purposes.
+     * <p>
+     * The default value is null.
+     * @param glWrapper the new GLWrapper
+     */
+    public void setGLWrapper(GLWrapper glWrapper) {
+        mGLWrapper = glWrapper;
+    }
+
+    /**
+     * Set the debug flags to a new value. The value is
+     * constructed by OR-together zero or more
+     * of the DEBUG_CHECK_* constants. The debug flags take effect
+     * whenever a surface is created. The default value is zero.
+     * @param debugFlags the new debug flags
+     * @see #DEBUG_CHECK_GL_ERROR
+     * @see #DEBUG_LOG_GL_CALLS
+     */
+    public void setDebugFlags(int debugFlags) {
+        mDebugFlags = debugFlags;
+    }
+
+    /**
+     * Get the current value of the debug flags.
+     * @return the current value of the debug flags.
+     */
+    public int getDebugFlags() {
+        return mDebugFlags;
+    }
+
+    /**
+     * Control whether the EGL context is preserved when the EGLSurfaceView is paused and
+     * resumed.
+     * <p>
+     * If set to true, then the EGL context may be preserved when the EGLSurfaceView is paused.
+     * Whether the EGL context is actually preserved or not depends upon whether the
+     * Android device that the program is running on can support an arbitrary number of EGL
+     * contexts or not. Devices that can only support a limited number of EGL contexts must
+     * release the  EGL context in order to allow multiple applications to share the GPU.
+     * <p>
+     * If set to false, the EGL context will be released when the EGLSurfaceView is paused,
+     * and recreated when the EGLSurfaceView is resumed.
+     * <p>
+     *
+     * The default is false.
+     *
+     * @param preserveOnPause preserve the EGL context when paused
+     */
+    public void setPreserveEGLContextOnPause(boolean preserveOnPause) {
+        mPreserveEGLContextOnPause = preserveOnPause;
+    }
+
+    /**
+     * @return true if the EGL context will be preserved when paused
+     */
+    public boolean getPreserveEGLContextOnPause() {
+        return mPreserveEGLContextOnPause;
+    }
+
+    /**
+     * Set the renderer associated with this view. Also starts the thread that
+     * will call the renderer, which in turn causes the rendering to start.
+     * <p>This method should be called once and only once in the life-cycle of
+     * a EGLSurfaceView.
+     * <p>The following EGLSurfaceView methods can only be called <em>before</em>
+     * setRenderer is called:
+     * <ul>
+     * <li>{@link #setEGLConfigChooser(boolean)}
+     * <li>{@link #setEGLConfigChooser(EGLConfigChooser)}
+     * <li>{@link #setEGLConfigChooser(int, int, int, int, int, int)}
+     * </ul>
+     * <p>
+     * The following EGLSurfaceView methods can only be called <em>after</em>
+     * setRenderer is called:
+     * <ul>
+     * <li>{@link #getRenderMode()}
+     * <li>{@link #onPause()}
+     * <li>{@link #onResume()}
+     * <li>{@link #queueEvent(Runnable)}
+     * <li>{@link #swapBuffers()}
+     * <li>{@link #setRenderMode(int)}
+     * </ul>
+     *
+     * @param renderer the renderer to use to perform OpenGL drawing.
+     */
+    public void setRenderer(Renderer renderer) {
+        checkRenderThreadState();
+        if (mEGLConfigChooser == null) {
+            mEGLConfigChooser = new SimpleEGLConfigChooser(true);
+        }
+        if (mEGLContextFactory == null) {
+            mEGLContextFactory = new DefaultContextFactory();
+        }
+        if (mEGLWindowSurfaceFactory == null) {
+            mEGLWindowSurfaceFactory = new DefaultWindowSurfaceFactory();
+        }
+        mRenderer = renderer;
+        mGLThread = new GLThread(mThisWeakRef);
+        mGLThread.start();
+    }
+
+    /**
+     * Install a custom EGLContextFactory.
+     * <p>If this method is
+     * called, it must be called before {@link #setRenderer(Renderer)}
+     * is called.
+     * <p>
+     * If this method is not called, then by default
+     * a context will be created with no shared context and
+     * with a null attribute list.
+     */
+    public void setEGLContextFactory(EGLContextFactory factory) {
+        checkRenderThreadState();
+        mEGLContextFactory = factory;
+    }
+
+    /**
+     * Install a custom EGLWindowSurfaceFactory.
+     * <p>If this method is
+     * called, it must be called before {@link #setRenderer(Renderer)}
+     * is called.
+     * <p>
+     * If this method is not called, then by default
+     * a window surface will be created with a null attribute list.
+     */
+    public void setEGLWindowSurfaceFactory(EGLWindowSurfaceFactory factory) {
+        checkRenderThreadState();
+        mEGLWindowSurfaceFactory = factory;
+    }
+
+    /**
+     * Install a custom EGLConfigChooser.
+     * <p>If this method is
+     * called, it must be called before {@link #setRenderer(Renderer)}
+     * is called.
+     * <p>
+     * If no setEGLConfigChooser method is called, then by default the
+     * view will choose an EGLConfig that is compatible with the current
+     * android.view.Surface, with a depth buffer depth of
+     * at least 16 bits.
+     * @param configChooser
+     */
+    public void setEGLConfigChooser(EGLConfigChooser configChooser) {
+        checkRenderThreadState();
+        mEGLConfigChooser = configChooser;
+    }
+
+    /**
+     * Install a config chooser which will choose a config
+     * as close to 16-bit RGB as possible, with or without an optional depth
+     * buffer as close to 16-bits as possible.
+     * <p>If this method is
+     * called, it must be called before {@link #setRenderer(Renderer)}
+     * is called.
+     * <p>
+     * If no setEGLConfigChooser method is called, then by default the
+     * view will choose an RGB_888 surface with a depth buffer depth of
+     * at least 16 bits.
+     *
+     * @param needDepth
+     */
+    public void setEGLConfigChooser(boolean needDepth) {
+        setEGLConfigChooser(new SimpleEGLConfigChooser(needDepth));
+    }
+
+    /**
+     * Install a config chooser which will choose a config
+     * with at least the specified depthSize and stencilSize,
+     * and exactly the specified redSize, greenSize, blueSize and alphaSize.
+     * <p>If this method is
+     * called, it must be called before {@link #setRenderer(Renderer)}
+     * is called.
+     * <p>
+     * If no setEGLConfigChooser method is called, then by default the
+     * view will choose an RGB_888 surface with a depth buffer depth of
+     * at least 16 bits.
+     *
+     */
+    public void setEGLConfigChooser(int redSize, int greenSize, int blueSize,
+                                    int alphaSize, int depthSize, int stencilSize) {
+        setEGLConfigChooser(new ComponentSizeChooser(redSize, greenSize,
+                blueSize, alphaSize, depthSize, stencilSize));
+    }
+
+    /**
+     * Inform the default EGLContextFactory and default EGLConfigChooser
+     * which EGLContext client version to pick.
+     * <p>Use this method to create an OpenGL ES 2.0-compatible context.
+     * Example:
+     * <pre class="prettyprint">
+     *     public MyView(Context context) {
+     *         super(context);
+     *         setEGLContextClientVersion(2); // Pick an OpenGL ES 2.0 context.
+     *         setRenderer(new MyRenderer());
+     *     }
+     * </pre>
+     * <p>Note: Activities which require OpenGL ES 2.0 should indicate this by
+     * setting @lt;uses-feature android:glEsVersion="0x00020000" /> in the activity's
+     * AndroidManifest.xml file.
+     * <p>If this method is called, it must be called before {@link #setRenderer(Renderer)}
+     * is called.
+     * <p>This method only affects the behavior of the default EGLContexFactory and the
+     * default EGLConfigChooser. If
+     * {@link #setEGLContextFactory(EGLContextFactory)} has been called, then the supplied
+     * EGLContextFactory is responsible for creating an OpenGL ES 2.0-compatible context.
+     * If
+     * {@link #setEGLConfigChooser(EGLConfigChooser)} has been called, then the supplied
+     * EGLConfigChooser is responsible for choosing an OpenGL ES 2.0-compatible config.
+     * @param version The EGLContext client version to choose. Use 2 for OpenGL ES 2.0
+     */
+    public void setEGLContextClientVersion(int version) {
+        checkRenderThreadState();
+        mEGLContextClientVersion = version;
+    }
+
+    int mRendermode;
+
+    /**
+     * Set the rendering mode. When renderMode is
+     * RENDERMODE_CONTINUOUSLY, the renderer is called
+     * repeatedly to re-render the scene. When renderMode
+     * is RENDERMODE_WHEN_DIRTY, the renderer only rendered when the surface
+     * is created, or when {@link #swapBuffers} is called. Defaults to RENDERMODE_CONTINUOUSLY.
+     * <p>
+     * Using RENDERMODE_WHEN_DIRTY can improve battery life and overall system performance
+     * by allowing the GPU and CPU to idle when the view does not need to be updated.
+     * <p>
+     * This method can only be called after {@link #setRenderer(Renderer)}
+     * <p>
+     *
+     * @deprecated This has no effect on rendering.
+     * @param renderMode one of the RENDERMODE_X constants
+     * @see #RENDERMODE_CONTINUOUSLY
+     * @see #RENDERMODE_WHEN_DIRTY
+     */
+    public void setRenderMode(int renderMode) {
+        mRendermode = renderMode;
+    }
+
+    /**
+     * Get the current rendering mode. May be called
+     * from any thread. Must not be called before a renderer has been set.
+     *
+     * @deprecated This has no effect on rendering.
+     * @return the current rendering mode.
+     * @see #RENDERMODE_CONTINUOUSLY
+     * @see #RENDERMODE_WHEN_DIRTY
+     */
+    public int getRenderMode() {
+        return mRendermode;
+    }
+
+    /**
+     * Request that the renderer render a frame.
+     * This method is typically used when the render mode has been set to
+     * {@link #RENDERMODE_WHEN_DIRTY}, so that frames are only rendered on demand.
+     * May be called
+     * from any thread. Must not be called before a renderer has been set.
+     * <br><br>
+     * this calls {@link #swapBuffers}
+     * @see #swapBuffers
+     */
+    public void requestRender() {
+        swapBuffers();
+    }
+
+    /**
+     * This is called immediately after the surface is first created.
+     * Implementations of this should start up whatever rendering code
+     * they desire.  Note that only one thread can ever draw into
+     * a {@link Surface}, so you should not draw into the Surface here
+     * if your normal rendering will be in another thread.
+     *
+     * @param holder The SurfaceHolder whose surface is being created.
+     */
+    @Override
+    final public void surfaceCreated(@NonNull SurfaceHolder holder) {
+        mGLThread.surfaceCreated();
+    }
+
+    /**
+     * This is called immediately after any structural changes (format or
+     * size) have been made to the surface.  You should at this point update
+     * the imagery in the surface.  This method is always called at least
+     * once, after {@link #surfaceCreated}.
+     *
+     * @param holder The SurfaceHolder whose surface has changed.
+     * @param format The new {@link PixelFormat} of the surface.
+     * @param width  The new width of the surface.
+     * @param height The new height of the surface.
+     */
+    @Override
+    final public void surfaceChanged(@NonNull SurfaceHolder holder, int format, int width, int height) {
+        mGLThread.onWindowResize(width, height);
+    }
+
+    /**
+     * This is called immediately before a surface is being destroyed. After
+     * returning from this call, you should no longer try to access this
+     * surface.  If you have a rendering thread that directly accesses
+     * the surface, you must ensure that thread is no longer touching the
+     * Surface before returning from this function.
+     *
+     * @param holder The SurfaceHolder whose surface is being destroyed.
+     */
+    @Override
+    final public void surfaceDestroyed(@NonNull SurfaceHolder holder) {
+        // Surface will be destroyed when we return
+        mGLThread.surfaceDestroyed();
+        if(null != mRenderer) {
+            mRenderer.onSurfaceDestroyed();
+        }
+    }
+
+    /**
+     * Inform the view that the activity is paused. The owner of this view must
+     * call this method when the activity is paused. Calling this method will
+     * pause the rendering thread.
+     * Must not be called before a renderer has been set.
+     */
+    @CallSuper
+    public void onPause() {
+        mGLThread.onPause();
+    }
+
+    /**
+     * Inform the view that the activity is resumed. The owner of this view must
+     * call this method when the activity is resumed. Calling this method will
+     * recreate the OpenGL display and resume the rendering
+     * thread.
+     * Must not be called before a renderer has been set.
+     */
+    @CallSuper
+    public void onResume() {
+        mGLThread.onResume();
+    }
+
+    /**
+     * Queue a runnable to be run on the GL rendering thread. This can be used
+     * to communicate with the Renderer on the rendering thread.
+     * Must not be called before a renderer has been set.
+     * @param r the runnable to be run on the GL rendering thread.
+     */
+    @CallSuper
+    public void queueEvent(Runnable r) {
+        mGLThread.queueEvent(r);
+    }
+
+    /**
+     * This method is used as part of the View class and is not normally
+     * called or subclassed by clients of EGLSurfaceView.
+     */
+    @Override
+    @CallSuper
+    protected void onAttachedToWindow() {
+        super.onAttachedToWindow();
+        if (LOG_ATTACH_DETACH) {
+            Log.d(TAG, "onAttachedToWindow reattach =" + mDetached);
+        }
+        if (mDetached && (mRenderer != null)) {
+            mGLThread = new GLThread(mThisWeakRef);
+            mGLThread.start();
+        }
+        mDetached = false;
+    }
+
+    @Override
+    @CallSuper
+    protected void onDetachedFromWindow() {
+        if (LOG_ATTACH_DETACH) {
+            Log.d(TAG, "onDetachedFromWindow");
+        }
+        if (mGLThread != null) {
+            mGLThread.requestExitAndWait();
+        }
+        mDetached = true;
+        super.onDetachedFromWindow();
+    }
+
+    // ----------------------------------------------------------------------
+
+    /**
+     * An interface used to wrap a GL interface.
+     * <p>Typically
+     * used for implementing debugging and tracing on top of the default
+     * GL interface. You would typically use this by creating your own class
+     * that implemented all the GL methods by delegating to another GL instance.
+     * Then you could add your own behavior before or after calling the
+     * delegate. All the GLWrapper would do was instantiate and return the
+     * wrapper GL instance:
+     * <pre class="prettyprint">
+     * class MyGLWrapper implements GLWrapper {
+     *     GL wrap(GL gl) {
+     *         return new MyGLImplementation(gl);
+     *     }
+     *     static class MyGLImplementation implements GL,GL10,GL11,... {
+     *         ...
+     *     }
+     * }
+     * </pre>
+     * @see #setGLWrapper(GLWrapper)
+     */
+    public interface GLWrapper {
+        /**
+         * Wraps a gl interface in another gl interface.
+         * @param gl a GL interface that is to be wrapped.
+         * @return either the input argument or another GL object that wraps the input argument.
+         */
+        GL wrap(GL gl);
+    }
+
+    /**
+     * A generic renderer interface.
+     * <p>
+     * The renderer is responsible for making OpenGL calls to render a frame.
+     * <p>
+     * EGLSurfaceView clients typically create their own classes that implement
+     * this interface, and then call {@link EGLSurfaceView#setRenderer} to
+     * register the renderer with the EGLSurfaceView.
+     * <p>
+     *
+     * <div class="special reference">
+     * <h3>Developer Guides</h3>
+     * <p>For more information about how to use OpenGL, read the
+     * <a href="{@docRoot}guide/topics/graphics/opengl.html">OpenGL</a> developer guide.</p>
+     * </div>
+     *
+     * <h3>Threading</h3>
+     * The renderer will be called on a separate thread, so that rendering
+     * performance is decoupled from the UI thread. Clients typically need to
+     * communicate with the renderer from the UI thread, because that's where
+     * input events are received. Clients can communicate using any of the
+     * standard Java techniques for cross-thread communication, or they can
+     * use the {@link EGLSurfaceView#queueEvent(Runnable)} convenience method.
+     * <p>
+     * <h3>EGL Context Lost</h3>
+     * There are situations where the EGL rendering context will be lost. This
+     * typically happens when device wakes up after going to sleep. When
+     * the EGL context is lost, all OpenGL resources (such as textures) that are
+     * associated with that context will be automatically deleted. In order to
+     * keep rendering correctly, a renderer must recreate any lost resources
+     * that it still needs. The {@link #onSurfaceCreated(GL10, EGLConfig)} method
+     * is a convenient place to do this.
+     *
+     *
+     * @see #setRenderer(Renderer)
+     */
+    public interface Renderer {
+        /**
+         * Called when the surface is created or recreated.
+         * <p>
+         * Called when the rendering thread
+         * starts and whenever the EGL context is lost. The EGL context will typically
+         * be lost when the Android device awakes after going to sleep.
+         * <p>
+         * Since this method is called at the beginning of rendering, as well as
+         * every time the EGL context is lost, this method is a convenient place to put
+         * code to create resources that need to be created when the rendering
+         * starts, and that need to be recreated when the EGL context is lost.
+         * Textures are an example of a resource that you might want to create
+         * here.
+         * <p>
+         * Note that when the EGL context is lost, all OpenGL resources associated
+         * with that context will be automatically deleted. You do not need to call
+         * the corresponding "glDelete" methods such as glDeleteTextures to
+         * manually delete these lost resources.
+         * <p>
+         * @param gl the GL interface. Use <code>instanceof</code> to
+         * test if the interface supports GL11 or higher interfaces.
+         * @param config the EGLConfig of the created surface. Can be used
+         * to create matching pbuffers.
+         */
+        default void onSurfaceCreated(GL10 gl, EGLConfig config) {}
+
+        /**
+         * Called when the surface changed size.
+         * <p>
+         * Called after the surface is created and whenever
+         * the OpenGL ES surface size changes.
+         * <p>
+         * Typically you will set your viewport here. If your camera
+         * is fixed then you could also set your projection matrix here:
+         * <pre class="prettyprint">
+         * void onSurfaceChanged(GL10 gl, int width, int height) {
+         *     gl.glViewport(0, 0, width, height);
+         *     // for a fixed camera, set the projection too
+         *     float ratio = (float) width / height;
+         *     gl.glMatrixMode(GL10.GL_PROJECTION);
+         *     gl.glLoadIdentity();
+         *     gl.glFrustumf(-ratio, ratio, -1, 1, 1, 10);
+         * }
+         * </pre>
+         * @param gl the GL interface. Use <code>instanceof</code> to
+         * test if the interface supports GL11 or higher interfaces.
+         * @param width surface width
+         * @param height surface height
+         */
+        void onSurfaceChanged(GL10 gl, int width, int height);
+
+        /**
+         * Called to draw the current frame.
+         * <p>
+         * This method is responsible for drawing the current frame.
+         * <p>
+         * The implementation of this method typically looks like this:
+         * <pre class="prettyprint">
+         * void onDrawFrame(GL10 gl) {
+         *     gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
+         *     //... other gl calls to render the scene ...
+         *     swapBuffers();
+         * }
+         * </pre>
+         * @param gl the GL interface. Use <code>instanceof</code> to
+         * test if the interface supports GL11 or higher interfaces.
+         *
+         * @implSpec you must call {@link #swapBuffers()} to draw anything
+         * @see #swapBuffers()
+         */
+        void onDrawFrame(GL10 gl);
+
+        default void onSurfaceDestroyed() {}
+
+        /**
+         * Called when the EGL context is made current
+         */
+        default void onEglSetup() {}
+
+        /**
+         * Called before the EGL context is lost
+         */
+        default void onEglTearDown() {}
+
+    }
+
+    /**
+     * An interface for customizing the eglCreateContext and eglDestroyContext calls.
+     * <p>
+     * This interface must be implemented by clients wishing to call
+     * {@link EGLSurfaceView#setEGLContextFactory(EGLContextFactory)}
+     */
+    public interface EGLContextFactory {
+        EGLContext createContext(EGL10 egl, EGLDisplay display, EGLConfig eglConfig);
+        void destroyContext(EGL10 egl, EGLDisplay display, EGLContext context);
+    }
+
+    private class DefaultContextFactory implements EGLContextFactory {
+        private int EGL_CONTEXT_CLIENT_VERSION = 0x3098;
+
+        public EGLContext createContext(EGL10 egl, EGLDisplay display, EGLConfig config) {
+            int[] attrib_list = {EGL_CONTEXT_CLIENT_VERSION, mEGLContextClientVersion,
+                    EGL10.EGL_NONE };
+
+            return egl.eglCreateContext(display, config, EGL10.EGL_NO_CONTEXT,
+                    mEGLContextClientVersion != 0 ? attrib_list : null);
+        }
+
+        public void destroyContext(EGL10 egl, EGLDisplay display,
+                                   EGLContext context) {
+            if (!egl.eglDestroyContext(display, context)) {
+                Log.e("DefaultContextFactory", "display:" + display + " context: " + context);
+                if (LOG_THREADS) {
+                    Log.i("DefaultContextFactory", "tid=" + Thread.currentThread().getId());
+                }
+                EglHelper.throwEglException("eglDestroyContex", egl.eglGetError());
+            }
+        }
+    }
+
+    /**
+     * An interface for customizing the eglCreateWindowSurface and eglDestroySurface calls.
+     * <p>
+     * This interface must be implemented by clients wishing to call
+     * {@link EGLSurfaceView#setEGLWindowSurfaceFactory(EGLWindowSurfaceFactory)}
+     */
+    public interface EGLWindowSurfaceFactory {
+        /**
+         *  @return null if the surface cannot be constructed.
+         */
+        EGLSurface createWindowSurface(EGL10 egl, EGLDisplay display, EGLConfig config,
+                                       Object nativeWindow);
+        void destroySurface(EGL10 egl, EGLDisplay display, EGLSurface surface);
+    }
+
+    private static class DefaultWindowSurfaceFactory implements EGLWindowSurfaceFactory {
+
+        public EGLSurface createWindowSurface(EGL10 egl, EGLDisplay display,
+                                              EGLConfig config, Object nativeWindow) {
+            EGLSurface result = null;
+            try {
+                result = egl.eglCreateWindowSurface(display, config, nativeWindow, null);
+            } catch (IllegalArgumentException e) {
+                // This exception indicates that the surface flinger surface
+                // is not valid. This can happen if the surface flinger surface has
+                // been torn down, but the application has not yet been
+                // notified via SurfaceHolder.Callback.surfaceDestroyed.
+                // In theory the application should be notified first,
+                // but in practice sometimes it is not. See b/4588890
+                Log.e(TAG, "eglCreateWindowSurface", e);
+            }
+            return result;
+        }
+
+        public void destroySurface(EGL10 egl, EGLDisplay display,
+                                   EGLSurface surface) {
+            egl.eglDestroySurface(display, surface);
+        }
+    }
+
+    /**
+     * An interface for choosing an EGLConfig configuration from a list of
+     * potential configurations.
+     * <p>
+     * This interface must be implemented by clients wishing to call
+     * {@link EGLSurfaceView#setEGLConfigChooser(EGLConfigChooser)}
+     */
+    public interface EGLConfigChooser {
+        /**
+         * Choose a configuration from the list. Implementors typically
+         * implement this method by calling
+         * {@link EGL10#eglChooseConfig} and iterating through the results. Please consult the
+         * EGL specification available from The Khronos Group to learn how to call eglChooseConfig.
+         * @param egl the EGL10 for the current display.
+         * @param display the current display.
+         * @return the chosen configuration.
+         */
+        EGLConfig chooseConfig(EGL10 egl, EGLDisplay display);
+    }
+
+    private abstract class BaseConfigChooser
+            implements EGLConfigChooser {
+        public BaseConfigChooser(int[] configSpec) {
+            mConfigSpec = filterConfigSpec(configSpec);
+        }
+
+        public EGLConfig chooseConfig(EGL10 egl, EGLDisplay display) {
+            int[] num_config = new int[1];
+            if (!egl.eglChooseConfig(display, mConfigSpec, null, 0,
+                    num_config)) {
+                throw new IllegalArgumentException("eglChooseConfig failed");
+            }
+
+            int numConfigs = num_config[0];
+
+            if (numConfigs <= 0) {
+                throw new IllegalArgumentException(
+                        "No configs match configSpec");
+            }
+
+            EGLConfig[] configs = new EGLConfig[numConfigs];
+            if (!egl.eglChooseConfig(display, mConfigSpec, configs, numConfigs,
+                    num_config)) {
+                throw new IllegalArgumentException("eglChooseConfig#2 failed");
+            }
+            EGLConfig config = chooseConfig(egl, display, configs);
+            if (config == null) {
+                throw new IllegalArgumentException("No config chosen");
+            }
+            return config;
+        }
+
+        abstract EGLConfig chooseConfig(EGL10 egl, EGLDisplay display,
+                                        EGLConfig[] configs);
+
+        protected int[] mConfigSpec;
+
+        private int[] filterConfigSpec(int[] configSpec) {
+            if (mEGLContextClientVersion != 2 && mEGLContextClientVersion != 3) {
+                return configSpec;
+            }
+            /* We know none of the subclasses define EGL_RENDERABLE_TYPE.
+             * And we know the configSpec is well formed.
+             */
+            int len = configSpec.length;
+            int[] newConfigSpec = new int[len + 2];
+            System.arraycopy(configSpec, 0, newConfigSpec, 0, len-1);
+            newConfigSpec[len-1] = EGL10.EGL_RENDERABLE_TYPE;
+            if (mEGLContextClientVersion == 2) {
+                newConfigSpec[len] = EGL14.EGL_OPENGL_ES2_BIT;  /* EGL_OPENGL_ES2_BIT */
+            } else {
+                newConfigSpec[len] = EGLExt.EGL_OPENGL_ES3_BIT_KHR; /* EGL_OPENGL_ES3_BIT_KHR */
+            }
+            newConfigSpec[len+1] = EGL10.EGL_NONE;
+            return newConfigSpec;
+        }
+    }
+
+    /**
+     * Choose a configuration with exactly the specified r,g,b,a sizes,
+     * and at least the specified depth and stencil sizes.
+     */
+    private class ComponentSizeChooser extends BaseConfigChooser {
+        public ComponentSizeChooser(int redSize, int greenSize, int blueSize,
+                                    int alphaSize, int depthSize, int stencilSize) {
+            super(new int[] {
+                    EGL10.EGL_RED_SIZE, redSize,
+                    EGL10.EGL_GREEN_SIZE, greenSize,
+                    EGL10.EGL_BLUE_SIZE, blueSize,
+                    EGL10.EGL_ALPHA_SIZE, alphaSize,
+                    EGL10.EGL_DEPTH_SIZE, depthSize,
+                    EGL10.EGL_STENCIL_SIZE, stencilSize,
+                    EGL10.EGL_NONE});
+            mValue = new int[1];
+            mRedSize = redSize;
+            mGreenSize = greenSize;
+            mBlueSize = blueSize;
+            mAlphaSize = alphaSize;
+            mDepthSize = depthSize;
+            mStencilSize = stencilSize;
+        }
+
+        @Override
+        public EGLConfig chooseConfig(EGL10 egl, EGLDisplay display,
+                                      EGLConfig[] configs) {
+            for (EGLConfig config : configs) {
+                int d = findConfigAttrib(egl, display, config,
+                        EGL10.EGL_DEPTH_SIZE, 0);
+                int s = findConfigAttrib(egl, display, config,
+                        EGL10.EGL_STENCIL_SIZE, 0);
+                if ((d >= mDepthSize) && (s >= mStencilSize)) {
+                    int r = findConfigAttrib(egl, display, config,
+                            EGL10.EGL_RED_SIZE, 0);
+                    int g = findConfigAttrib(egl, display, config,
+                            EGL10.EGL_GREEN_SIZE, 0);
+                    int b = findConfigAttrib(egl, display, config,
+                            EGL10.EGL_BLUE_SIZE, 0);
+                    int a = findConfigAttrib(egl, display, config,
+                            EGL10.EGL_ALPHA_SIZE, 0);
+                    if ((r == mRedSize) && (g == mGreenSize)
+                            && (b == mBlueSize) && (a == mAlphaSize)) {
+                        return config;
+                    }
+                }
+            }
+            return null;
+        }
+
+        private int findConfigAttrib(EGL10 egl, EGLDisplay display,
+                                     EGLConfig config, int attribute, int defaultValue) {
+
+            if (egl.eglGetConfigAttrib(display, config, attribute, mValue)) {
+                return mValue[0];
+            }
+            return defaultValue;
+        }
+
+        private int[] mValue;
+        // Subclasses can adjust these values:
+        protected int mRedSize;
+        protected int mGreenSize;
+        protected int mBlueSize;
+        protected int mAlphaSize;
+        protected int mDepthSize;
+        protected int mStencilSize;
+    }
+
+    /**
+     * This class will choose a RGB_888 surface with
+     * or without a depth buffer.
+     *
+     */
+    private class SimpleEGLConfigChooser extends ComponentSizeChooser {
+        public SimpleEGLConfigChooser(boolean withDepthBuffer) {
+            super(8, 8, 8, 0, withDepthBuffer ? 16 : 0, 0);
+        }
+    }
+
+    /**
+     * An EGL helper class.
+     */
+
+    private static class EglHelper {
+        public EglHelper(WeakReference<EGLSurfaceView> EGLSurfaceViewWeakRef) {
+            mEGLSurfaceViewWeakRef = EGLSurfaceViewWeakRef;
+        }
+
+        /**
+         * Initialize EGL for a given configuration spec.
+         */
+        public void start() {
+            if (LOG_EGL) {
+                Log.w("EglHelper", "start() tid=" + Thread.currentThread().getId());
+            }
+            /*
+             * Get an EGL instance
+             */
+            mEgl = (EGL10) EGLContext.getEGL();
+
+            /*
+             * Get to the default display.
+             */
+            mEglDisplay = mEgl.eglGetDisplay(EGL10.EGL_DEFAULT_DISPLAY);
+
+            if (mEglDisplay == EGL10.EGL_NO_DISPLAY) {
+                throw new RuntimeException("eglGetDisplay failed");
+            }
+
+            /*
+             * We can now initialize EGL for that display
+             */
+            int[] version = new int[2];
+            if(!mEgl.eglInitialize(mEglDisplay, version)) {
+                throw new RuntimeException("eglInitialize failed");
+            }
+            EGLSurfaceView view = mEGLSurfaceViewWeakRef.get();
+            if (view == null) {
+                mEglConfig = null;
+                mEglContext = null;
+            } else {
+                mEglConfig = view.mEGLConfigChooser.chooseConfig(mEgl, mEglDisplay);
+
+                /*
+                 * Create an EGL context. We want to do this as rarely as we can, because an
+                 * EGL context is a somewhat heavy object.
+                 */
+                mEglContext = view.mEGLContextFactory.createContext(mEgl, mEglDisplay, mEglConfig);
+            }
+            if (mEglContext == null || mEglContext == EGL10.EGL_NO_CONTEXT) {
+                mEglContext = null;
+                throwEglException("createContext");
+            }
+            if (LOG_EGL) {
+                Log.w("EglHelper", "createContext " + mEglContext + " tid=" + Thread.currentThread().getId());
+            }
+
+            mEglSurface = null;
+        }
+
+        /**
+         * Create an egl surface for the current SurfaceHolder surface. If a surface
+         * already exists, destroy it before creating the new surface.
+         *
+         * @return true if the surface was created successfully.
+         */
+        public boolean createSurface() {
+            if (LOG_EGL) {
+                Log.w("EglHelper", "createSurface()  tid=" + Thread.currentThread().getId());
+            }
+            /*
+             * Check preconditions.
+             */
+            if (mEgl == null) {
+                throw new RuntimeException("egl not initialized");
+            }
+            if (mEglDisplay == null) {
+                throw new RuntimeException("eglDisplay not initialized");
+            }
+            if (mEglConfig == null) {
+                throw new RuntimeException("mEglConfig not initialized");
+            }
+
+            /*
+             *  The window size has changed, so we need to create a new
+             *  surface.
+             */
+            destroySurfaceImp();
+
+            /*
+             * Create an EGL surface we can render into.
+             */
+            EGLSurfaceView view = mEGLSurfaceViewWeakRef.get();
+            if (view != null) {
+                mEglSurface = view.mEGLWindowSurfaceFactory.createWindowSurface(mEgl,
+                        mEglDisplay, mEglConfig, view.getHolder().getSurface());
+            } else {
+                mEglSurface = null;
+            }
+
+            if (mEglSurface == null || mEglSurface == EGL10.EGL_NO_SURFACE) {
+                int error = mEgl.eglGetError();
+                if (error == EGL10.EGL_BAD_NATIVE_WINDOW) {
+                    Log.e("EglHelper", "createWindowSurface returned EGL_BAD_NATIVE_WINDOW.");
+                }
+                return false;
+            }
+
+            /*
+             * Before we can issue GL commands, we need to make sure
+             * the context is current and bound to a surface.
+             */
+            if (!mEgl.eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface, mEglContext)) {
+                /*
+                 * Could not make the context current, probably because the underlying
+                 * SurfaceView surface has been destroyed.
+                 */
+                logEglErrorAsWarning("EGLHelper", "eglMakeCurrent", mEgl.eglGetError());
+                return false;
+            }
+
+            if (view != null) {
+                view.mRenderer.onEglSetup();
+            }
+
+            return true;
+        }
+
+        /**
+         * Create a GL object for the current EGL context.
+         * @return
+         */
+        GL createGL() {
+
+            GL gl = mEglContext.getGL();
+            EGLSurfaceView view = mEGLSurfaceViewWeakRef.get();
+            if (view != null) {
+                if (view.mGLWrapper != null) {
+                    gl = view.mGLWrapper.wrap(gl);
+                }
+
+                if ((view.mDebugFlags & (DEBUG_CHECK_GL_ERROR | DEBUG_LOG_GL_CALLS)) != 0) {
+                    int configFlags = 0;
+                    Writer log = null;
+                    if ((view.mDebugFlags & DEBUG_CHECK_GL_ERROR) != 0) {
+                        configFlags |= GLDebugHelper.CONFIG_CHECK_GL_ERROR;
+                    }
+                    if ((view.mDebugFlags & DEBUG_LOG_GL_CALLS) != 0) {
+                        log = new LogWriter();
+                    }
+                    gl = GLDebugHelper.wrap(gl, configFlags, log);
+                }
+            }
+            return gl;
+        }
+
+        /**
+         * Display the current render surface.
+         * @return the EGL error code from eglSwapBuffers.
+         */
+        public int swap() {
+            if (! mEgl.eglSwapBuffers(mEglDisplay, mEglSurface)) {
+                return mEgl.eglGetError();
+            }
+            return EGL10.EGL_SUCCESS;
+        }
+
+        public void destroySurface() {
+            if (LOG_EGL) {
+                Log.w("EglHelper", "destroySurface()  tid=" + Thread.currentThread().getId());
+            }
+            destroySurfaceImp();
+        }
+
+        private void destroySurfaceImp() {
+            if (mEglSurface != null && mEglSurface != EGL10.EGL_NO_SURFACE) {
+                EGLSurfaceView view = mEGLSurfaceViewWeakRef.get();
+                if (view != null) {
+                    view.mRenderer.onEglTearDown();
+                }
+                mEgl.eglMakeCurrent(mEglDisplay, EGL10.EGL_NO_SURFACE,
+                        EGL10.EGL_NO_SURFACE,
+                        EGL10.EGL_NO_CONTEXT);
+                if (view != null) {
+                    view.mEGLWindowSurfaceFactory.destroySurface(mEgl, mEglDisplay, mEglSurface);
+                }
+                mEglSurface = null;
+            }
+        }
+
+        public void finish() {
+            if (LOG_EGL) {
+                Log.w("EglHelper", "finish() tid=" + Thread.currentThread().getId());
+            }
+            if (mEglContext != null) {
+                EGLSurfaceView view = mEGLSurfaceViewWeakRef.get();
+                if (view != null) {
+                    view.mEGLContextFactory.destroyContext(mEgl, mEglDisplay, mEglContext);
+                }
+                mEglContext = null;
+            }
+            if (mEglDisplay != null) {
+                mEgl.eglTerminate(mEglDisplay);
+                mEglDisplay = null;
+            }
+        }
+
+        private void throwEglException(String function) {
+            throwEglException(function, mEgl.eglGetError());
+        }
+
+        public static void throwEglException(String function, int error) {
+            String message = formatEglError(function, error);
+            if (LOG_THREADS) {
+                Log.e("EglHelper", "throwEglException tid=" + Thread.currentThread().getId() + " "
+                        + message);
+            }
+            throw new RuntimeException(message);
+        }
+
+        public static void logEglErrorAsWarning(String tag, String function, int error) {
+            Log.w(tag, formatEglError(function, error));
+        }
+
+        public static String formatEglError(String function, int error) {
+            return function + " failed: " + eglGetErrorString(error);
+        }
+
+        static String eglGetErrorString(int error) {
+            switch (error) {
+                case EGL11.EGL_SUCCESS:
+                    return "EGL_SUCCESS";
+                case EGL11.EGL_NOT_INITIALIZED:
+                    return "EGL_NOT_INITIALIZED";
+                case EGL11.EGL_BAD_ACCESS:
+                    return "EGL_BAD_ACCESS";
+                case EGL11.EGL_BAD_ALLOC:
+                    return "EGL_BAD_ALLOC";
+                case EGL11.EGL_BAD_ATTRIBUTE:
+                    return "EGL_BAD_ATTRIBUTE";
+                case EGL11.EGL_BAD_CONFIG:
+                    return "EGL_BAD_CONFIG";
+                case EGL11.EGL_BAD_CONTEXT:
+                    return "EGL_BAD_CONTEXT";
+                case EGL11.EGL_BAD_CURRENT_SURFACE:
+                    return "EGL_BAD_CURRENT_SURFACE";
+                case EGL11.EGL_BAD_DISPLAY:
+                    return "EGL_BAD_DISPLAY";
+                case EGL11.EGL_BAD_MATCH:
+                    return "EGL_BAD_MATCH";
+                case EGL11.EGL_BAD_NATIVE_PIXMAP:
+                    return "EGL_BAD_NATIVE_PIXMAP";
+                case EGL11.EGL_BAD_NATIVE_WINDOW:
+                    return "EGL_BAD_NATIVE_WINDOW";
+                case EGL11.EGL_BAD_PARAMETER:
+                    return "EGL_BAD_PARAMETER";
+                case EGL11.EGL_BAD_SURFACE:
+                    return "EGL_BAD_SURFACE";
+                case EGL11.EGL_CONTEXT_LOST:
+                    return "EGL_CONTEXT_LOST";
+                default:
+                    return "0x" + Integer.toHexString(error);
+            }
+        }
+
+        private WeakReference<EGLSurfaceView> mEGLSurfaceViewWeakRef;
+        EGL10 mEgl;
+        EGLDisplay mEglDisplay;
+        EGLSurface mEglSurface;
+        EGLConfig mEglConfig;
+        EGLContext mEglContext;
+
+    }
+
+    /**
+     * A generic GL Thread. Takes care of initializing EGL and GL. Delegates
+     * to a Renderer instance to do the actual drawing. Can be configured to
+     * render continuously or on request.
+     *
+     * All potentially blocking synchronization is done through the
+     * sGLThreadManager object. This avoids multiple-lock ordering issues.
+     *
+     */
+    class GLThread extends Thread {
+        GLThread(WeakReference<EGLSurfaceView> EGLSurfaceViewWeakRef) {
+            super();
+            mWidth = 0;
+            mHeight = 0;
+            mRequestRender = true;
+            mEGLSurfaceViewWeakRef = EGLSurfaceViewWeakRef;
+        }
+
+        @Override
+        public void run() {
+            setName("GLThread " + getId());
+            if (LOG_THREADS) {
+                Log.i("GLThread", "starting tid=" + getId());
+            }
+
+            try {
+                guardedRun();
+            } catch (InterruptedException e) {
+                // fall through and exit normally
+            } finally {
+                sGLThreadManager.threadExiting(this);
+            }
+        }
+
+        /*
+         * This private method should only be called inside a
+         * synchronized(sGLThreadManager) block.
+         */
+        private void stopEglSurfaceLocked() {
+            if (mHaveEglSurface) {
+                mHaveEglSurface = false;
+                mEglHelper.destroySurface();
+            }
+        }
+
+        /*
+         * This private method should only be called inside a
+         * synchronized(sGLThreadManager) block.
+         */
+        private void stopEglContextLocked() {
+            if (mHaveEglContext) {
+                mEglHelper.finish();
+                mHaveEglContext = false;
+                sGLThreadManager.releaseEglContextLocked(this);
+            }
+        }
+        private void guardedRun() throws InterruptedException {
+            mEglHelper = new EglHelper(mEGLSurfaceViewWeakRef);
+            mHaveEglContext = false;
+            mHaveEglSurface = false;
+            try {
+                GL10 gl = null;
+                boolean createEglContext = false;
+                boolean createEglSurface = false;
+                boolean createGlInterface = false;
+                boolean lostEglContext = false;
+                boolean sizeChanged = false;
+                boolean wantRenderNotification = false;
+                boolean doRenderNotification = false;
+                boolean askedToReleaseEglContext = false;
+                int w = 0;
+                int h = 0;
+                Runnable event = null;
+
+                while (true) {
+                    synchronized (sGLThreadManager) {
+                        while (true) {
+                            if (mShouldExit) {
+                                return;
+                            }
+
+                            if (! mEventQueue.isEmpty()) {
+                                event = mEventQueue.remove(0);
+                                break;
+                            }
+
+                            // Update the pause state.
+                            boolean pausing = false;
+                            if (mPaused != mRequestPaused) {
+                                pausing = mRequestPaused;
+                                mPaused = mRequestPaused;
+                                sGLThreadManager.notifyAll();
+                                if (LOG_PAUSE_RESUME) {
+                                    Log.i("GLThread", "mPaused is now " + mPaused + " tid=" + getId());
+                                }
+                            }
+
+                            // Do we need to give up the EGL context?
+                            if (mShouldReleaseEglContext) {
+                                if (LOG_SURFACE) {
+                                    Log.i("GLThread", "releasing EGL context because asked to tid=" + getId());
+                                }
+                                stopEglSurfaceLocked();
+                                stopEglContextLocked();
+                                mShouldReleaseEglContext = false;
+                                askedToReleaseEglContext = true;
+                            }
+
+                            // Have we lost the EGL context?
+                            if (lostEglContext) {
+                                stopEglSurfaceLocked();
+                                stopEglContextLocked();
+                                lostEglContext = false;
+                            }
+
+                            // When pausing, release the EGL surface:
+                            if (pausing && mHaveEglSurface) {
+                                if (LOG_SURFACE) {
+                                    Log.i("GLThread", "releasing EGL surface because paused tid=" + getId());
+                                }
+                                stopEglSurfaceLocked();
+                            }
+
+                            // When pausing, optionally release the EGL Context:
+                            if (pausing && mHaveEglContext) {
+                                EGLSurfaceView view = mEGLSurfaceViewWeakRef.get();
+                                boolean preserveEglContextOnPause = view == null ?
+                                        false : view.mPreserveEGLContextOnPause;
+                                if (!preserveEglContextOnPause || sGLThreadManager.shouldReleaseEGLContextWhenPausing()) {
+                                    stopEglContextLocked();
+                                    if (LOG_SURFACE) {
+                                        Log.i("GLThread", "releasing EGL context because paused tid=" + getId());
+                                    }
+                                }
+                            }
+
+                            // When pausing, optionally terminate EGL:
+                            if (pausing) {
+                                if (sGLThreadManager.shouldTerminateEGLWhenPausing()) {
+                                    mEglHelper.finish();
+                                    if (LOG_SURFACE) {
+                                        Log.i("GLThread", "terminating EGL because paused tid=" + getId());
+                                    }
+                                }
+                            }
+
+                            // Have we lost the SurfaceView surface?
+                            if ((! mHasSurface) && (! mWaitingForSurface)) {
+                                if (LOG_SURFACE) {
+                                    Log.i("GLThread", "noticed SurfaceView surface lost tid=" + getId());
+                                }
+                                if (mHaveEglSurface) {
+                                    stopEglSurfaceLocked();
+                                }
+                                mWaitingForSurface = true;
+                                mSurfaceIsBad = false;
+                                sGLThreadManager.notifyAll();
+                            }
+
+                            // Have we acquired the surface view surface?
+                            if (mHasSurface && mWaitingForSurface) {
+                                if (LOG_SURFACE) {
+                                    Log.i("GLThread", "noticed SurfaceView surface acquired tid=" + getId());
+                                }
+                                mWaitingForSurface = false;
+                                sGLThreadManager.notifyAll();
+                            }
+
+                            if (doRenderNotification) {
+                                if (LOG_SURFACE) {
+                                    Log.i("GLThread", "sending render notification tid=" + getId());
+                                }
+                                wantRenderNotification = false;
+                                doRenderNotification = false;
+                                mRenderComplete = true;
+                                sGLThreadManager.notifyAll();
+                            }
+
+                            // Ready to draw?
+                            if (readyToDraw()) {
+
+                                // If we don't have an EGL context, try to acquire one.
+                                if (! mHaveEglContext) {
+                                    if (askedToReleaseEglContext) {
+                                        askedToReleaseEglContext = false;
+                                    } else if (sGLThreadManager.tryAcquireEglContextLocked(this)) {
+                                        try {
+                                            mEglHelper.start();
+                                        } catch (RuntimeException t) {
+                                            sGLThreadManager.releaseEglContextLocked(this);
+                                            throw t;
+                                        }
+                                        mHaveEglContext = true;
+                                        createEglContext = true;
+
+                                        sGLThreadManager.notifyAll();
+                                    }
+                                }
+
+                                if (mHaveEglContext && !mHaveEglSurface) {
+                                    mHaveEglSurface = true;
+                                    createEglSurface = true;
+                                    createGlInterface = true;
+                                    sizeChanged = true;
+                                }
+
+                                if (mHaveEglSurface) {
+                                    if (mSizeChanged) {
+                                        sizeChanged = true;
+                                        w = mWidth;
+                                        h = mHeight;
+                                        wantRenderNotification = true;
+                                        if (LOG_SURFACE) {
+                                            Log.i("GLThread",
+                                                    "noticing that we want render notification tid="
+                                                            + getId());
+                                        }
+
+                                        // Destroy and recreate the EGL surface.
+                                        createEglSurface = true;
+
+                                        mSizeChanged = false;
+                                    }
+                                    mRequestRender = false;
+                                    sGLThreadManager.notifyAll();
+                                    break;
+                                }
+                            }
+
+                            // By design, this is the only place in a GLThread thread where we wait().
+                            if (LOG_THREADS) {
+                                Log.i("GLThread", "\nwaiting tid=" + getId()
+                                        + "\nmHaveEglContext: " + mHaveEglContext
+                                        + "\nmHaveEglSurface: " + mHaveEglSurface
+                                        + "\nmFinishedCreatingEglSurface: " + mFinishedCreatingEglSurface
+                                        + "\nmPaused: " + mPaused
+                                        + "\nmHasSurface: " + mHasSurface
+                                        + "\nmSurfaceIsBad: " + mSurfaceIsBad
+                                        + "\nmWaitingForSurface: " + mWaitingForSurface
+                                        + "\nmWidth: " + mWidth
+                                        + "\nmHeight: " + mHeight
+                                        + "\nmRequestRender: " + mRequestRender);
+                            }
+                            sGLThreadManager.wait();
+                        }
+                    } // end of synchronized(sGLThreadManager)
+
+                    if (event != null) {
+                        event.run();
+                        event = null;
+                        continue;
+                    }
+
+                    if (createEglSurface) {
+                        if (LOG_SURFACE) {
+                            Log.w("GLThread", "egl createSurface");
+                        }
+                        if (mEglHelper.createSurface()) {
+                            synchronized(sGLThreadManager) {
+                                mFinishedCreatingEglSurface = true;
+                                sGLThreadManager.notifyAll();
+                            }
+                        } else {
+                            synchronized(sGLThreadManager) {
+                                mFinishedCreatingEglSurface = true;
+                                mSurfaceIsBad = true;
+                                sGLThreadManager.notifyAll();
+                            }
+                            continue;
+                        }
+                        createEglSurface = false;
+                    }
+
+                    if (createGlInterface) {
+                        gl = (GL10) mEglHelper.createGL();
+
+                        sGLThreadManager.checkGLDriver(gl);
+                        createGlInterface = false;
+                    }
+
+                    if (createEglContext) {
+                        if (LOG_RENDERER) {
+                            Log.w("GLThread", "onSurfaceCreated");
+                        }
+                        EGLSurfaceView view = mEGLSurfaceViewWeakRef.get();
+                        if (view != null) {
+                            view.mRenderer.onSurfaceCreated(gl, mEglHelper.mEglConfig);
+                        }
+                        createEglContext = false;
+                    }
+
+                    if (sizeChanged) {
+                        if (LOG_RENDERER) {
+                            Log.w("GLThread", "onSurfaceChanged(" + w + ", " + h + ")");
+                        }
+                        EGLSurfaceView view = mEGLSurfaceViewWeakRef.get();
+                        if (view != null) {
+                            view.mRenderer.onSurfaceChanged(gl, w, h);
+                        }
+                        sizeChanged = false;
+                    }
+
+                    synchronized (VSYNC_LOCK) {
+                        if (vsynced) {
+                            vsynced = false;
+                            if (LOG_RENDERER_DRAW_FRAME) {
+                                Log.w("GLThread", "onDrawFrame tid=" + getId());
+                            }
+                            EGLSurfaceView view = mEGLSurfaceViewWeakRef.get();
+                            if (view != null) {
+                                view.mRenderer.onDrawFrame(gl);
+                            }
+                            if (shouldSwap) {
+                                int swapError = mEglHelper.swap();
+                                shouldSwap = false;
+                                switch (swapError) {
+                                    case EGL10.EGL_SUCCESS:
+                                        break;
+                                    case EGL11.EGL_CONTEXT_LOST:
+                                        if (LOG_SURFACE) {
+                                            Log.i("GLThread", "egl context lost tid=" + getId());
+                                        }
+                                        lostEglContext = true;
+                                        break;
+                                    default:
+                                        // Other errors typically mean that the current surface is bad,
+                                        // probably because the SurfaceView surface has been destroyed,
+                                        // but we haven't been notified yet.
+                                        // Log the error to help developers understand why rendering stopped.
+                                        EglHelper.logEglErrorAsWarning("GLThread", "eglSwapBuffers", swapError);
+
+                                        synchronized (sGLThreadManager) {
+                                            mSurfaceIsBad = true;
+                                            sGLThreadManager.notifyAll();
+                                        }
+                                        break;
+                                }
+                            }
+                        }
+                    }
+
+                    if (wantRenderNotification) {
+                        doRenderNotification = true;
+                    }
+                }
+
+            } finally {
+                /*
+                 * clean-up everything...
+                 */
+                synchronized (sGLThreadManager) {
+                    stopEglSurfaceLocked();
+                    stopEglContextLocked();
+                }
+            }
+        }
+
+        public boolean ableToDraw() {
+            return mHaveEglContext && mHaveEglSurface && readyToDraw();
+        }
+
+        private boolean readyToDraw() {
+            return (!mPaused) && mHasSurface && (!mSurfaceIsBad)
+                    && (mWidth > 0) && (mHeight > 0)
+                    && (mRequestRender);
+        }
+
+        public void requestRender() {
+            synchronized(sGLThreadManager) {
+                mRequestRender = true;
+                sGLThreadManager.notifyAll();
+            }
+        }
+
+        public void surfaceCreated() {
+            synchronized(sGLThreadManager) {
+                if (LOG_THREADS) {
+                    Log.i("GLThread", "surfaceCreated tid=" + getId());
+                }
+                mHasSurface = true;
+                mFinishedCreatingEglSurface = false;
+                sGLThreadManager.notifyAll();
+                while (mWaitingForSurface
+                        && !mFinishedCreatingEglSurface
+                        && !mExited) {
+                    try {
+                        sGLThreadManager.wait();
+                    } catch (InterruptedException e) {
+                        Thread.currentThread().interrupt();
+                    }
+                }
+            }
+        }
+
+        public void surfaceDestroyed() {
+            synchronized(sGLThreadManager) {
+                if (LOG_THREADS) {
+                    Log.i("GLThread", "surfaceDestroyed tid=" + getId());
+                }
+                mHasSurface = false;
+                sGLThreadManager.notifyAll();
+                while((!mWaitingForSurface) && (!mExited)) {
+                    try {
+                        sGLThreadManager.wait();
+                    } catch (InterruptedException e) {
+                        Thread.currentThread().interrupt();
+                    }
+                }
+            }
+        }
+
+        public void onPause() {
+            synchronized (sGLThreadManager) {
+                if (LOG_PAUSE_RESUME) {
+                    Log.i("GLThread", "onPause tid=" + getId());
+                }
+                mRequestPaused = true;
+                sGLThreadManager.notifyAll();
+                while ((! mExited) && (! mPaused)) {
+                    if (LOG_PAUSE_RESUME) {
+                        Log.i("Main thread", "onPause waiting for mPaused.");
+                    }
+                    try {
+                        sGLThreadManager.wait();
+                    } catch (InterruptedException ex) {
+                        Thread.currentThread().interrupt();
+                    }
+                }
+            }
+        }
+
+        public void onResume() {
+            synchronized (sGLThreadManager) {
+                if (LOG_PAUSE_RESUME) {
+                    Log.i("GLThread", "onResume tid=" + getId());
+                }
+                mRequestPaused = false;
+                mRequestRender = true;
+                mRenderComplete = false;
+                sGLThreadManager.notifyAll();
+                while ((! mExited) && mPaused && (!mRenderComplete)) {
+                    if (LOG_PAUSE_RESUME) {
+                        Log.i("Main thread", "onResume waiting for !mPaused.");
+                    }
+                    try {
+                        sGLThreadManager.wait();
+                    } catch (InterruptedException ex) {
+                        Thread.currentThread().interrupt();
+                    }
+                }
+            }
+        }
+
+        public void onWindowResize(int w, int h) {
+            synchronized (sGLThreadManager) {
+                mWidth = w;
+                mHeight = h;
+                mSizeChanged = true;
+                mRequestRender = true;
+                mRenderComplete = false;
+                sGLThreadManager.notifyAll();
+
+                // Wait for thread to react to resize and render a frame
+                while (! mExited && !mPaused && !mRenderComplete
+                        && ableToDraw()) {
+                    if (LOG_SURFACE) {
+                        Log.i("Main thread", "onWindowResize waiting for render complete from tid=" + getId());
+                    }
+                    try {
+                        sGLThreadManager.wait();
+                    } catch (InterruptedException ex) {
+                        Thread.currentThread().interrupt();
+                    }
+                }
+            }
+        }
+
+        public void requestExitAndWait() {
+            // don't call this from GLThread thread or it is a guaranteed
+            // deadlock!
+            synchronized(sGLThreadManager) {
+                mShouldExit = true;
+                sGLThreadManager.notifyAll();
+                while (! mExited) {
+                    try {
+                        sGLThreadManager.wait();
+                    } catch (InterruptedException ex) {
+                        Thread.currentThread().interrupt();
+                    }
+                }
+            }
+        }
+
+        public void requestReleaseEglContextLocked() {
+            mShouldReleaseEglContext = true;
+            sGLThreadManager.notifyAll();
+        }
+
+        /**
+         * Queue an "event" to be run on the GL rendering thread.
+         * @param r the runnable to be run on the GL rendering thread.
+         */
+        public void queueEvent(Runnable r) {
+            if (r == null) {
+                throw new IllegalArgumentException("r must not be null");
+            }
+            synchronized(sGLThreadManager) {
+                mEventQueue.add(r);
+                sGLThreadManager.notifyAll();
+            }
+        }
+
+        // Once the thread is started, all accesses to the following member
+        // variables are protected by the sGLThreadManager monitor
+        private boolean mShouldExit;
+        private boolean mExited;
+        private boolean mRequestPaused;
+        private boolean mPaused;
+        private boolean mHasSurface;
+        private boolean mSurfaceIsBad;
+        private boolean mWaitingForSurface;
+        private boolean mHaveEglContext;
+        private boolean mHaveEglSurface;
+        private boolean mFinishedCreatingEglSurface;
+        private boolean mShouldReleaseEglContext;
+        private int mWidth;
+        private int mHeight;
+        private boolean mRequestRender;
+        private boolean mRenderComplete;
+        private ArrayList<Runnable> mEventQueue = new ArrayList<Runnable>();
+        private boolean mSizeChanged = true;
+
+        // End of member variables protected by the sGLThreadManager monitor.
+
+        private EglHelper mEglHelper;
+
+        /**
+         * Set once at thread construction time, nulled out when the parent view is garbage
+         * called. This weak reference allows the EGLSurfaceView to be garbage collected while
+         * the GLThread is still alive.
+         */
+        private WeakReference<EGLSurfaceView> mEGLSurfaceViewWeakRef;
+
+    }
+
+    static class LogWriter extends Writer {
+
+        @Override public void close() {
+            flushBuilder();
+        }
+
+        @Override public void flush() {
+            flushBuilder();
+        }
+
+        @Override public void write(char[] buf, int offset, int count) {
+            for(int i = 0; i < count; i++) {
+                char c = buf[offset + i];
+                if ( c == '\n') {
+                    flushBuilder();
+                }
+                else {
+                    mBuilder.append(c);
+                }
+            }
+        }
+
+        private void flushBuilder() {
+            if (mBuilder.length() > 0) {
+                Log.v("EGLSurfaceView", mBuilder.toString());
+                mBuilder.delete(0, mBuilder.length());
+            }
+        }
+
+        private StringBuilder mBuilder = new StringBuilder();
+    }
+
+
+    private final void checkRenderThreadState() {
+        if (mGLThread != null) {
+            throw new IllegalStateException(
+                    "setRenderer has already been called for this instance.");
+        }
+    }
+
+    private static class GLThreadManager {
+        private static String TAG = "GLThreadManager";
+
+        public synchronized void threadExiting(GLThread thread) {
+            if (LOG_THREADS) {
+                Log.i("GLThread", "exiting tid=" +  thread.getId());
+            }
+            thread.mExited = true;
+            if (mEglOwner == thread) {
+                mEglOwner = null;
+            }
+            notifyAll();
+        }
+
+        /*
+         * Tries once to acquire the right to use an EGL
+         * context. Does not block. Requires that we are already
+         * in the sGLThreadManager monitor when this is called.
+         *
+         * @return true if the right to use an EGL context was acquired.
+         */
+        public boolean tryAcquireEglContextLocked(GLThread thread) {
+            if (mEglOwner == thread || mEglOwner == null) {
+                mEglOwner = thread;
+                notifyAll();
+                return true;
+            }
+            checkGLESVersion();
+            if (mMultipleGLESContextsAllowed) {
+                return true;
+            }
+            // Notify the owning thread that it should release the context.
+            // TODO: implement a fairness policy. Currently
+            // if the owning thread is drawing continuously it will just
+            // reacquire the EGL context.
+            if (mEglOwner != null) {
+                mEglOwner.requestReleaseEglContextLocked();
+            }
+            return false;
+        }
+
+        /*
+         * Releases the EGL context. Requires that we are already in the
+         * sGLThreadManager monitor when this is called.
+         */
+        public void releaseEglContextLocked(GLThread thread) {
+            if (mEglOwner == thread) {
+                mEglOwner = null;
+            }
+            notifyAll();
+        }
+
+        public synchronized boolean shouldReleaseEGLContextWhenPausing() {
+            // Release the EGL context when pausing even if
+            // the hardware supports multiple EGL contexts.
+            // Otherwise the device could run out of EGL contexts.
+            return mLimitedGLESContexts;
+        }
+
+        public synchronized boolean shouldTerminateEGLWhenPausing() {
+            checkGLESVersion();
+            return !mMultipleGLESContextsAllowed;
+        }
+
+        public synchronized void checkGLDriver(GL10 gl) {
+            if (! mGLESDriverCheckComplete) {
+                checkGLESVersion();
+                String renderer = gl.glGetString(GL10.GL_RENDERER);
+                if (mGLESVersion < kGLES_20) {
+                    mMultipleGLESContextsAllowed =
+                            ! renderer.startsWith(kMSM7K_RENDERER_PREFIX);
+                    notifyAll();
+                }
+                mLimitedGLESContexts = !mMultipleGLESContextsAllowed;
+                if (LOG_SURFACE) {
+                    Log.w(TAG, "checkGLDriver renderer = \"" + renderer + "\" multipleContextsAllowed = "
+                            + mMultipleGLESContextsAllowed
+                            + " mLimitedGLESContexts = " + mLimitedGLESContexts);
+                }
+                mGLESDriverCheckComplete = true;
+            }
+        }
+
+        private void checkGLESVersion() {
+            if (! mGLESVersionCheckComplete) {
+                mGLESVersion = SystemProperties.getInt(
+                        "ro.opengles.version",
+                        ConfigurationInfo.GL_ES_VERSION_UNDEFINED);
+                if (mGLESVersion >= kGLES_20) {
+                    mMultipleGLESContextsAllowed = true;
+                }
+                if (LOG_SURFACE) {
+                    Log.w(TAG, "checkGLESVersion mGLESVersion =" +
+                            " " + mGLESVersion + " mMultipleGLESContextsAllowed = " + mMultipleGLESContextsAllowed);
+                }
+                mGLESVersionCheckComplete = true;
+            }
+        }
+
+        /**
+         * This check was required for some pre-Android-3.0 hardware. Android 3.0 provides
+         * support for hardware-accelerated views, therefore multiple EGL contexts are
+         * supported on all Android 3.0+ EGL drivers.
+         */
+        private boolean mGLESVersionCheckComplete;
+        private int mGLESVersion;
+        private boolean mGLESDriverCheckComplete;
+        private boolean mMultipleGLESContextsAllowed;
+        private boolean mLimitedGLESContexts;
+        private static final int kGLES_20 = 0x20000;
+        private static final String kMSM7K_RENDERER_PREFIX =
+                "Q3Dimension MSM7500 ";
+        private GLThread mEglOwner;
+    }
+
+    private static final GLThreadManager sGLThreadManager = new GLThreadManager();
+
+    private final WeakReference<EGLSurfaceView> mThisWeakRef =
+            new WeakReference<EGLSurfaceView>(this);
+    private GLThread mGLThread;
+    private Renderer mRenderer;
+    private boolean mDetached;
+    private EGLConfigChooser mEGLConfigChooser;
+    private EGLContextFactory mEGLContextFactory;
+    private EGLWindowSurfaceFactory mEGLWindowSurfaceFactory;
+    private GLWrapper mGLWrapper;
+    private int mDebugFlags;
+    private int mEGLContextClientVersion;
+    private boolean mPreserveEGLContextOnPause;
+
+    /**
+     * Gives access to the system properties store.  The system properties
+     * store contains a list of string key-value pairs.
+     */
+    private static class SystemProperties
+    {
+        public static final int PROP_NAME_MAX = 31;
+        public static final int PROP_VALUE_MAX = 91;
+
+        /**
+         * Get the value for the given key.
+         * @return an empty string if the key isn't found
+         * @throws IllegalArgumentException if the key exceeds 32 characters
+         */
+        public static String get(String key) {
+            if (key.length() > PROP_NAME_MAX) {
+                throw new IllegalArgumentException("key.length > " + PROP_NAME_MAX);
+            }
+            try {
+                return native_get(key);
+            } catch (Exception e) {
+                return "";
+            }
+        }
+        /**
+         * Get the value for the given key.
+         * @return if the key isn't found, return def if it isn't null, or an empty string otherwise
+         * @throws IllegalArgumentException if the key exceeds 32 characters
+         */
+        public static String get(String key, String def) {
+            if (key.length() > PROP_NAME_MAX) {
+                throw new IllegalArgumentException("key.length > " + PROP_NAME_MAX);
+            }
+            try {
+                String ret = native_get(key);
+                if(TextUtils.isEmpty(ret)) {
+                    return def;
+                }
+                return ret;
+            } catch (Exception e) {
+                return def;
+            }
+        }
+        /**
+         * Get the value for the given key, and return as an integer.
+         * @param key the key to lookup
+         * @param def a default value to return
+         * @return the key parsed as an integer, or def if the key isn't found or
+         *         cannot be parsed
+         * @throws IllegalArgumentException if the key exceeds 32 characters
+         */
+        public static int getInt(String key, int def) {
+            if (key.length() > PROP_NAME_MAX) {
+                throw new IllegalArgumentException("key.length > " + PROP_NAME_MAX);
+            }
+            try {
+                return Integer.parseInt(native_get(key));
+            } catch (Exception e) {
+                return def;
+            }
+        }
+        /**
+         * Get the value for the given key, and return as a long.
+         * @param key the key to lookup
+         * @param def a default value to return
+         * @return the key parsed as a long, or def if the key isn't found or
+         *         cannot be parsed
+         * @throws IllegalArgumentException if the key exceeds 32 characters
+         */
+        public static long getLong(String key, long def) {
+            if (key.length() > PROP_NAME_MAX) {
+                throw new IllegalArgumentException("key.length > " + PROP_NAME_MAX);
+            }
+            try {
+                return Long.parseLong(native_get(key));
+            } catch (Exception e) {
+                return def;
+            }
+        }
+        /**
+         * Get the value for the given key, returned as a boolean.
+         * Values 'n', 'no', '0', 'false' or 'off' are considered false.
+         * Values 'y', 'yes', '1', 'true' or 'on' are considered true.
+         * (case sensitive).
+         * If the key does not exist, or has any other value, then the default
+         * result is returned.
+         * @param key the key to lookup
+         * @param def a default value to return
+         * @return the key parsed as a boolean, or def if the key isn't found or is
+         *         not able to be parsed as a boolean.
+         * @throws IllegalArgumentException if the key exceeds 32 characters
+         */
+        public static boolean getBoolean(String key, boolean def) {
+            if (key.length() > PROP_NAME_MAX) {
+                throw new IllegalArgumentException("key.length > " + PROP_NAME_MAX);
+            }
+            try {
+                return Boolean.parseBoolean(native_get(key));
+            } catch (Exception e) {
+                return def;
+            }
+        }
+
+        private static Map<String, String> cache = new HashMap<String, String>();
+        private static String native_get(String key) throws Exception {
+            if(cache.containsKey(key)) {
+                return cache.get(key);
+            }
+
+            Process p = Runtime.getRuntime().exec("/system/bin/getprop " + key);
+            p.waitFor();
+            BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream()));
+            String ln = reader.readLine();
+            reader.close();
+            p.destroy();
+
+            cache.put(key, ln);
+            return ln;
+        }
+
+    }
+}
diff --git a/app/src/main/java/smallville7123/EGLSurfaceView_EGLTextureView/EGLTextureView.java b/app/src/main/java/smallville7123/EGLSurfaceView_EGLTextureView/EGLTextureView.java
new file mode 100644
index 00000000..0b6e721a
--- /dev/null
+++ b/app/src/main/java/smallville7123/EGLSurfaceView_EGLTextureView/EGLTextureView.java
@@ -0,0 +1,2406 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package smallville7123.EGLSurfaceView_EGLTextureView;
+
+import android.content.Context;
+import android.content.pm.ConfigurationInfo;
+import android.graphics.SurfaceTexture;
+import android.opengl.EGL14;
+import android.opengl.EGLExt;
+import android.opengl.GLDebugHelper;
+import android.os.SystemClock;
+import android.text.TextUtils;
+import android.util.AttributeSet;
+import android.util.Log;
+import android.view.Choreographer;
+import android.view.TextureView;
+
+import androidx.annotation.CallSuper;
+
+import java.io.BufferedReader;
+import java.io.InputStreamReader;
+import java.io.Writer;
+import java.lang.ref.WeakReference;
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Map;
+
+import javax.microedition.khronos.egl.EGL10;
+import javax.microedition.khronos.egl.EGL11;
+import javax.microedition.khronos.egl.EGLConfig;
+import javax.microedition.khronos.egl.EGLContext;
+import javax.microedition.khronos.egl.EGLDisplay;
+import javax.microedition.khronos.egl.EGLSurface;
+import javax.microedition.khronos.opengles.GL;
+import javax.microedition.khronos.opengles.GL10;
+
+/**
+ * An implementation of TextureView that uses the dedicated surface for
+ * displaying OpenGL rendering.
+ * <p>
+ * A EGLTextureView provides the following features:
+ * <p>
+ * <ul>
+ * <li>Manages a surface, which is a special piece of memory that can be
+ * composited into the Android view system.
+ * <li>Manages an EGL display, which enables OpenGL to render into a surface.
+ * <li>Accepts a user-provided Renderer object that does the actual rendering.
+ * <li>Renders on a dedicated thread to decouple rendering performance from the
+ * UI thread.
+ * <li>Supports both on-demand and continuous rendering.
+ * <li>Optionally wraps, traces, and/or error-checks the renderer's OpenGL calls.
+ * </ul>
+ *
+ * <div class="special reference">
+ * <h3>Developer Guides</h3>
+ * <p>For more information about how to use OpenGL, read the
+ * <a href="{@docRoot}guide/topics/graphics/opengl.html">OpenGL</a> developer guide.</p>
+ * </div>
+ *
+ * <h3>Using EGLTextureView</h3>
+ * <p>
+ * Typically you use EGLTextureView by subclassing it and overriding one or more of the
+ * View system input event methods. If your application does not need to override event
+ * methods then EGLTextureView can be used as-is. For the most part
+ * EGLTextureView behavior is customized by calling "set" methods rather than by subclassing.
+ * For example, unlike a regular View, drawing is delegated to a separate Renderer object which
+ * is registered with the EGLTextureView
+ * using the {@link #setRenderer(Renderer)} call.
+ * <p>
+ * <h3>Initializing EGLTextureView</h3>
+ * All you have to do to initialize a EGLTextureView is call {@link #setRenderer(Renderer)}.
+ * However, if desired, you can modify the default behavior of EGLTextureView by calling one or
+ * more of these methods before calling setRenderer:
+ * <ul>
+ * <li>{@link #setDebugFlags(int)}
+ * <li>{@link #setEGLConfigChooser(boolean)}
+ * <li>{@link #setEGLConfigChooser(EGLConfigChooser)}
+ * <li>{@link #setEGLConfigChooser(int, int, int, int, int, int)}
+ * <li>{@link #setGLWrapper(GLWrapper)}
+ * </ul>
+ * <p>
+ * <h4>Specifying the android.view.Surface</h4>
+ * By default EGLTextureView will create a PixelFormat.RGB_888 format surface. If a translucent
+ * surface is required, call getHolder().setFormat(PixelFormat.TRANSLUCENT).
+ * The exact format of a TRANSLUCENT surface is device dependent, but it will be
+ * a 32-bit-per-pixel surface with 8 bits per component.
+ * <p>
+ * <h4>Choosing an EGL Configuration</h4>
+ * A given Android device may support multiple EGLConfig rendering configurations.
+ * The available configurations may differ in how may channels of data are present, as
+ * well as how many bits are allocated to each channel. Therefore, the first thing
+ * EGLTextureView has to do when starting to render is choose what EGLConfig to use.
+ * <p>
+ * By default EGLTextureView chooses a EGLConfig that has an RGB_888 pixel format,
+ * with at least a 16-bit depth buffer and no stencil.
+ * <p>
+ * If you would prefer a different EGLConfig
+ * you can override the default behavior by calling one of the
+ * setEGLConfigChooser methods.
+ * <p>
+ * <h4>Debug Behavior</h4>
+ * You can optionally modify the behavior of EGLTextureView by calling
+ * one or more of the debugging methods {@link #setDebugFlags(int)},
+ * and {@link #setGLWrapper}. These methods may be called before and/or after setRenderer, but
+ * typically they are called before setRenderer so that they take effect immediately.
+ * <p>
+ * <h4>Setting a Renderer</h4>
+ * Finally, you must call {@link #setRenderer} to register a {@link Renderer}.
+ * The renderer is
+ * responsible for doing the actual OpenGL rendering.
+ * <p>
+ * <h3>Rendering Mode</h3>
+ * Once the renderer is set, you can control whether the renderer draws
+ * continuously or on-demand by calling
+ * {@link #setRenderMode}. The default is continuous rendering.
+ * <p>
+ * <h3>Activity Life-cycle</h3>
+ * A EGLTextureView must be notified when the activity is paused and resumed. EGLTextureView clients
+ * are required to call {@link #onPause()} when the activity pauses and
+ * {@link #onResume()} when the activity resumes. These calls allow EGLTextureView to
+ * pause and resume the rendering thread, and also allow EGLTextureView to release and recreate
+ * the OpenGL display.
+ * <p>
+ * <h3>Handling events</h3>
+ * <p>
+ * To handle an event you will typically subclass EGLTextureView and override the
+ * appropriate method, just as you would with any other View. However, when handling
+ * the event, you may need to communicate with the Renderer object
+ * that's running in the rendering thread. You can do this using any
+ * standard Java cross-thread communication mechanism. In addition,
+ * one relatively easy way to communicate with your renderer is
+ * to call
+ * {@link #queueEvent(Runnable)}. For example:
+ * <pre class="prettyprint">
+ * class MyEGLTextureView extends EGLTextureView {
+ *
+ *     private MyRenderer mMyRenderer;
+ *
+ *     public void start() {
+ *         mMyRenderer = ...;
+ *         setRenderer(mMyRenderer);
+ *     }
+ *
+ *     public boolean onKeyDown(int keyCode, KeyEvent event) {
+ *         if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {
+ *             queueEvent(new Runnable() {
+ *                 // This method will be called on the rendering
+ *                 // thread:
+ *                 public void run() {
+ *                     mMyRenderer.handleDpadCenter();
+ *                 }});
+ *             return true;
+ *         }
+ *         return super.onKeyDown(keyCode, event);
+ *     }
+ * }
+ * </pre>
+ *
+ */
+public class EGLTextureView extends TextureView implements TextureView.SurfaceTextureListener {
+    private final static String TAG = "EGLTextureView";
+
+    private final static boolean LOG_ATTACH_DETACH = false;
+    private final static boolean LOG_THREADS = false;
+    private final static boolean LOG_PAUSE_RESUME = false;
+    private final static boolean LOG_SURFACE = false;
+    private final static boolean LOG_RENDERER = false;
+    private final static boolean LOG_RENDERER_DRAW_FRAME = false;
+    private final static boolean LOG_EGL = false;
+    /**
+     * The renderer only renders
+     * when the surface is created, or when {@link #requestRender} is called.
+     *
+     * @see #getRenderMode()
+     * @see #setRenderMode(int)
+     * @see #requestRender()
+     */
+    public final static int RENDERMODE_WHEN_DIRTY = 0;
+    /**
+     * The renderer is called
+     * continuously to re-render the scene.
+     *
+     * @see #getRenderMode()
+     * @see #setRenderMode(int)
+     */
+    public final static int RENDERMODE_CONTINUOUSLY = 1;
+
+    /**
+     * Check glError() after every GL call and throw an exception if glError indicates
+     * that an error has occurred. This can be used to help track down which OpenGL ES call
+     * is causing an error.
+     *
+     * @see #getDebugFlags
+     * @see #setDebugFlags
+     */
+    public final static int DEBUG_CHECK_GL_ERROR = 1;
+
+    /**
+     * Log GL calls to the system log at "verbose" level with tag "EGLTextureView".
+     *
+     * @see #getDebugFlags
+     * @see #setDebugFlags
+     */
+    public final static int DEBUG_LOG_GL_CALLS = 2;
+
+    /**
+     * Standard View constructor. In order to render something, you
+     * must call {@link #setRenderer} to register a renderer.
+     */
+    public EGLTextureView(Context context) {
+        super(context);
+        init();
+    }
+
+    /**
+     * Standard View constructor. In order to render something, you
+     * must call {@link #setRenderer} to register a renderer.
+     */
+    public EGLTextureView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        init();
+    }
+
+    @Override
+    @CallSuper
+    protected void finalize() throws Throwable {
+        try {
+            if (mGLThread != null) {
+                // GLThread may still be running if this view was never
+                // attached to a window.
+                mGLThread.requestExitAndWait();
+            }
+        } finally {
+            super.finalize();
+        }
+    }
+
+    private class Methods {
+        private final Class<EGLTextureView> clazz;
+        Method swapBuffersMethod;
+        String swapBuffersName;
+        String swapBuffersSignature;
+        Methods() {
+            clazz = EGLTextureView.class;
+            try {
+                swapBuffersMethod = clazz.getDeclaredMethod("swapBuffers");
+            } catch (NoSuchMethodException e) {
+                throw new RuntimeException("cannot find own methods");
+            }
+            swapBuffersName = swapBuffersMethod.getName();
+            swapBuffersSignature = "()V";
+        }
+    }
+
+    private Methods methods;
+
+    public enum METHOD {
+        SWAP_BUFFERS
+    }
+
+    public final String getJavaNameForJNI(METHOD METHOD) {
+        switch (METHOD) {
+            case SWAP_BUFFERS:
+                return methods.swapBuffersName;
+        }
+        return null;
+    }
+
+    public final String getJavaSignatureForJNI(METHOD METHOD) {
+        switch (METHOD) {
+            case SWAP_BUFFERS:
+                return methods.swapBuffersSignature;
+        }
+        return null;
+    }
+
+    private final Choreographer choreographer = Choreographer.getInstance();
+    private final Object VSYNC_LOCK = new Object();
+    private boolean vsynced;
+    private boolean shouldSwap;
+
+    /**
+     * Requests that the render thread swaps its buffers
+     * <br><br>
+     * The buffers will be swapped either when the current draw completes,
+     * or when the next draw completes
+     * <br><br>
+     * Subsequent calls in the same frame has no effect
+     * <br><br>
+     * This may be called from any thread
+     * <br><br>
+     * <br><br>
+     * Ensures that the render thread calls:
+     * <code>eglSwapBuffers(EGLDisplay, EGLSurface)</code>
+     * <br><br>
+     * <br><br>
+     * If you need to call this method from jni,
+     * please adapt your code to use the following
+     * <br><br>
+     *     Java:
+     * <pre class="prettyprint">
+     * {@literal @Override}
+     * public class Example extends EGLTextureView {
+     *     // ...
+     *     class ExampleRenderer implements Renderer {
+     *         native long createNativeInstance();
+     *         native void onEglSetup(long instance, Object classInstance, String name, String signature);
+     *         native void surfaceChanged(long instance, int w, int h);
+     *         native void onDraw(long instance);
+     *         native void onEglTearDown(long instance);
+     *         long nativeInstance;
+     *
+     *         ExampleRenderer() {
+     *             System.loadLibrary("YourNativeLibrary");
+     *             nativeInstance = createNativeInstance();
+     *         }
+     *
+     *         {@literal @Override}
+     *         public void onEglSetup() {
+     *             onEglSetup(nativeInstance, Example.this,
+     *                     getJavaNameForJNI(METHOD.SWAP_BUFFERS),
+     *                     getJavaSignatureForJNI(METHOD.SWAP_BUFFERS)
+     *             );
+     *         }
+     *
+     *         {@literal @Override}
+     *         public void onEglTearDown() {
+     *             onEglTearDown(nativeInstance);
+     *         }
+     *
+     *         {@literal @Override}
+     *         public void onSurfaceChanged(GL10 gl, int width, int height) {
+     *             surfaceChanged(nativeInstance, width, height);
+     *         }
+     *
+     *         {@literal @Override}
+     *         public void onDrawFrame(GL10 gl) {
+     *             onDraw(nativeInstance);
+     *         }
+     *     }
+     * }
+     * </pre>
+     *     Jni Header file:
+     * <pre class="prettyprint">
+     * class Example {
+     *     class JVM_MANAGER {
+     *     public:
+     *         JavaVM * jvm;
+     *         JNIEnv* jenv;
+     *         JavaVMAttachArgs jvmArgs;
+     *         bool needsToDetach;
+     *
+     *         JVM_MANAGER();
+     *         bool getJVM(JNIEnv * env);
+     *         bool attachJVM();
+     *         void detachJVM();
+     *
+     *         template <typename J, typename O> O globalRef(J j, O o) {
+     *             return reinterpret_cast<O>(j->NewGlobalRef(o));
+     *         }
+     *     };
+     *
+     *
+     *     JVM_MANAGER jvmManager;
+     *     jobject jObject;
+     *     jclass jClass;
+     *     jmethodID jSwapBuffers;
+     * }
+     * </pre>
+     *     Jni CPP file:
+     * <pre class="prettyprint">
+     * Example::JVM_MANAGER::JVM_MANAGER() {
+     *     jvm = nullptr;
+     *     jenv = nullptr;
+     *     needsToDetach = false;
+     *     jvmArgs.version = JNI_VERSION_1_6;
+     * }
+     *
+     * bool Example::JVM_MANAGER::getJVM(JNIEnv *env) {
+     *     return env->GetJavaVM(&jvm) == JNI_OK;
+     * }
+     *
+     * bool Example::JVM_MANAGER::attachJVM() {
+     *     // checks if current env needs attaching or it is already attached
+     *     jint res = jvm->GetEnv((void**)&jenv, JNI_VERSION_1_6);
+     *     if (res == JNI_EDETACHED) {
+     *         // Supported but not attached yet, needs to call AttachCurrentThread
+     *         res = jvm->AttachCurrentThread(&jenv, &jvmArgs);
+     *         if (res == JNI_OK) {
+     *             needsToDetach = true;
+     *         } else {
+     *             // Failed to attach, cancel
+     *             return false;
+     *         }
+     *     } else if (JNI_OK == res) {
+     *         // Current thread already attached, do not attach 'again' (just to save the attachedHere flag)
+     *         // We make sure to keep attached = 0
+     *         needsToDetach = false;
+     *     } else {
+     *         // JNI_EVERSION, specified version is not supported cancel this..
+     *         return false;
+     *     }
+     *     return true;
+     * }
+     *
+     * void Example::JVM_MANAGER::detachJVM() {
+     *     if (needsToDetach) {
+     *         jvm->DetachCurrentThread();
+     *     }
+     * }
+     * 
+     * Example::Example(JNIEnv *jenv, jobject classInstance, jstring name, jstring signature) {
+     *     if (!jvmManager.getJVM(jenv)) {
+     *         // failed to get JavaVM
+     *         return;
+     *     }
+     *     if (!jvmManager.attachJVM()) {
+     *         // failed to attach JVM
+     *         return;
+     *     }
+     *     jObject = jvmManager.globalRef(jenv, classInstance);
+     *     jClass = jvmManager.globalRef(jenv, jenv->GetObjectClass(jObject));
+     *     jboolean isCopy1, isCopy2;
+     *
+     *     if (name == nullptr) {
+     *          // cannot use a null name (0x0)
+     *         return;
+     *     }
+     *
+     *     if (signature == nullptr) {
+     *         // cannot use a null signature (0x0)
+     *         return;
+     *     }
+     *
+     *     const char * n = jvmManager.jenv->GetStringUTFChars(name, &isCopy1);
+     *     if (n == nullptr) {
+     *         // cannot get UTF chars from name
+     *         return;
+     *     }
+     *
+     *     const char * s = jvmManager.jenv->GetStringUTFChars(signature, &isCopy2);
+     *     if (s == nullptr) {
+     *         // cannot get UTF chars from signature
+     *         jvmManager.jenv->ReleaseStringUTFChars(name, n);
+     *         return;
+     *     }
+     *
+     *     jSwapBuffers = jvmManager.jenv->GetMethodID(jClass, n, s);
+     *
+     *     jvmManager.jenv->ReleaseStringUTFChars(name, n);
+     *     jvmManager.jenv->ReleaseStringUTFChars(name, s);
+     *
+     *     if (jSwapBuffers == nullptr) {
+     *         // cannot find method with name 'name', and signature 'signature'
+     *     }
+     * }
+     *
+     * Example::~Example() {
+     *     jvmManager.jenv->DeleteGlobalRef(jClass);
+     *     jvmManager.jenv->DeleteGlobalRef(jObject);
+     *     jvmManager.detachJVM();
+     * }
+     *
+     * void Example::swapBuffers() {
+     *     if (jSwapBuffers != nullptr) {
+     *         jvmManager.jenv->CallVoidMethod(jObject, jSwapBuffers);
+     *     }
+     * }
+     * </pre>
+     */
+    protected final void swapBuffers() {
+        synchronized (VSYNC_LOCK) {
+            if (!shouldSwap) {
+                shouldSwap = true;
+            }
+        }
+    }
+
+    @CallSuper
+    protected void init() {
+        shouldSwap = false;
+
+        // provides info for jni to java
+        methods = new Methods();
+
+        choreographer.postFrameCallback(
+                new Choreographer.FrameCallback() {
+                    /**
+                     * Called when a new display frame is being rendered.
+                     * <p>
+                     * This method provides the time in nanoseconds when the frame started being rendered.
+                     * The frame time provides a stable time base for synchronizing animations
+                     * and drawing.  It should be used instead of {@link SystemClock#uptimeMillis()}
+                     * or {@link System#nanoTime()} for animations and drawing in the UI.  Using the frame
+                     * time helps to reduce inter-frame jitter because the frame time is fixed at the time
+                     * the frame was scheduled to start, regardless of when the animations or drawing
+                     * callback actually runs.  All callbacks that run as part of rendering a frame will
+                     * observe the same frame time so using the frame time also helps to synchronize effects
+                     * that are performed by different callbacks.
+                     * </p><p>
+                     * Please note that the framework already takes care to process animations and
+                     * drawing using the frame time as a stable time base.  Most applications should
+                     * not need to use the frame time information directly.
+                     * </p>
+                     *
+                     * @param frameTimeNanos The time in nanoseconds when the frame started being rendered,
+                     *                       in the {@link System#nanoTime()} timebase.  Divide this value by {@code 1000000}
+                     *                       to convert it to the {@link SystemClock#uptimeMillis()} time base.
+                     */
+                    @Override
+                    public void doFrame(long frameTimeNanos) {
+                        synchronized (VSYNC_LOCK) {
+                            vsynced = true;
+                            mGLThread.requestRender();
+                        }
+                        choreographer.postFrameCallback(this);
+                    }
+                }
+        );
+        super.setSurfaceTextureListener(this);
+    }
+
+    /**
+     * Set the glWrapper. If the glWrapper is not null, its
+     * {@link GLWrapper#wrap(GL)} method is called
+     * whenever a surface is created. A GLWrapper can be used to wrap
+     * the GL object that's passed to the renderer. Wrapping a GL
+     * object enables examining and modifying the behavior of the
+     * GL calls made by the renderer.
+     * <p>
+     * Wrapping is typically used for debugging purposes.
+     * <p>
+     * The default value is null.
+     * @param glWrapper the new GLWrapper
+     */
+    public void setGLWrapper(GLWrapper glWrapper) {
+        mGLWrapper = glWrapper;
+    }
+
+    /**
+     * Set the debug flags to a new value. The value is
+     * constructed by OR-together zero or more
+     * of the DEBUG_CHECK_* constants. The debug flags take effect
+     * whenever a surface is created. The default value is zero.
+     * @param debugFlags the new debug flags
+     * @see #DEBUG_CHECK_GL_ERROR
+     * @see #DEBUG_LOG_GL_CALLS
+     */
+    public void setDebugFlags(int debugFlags) {
+        mDebugFlags = debugFlags;
+    }
+
+    /**
+     * Get the current value of the debug flags.
+     * @return the current value of the debug flags.
+     */
+    public int getDebugFlags() {
+        return mDebugFlags;
+    }
+
+    /**
+     * Control whether the EGL context is preserved when the EGLTextureView is paused and
+     * resumed.
+     * <p>
+     * If set to true, then the EGL context may be preserved when the EGLTextureView is paused.
+     * Whether the EGL context is actually preserved or not depends upon whether the
+     * Android device that the program is running on can support an arbitrary number of EGL
+     * contexts or not. Devices that can only support a limited number of EGL contexts must
+     * release the  EGL context in order to allow multiple applications to share the GPU.
+     * <p>
+     * If set to false, the EGL context will be released when the EGLTextureView is paused,
+     * and recreated when the EGLTextureView is resumed.
+     * <p>
+     *
+     * The default is false.
+     *
+     * @param preserveOnPause preserve the EGL context when paused
+     */
+    public void setPreserveEGLContextOnPause(boolean preserveOnPause) {
+        mPreserveEGLContextOnPause = preserveOnPause;
+    }
+
+    /**
+     * @return true if the EGL context will be preserved when paused
+     */
+    public boolean getPreserveEGLContextOnPause() {
+        return mPreserveEGLContextOnPause;
+    }
+
+    /**
+     * Set the renderer associated with this view. Also starts the thread that
+     * will call the renderer, which in turn causes the rendering to start.
+     * <p>This method should be called once and only once in the life-cycle of
+     * a EGLTextureView.
+     * <p>The following EGLTextureView methods can only be called <em>before</em>
+     * setRenderer is called:
+     * <ul>
+     * <li>{@link #setEGLConfigChooser(boolean)}
+     * <li>{@link #setEGLConfigChooser(EGLConfigChooser)}
+     * <li>{@link #setEGLConfigChooser(int, int, int, int, int, int)}
+     * </ul>
+     * <p>
+     * The following EGLTextureView methods can only be called <em>after</em>
+     * setRenderer is called:
+     * <ul>
+     * <li>{@link #getRenderMode()}
+     * <li>{@link #onPause()}
+     * <li>{@link #onResume()}
+     * <li>{@link #queueEvent(Runnable)}
+     * <li>{@link #swapBuffers()}
+     * <li>{@link #setRenderMode(int)}
+     * </ul>
+     *
+     * @param renderer the renderer to use to perform OpenGL drawing.
+     */
+    public void setRenderer(Renderer renderer) {
+        checkRenderThreadState();
+        if (mEGLConfigChooser == null) {
+            mEGLConfigChooser = new SimpleEGLConfigChooser(true);
+        }
+        if (mEGLContextFactory == null) {
+            mEGLContextFactory = new DefaultContextFactory();
+        }
+        if (mEGLWindowSurfaceFactory == null) {
+            mEGLWindowSurfaceFactory = new DefaultWindowSurfaceFactory();
+        }
+        mRenderer = renderer;
+        mGLThread = new GLThread(mThisWeakRef);
+        mGLThread.start();
+    }
+
+    /**
+     * Install a custom EGLContextFactory.
+     * <p>If this method is
+     * called, it must be called before {@link #setRenderer(Renderer)}
+     * is called.
+     * <p>
+     * If this method is not called, then by default
+     * a context will be created with no shared context and
+     * with a null attribute list.
+     */
+    public void setEGLContextFactory(EGLContextFactory factory) {
+        checkRenderThreadState();
+        mEGLContextFactory = factory;
+    }
+
+    /**
+     * Install a custom EGLWindowSurfaceFactory.
+     * <p>If this method is
+     * called, it must be called before {@link #setRenderer(Renderer)}
+     * is called.
+     * <p>
+     * If this method is not called, then by default
+     * a window surface will be created with a null attribute list.
+     */
+    public void setEGLWindowSurfaceFactory(EGLWindowSurfaceFactory factory) {
+        checkRenderThreadState();
+        mEGLWindowSurfaceFactory = factory;
+    }
+
+    /**
+     * Install a custom EGLConfigChooser.
+     * <p>If this method is
+     * called, it must be called before {@link #setRenderer(Renderer)}
+     * is called.
+     * <p>
+     * If no setEGLConfigChooser method is called, then by default the
+     * view will choose an EGLConfig that is compatible with the current
+     * android.view.Surface, with a depth buffer depth of
+     * at least 16 bits.
+     * @param configChooser
+     */
+    public void setEGLConfigChooser(EGLConfigChooser configChooser) {
+        checkRenderThreadState();
+        mEGLConfigChooser = configChooser;
+    }
+
+    /**
+     * Install a config chooser which will choose a config
+     * as close to 16-bit RGB as possible, with or without an optional depth
+     * buffer as close to 16-bits as possible.
+     * <p>If this method is
+     * called, it must be called before {@link #setRenderer(Renderer)}
+     * is called.
+     * <p>
+     * If no setEGLConfigChooser method is called, then by default the
+     * view will choose an RGB_888 surface with a depth buffer depth of
+     * at least 16 bits.
+     *
+     * @param needDepth
+     */
+    public void setEGLConfigChooser(boolean needDepth) {
+        setEGLConfigChooser(new SimpleEGLConfigChooser(needDepth));
+    }
+
+    /**
+     * Install a config chooser which will choose a config
+     * with at least the specified depthSize and stencilSize,
+     * and exactly the specified redSize, greenSize, blueSize and alphaSize.
+     * <p>If this method is
+     * called, it must be called before {@link #setRenderer(Renderer)}
+     * is called.
+     * <p>
+     * If no setEGLConfigChooser method is called, then by default the
+     * view will choose an RGB_888 surface with a depth buffer depth of
+     * at least 16 bits.
+     *
+     */
+    public void setEGLConfigChooser(int redSize, int greenSize, int blueSize,
+                                    int alphaSize, int depthSize, int stencilSize) {
+        setEGLConfigChooser(new ComponentSizeChooser(redSize, greenSize,
+                blueSize, alphaSize, depthSize, stencilSize));
+    }
+
+    /**
+     * Inform the default EGLContextFactory and default EGLConfigChooser
+     * which EGLContext client version to pick.
+     * <p>Use this method to create an OpenGL ES 2.0-compatible context.
+     * Example:
+     * <pre class="prettyprint">
+     *     public MyView(Context context) {
+     *         super(context);
+     *         setEGLContextClientVersion(2); // Pick an OpenGL ES 2.0 context.
+     *         setRenderer(new MyRenderer());
+     *     }
+     * </pre>
+     * <p>Note: Activities which require OpenGL ES 2.0 should indicate this by
+     * setting @lt;uses-feature android:glEsVersion="0x00020000" /> in the activity's
+     * AndroidManifest.xml file.
+     * <p>If this method is called, it must be called before {@link #setRenderer(Renderer)}
+     * is called.
+     * <p>This method only affects the behavior of the default EGLContexFactory and the
+     * default EGLConfigChooser. If
+     * {@link #setEGLContextFactory(EGLContextFactory)} has been called, then the supplied
+     * EGLContextFactory is responsible for creating an OpenGL ES 2.0-compatible context.
+     * If
+     * {@link #setEGLConfigChooser(EGLConfigChooser)} has been called, then the supplied
+     * EGLConfigChooser is responsible for choosing an OpenGL ES 2.0-compatible config.
+     * @param version The EGLContext client version to choose. Use 2 for OpenGL ES 2.0
+     */
+    public void setEGLContextClientVersion(int version) {
+        checkRenderThreadState();
+        mEGLContextClientVersion = version;
+    }
+
+    int mRendermode;
+
+    /**
+     * Set the rendering mode. When renderMode is
+     * RENDERMODE_CONTINUOUSLY, the renderer is called
+     * repeatedly to re-render the scene. When renderMode
+     * is RENDERMODE_WHEN_DIRTY, the renderer only rendered when the surface
+     * is created, or when {@link #swapBuffers} is called. Defaults to RENDERMODE_CONTINUOUSLY.
+     * <p>
+     * Using RENDERMODE_WHEN_DIRTY can improve battery life and overall system performance
+     * by allowing the GPU and CPU to idle when the view does not need to be updated.
+     * <p>
+     * This method can only be called after {@link #setRenderer(Renderer)}
+     * <p>
+     *
+     * @deprecated This has no effect on rendering.
+     * @param renderMode one of the RENDERMODE_X constants
+     * @see #RENDERMODE_CONTINUOUSLY
+     * @see #RENDERMODE_WHEN_DIRTY
+     */
+    public void setRenderMode(int renderMode) {
+        mRendermode = renderMode;
+    }
+
+    /**
+     * Get the current rendering mode. May be called
+     * from any thread. Must not be called before a renderer has been set.
+     *
+     * @deprecated This has no effect on rendering.
+     * @return the current rendering mode.
+     * @see #RENDERMODE_CONTINUOUSLY
+     * @see #RENDERMODE_WHEN_DIRTY
+     */
+    public int getRenderMode() {
+        return mRendermode;
+    }
+
+    /**
+     * Request that the renderer render a frame.
+     * This method is typically used when the render mode has been set to
+     * {@link #RENDERMODE_WHEN_DIRTY}, so that frames are only rendered on demand.
+     * May be called
+     * from any thread. Must not be called before a renderer has been set.
+     * <br><br>
+     * this calls {@link #swapBuffers}
+     * @see #swapBuffers
+     */
+    public void requestRender() {
+        swapBuffers();
+    }
+
+    @Override
+    final public void setSurfaceTextureListener(SurfaceTextureListener listener) {
+        Log.e(TAG, "setSurfaceTextureListener preserved, setRenderer() instead?");
+    }
+
+    @Override
+    final public void onSurfaceTextureAvailable(SurfaceTexture surface, int width, int height) {
+        mGLThread.surfaceCreated();
+        onSurfaceTextureSizeChanged(surface, width, height);
+    }
+
+    @Override
+    final public void onSurfaceTextureSizeChanged(SurfaceTexture surface, int width, int height) {
+        mGLThread.onWindowResize(width, height);
+    }
+
+    @Override
+    final public boolean onSurfaceTextureDestroyed(SurfaceTexture surface) {
+        // Surface will be destroyed when we return
+        mGLThread.surfaceDestroyed();
+        if(null != mRenderer) {
+            mRenderer.onSurfaceDestroyed();
+        }
+        return true;
+    }
+
+    @Override
+    final public void onSurfaceTextureUpdated(SurfaceTexture surface) {
+
+    }
+
+    /**
+     * Inform the view that the activity is paused. The owner of this view must
+     * call this method when the activity is paused. Calling this method will
+     * pause the rendering thread.
+     * Must not be called before a renderer has been set.
+     */
+    @CallSuper
+    public void onPause() {
+        mGLThread.onPause();
+    }
+
+    /**
+     * Inform the view that the activity is resumed. The owner of this view must
+     * call this method when the activity is resumed. Calling this method will
+     * recreate the OpenGL display and resume the rendering
+     * thread.
+     * Must not be called before a renderer has been set.
+     */
+    @CallSuper
+    public void onResume() {
+        mGLThread.onResume();
+    }
+
+    /**
+     * Queue a runnable to be run on the GL rendering thread. This can be used
+     * to communicate with the Renderer on the rendering thread.
+     * Must not be called before a renderer has been set.
+     * @param r the runnable to be run on the GL rendering thread.
+     */
+    @CallSuper
+    public void queueEvent(Runnable r) {
+        mGLThread.queueEvent(r);
+    }
+
+    /**
+     * This method is used as part of the View class and is not normally
+     * called or subclassed by clients of EGLTextureView.
+     */
+    @Override
+    @CallSuper
+    protected void onAttachedToWindow() {
+        super.onAttachedToWindow();
+        if (LOG_ATTACH_DETACH) {
+            Log.d(TAG, "onAttachedToWindow reattach =" + mDetached);
+        }
+        if (mDetached && (mRenderer != null)) {
+            mGLThread = new GLThread(mThisWeakRef);
+            mGLThread.start();
+        }
+        mDetached = false;
+    }
+
+    @Override
+    @CallSuper
+    protected void onDetachedFromWindow() {
+        if (LOG_ATTACH_DETACH) {
+            Log.d(TAG, "onDetachedFromWindow");
+        }
+        if (mGLThread != null) {
+            mGLThread.requestExitAndWait();
+        }
+        mDetached = true;
+        super.onDetachedFromWindow();
+    }
+
+    // ----------------------------------------------------------------------
+
+    /**
+     * An interface used to wrap a GL interface.
+     * <p>Typically
+     * used for implementing debugging and tracing on top of the default
+     * GL interface. You would typically use this by creating your own class
+     * that implemented all the GL methods by delegating to another GL instance.
+     * Then you could add your own behavior before or after calling the
+     * delegate. All the GLWrapper would do was instantiate and return the
+     * wrapper GL instance:
+     * <pre class="prettyprint">
+     * class MyGLWrapper implements GLWrapper {
+     *     GL wrap(GL gl) {
+     *         return new MyGLImplementation(gl);
+     *     }
+     *     static class MyGLImplementation implements GL,GL10,GL11,... {
+     *         ...
+     *     }
+     * }
+     * </pre>
+     * @see #setGLWrapper(GLWrapper)
+     */
+    public interface GLWrapper {
+        /**
+         * Wraps a gl interface in another gl interface.
+         * @param gl a GL interface that is to be wrapped.
+         * @return either the input argument or another GL object that wraps the input argument.
+         */
+        GL wrap(GL gl);
+    }
+
+    /**
+     * A generic renderer interface.
+     * <p>
+     * The renderer is responsible for making OpenGL calls to render a frame.
+     * <p>
+     * EGLTextureView clients typically create their own classes that implement
+     * this interface, and then call {@link EGLTextureView#setRenderer} to
+     * register the renderer with the EGLTextureView.
+     * <p>
+     *
+     * <div class="special reference">
+     * <h3>Developer Guides</h3>
+     * <p>For more information about how to use OpenGL, read the
+     * <a href="{@docRoot}guide/topics/graphics/opengl.html">OpenGL</a> developer guide.</p>
+     * </div>
+     *
+     * <h3>Threading</h3>
+     * The renderer will be called on a separate thread, so that rendering
+     * performance is decoupled from the UI thread. Clients typically need to
+     * communicate with the renderer from the UI thread, because that's where
+     * input events are received. Clients can communicate using any of the
+     * standard Java techniques for cross-thread communication, or they can
+     * use the {@link EGLTextureView#queueEvent(Runnable)} convenience method.
+     * <p>
+     * <h3>EGL Context Lost</h3>
+     * There are situations where the EGL rendering context will be lost. This
+     * typically happens when device wakes up after going to sleep. When
+     * the EGL context is lost, all OpenGL resources (such as textures) that are
+     * associated with that context will be automatically deleted. In order to
+     * keep rendering correctly, a renderer must recreate any lost resources
+     * that it still needs. The {@link #onSurfaceCreated(GL10, EGLConfig)} method
+     * is a convenient place to do this.
+     *
+     *
+     * @see #setRenderer(Renderer)
+     */
+    public interface Renderer {
+        /**
+         * Called when the surface is created or recreated.
+         * <p>
+         * Called when the rendering thread
+         * starts and whenever the EGL context is lost. The EGL context will typically
+         * be lost when the Android device awakes after going to sleep.
+         * <p>
+         * Since this method is called at the beginning of rendering, as well as
+         * every time the EGL context is lost, this method is a convenient place to put
+         * code to create resources that need to be created when the rendering
+         * starts, and that need to be recreated when the EGL context is lost.
+         * Textures are an example of a resource that you might want to create
+         * here.
+         * <p>
+         * Note that when the EGL context is lost, all OpenGL resources associated
+         * with that context will be automatically deleted. You do not need to call
+         * the corresponding "glDelete" methods such as glDeleteTextures to
+         * manually delete these lost resources.
+         * <p>
+         * @param gl the GL interface. Use <code>instanceof</code> to
+         * test if the interface supports GL11 or higher interfaces.
+         * @param config the EGLConfig of the created surface. Can be used
+         * to create matching pbuffers.
+         */
+        default void onSurfaceCreated(GL10 gl, EGLConfig config) {}
+
+        /**
+         * Called when the surface changed size.
+         * <p>
+         * Called after the surface is created and whenever
+         * the OpenGL ES surface size changes.
+         * <p>
+         * Typically you will set your viewport here. If your camera
+         * is fixed then you could also set your projection matrix here:
+         * <pre class="prettyprint">
+         * void onSurfaceChanged(GL10 gl, int width, int height) {
+         *     gl.glViewport(0, 0, width, height);
+         *     // for a fixed camera, set the projection too
+         *     float ratio = (float) width / height;
+         *     gl.glMatrixMode(GL10.GL_PROJECTION);
+         *     gl.glLoadIdentity();
+         *     gl.glFrustumf(-ratio, ratio, -1, 1, 1, 10);
+         * }
+         * </pre>
+         * @param gl the GL interface. Use <code>instanceof</code> to
+         * test if the interface supports GL11 or higher interfaces.
+         * @param width surface width
+         * @param height surface height
+         */
+        void onSurfaceChanged(GL10 gl, int width, int height);
+
+        /**
+         * Called to draw the current frame.
+         * <p>
+         * This method is responsible for drawing the current frame.
+         * <p>
+         * The implementation of this method typically looks like this:
+         * <pre class="prettyprint">
+         * void onDrawFrame(GL10 gl) {
+         *     gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
+         *     //... other gl calls to render the scene ...
+         *     swapBuffers();
+         * }
+         * </pre>
+         * @param gl the GL interface. Use <code>instanceof</code> to
+         * test if the interface supports GL11 or higher interfaces.
+         *
+         * @implSpec you must call {@link #swapBuffers()} to draw anything
+         * @see #swapBuffers()
+         */
+        void onDrawFrame(GL10 gl);
+
+        default void onSurfaceDestroyed() {}
+
+        /**
+         * Called when the EGL context is made current
+         */
+        default void onEglSetup() {}
+
+        /**
+         * Called before the EGL context is lost
+         */
+        default void onEglTearDown() {}
+
+    }
+
+    /**
+     * An interface for customizing the eglCreateContext and eglDestroyContext calls.
+     * <p>
+     * This interface must be implemented by clients wishing to call
+     * {@link EGLTextureView#setEGLContextFactory(EGLContextFactory)}
+     */
+    public interface EGLContextFactory {
+        EGLContext createContext(EGL10 egl, EGLDisplay display, EGLConfig eglConfig);
+        void destroyContext(EGL10 egl, EGLDisplay display, EGLContext context);
+    }
+
+    private class DefaultContextFactory implements EGLContextFactory {
+        private int EGL_CONTEXT_CLIENT_VERSION = 0x3098;
+
+        public EGLContext createContext(EGL10 egl, EGLDisplay display, EGLConfig config) {
+            int[] attrib_list = {EGL_CONTEXT_CLIENT_VERSION, mEGLContextClientVersion,
+                    EGL10.EGL_NONE };
+
+            return egl.eglCreateContext(display, config, EGL10.EGL_NO_CONTEXT,
+                    mEGLContextClientVersion != 0 ? attrib_list : null);
+        }
+
+        public void destroyContext(EGL10 egl, EGLDisplay display,
+                                   EGLContext context) {
+            if (!egl.eglDestroyContext(display, context)) {
+                Log.e("DefaultContextFactory", "display:" + display + " context: " + context);
+                if (LOG_THREADS) {
+                    Log.i("DefaultContextFactory", "tid=" + Thread.currentThread().getId());
+                }
+                EglHelper.throwEglException("eglDestroyContex", egl.eglGetError());
+            }
+        }
+    }
+
+    /**
+     * An interface for customizing the eglCreateWindowSurface and eglDestroySurface calls.
+     * <p>
+     * This interface must be implemented by clients wishing to call
+     * {@link EGLTextureView#setEGLWindowSurfaceFactory(EGLWindowSurfaceFactory)}
+     */
+    public interface EGLWindowSurfaceFactory {
+        /**
+         *  @return null if the surface cannot be constructed.
+         */
+        EGLSurface createWindowSurface(EGL10 egl, EGLDisplay display, EGLConfig config,
+                                       Object nativeWindow);
+        void destroySurface(EGL10 egl, EGLDisplay display, EGLSurface surface);
+    }
+
+    private static class DefaultWindowSurfaceFactory implements EGLWindowSurfaceFactory {
+
+        public EGLSurface createWindowSurface(EGL10 egl, EGLDisplay display,
+                                              EGLConfig config, Object nativeWindow) {
+            EGLSurface result = null;
+            try {
+                result = egl.eglCreateWindowSurface(display, config, nativeWindow, null);
+            } catch (IllegalArgumentException e) {
+                // This exception indicates that the surface flinger surface
+                // is not valid. This can happen if the surface flinger surface has
+                // been torn down, but the application has not yet been
+                // notified via SurfaceHolder.Callback.surfaceDestroyed.
+                // In theory the application should be notified first,
+                // but in practice sometimes it is not. See b/4588890
+                Log.e(TAG, "eglCreateWindowSurface", e);
+            }
+            return result;
+        }
+
+        public void destroySurface(EGL10 egl, EGLDisplay display,
+                                   EGLSurface surface) {
+            egl.eglDestroySurface(display, surface);
+        }
+    }
+
+    /**
+     * An interface for choosing an EGLConfig configuration from a list of
+     * potential configurations.
+     * <p>
+     * This interface must be implemented by clients wishing to call
+     * {@link EGLTextureView#setEGLConfigChooser(EGLConfigChooser)}
+     */
+    public interface EGLConfigChooser {
+        /**
+         * Choose a configuration from the list. Implementors typically
+         * implement this method by calling
+         * {@link EGL10#eglChooseConfig} and iterating through the results. Please consult the
+         * EGL specification available from The Khronos Group to learn how to call eglChooseConfig.
+         * @param egl the EGL10 for the current display.
+         * @param display the current display.
+         * @return the chosen configuration.
+         */
+        EGLConfig chooseConfig(EGL10 egl, EGLDisplay display);
+    }
+
+    private abstract class BaseConfigChooser
+            implements EGLConfigChooser {
+        public BaseConfigChooser(int[] configSpec) {
+            mConfigSpec = filterConfigSpec(configSpec);
+        }
+
+        public EGLConfig chooseConfig(EGL10 egl, EGLDisplay display) {
+            int[] num_config = new int[1];
+            if (!egl.eglChooseConfig(display, mConfigSpec, null, 0,
+                    num_config)) {
+                throw new IllegalArgumentException("eglChooseConfig failed");
+            }
+
+            int numConfigs = num_config[0];
+
+            if (numConfigs <= 0) {
+                throw new IllegalArgumentException(
+                        "No configs match configSpec");
+            }
+
+            EGLConfig[] configs = new EGLConfig[numConfigs];
+            if (!egl.eglChooseConfig(display, mConfigSpec, configs, numConfigs,
+                    num_config)) {
+                throw new IllegalArgumentException("eglChooseConfig#2 failed");
+            }
+            EGLConfig config = chooseConfig(egl, display, configs);
+            if (config == null) {
+                throw new IllegalArgumentException("No config chosen");
+            }
+            return config;
+        }
+
+        abstract EGLConfig chooseConfig(EGL10 egl, EGLDisplay display,
+                                        EGLConfig[] configs);
+
+        protected int[] mConfigSpec;
+
+        private int[] filterConfigSpec(int[] configSpec) {
+            if (mEGLContextClientVersion != 2 && mEGLContextClientVersion != 3) {
+                return configSpec;
+            }
+            /* We know none of the subclasses define EGL_RENDERABLE_TYPE.
+             * And we know the configSpec is well formed.
+             */
+            int len = configSpec.length;
+            int[] newConfigSpec = new int[len + 2];
+            System.arraycopy(configSpec, 0, newConfigSpec, 0, len-1);
+            newConfigSpec[len-1] = EGL10.EGL_RENDERABLE_TYPE;
+            if (mEGLContextClientVersion == 2) {
+                newConfigSpec[len] = EGL14.EGL_OPENGL_ES2_BIT;  /* EGL_OPENGL_ES2_BIT */
+            } else {
+                newConfigSpec[len] = EGLExt.EGL_OPENGL_ES3_BIT_KHR; /* EGL_OPENGL_ES3_BIT_KHR */
+            }
+            newConfigSpec[len+1] = EGL10.EGL_NONE;
+            return newConfigSpec;
+        }
+    }
+
+    /**
+     * Choose a configuration with exactly the specified r,g,b,a sizes,
+     * and at least the specified depth and stencil sizes.
+     */
+    private class ComponentSizeChooser extends BaseConfigChooser {
+        public ComponentSizeChooser(int redSize, int greenSize, int blueSize,
+                                    int alphaSize, int depthSize, int stencilSize) {
+            super(new int[] {
+                    EGL10.EGL_RED_SIZE, redSize,
+                    EGL10.EGL_GREEN_SIZE, greenSize,
+                    EGL10.EGL_BLUE_SIZE, blueSize,
+                    EGL10.EGL_ALPHA_SIZE, alphaSize,
+                    EGL10.EGL_DEPTH_SIZE, depthSize,
+                    EGL10.EGL_STENCIL_SIZE, stencilSize,
+                    EGL10.EGL_NONE});
+            mValue = new int[1];
+            mRedSize = redSize;
+            mGreenSize = greenSize;
+            mBlueSize = blueSize;
+            mAlphaSize = alphaSize;
+            mDepthSize = depthSize;
+            mStencilSize = stencilSize;
+        }
+
+        @Override
+        public EGLConfig chooseConfig(EGL10 egl, EGLDisplay display,
+                                      EGLConfig[] configs) {
+            for (EGLConfig config : configs) {
+                int d = findConfigAttrib(egl, display, config,
+                        EGL10.EGL_DEPTH_SIZE, 0);
+                int s = findConfigAttrib(egl, display, config,
+                        EGL10.EGL_STENCIL_SIZE, 0);
+                if ((d >= mDepthSize) && (s >= mStencilSize)) {
+                    int r = findConfigAttrib(egl, display, config,
+                            EGL10.EGL_RED_SIZE, 0);
+                    int g = findConfigAttrib(egl, display, config,
+                            EGL10.EGL_GREEN_SIZE, 0);
+                    int b = findConfigAttrib(egl, display, config,
+                            EGL10.EGL_BLUE_SIZE, 0);
+                    int a = findConfigAttrib(egl, display, config,
+                            EGL10.EGL_ALPHA_SIZE, 0);
+                    if ((r == mRedSize) && (g == mGreenSize)
+                            && (b == mBlueSize) && (a == mAlphaSize)) {
+                        return config;
+                    }
+                }
+            }
+            return null;
+        }
+
+        private int findConfigAttrib(EGL10 egl, EGLDisplay display,
+                                     EGLConfig config, int attribute, int defaultValue) {
+
+            if (egl.eglGetConfigAttrib(display, config, attribute, mValue)) {
+                return mValue[0];
+            }
+            return defaultValue;
+        }
+
+        private int[] mValue;
+        // Subclasses can adjust these values:
+        protected int mRedSize;
+        protected int mGreenSize;
+        protected int mBlueSize;
+        protected int mAlphaSize;
+        protected int mDepthSize;
+        protected int mStencilSize;
+    }
+
+    /**
+     * This class will choose a RGB_888 surface with
+     * or without a depth buffer.
+     *
+     */
+    private class SimpleEGLConfigChooser extends ComponentSizeChooser {
+        public SimpleEGLConfigChooser(boolean withDepthBuffer) {
+            super(8, 8, 8, 0, withDepthBuffer ? 16 : 0, 0);
+        }
+    }
+
+    /**
+     * An EGL helper class.
+     */
+
+    private static class EglHelper {
+        public EglHelper(WeakReference<EGLTextureView> EGLTextureViewWeakRef) {
+            mEGLTextureViewWeakRef = EGLTextureViewWeakRef;
+        }
+
+        /**
+         * Initialize EGL for a given configuration spec.
+         */
+        public void start() {
+            if (LOG_EGL) {
+                Log.w("EglHelper", "start() tid=" + Thread.currentThread().getId());
+            }
+            /*
+             * Get an EGL instance
+             */
+            mEgl = (EGL10) EGLContext.getEGL();
+
+            /*
+             * Get to the default display.
+             */
+            mEglDisplay = mEgl.eglGetDisplay(EGL10.EGL_DEFAULT_DISPLAY);
+
+            if (mEglDisplay == EGL10.EGL_NO_DISPLAY) {
+                throw new RuntimeException("eglGetDisplay failed");
+            }
+
+            /*
+             * We can now initialize EGL for that display
+             */
+            int[] version = new int[2];
+            if(!mEgl.eglInitialize(mEglDisplay, version)) {
+                throw new RuntimeException("eglInitialize failed");
+            }
+            EGLTextureView view = mEGLTextureViewWeakRef.get();
+            if (view == null) {
+                mEglConfig = null;
+                mEglContext = null;
+            } else {
+                mEglConfig = view.mEGLConfigChooser.chooseConfig(mEgl, mEglDisplay);
+
+                /*
+                 * Create an EGL context. We want to do this as rarely as we can, because an
+                 * EGL context is a somewhat heavy object.
+                 */
+                mEglContext = view.mEGLContextFactory.createContext(mEgl, mEglDisplay, mEglConfig);
+            }
+            if (mEglContext == null || mEglContext == EGL10.EGL_NO_CONTEXT) {
+                mEglContext = null;
+                throwEglException("createContext");
+            }
+            if (LOG_EGL) {
+                Log.w("EglHelper", "createContext " + mEglContext + " tid=" + Thread.currentThread().getId());
+            }
+
+            mEglSurface = null;
+        }
+
+        /**
+         * Create an egl surface for the current SurfaceHolder surface. If a surface
+         * already exists, destroy it before creating the new surface.
+         *
+         * @return true if the surface was created successfully.
+         */
+        public boolean createSurface() {
+            if (LOG_EGL) {
+                Log.w("EglHelper", "createSurface()  tid=" + Thread.currentThread().getId());
+            }
+            /*
+             * Check preconditions.
+             */
+            if (mEgl == null) {
+                throw new RuntimeException("egl not initialized");
+            }
+            if (mEglDisplay == null) {
+                throw new RuntimeException("eglDisplay not initialized");
+            }
+            if (mEglConfig == null) {
+                throw new RuntimeException("mEglConfig not initialized");
+            }
+
+            /*
+             *  The window size has changed, so we need to create a new
+             *  surface.
+             */
+            destroySurfaceImp();
+
+            /*
+             * Create an EGL surface we can render into.
+             */
+            EGLTextureView view = mEGLTextureViewWeakRef.get();
+            if (view != null) {
+                mEglSurface = view.mEGLWindowSurfaceFactory.createWindowSurface(mEgl,
+                        mEglDisplay, mEglConfig, view.getSurfaceTexture());
+            } else {
+                mEglSurface = null;
+            }
+
+            if (mEglSurface == null || mEglSurface == EGL10.EGL_NO_SURFACE) {
+                int error = mEgl.eglGetError();
+                if (error == EGL10.EGL_BAD_NATIVE_WINDOW) {
+                    Log.e("EglHelper", "createWindowSurface returned EGL_BAD_NATIVE_WINDOW.");
+                }
+                return false;
+            }
+
+            /*
+             * Before we can issue GL commands, we need to make sure
+             * the context is current and bound to a surface.
+             */
+            if (!mEgl.eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface, mEglContext)) {
+                /*
+                 * Could not make the context current, probably because the underlying
+                 * TextureView surface has been destroyed.
+                 */
+                logEglErrorAsWarning("EGLHelper", "eglMakeCurrent", mEgl.eglGetError());
+                return false;
+            }
+
+            if (view != null) {
+                view.mRenderer.onEglSetup();
+            }
+
+            return true;
+        }
+
+        /**
+         * Create a GL object for the current EGL context.
+         * @return
+         */
+        GL createGL() {
+
+            GL gl = mEglContext.getGL();
+            EGLTextureView view = mEGLTextureViewWeakRef.get();
+            if (view != null) {
+                if (view.mGLWrapper != null) {
+                    gl = view.mGLWrapper.wrap(gl);
+                }
+
+                if ((view.mDebugFlags & (DEBUG_CHECK_GL_ERROR | DEBUG_LOG_GL_CALLS)) != 0) {
+                    int configFlags = 0;
+                    Writer log = null;
+                    if ((view.mDebugFlags & DEBUG_CHECK_GL_ERROR) != 0) {
+                        configFlags |= GLDebugHelper.CONFIG_CHECK_GL_ERROR;
+                    }
+                    if ((view.mDebugFlags & DEBUG_LOG_GL_CALLS) != 0) {
+                        log = new LogWriter();
+                    }
+                    gl = GLDebugHelper.wrap(gl, configFlags, log);
+                }
+            }
+            return gl;
+        }
+
+        /**
+         * Display the current render surface.
+         * @return the EGL error code from eglSwapBuffers.
+         */
+        public int swap() {
+            if (! mEgl.eglSwapBuffers(mEglDisplay, mEglSurface)) {
+                return mEgl.eglGetError();
+            }
+            return EGL10.EGL_SUCCESS;
+        }
+
+        public void destroySurface() {
+            if (LOG_EGL) {
+                Log.w("EglHelper", "destroySurface()  tid=" + Thread.currentThread().getId());
+            }
+            destroySurfaceImp();
+        }
+
+        private void destroySurfaceImp() {
+            if (mEglSurface != null && mEglSurface != EGL10.EGL_NO_SURFACE) {
+                EGLTextureView view = mEGLTextureViewWeakRef.get();
+                if (view != null) {
+                    view.mRenderer.onEglTearDown();
+                }
+                mEgl.eglMakeCurrent(mEglDisplay, EGL10.EGL_NO_SURFACE,
+                        EGL10.EGL_NO_SURFACE,
+                        EGL10.EGL_NO_CONTEXT);
+                if (view != null) {
+                    view.mEGLWindowSurfaceFactory.destroySurface(mEgl, mEglDisplay, mEglSurface);
+                }
+                mEglSurface = null;
+            }
+        }
+
+        public void finish() {
+            if (LOG_EGL) {
+                Log.w("EglHelper", "finish() tid=" + Thread.currentThread().getId());
+            }
+            if (mEglContext != null) {
+                EGLTextureView view = mEGLTextureViewWeakRef.get();
+                if (view != null) {
+                    view.mEGLContextFactory.destroyContext(mEgl, mEglDisplay, mEglContext);
+                }
+                mEglContext = null;
+            }
+            if (mEglDisplay != null) {
+                mEgl.eglTerminate(mEglDisplay);
+                mEglDisplay = null;
+            }
+        }
+
+        private void throwEglException(String function) {
+            throwEglException(function, mEgl.eglGetError());
+        }
+
+        public static void throwEglException(String function, int error) {
+            String message = formatEglError(function, error);
+            if (LOG_THREADS) {
+                Log.e("EglHelper", "throwEglException tid=" + Thread.currentThread().getId() + " "
+                        + message);
+            }
+            throw new RuntimeException(message);
+        }
+
+        public static void logEglErrorAsWarning(String tag, String function, int error) {
+            Log.w(tag, formatEglError(function, error));
+        }
+
+        public static String formatEglError(String function, int error) {
+            return function + " failed: " + eglGetErrorString(error);
+        }
+
+        static String eglGetErrorString(int error) {
+            switch (error) {
+                case EGL11.EGL_SUCCESS:
+                    return "EGL_SUCCESS";
+                case EGL11.EGL_NOT_INITIALIZED:
+                    return "EGL_NOT_INITIALIZED";
+                case EGL11.EGL_BAD_ACCESS:
+                    return "EGL_BAD_ACCESS";
+                case EGL11.EGL_BAD_ALLOC:
+                    return "EGL_BAD_ALLOC";
+                case EGL11.EGL_BAD_ATTRIBUTE:
+                    return "EGL_BAD_ATTRIBUTE";
+                case EGL11.EGL_BAD_CONFIG:
+                    return "EGL_BAD_CONFIG";
+                case EGL11.EGL_BAD_CONTEXT:
+                    return "EGL_BAD_CONTEXT";
+                case EGL11.EGL_BAD_CURRENT_SURFACE:
+                    return "EGL_BAD_CURRENT_SURFACE";
+                case EGL11.EGL_BAD_DISPLAY:
+                    return "EGL_BAD_DISPLAY";
+                case EGL11.EGL_BAD_MATCH:
+                    return "EGL_BAD_MATCH";
+                case EGL11.EGL_BAD_NATIVE_PIXMAP:
+                    return "EGL_BAD_NATIVE_PIXMAP";
+                case EGL11.EGL_BAD_NATIVE_WINDOW:
+                    return "EGL_BAD_NATIVE_WINDOW";
+                case EGL11.EGL_BAD_PARAMETER:
+                    return "EGL_BAD_PARAMETER";
+                case EGL11.EGL_BAD_SURFACE:
+                    return "EGL_BAD_SURFACE";
+                case EGL11.EGL_CONTEXT_LOST:
+                    return "EGL_CONTEXT_LOST";
+                default:
+                    return "0x" + Integer.toHexString(error);
+            }
+        }
+
+        private WeakReference<EGLTextureView> mEGLTextureViewWeakRef;
+        EGL10 mEgl;
+        EGLDisplay mEglDisplay;
+        EGLSurface mEglSurface;
+        EGLConfig mEglConfig;
+        EGLContext mEglContext;
+
+    }
+
+    /**
+     * A generic GL Thread. Takes care of initializing EGL and GL. Delegates
+     * to a Renderer instance to do the actual drawing. Can be configured to
+     * render continuously or on request.
+     *
+     * All potentially blocking synchronization is done through the
+     * sGLThreadManager object. This avoids multiple-lock ordering issues.
+     *
+     */
+    class GLThread extends Thread {
+        GLThread(WeakReference<EGLTextureView> EGLTextureViewWeakRef) {
+            super();
+            mWidth = 0;
+            mHeight = 0;
+            mRequestRender = true;
+            mEGLTextureViewWeakRef = EGLTextureViewWeakRef;
+        }
+
+        @Override
+        public void run() {
+            setName("GLThread " + getId());
+            if (LOG_THREADS) {
+                Log.i("GLThread", "starting tid=" + getId());
+            }
+
+            try {
+                guardedRun();
+            } catch (InterruptedException e) {
+                // fall through and exit normally
+            } finally {
+                sGLThreadManager.threadExiting(this);
+            }
+        }
+
+        /*
+         * This private method should only be called inside a
+         * synchronized(sGLThreadManager) block.
+         */
+        private void stopEglSurfaceLocked() {
+            if (mHaveEglSurface) {
+                mHaveEglSurface = false;
+                mEglHelper.destroySurface();
+            }
+        }
+
+        /*
+         * This private method should only be called inside a
+         * synchronized(sGLThreadManager) block.
+         */
+        private void stopEglContextLocked() {
+            if (mHaveEglContext) {
+                mEglHelper.finish();
+                mHaveEglContext = false;
+                sGLThreadManager.releaseEglContextLocked(this);
+            }
+        }
+        private void guardedRun() throws InterruptedException {
+            mEglHelper = new EglHelper(mEGLTextureViewWeakRef);
+            mHaveEglContext = false;
+            mHaveEglSurface = false;
+            try {
+                GL10 gl = null;
+                boolean createEglContext = false;
+                boolean createEglSurface = false;
+                boolean createGlInterface = false;
+                boolean lostEglContext = false;
+                boolean sizeChanged = false;
+                boolean wantRenderNotification = false;
+                boolean doRenderNotification = false;
+                boolean askedToReleaseEglContext = false;
+                int w = 0;
+                int h = 0;
+                Runnable event = null;
+
+                while (true) {
+                    synchronized (sGLThreadManager) {
+                        while (true) {
+                            if (mShouldExit) {
+                                return;
+                            }
+
+                            if (! mEventQueue.isEmpty()) {
+                                event = mEventQueue.remove(0);
+                                break;
+                            }
+
+                            // Update the pause state.
+                            boolean pausing = false;
+                            if (mPaused != mRequestPaused) {
+                                pausing = mRequestPaused;
+                                mPaused = mRequestPaused;
+                                sGLThreadManager.notifyAll();
+                                if (LOG_PAUSE_RESUME) {
+                                    Log.i("GLThread", "mPaused is now " + mPaused + " tid=" + getId());
+                                }
+                            }
+
+                            // Do we need to give up the EGL context?
+                            if (mShouldReleaseEglContext) {
+                                if (LOG_SURFACE) {
+                                    Log.i("GLThread", "releasing EGL context because asked to tid=" + getId());
+                                }
+                                stopEglSurfaceLocked();
+                                stopEglContextLocked();
+                                mShouldReleaseEglContext = false;
+                                askedToReleaseEglContext = true;
+                            }
+
+                            // Have we lost the EGL context?
+                            if (lostEglContext) {
+                                stopEglSurfaceLocked();
+                                stopEglContextLocked();
+                                lostEglContext = false;
+                            }
+
+                            // When pausing, release the EGL surface:
+                            if (pausing && mHaveEglSurface) {
+                                if (LOG_SURFACE) {
+                                    Log.i("GLThread", "releasing EGL surface because paused tid=" + getId());
+                                }
+                                stopEglSurfaceLocked();
+                            }
+
+                            // When pausing, optionally release the EGL Context:
+                            if (pausing && mHaveEglContext) {
+                                EGLTextureView view = mEGLTextureViewWeakRef.get();
+                                boolean preserveEglContextOnPause = view == null ?
+                                        false : view.mPreserveEGLContextOnPause;
+                                if (!preserveEglContextOnPause || sGLThreadManager.shouldReleaseEGLContextWhenPausing()) {
+                                    stopEglContextLocked();
+                                    if (LOG_SURFACE) {
+                                        Log.i("GLThread", "releasing EGL context because paused tid=" + getId());
+                                    }
+                                }
+                            }
+
+                            // When pausing, optionally terminate EGL:
+                            if (pausing) {
+                                if (sGLThreadManager.shouldTerminateEGLWhenPausing()) {
+                                    mEglHelper.finish();
+                                    if (LOG_SURFACE) {
+                                        Log.i("GLThread", "terminating EGL because paused tid=" + getId());
+                                    }
+                                }
+                            }
+
+                            // Have we lost the TextureView surface?
+                            if ((! mHasSurface) && (! mWaitingForSurface)) {
+                                if (LOG_SURFACE) {
+                                    Log.i("GLThread", "noticed TextureView surface lost tid=" + getId());
+                                }
+                                if (mHaveEglSurface) {
+                                    stopEglSurfaceLocked();
+                                }
+                                mWaitingForSurface = true;
+                                mSurfaceIsBad = false;
+                                sGLThreadManager.notifyAll();
+                            }
+
+                            // Have we acquired the surface view surface?
+                            if (mHasSurface && mWaitingForSurface) {
+                                if (LOG_SURFACE) {
+                                    Log.i("GLThread", "noticed TextureView surface acquired tid=" + getId());
+                                }
+                                mWaitingForSurface = false;
+                                sGLThreadManager.notifyAll();
+                            }
+
+                            if (doRenderNotification) {
+                                if (LOG_SURFACE) {
+                                    Log.i("GLThread", "sending render notification tid=" + getId());
+                                }
+                                wantRenderNotification = false;
+                                doRenderNotification = false;
+                                mRenderComplete = true;
+                                sGLThreadManager.notifyAll();
+                            }
+
+                            // Ready to draw?
+                            if (readyToDraw()) {
+
+                                // If we don't have an EGL context, try to acquire one.
+                                if (! mHaveEglContext) {
+                                    if (askedToReleaseEglContext) {
+                                        askedToReleaseEglContext = false;
+                                    } else if (sGLThreadManager.tryAcquireEglContextLocked(this)) {
+                                        try {
+                                            mEglHelper.start();
+                                        } catch (RuntimeException t) {
+                                            sGLThreadManager.releaseEglContextLocked(this);
+                                            throw t;
+                                        }
+                                        mHaveEglContext = true;
+                                        createEglContext = true;
+
+                                        sGLThreadManager.notifyAll();
+                                    }
+                                }
+
+                                if (mHaveEglContext && !mHaveEglSurface) {
+                                    mHaveEglSurface = true;
+                                    createEglSurface = true;
+                                    createGlInterface = true;
+                                    sizeChanged = true;
+                                }
+
+                                if (mHaveEglSurface) {
+                                    if (mSizeChanged) {
+                                        sizeChanged = true;
+                                        w = mWidth;
+                                        h = mHeight;
+                                        wantRenderNotification = true;
+                                        if (LOG_SURFACE) {
+                                            Log.i("GLThread",
+                                                    "noticing that we want render notification tid="
+                                                            + getId());
+                                        }
+
+                                        // Destroy and recreate the EGL surface.
+                                        createEglSurface = true;
+
+                                        mSizeChanged = false;
+                                    }
+                                    mRequestRender = false;
+                                    sGLThreadManager.notifyAll();
+                                    break;
+                                }
+                            }
+
+                            // By design, this is the only place in a GLThread thread where we wait().
+                            if (LOG_THREADS) {
+                                Log.i("GLThread", "\nwaiting tid=" + getId()
+                                        + "\nmHaveEglContext: " + mHaveEglContext
+                                        + "\nmHaveEglSurface: " + mHaveEglSurface
+                                        + "\nmFinishedCreatingEglSurface: " + mFinishedCreatingEglSurface
+                                        + "\nmPaused: " + mPaused
+                                        + "\nmHasSurface: " + mHasSurface
+                                        + "\nmSurfaceIsBad: " + mSurfaceIsBad
+                                        + "\nmWaitingForSurface: " + mWaitingForSurface
+                                        + "\nmWidth: " + mWidth
+                                        + "\nmHeight: " + mHeight
+                                        + "\nmRequestRender: " + mRequestRender);
+                            }
+                            sGLThreadManager.wait();
+                        }
+                    } // end of synchronized(sGLThreadManager)
+
+                    if (event != null) {
+                        event.run();
+                        event = null;
+                        continue;
+                    }
+
+                    if (createEglSurface) {
+                        if (LOG_SURFACE) {
+                            Log.w("GLThread", "egl createSurface");
+                        }
+                        if (mEglHelper.createSurface()) {
+                            synchronized(sGLThreadManager) {
+                                mFinishedCreatingEglSurface = true;
+                                sGLThreadManager.notifyAll();
+                            }
+                        } else {
+                            synchronized(sGLThreadManager) {
+                                mFinishedCreatingEglSurface = true;
+                                mSurfaceIsBad = true;
+                                sGLThreadManager.notifyAll();
+                            }
+                            continue;
+                        }
+                        createEglSurface = false;
+                    }
+
+                    if (createGlInterface) {
+                        gl = (GL10) mEglHelper.createGL();
+
+                        sGLThreadManager.checkGLDriver(gl);
+                        createGlInterface = false;
+                    }
+
+                    if (createEglContext) {
+                        if (LOG_RENDERER) {
+                            Log.w("GLThread", "onSurfaceCreated");
+                        }
+                        EGLTextureView view = mEGLTextureViewWeakRef.get();
+                        if (view != null) {
+                            view.mRenderer.onSurfaceCreated(gl, mEglHelper.mEglConfig);
+                        }
+                        createEglContext = false;
+                    }
+
+                    if (sizeChanged) {
+                        if (LOG_RENDERER) {
+                            Log.w("GLThread", "onSurfaceChanged(" + w + ", " + h + ")");
+                        }
+                        EGLTextureView view = mEGLTextureViewWeakRef.get();
+                        if (view != null) {
+                            view.mRenderer.onSurfaceChanged(gl, w, h);
+                        }
+                        sizeChanged = false;
+                    }
+
+                    synchronized (VSYNC_LOCK) {
+                        if (vsynced) {
+                            vsynced = false;
+                            if (LOG_RENDERER_DRAW_FRAME) {
+                                Log.w("GLThread", "onDrawFrame tid=" + getId());
+                            }
+                            EGLTextureView view = mEGLTextureViewWeakRef.get();
+                            if (view != null) {
+                                view.mRenderer.onDrawFrame(gl);
+                            }
+                            if (shouldSwap) {
+                                int swapError = mEglHelper.swap();
+                                shouldSwap = false;
+                                switch (swapError) {
+                                    case EGL10.EGL_SUCCESS:
+                                        break;
+                                    case EGL11.EGL_CONTEXT_LOST:
+                                        if (LOG_SURFACE) {
+                                            Log.i("GLThread", "egl context lost tid=" + getId());
+                                        }
+                                        lostEglContext = true;
+                                        break;
+                                    default:
+                                        // Other errors typically mean that the current surface is bad,
+                                        // probably because the TextureView surface has been destroyed,
+                                        // but we haven't been notified yet.
+                                        // Log the error to help developers understand why rendering stopped.
+                                        EglHelper.logEglErrorAsWarning("GLThread", "eglSwapBuffers", swapError);
+
+                                        synchronized (sGLThreadManager) {
+                                            mSurfaceIsBad = true;
+                                            sGLThreadManager.notifyAll();
+                                        }
+                                        break;
+                                }
+                            }
+                        }
+                    }
+
+                    if (wantRenderNotification) {
+                        doRenderNotification = true;
+                    }
+                }
+
+            } finally {
+                /*
+                 * clean-up everything...
+                 */
+                synchronized (sGLThreadManager) {
+                    stopEglSurfaceLocked();
+                    stopEglContextLocked();
+                }
+            }
+        }
+
+        public boolean ableToDraw() {
+            return mHaveEglContext && mHaveEglSurface && readyToDraw();
+        }
+
+        private boolean readyToDraw() {
+            return (!mPaused) && mHasSurface && (!mSurfaceIsBad)
+                    && (mWidth > 0) && (mHeight > 0)
+                    && (mRequestRender);
+        }
+
+        public void requestRender() {
+            synchronized(sGLThreadManager) {
+                mRequestRender = true;
+                sGLThreadManager.notifyAll();
+            }
+        }
+
+        public void surfaceCreated() {
+            synchronized(sGLThreadManager) {
+                if (LOG_THREADS) {
+                    Log.i("GLThread", "surfaceCreated tid=" + getId());
+                }
+                mHasSurface = true;
+                mFinishedCreatingEglSurface = false;
+                sGLThreadManager.notifyAll();
+                while (mWaitingForSurface
+                        && !mFinishedCreatingEglSurface
+                        && !mExited) {
+                    try {
+                        sGLThreadManager.wait();
+                    } catch (InterruptedException e) {
+                        Thread.currentThread().interrupt();
+                    }
+                }
+            }
+        }
+
+        public void surfaceDestroyed() {
+            synchronized(sGLThreadManager) {
+                if (LOG_THREADS) {
+                    Log.i("GLThread", "surfaceDestroyed tid=" + getId());
+                }
+                mHasSurface = false;
+                sGLThreadManager.notifyAll();
+                while((!mWaitingForSurface) && (!mExited)) {
+                    try {
+                        sGLThreadManager.wait();
+                    } catch (InterruptedException e) {
+                        Thread.currentThread().interrupt();
+                    }
+                }
+            }
+        }
+
+        public void onPause() {
+            synchronized (sGLThreadManager) {
+                if (LOG_PAUSE_RESUME) {
+                    Log.i("GLThread", "onPause tid=" + getId());
+                }
+                mRequestPaused = true;
+                sGLThreadManager.notifyAll();
+                while ((! mExited) && (! mPaused)) {
+                    if (LOG_PAUSE_RESUME) {
+                        Log.i("Main thread", "onPause waiting for mPaused.");
+                    }
+                    try {
+                        sGLThreadManager.wait();
+                    } catch (InterruptedException ex) {
+                        Thread.currentThread().interrupt();
+                    }
+                }
+            }
+        }
+
+        public void onResume() {
+            synchronized (sGLThreadManager) {
+                if (LOG_PAUSE_RESUME) {
+                    Log.i("GLThread", "onResume tid=" + getId());
+                }
+                mRequestPaused = false;
+                mRequestRender = true;
+                mRenderComplete = false;
+                sGLThreadManager.notifyAll();
+                while ((! mExited) && mPaused && (!mRenderComplete)) {
+                    if (LOG_PAUSE_RESUME) {
+                        Log.i("Main thread", "onResume waiting for !mPaused.");
+                    }
+                    try {
+                        sGLThreadManager.wait();
+                    } catch (InterruptedException ex) {
+                        Thread.currentThread().interrupt();
+                    }
+                }
+            }
+        }
+
+        public void onWindowResize(int w, int h) {
+            synchronized (sGLThreadManager) {
+                mWidth = w;
+                mHeight = h;
+                mSizeChanged = true;
+                mRequestRender = true;
+                mRenderComplete = false;
+                sGLThreadManager.notifyAll();
+
+                // Wait for thread to react to resize and render a frame
+                while (! mExited && !mPaused && !mRenderComplete
+                        && ableToDraw()) {
+                    if (LOG_SURFACE) {
+                        Log.i("Main thread", "onWindowResize waiting for render complete from tid=" + getId());
+                    }
+                    try {
+                        sGLThreadManager.wait();
+                    } catch (InterruptedException ex) {
+                        Thread.currentThread().interrupt();
+                    }
+                }
+            }
+        }
+
+        public void requestExitAndWait() {
+            // don't call this from GLThread thread or it is a guaranteed
+            // deadlock!
+            synchronized(sGLThreadManager) {
+                mShouldExit = true;
+                sGLThreadManager.notifyAll();
+                while (! mExited) {
+                    try {
+                        sGLThreadManager.wait();
+                    } catch (InterruptedException ex) {
+                        Thread.currentThread().interrupt();
+                    }
+                }
+            }
+        }
+
+        public void requestReleaseEglContextLocked() {
+            mShouldReleaseEglContext = true;
+            sGLThreadManager.notifyAll();
+        }
+
+        /**
+         * Queue an "event" to be run on the GL rendering thread.
+         * @param r the runnable to be run on the GL rendering thread.
+         */
+        public void queueEvent(Runnable r) {
+            if (r == null) {
+                throw new IllegalArgumentException("r must not be null");
+            }
+            synchronized(sGLThreadManager) {
+                mEventQueue.add(r);
+                sGLThreadManager.notifyAll();
+            }
+        }
+
+        // Once the thread is started, all accesses to the following member
+        // variables are protected by the sGLThreadManager monitor
+        private boolean mShouldExit;
+        private boolean mExited;
+        private boolean mRequestPaused;
+        private boolean mPaused;
+        private boolean mHasSurface;
+        private boolean mSurfaceIsBad;
+        private boolean mWaitingForSurface;
+        private boolean mHaveEglContext;
+        private boolean mHaveEglSurface;
+        private boolean mFinishedCreatingEglSurface;
+        private boolean mShouldReleaseEglContext;
+        private int mWidth;
+        private int mHeight;
+        private boolean mRequestRender;
+        private boolean mRenderComplete;
+        private ArrayList<Runnable> mEventQueue = new ArrayList<Runnable>();
+        private boolean mSizeChanged = true;
+
+        // End of member variables protected by the sGLThreadManager monitor.
+
+        private EglHelper mEglHelper;
+
+        /**
+         * Set once at thread construction time, nulled out when the parent view is garbage
+         * called. This weak reference allows the EGLTextureView to be garbage collected while
+         * the GLThread is still alive.
+         */
+        private WeakReference<EGLTextureView> mEGLTextureViewWeakRef;
+
+    }
+
+    static class LogWriter extends Writer {
+
+        @Override public void close() {
+            flushBuilder();
+        }
+
+        @Override public void flush() {
+            flushBuilder();
+        }
+
+        @Override public void write(char[] buf, int offset, int count) {
+            for(int i = 0; i < count; i++) {
+                char c = buf[offset + i];
+                if ( c == '\n') {
+                    flushBuilder();
+                }
+                else {
+                    mBuilder.append(c);
+                }
+            }
+        }
+
+        private void flushBuilder() {
+            if (mBuilder.length() > 0) {
+                Log.v("EGLTextureView", mBuilder.toString());
+                mBuilder.delete(0, mBuilder.length());
+            }
+        }
+
+        private StringBuilder mBuilder = new StringBuilder();
+    }
+
+
+    private final void checkRenderThreadState() {
+        if (mGLThread != null) {
+            throw new IllegalStateException(
+                    "setRenderer has already been called for this instance.");
+        }
+    }
+
+    private static class GLThreadManager {
+        private static String TAG = "GLThreadManager";
+
+        public synchronized void threadExiting(GLThread thread) {
+            if (LOG_THREADS) {
+                Log.i("GLThread", "exiting tid=" +  thread.getId());
+            }
+            thread.mExited = true;
+            if (mEglOwner == thread) {
+                mEglOwner = null;
+            }
+            notifyAll();
+        }
+
+        /*
+         * Tries once to acquire the right to use an EGL
+         * context. Does not block. Requires that we are already
+         * in the sGLThreadManager monitor when this is called.
+         *
+         * @return true if the right to use an EGL context was acquired.
+         */
+        public boolean tryAcquireEglContextLocked(GLThread thread) {
+            if (mEglOwner == thread || mEglOwner == null) {
+                mEglOwner = thread;
+                notifyAll();
+                return true;
+            }
+            checkGLESVersion();
+            if (mMultipleGLESContextsAllowed) {
+                return true;
+            }
+            // Notify the owning thread that it should release the context.
+            // TODO: implement a fairness policy. Currently
+            // if the owning thread is drawing continuously it will just
+            // reacquire the EGL context.
+            if (mEglOwner != null) {
+                mEglOwner.requestReleaseEglContextLocked();
+            }
+            return false;
+        }
+
+        /*
+         * Releases the EGL context. Requires that we are already in the
+         * sGLThreadManager monitor when this is called.
+         */
+        public void releaseEglContextLocked(GLThread thread) {
+            if (mEglOwner == thread) {
+                mEglOwner = null;
+            }
+            notifyAll();
+        }
+
+        public synchronized boolean shouldReleaseEGLContextWhenPausing() {
+            // Release the EGL context when pausing even if
+            // the hardware supports multiple EGL contexts.
+            // Otherwise the device could run out of EGL contexts.
+            return mLimitedGLESContexts;
+        }
+
+        public synchronized boolean shouldTerminateEGLWhenPausing() {
+            checkGLESVersion();
+            return !mMultipleGLESContextsAllowed;
+        }
+
+        public synchronized void checkGLDriver(GL10 gl) {
+            if (! mGLESDriverCheckComplete) {
+                checkGLESVersion();
+                String renderer = gl.glGetString(GL10.GL_RENDERER);
+                if (mGLESVersion < kGLES_20) {
+                    mMultipleGLESContextsAllowed =
+                            ! renderer.startsWith(kMSM7K_RENDERER_PREFIX);
+                    notifyAll();
+                }
+                mLimitedGLESContexts = !mMultipleGLESContextsAllowed;
+                if (LOG_SURFACE) {
+                    Log.w(TAG, "checkGLDriver renderer = \"" + renderer + "\" multipleContextsAllowed = "
+                            + mMultipleGLESContextsAllowed
+                            + " mLimitedGLESContexts = " + mLimitedGLESContexts);
+                }
+                mGLESDriverCheckComplete = true;
+            }
+        }
+
+        private void checkGLESVersion() {
+            if (! mGLESVersionCheckComplete) {
+                mGLESVersion = SystemProperties.getInt(
+                        "ro.opengles.version",
+                        ConfigurationInfo.GL_ES_VERSION_UNDEFINED);
+                if (mGLESVersion >= kGLES_20) {
+                    mMultipleGLESContextsAllowed = true;
+                }
+                if (LOG_SURFACE) {
+                    Log.w(TAG, "checkGLESVersion mGLESVersion =" +
+                            " " + mGLESVersion + " mMultipleGLESContextsAllowed = " + mMultipleGLESContextsAllowed);
+                }
+                mGLESVersionCheckComplete = true;
+            }
+        }
+
+        /**
+         * This check was required for some pre-Android-3.0 hardware. Android 3.0 provides
+         * support for hardware-accelerated views, therefore multiple EGL contexts are
+         * supported on all Android 3.0+ EGL drivers.
+         */
+        private boolean mGLESVersionCheckComplete;
+        private int mGLESVersion;
+        private boolean mGLESDriverCheckComplete;
+        private boolean mMultipleGLESContextsAllowed;
+        private boolean mLimitedGLESContexts;
+        private static final int kGLES_20 = 0x20000;
+        private static final String kMSM7K_RENDERER_PREFIX =
+                "Q3Dimension MSM7500 ";
+        private GLThread mEglOwner;
+    }
+
+    private static final GLThreadManager sGLThreadManager = new GLThreadManager();
+
+    private final WeakReference<EGLTextureView> mThisWeakRef =
+            new WeakReference<EGLTextureView>(this);
+    private GLThread mGLThread;
+    private Renderer mRenderer;
+    private boolean mDetached;
+    private EGLConfigChooser mEGLConfigChooser;
+    private EGLContextFactory mEGLContextFactory;
+    private EGLWindowSurfaceFactory mEGLWindowSurfaceFactory;
+    private GLWrapper mGLWrapper;
+    private int mDebugFlags;
+    private int mEGLContextClientVersion;
+    private boolean mPreserveEGLContextOnPause;
+
+    /**
+     * Gives access to the system properties store.  The system properties
+     * store contains a list of string key-value pairs.
+     */
+    private static class SystemProperties
+    {
+        public static final int PROP_NAME_MAX = 31;
+        public static final int PROP_VALUE_MAX = 91;
+
+        /**
+         * Get the value for the given key.
+         * @return an empty string if the key isn't found
+         * @throws IllegalArgumentException if the key exceeds 32 characters
+         */
+        public static String get(String key) {
+            if (key.length() > PROP_NAME_MAX) {
+                throw new IllegalArgumentException("key.length > " + PROP_NAME_MAX);
+            }
+            try {
+                return native_get(key);
+            } catch (Exception e) {
+                return "";
+            }
+        }
+        /**
+         * Get the value for the given key.
+         * @return if the key isn't found, return def if it isn't null, or an empty string otherwise
+         * @throws IllegalArgumentException if the key exceeds 32 characters
+         */
+        public static String get(String key, String def) {
+            if (key.length() > PROP_NAME_MAX) {
+                throw new IllegalArgumentException("key.length > " + PROP_NAME_MAX);
+            }
+            try {
+                String ret = native_get(key);
+                if(TextUtils.isEmpty(ret)) {
+                    return def;
+                }
+                return ret;
+            } catch (Exception e) {
+                return def;
+            }
+        }
+        /**
+         * Get the value for the given key, and return as an integer.
+         * @param key the key to lookup
+         * @param def a default value to return
+         * @return the key parsed as an integer, or def if the key isn't found or
+         *         cannot be parsed
+         * @throws IllegalArgumentException if the key exceeds 32 characters
+         */
+        public static int getInt(String key, int def) {
+            if (key.length() > PROP_NAME_MAX) {
+                throw new IllegalArgumentException("key.length > " + PROP_NAME_MAX);
+            }
+            try {
+                return Integer.parseInt(native_get(key));
+            } catch (Exception e) {
+                return def;
+            }
+        }
+        /**
+         * Get the value for the given key, and return as a long.
+         * @param key the key to lookup
+         * @param def a default value to return
+         * @return the key parsed as a long, or def if the key isn't found or
+         *         cannot be parsed
+         * @throws IllegalArgumentException if the key exceeds 32 characters
+         */
+        public static long getLong(String key, long def) {
+            if (key.length() > PROP_NAME_MAX) {
+                throw new IllegalArgumentException("key.length > " + PROP_NAME_MAX);
+            }
+            try {
+                return Long.parseLong(native_get(key));
+            } catch (Exception e) {
+                return def;
+            }
+        }
+        /**
+         * Get the value for the given key, returned as a boolean.
+         * Values 'n', 'no', '0', 'false' or 'off' are considered false.
+         * Values 'y', 'yes', '1', 'true' or 'on' are considered true.
+         * (case sensitive).
+         * If the key does not exist, or has any other value, then the default
+         * result is returned.
+         * @param key the key to lookup
+         * @param def a default value to return
+         * @return the key parsed as a boolean, or def if the key isn't found or is
+         *         not able to be parsed as a boolean.
+         * @throws IllegalArgumentException if the key exceeds 32 characters
+         */
+        public static boolean getBoolean(String key, boolean def) {
+            if (key.length() > PROP_NAME_MAX) {
+                throw new IllegalArgumentException("key.length > " + PROP_NAME_MAX);
+            }
+            try {
+                return Boolean.parseBoolean(native_get(key));
+            } catch (Exception e) {
+                return def;
+            }
+        }
+
+        private static Map<String, String> cache = new HashMap<String, String>();
+        private static String native_get(String key) throws Exception {
+            if(cache.containsKey(key)) {
+                return cache.get(key);
+            }
+
+            Process p = Runtime.getRuntime().exec("/system/bin/getprop " + key);
+            p.waitFor();
+            BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream()));
+            String ln = reader.readLine();
+            reader.close();
+            p.destroy();
+
+            cache.put(key, ln);
+            return ln;
+        }
+
+    }
+}
diff --git a/app/src/main/java/smallville7123/graphical/tool/kit/Cleaner.java b/app/src/main/java/smallville7123/graphical/tool/kit/Cleaner.java
new file mode 100644
index 00000000..04e23155
--- /dev/null
+++ b/app/src/main/java/smallville7123/graphical/tool/kit/Cleaner.java
@@ -0,0 +1,39 @@
+package smallville7123.graphical.tool.kit;
+
+public class Cleaner {
+    public interface Cleanable {
+        void clean();
+    }
+    public static Cleanable register(Object o, Runnable r) {
+        CleanerReference c = new CleanerReference(
+                java.util.Objects.requireNonNull(o), java.util.Objects.requireNonNull(r));
+        phantomReferences.add(c);
+        return c;
+    }
+    private static final java.util.Set<smallville7123.graphical.tool.kit.Cleaner.CleanerReference> phantomReferences
+                                             = java.util.concurrent.ConcurrentHashMap.newKeySet();
+    private static final java.lang.ref.ReferenceQueue<Object> garbageCollectedObjectsQueue
+                                              = new java.lang.ref.ReferenceQueue<>();
+
+    static final class CleanerReference extends java.lang.ref.PhantomReference<Object>
+                                        implements Cleanable {
+        private final Runnable cleaningAction;
+
+        CleanerReference(Object referent, Runnable action) {
+            super(referent, garbageCollectedObjectsQueue);
+            cleaningAction = action;
+        }
+        public void clean() {
+            if(phantomReferences.remove(this)) {
+                super.clear();
+                cleaningAction.run();
+            }
+        }
+    }
+    public static void deleteOrphanedNativePeerObjects() {
+        CleanerReference reference;
+        while((reference=(CleanerReference)garbageCollectedObjectsQueue.poll()) != null) {
+            reference.clean();
+        }
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/smallville7123/graphical/tool/kit/DiligentEngineView.java b/app/src/main/java/smallville7123/graphical/tool/kit/DiligentEngineView.java
new file mode 100644
index 00000000..eca06cbe
--- /dev/null
+++ b/app/src/main/java/smallville7123/graphical/tool/kit/DiligentEngineView.java
@@ -0,0 +1,169 @@
+package smallville7123.graphical.tool.kit;
+
+import android.content.Context;
+import android.util.AttributeSet;
+import android.view.MotionEvent;
+
+import javax.microedition.khronos.egl.EGLConfig;
+import javax.microedition.khronos.opengles.GL10;
+
+import smallville7123.EGLSurfaceView_EGLTextureView.EGLTextureView;
+
+public class DiligentEngineView extends EGLTextureView {
+
+
+    private DiligentEngineView.DiligentEngineRenderer renderer;
+
+    /**
+     * Standard View constructor. In order to render something, you
+     * must call {@link #setRenderer} to register a renderer.
+     *
+     * @param context
+     */
+    public DiligentEngineView(Context context) {
+        super(context);
+    }
+
+    /**
+     * Standard View constructor. In order to render something, you
+     * must call {@link #setRenderer} to register a renderer.
+     *
+     * @param context
+     * @param attrs
+     */
+    public DiligentEngineView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+    }
+
+    @Override
+    protected void init() {
+        super.init();
+        setEGLContextClientVersion(3);
+        setRenderer(renderer = new DiligentEngineRenderer());
+    }
+
+    @Override
+    public boolean onTouchEvent(MotionEvent event) {
+        int action = event.getActionMasked();
+        int actionIndex = event.getActionIndex();
+        int id = 0;
+        boolean isUpDown = false;
+        switch (action) {
+            case MotionEvent.ACTION_CANCEL:
+            case MotionEvent.ACTION_DOWN:
+            case MotionEvent.ACTION_UP:
+            case MotionEvent.ACTION_POINTER_DOWN:
+            case MotionEvent.ACTION_POINTER_UP:
+                id = event.getPointerId(actionIndex);
+                isUpDown = true;
+                break;
+        }
+
+        int c = event.getPointerCount();
+        for (int i = 0; i < c; i++) {
+            int pid = event.getPointerId(i);
+            if (actionIndex != i || !isUpDown) {
+                renderer.moveTouch(
+                        pid,
+                        event.getX(i),
+                        event.getY(i),
+                        event.getSize(i),
+                        event.getPressure(i)
+                );
+            }
+        }
+        if (isUpDown) {
+            switch (action) {
+                case MotionEvent.ACTION_CANCEL:
+                    renderer.cancelTouch(
+                            id,
+                            event.getX(actionIndex),
+                            event.getY(actionIndex),
+                            event.getSize(actionIndex),
+                            event.getPressure(actionIndex)
+                    );
+                    break;
+                case MotionEvent.ACTION_DOWN:
+                case MotionEvent.ACTION_POINTER_DOWN:
+                    renderer.addTouch(
+                            id,
+                            event.getX(actionIndex),
+                            event.getY(actionIndex),
+                            event.getSize(actionIndex),
+                            event.getPressure(actionIndex)
+                    );
+                    break;
+                case MotionEvent.ACTION_UP:
+                case MotionEvent.ACTION_POINTER_UP:
+                    renderer.removeTouch(
+                            id,
+                            event.getX(actionIndex),
+                            event.getY(actionIndex),
+                            event.getSize(actionIndex),
+                            event.getPressure(actionIndex)
+                    );
+                    break;
+            }
+        }
+        renderer.onTouchEvent(renderer.nativeInstance);
+        // should a ViewGroup always return true for onTouchEvent?
+        return true;
+    }
+
+    private class DiligentEngineRenderer implements Renderer {
+        native long createNativeInstance();
+        native void destroyNativeInstance(long instance);
+        native void onEglSetup(long instance, Object classInstance, String name, String signature);
+        native void surfaceChanged(long instance, int w, int h);
+        native void addTouch(long identity, float x, float y);
+        native void addTouch(long identity, float x, float y, float size);
+        native void addTouch(long identity, float x, float y, float size, float pressure);
+        native void moveTouch(long identity, float x, float y);
+        native void moveTouch(long identity, float x, float y, float size);
+        native void moveTouch(long identity, float x, float y, float size, float pressure);
+        native void removeTouch(long identity, float x, float y);
+        native void removeTouch(long identity, float x, float y, float size);
+        native void removeTouch(long identity, float x, float y, float size, float pressure);
+        native void cancelTouch(long identity, float x, float y);
+        native void cancelTouch(long identity, float x, float y, float size);
+        native void cancelTouch(long identity, float x, float y, float size, float pressure);
+        native boolean onTouchEvent(long instance);
+        native void onDraw(long instance);
+        native void onEglTearDown(long instance);
+        long nativeInstance;
+
+        DiligentEngineRenderer() {
+            System.loadLibrary("native-lib");
+        }
+
+        @Override
+        public void onEglSetup() {
+            nativeInstance = createNativeInstance();
+            onEglSetup(nativeInstance, DiligentEngineView.this,
+                    getJavaNameForJNI(METHOD.SWAP_BUFFERS),
+                    getJavaSignatureForJNI(METHOD.SWAP_BUFFERS)
+            );
+        }
+
+        @Override
+        public void onEglTearDown() {
+            onEglTearDown(nativeInstance);
+            destroyNativeInstance(nativeInstance);
+        }
+
+        @Override
+        public void onSurfaceCreated(GL10 gl, EGLConfig config) {
+            // do nothing
+        }
+
+        @Override
+        public void onSurfaceChanged(GL10 gl, int width, int height) {
+            surfaceChanged(nativeInstance, width, height);
+        }
+
+        @Override
+        public void onDrawFrame(GL10 gl) {
+            onDraw(nativeInstance);
+        }
+    }
+}
diff --git a/settings.gradle b/settings.gradle
index f9e92492..cb854736 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -1,2 +1,2 @@
 include ':app'
-rootProject.name='Media Player Pro'
+rootProject.name='Linux Kernel 6.11'
-- 
2.46.0

